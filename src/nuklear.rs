#![allow(dead_code,
         mutable_transmutes,
         non_camel_case_types,
         non_snake_case,
         non_upper_case_globals,
         unused_mut,
         unused_comparisons,
         unused_assignments,
         unused_unsafe,
         unused_variables)]

use libc;
use offset_to::OffsetTo;
use std::ptr;

pub type int16_t = libc::c_short;
pub type int32_t = libc::c_int;
pub type uint8_t = libc::c_uchar;
pub type uint16_t = libc::c_ushort;
pub type uint32_t = libc::c_uint;
pub type uintptr_t = libc::c_ulong;
pub type nk_byte = uint8_t;
pub type nk_short = int16_t;
pub type nk_ushort = uint16_t;
pub type nk_int = int32_t;
pub type nk_uint = uint32_t;
pub type nk_size = uintptr_t;
pub type nk_ptr = uintptr_t;
pub type nk_hash = nk_uint;
pub type nk_flags = nk_uint;
pub type nk_rune = nk_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_buffer {
    pub marker: [nk_buffer_marker; 2],
    pub pool: nk_allocator,
    pub type_0: nk_allocation_type,
    pub memory: nk_memory,
    pub grow_factor: f32,
    pub allocated: nk_size,
    pub needed: nk_size,
    pub calls: nk_size,
    pub size: nk_size,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_memory {
    pub ptr: *mut libc::c_void,
    pub size: nk_size,
}
pub type nk_allocation_type = libc::c_uint;
pub const NK_BUFFER_DYNAMIC: nk_allocation_type = 1;
pub const NK_BUFFER_FIXED: nk_allocation_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_allocator {
    pub userdata: nk_handle,
    pub alloc: nk_plugin_alloc,
    pub free: nk_plugin_free,
}
pub type nk_plugin_free = Option<unsafe fn(_: nk_handle, _: *mut libc::c_void) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub union nk_handle {
    pub ptr: *mut libc::c_void,
    pub id: libc::c_int,
}
pub type nk_plugin_alloc =
    Option<unsafe fn(_: nk_handle, _: *mut libc::c_void, _: nk_size) -> *mut libc::c_void>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_buffer_marker {
    pub active: libc::c_int,
    pub offset: nk_size,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_buffer {
    pub base: *mut nk_buffer,
    pub clip: nk_rect,
    pub use_clipping: libc::c_int,
    pub userdata: nk_handle,
    pub begin: nk_size,
    pub end: nk_size,
    pub last: nk_size,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_rect {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_draw_command {
    pub elem_count: libc::c_uint,
    pub clip_rect: nk_rect,
    pub texture: nk_handle,
    pub userdata: nk_handle,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_convert_config {
    pub global_alpha: f32,
    pub line_AA: nk_anti_aliasing,
    pub shape_AA: nk_anti_aliasing,
    pub circle_segment_count: libc::c_uint,
    pub arc_segment_count: libc::c_uint,
    pub curve_segment_count: libc::c_uint,
    pub null: nk_draw_null_texture,
    pub vertex_layout: *const nk_draw_vertex_layout_element,
    pub vertex_size: nk_size,
    pub vertex_alignment: nk_size,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_draw_vertex_layout_element {
    pub attribute: nk_draw_vertex_layout_attribute,
    pub format: nk_draw_vertex_layout_format,
    pub offset: nk_size,
}
pub type nk_draw_vertex_layout_format = libc::c_uint;
pub const NK_FORMAT_COUNT: nk_draw_vertex_layout_format = 19;
pub const NK_FORMAT_COLOR_END: nk_draw_vertex_layout_format = 18;
pub const NK_FORMAT_RGBA32: nk_draw_vertex_layout_format = 18;
pub const NK_FORMAT_RGB32: nk_draw_vertex_layout_format = 17;
pub const NK_FORMAT_R32G32B32A32_DOUBLE: nk_draw_vertex_layout_format = 16;
pub const NK_FORMAT_R32G32B32A32_FLOAT: nk_draw_vertex_layout_format = 15;
pub const NK_FORMAT_R32G32B32A32: nk_draw_vertex_layout_format = 14;
pub const NK_FORMAT_R16G15B16A16: nk_draw_vertex_layout_format = 13;
pub const NK_FORMAT_B8G8R8A8: nk_draw_vertex_layout_format = 12;
pub const NK_FORMAT_R8G8B8A8: nk_draw_vertex_layout_format = 11;
pub const NK_FORMAT_R32G32B32: nk_draw_vertex_layout_format = 10;
pub const NK_FORMAT_R16G15B16: nk_draw_vertex_layout_format = 9;
pub const NK_FORMAT_R8G8B8: nk_draw_vertex_layout_format = 8;
pub const NK_FORMAT_COLOR_BEGIN: nk_draw_vertex_layout_format = 8;
pub const NK_FORMAT_DOUBLE: nk_draw_vertex_layout_format = 7;
pub const NK_FORMAT_FLOAT: nk_draw_vertex_layout_format = 6;
pub const NK_FORMAT_UINT: nk_draw_vertex_layout_format = 5;
pub const NK_FORMAT_USHORT: nk_draw_vertex_layout_format = 4;
pub const NK_FORMAT_UCHAR: nk_draw_vertex_layout_format = 3;
pub const NK_FORMAT_SINT: nk_draw_vertex_layout_format = 2;
pub const NK_FORMAT_SSHORT: nk_draw_vertex_layout_format = 1;
pub const NK_FORMAT_SCHAR: nk_draw_vertex_layout_format = 0;
/* build up path has a connection back to the beginning */
pub type nk_draw_vertex_layout_attribute = libc::c_uint;
pub const NK_VERTEX_ATTRIBUTE_COUNT: nk_draw_vertex_layout_attribute = 3;
pub const NK_VERTEX_TEXCOORD: nk_draw_vertex_layout_attribute = 2;
pub const NK_VERTEX_COLOR: nk_draw_vertex_layout_attribute = 1;
pub const NK_VERTEX_POSITION: nk_draw_vertex_layout_attribute = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_draw_null_texture {
    pub texture: nk_handle,
    pub uv: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_vec2 {
    pub x: f32,
    pub y: f32,
}


pub type nk_anti_aliasing = libc::c_uint;
pub const NK_ANTI_ALIASING_ON: nk_anti_aliasing = 1;
pub const NK_ANTI_ALIASING_OFF: nk_anti_aliasing = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_item {
    pub type_0: nk_style_item_type,
    pub data: nk_style_item_data,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union nk_style_item_data {
    image: nk_image,
    color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_color {
    pub r: nk_byte,
    pub g: nk_byte,
    pub b: nk_byte,
    pub a: nk_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_image {
    pub handle: nk_handle,
    pub w: libc::c_ushort,
    pub h: libc::c_ushort,
    pub region: [libc::c_ushort; 4],
}
pub type nk_style_item_type = libc::c_uint;
pub const NK_STYLE_ITEM_IMAGE: nk_style_item_type = 1;
pub const NK_STYLE_ITEM_COLOR: nk_style_item_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_text_edit {
    pub clip: nk_clipboard,
    pub string: nk_str,
    pub filter: nk_plugin_filter,
    pub scrollbar: nk_vec2,
    pub cursor: libc::c_int,
    pub select_start: libc::c_int,
    pub select_end: libc::c_int,
    pub mode: libc::c_uchar,
    pub cursor_at_end_of_line: libc::c_uchar,
    pub initialized: libc::c_uchar,
    pub has_preferred_x: libc::c_uchar,
    pub single_line: libc::c_uchar,
    pub active: libc::c_uchar,
    pub padding1: libc::c_uchar,
    pub preferred_x: f32,
    pub undo: nk_text_undo_state,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_text_undo_state {
    pub undo_rec: [nk_text_undo_record; 99],
    pub undo_char: [nk_rune; 999],
    pub undo_point: libc::c_short,
    pub redo_point: libc::c_short,
    pub undo_char_point: libc::c_short,
    pub redo_char_point: libc::c_short,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_text_undo_record {
    pub where_0: libc::c_int,
    pub insert_length: libc::c_short,
    pub delete_length: libc::c_short,
    pub char_storage: libc::c_short,
}
pub type nk_plugin_filter = Option<unsafe fn(_: *const nk_text_edit, _: nk_rune) -> libc::c_int>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_str {
    pub buffer: nk_buffer,
    pub len: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_clipboard {
    pub userdata: nk_handle,
    pub paste: nk_plugin_paste,
    pub copy: nk_plugin_copy,
}
pub type nk_plugin_copy =
    Option<unsafe fn(_: nk_handle, _: *const libc::c_char, _: libc::c_int) -> ()>;
pub type nk_plugin_paste = Option<unsafe fn(_: nk_handle, _: *mut nk_text_edit) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_draw_list {
    pub clip_rect: nk_rect,
    pub circle_vtx: [nk_vec2; 12],
    pub config: nk_convert_config,
    pub buffer: *mut nk_buffer,
    pub vertices: *mut nk_buffer,
    pub elements: *mut nk_buffer,
    pub element_count: libc::c_uint,
    pub vertex_count: libc::c_uint,
    pub cmd_count: libc::c_uint,
    pub cmd_offset: nk_size,
    pub path_count: libc::c_uint,
    pub path_offset: libc::c_uint,
    pub line_AA: nk_anti_aliasing,
    pub shape_AA: nk_anti_aliasing,
    pub userdata: nk_handle,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_user_font {
    pub userdata: nk_handle,
    pub height: f32,
    pub width: nk_text_width_f,
    pub query: nk_query_font_glyph_f,
    pub texture: nk_handle,
}
pub type nk_query_font_glyph_f = Option<
    unsafe fn(_: nk_handle, _: f32, _: *mut nk_user_font_glyph, _: nk_rune, _: nk_rune)
        -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_user_font_glyph {
    pub uv: [nk_vec2; 2],
    pub offset: nk_vec2,
    pub width: f32,
    pub height: f32,
    pub xadvance: f32,
}
pub type nk_text_width_f = Option<
    unsafe fn(_: nk_handle, _: f32, _: *const libc::c_char, _: libc::c_int)
        -> f32,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_panel {
    pub type_0: nk_panel_type,
    pub flags: nk_flags,
    pub bounds: nk_rect,
    pub offset_x: *mut nk_uint,
    pub offset_y: *mut nk_uint,
    pub at_x: f32,
    pub at_y: f32,
    pub max_x: f32,
    pub footer_height: f32,
    pub header_height: f32,
    pub border: f32,
    pub has_scrolling: libc::c_uint,
    pub clip: nk_rect,
    pub menu: nk_menu_state,
    pub row: nk_row_layout,
    pub chart: nk_chart,
    pub buffer: *mut nk_command_buffer,
    pub parent: *mut nk_panel,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_chart {
    pub slot: libc::c_int,
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
    pub slots: [nk_chart_slot; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_chart_slot {
    pub type_0: nk_chart_type,
    pub color: nk_color,
    pub highlight: nk_color,
    pub min: f32,
    pub max: f32,
    pub range: f32,
    pub count: libc::c_int,
    pub last: nk_vec2,
    pub index: libc::c_int,
}
pub type nk_chart_type = libc::c_uint;
pub const NK_CHART_MAX: nk_chart_type = 2;
pub const NK_CHART_COLUMN: nk_chart_type = 1;
pub const NK_CHART_LINES: nk_chart_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_row_layout {
    pub type_0: nk_panel_row_layout_type,
    pub index: libc::c_int,
    pub height: f32,
    pub min_height: f32,
    pub columns: libc::c_int,
    pub ratio: *const f32,
    pub item_width: f32,
    pub item_height: f32,
    pub item_offset: f32,
    pub filled: f32,
    pub item: nk_rect,
    pub tree_depth: libc::c_int,
    pub templates: [f32; 16],
}
pub type nk_panel_row_layout_type = libc::c_uint;
pub const NK_LAYOUT_COUNT: nk_panel_row_layout_type = 9;
pub const NK_LAYOUT_TEMPLATE: nk_panel_row_layout_type = 8;
pub const NK_LAYOUT_STATIC: nk_panel_row_layout_type = 7;
pub const NK_LAYOUT_STATIC_FREE: nk_panel_row_layout_type = 6;
pub const NK_LAYOUT_STATIC_ROW: nk_panel_row_layout_type = 5;
pub const NK_LAYOUT_STATIC_FIXED: nk_panel_row_layout_type = 4;
pub const NK_LAYOUT_DYNAMIC: nk_panel_row_layout_type = 3;
pub const NK_LAYOUT_DYNAMIC_FREE: nk_panel_row_layout_type = 2;
pub const NK_LAYOUT_DYNAMIC_ROW: nk_panel_row_layout_type = 1;
pub const NK_LAYOUT_DYNAMIC_FIXED: nk_panel_row_layout_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_menu_state {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
    pub offset: nk_scroll,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_scroll {
    pub x: nk_uint,
    pub y: nk_uint,
}
pub type nk_panel_type = libc::c_uint;
pub const NK_PANEL_TOOLTIP: nk_panel_type = 128;
pub const NK_PANEL_MENU: nk_panel_type = 64;
pub const NK_PANEL_COMBO: nk_panel_type = 32;
pub const NK_PANEL_CONTEXTUAL: nk_panel_type = 16;
pub const NK_PANEL_POPUP: nk_panel_type = 4;
pub const NK_PANEL_GROUP: nk_panel_type = 2;
pub const NK_PANEL_WINDOW: nk_panel_type = 1;
pub const NK_PANEL_NONE: nk_panel_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_context {
    pub input: nk_input,
    pub style: nk_style,
    pub memory: nk_buffer,
    pub clip: nk_clipboard,
    pub last_widget_state: nk_flags,
    pub button_behavior: nk_button_behavior,
    pub stacks: nk_configuration_stacks,
    pub delta_time_seconds: f32,
    pub draw_list: nk_draw_list,
    pub userdata: nk_handle,
    pub text_edit: nk_text_edit,
    pub overlay: nk_command_buffer,
    pub build: libc::c_int,
    pub use_pool: libc::c_int,
    pub pool: nk_pool,
    pub begin: *mut nk_window,
    pub end: *mut nk_window,
    pub active: *mut nk_window,
    pub current: *mut nk_window,
    pub freelist: *mut nk_page_element,
    pub count: libc::c_uint,
    pub seq: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_page_element {
    pub data: nk_page_data,
    pub next: *mut nk_page_element,
    pub prev: *mut nk_page_element,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union nk_page_data {
    tbl: nk_table,
    pan: nk_panel,
    win: nk_window,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_window {
    pub seq: libc::c_uint,
    pub name: nk_hash,
    pub name_string: [libc::c_char; 64],
    pub flags: nk_flags,
    pub bounds: nk_rect,
    pub scrollbar: nk_scroll,
    pub buffer: nk_command_buffer,
    pub layout: *mut nk_panel,
    pub scrollbar_hiding_timer: f32,
    pub property: nk_property_state,
    pub popup: nk_popup_state,
    pub edit: nk_edit_state,
    pub scrolled: libc::c_uint,
    pub tables: *mut nk_table,
    pub table_count: libc::c_uint,
    pub next: *mut nk_window,
    pub prev: *mut nk_window,
    pub parent: *mut nk_window,
}
/*==============================================================
 *                          WINDOW
 * =============================================================*/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_table {
    pub seq: libc::c_uint,
    pub size: libc::c_uint,
    pub keys: [nk_hash; 59],
    pub values: [nk_uint; 59],
    pub next: *mut nk_table,
    pub prev: *mut nk_table,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_edit_state {
    pub name: nk_hash,
    pub seq: libc::c_uint,
    pub old: libc::c_uint,
    pub active: libc::c_int,
    pub prev: libc::c_int,
    pub cursor: libc::c_int,
    pub sel_start: libc::c_int,
    pub sel_end: libc::c_int,
    pub scrollbar: nk_scroll,
    pub mode: libc::c_uchar,
    pub single_line: libc::c_uchar,
}
/* Removes read only mode at the end of the window */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_popup_state {
    pub win: *mut nk_window,
    pub type_0: nk_panel_type,
    pub buf: nk_popup_buffer,
    pub name: nk_hash,
    pub active: libc::c_int,
    pub combo_count: libc::c_uint,
    pub con_count: libc::c_uint,
    pub con_old: libc::c_uint,
    pub active_con: libc::c_uint,
    pub header: nk_rect,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_popup_buffer {
    pub begin: nk_size,
    pub parent: nk_size,
    pub last: nk_size,
    pub end: nk_size,
    pub active: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_property_state {
    pub active: libc::c_int,
    pub prev: libc::c_int,
    pub buffer: [libc::c_char; 64],
    pub length: libc::c_int,
    pub cursor: libc::c_int,
    pub select_start: libc::c_int,
    pub select_end: libc::c_int,
    pub name: nk_hash,
    pub seq: libc::c_uint,
    pub old: libc::c_uint,
    pub state: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_pool {
    pub alloc: nk_allocator,
    pub type_0: nk_allocation_type,
    pub page_count: libc::c_uint,
    pub pages: *mut nk_page,
    pub freelist: *mut nk_page_element,
    pub capacity: libc::c_uint,
    pub size: nk_size,
    pub cap: nk_size,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_page {
    pub size: libc::c_uint,
    pub next: *mut nk_page,
    pub win: [nk_page_element; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_configuration_stacks {
    pub style_items: nk_config_stack_style_item,
    pub floats: nk_config_stack_float,
    pub vectors: nk_config_stack_vec2,
    pub flags: nk_config_stack_flags,
    pub colors: nk_config_stack_color,
    pub fonts: nk_config_stack_user_font,
    pub button_behaviors: nk_config_stack_button_behavior,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_button_behavior {
    pub head: libc::c_int,
    pub elements: [nk_config_stack_button_behavior_element; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_button_behavior_element {
    pub address: *mut nk_button_behavior,
    pub old_value: nk_button_behavior,
}
pub type nk_button_behavior = libc::c_uint;
pub const NK_BUTTON_REPEATER: nk_button_behavior = 1;
pub const NK_BUTTON_DEFAULT: nk_button_behavior = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_user_font {
    pub head: libc::c_int,
    pub elements: [nk_config_stack_user_font_element; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_user_font_element {
    pub address: *mut *const nk_user_font,
    pub old_value: *const nk_user_font,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_color {
    pub head: libc::c_int,
    pub elements: [nk_config_stack_color_element; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_color_element {
    pub address: *mut nk_color,
    pub old_value: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_flags {
    pub head: libc::c_int,
    pub elements: [nk_config_stack_flags_element; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_flags_element {
    pub address: *mut nk_flags,
    pub old_value: nk_flags,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_vec2 {
    pub head: libc::c_int,
    pub elements: [nk_config_stack_vec2_element; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_vec2_element {
    pub address: *mut nk_vec2,
    pub old_value: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_float {
    pub head: libc::c_int,
    pub elements: [nk_config_stack_float_element; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_float_element {
    pub address: *mut f32,
    pub old_value: f32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_style_item {
    pub head: libc::c_int,
    pub elements: [nk_config_stack_style_item_element; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_config_stack_style_item_element {
    pub address: *mut nk_style_item,
    pub old_value: nk_style_item,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style {
    pub font: *const nk_user_font,
    pub cursors: [*const nk_cursor; 7],
    pub cursor_active: *const nk_cursor,
    pub cursor_last: *mut nk_cursor,
    pub cursor_visible: libc::c_int,
    pub text: nk_style_text,
    pub button: nk_style_button,
    pub contextual_button: nk_style_button,
    pub menu_button: nk_style_button,
    pub option: nk_style_toggle,
    pub checkbox: nk_style_toggle,
    pub selectable: nk_style_selectable,
    pub slider: nk_style_slider,
    pub progress: nk_style_progress,
    pub property: nk_style_property,
    pub edit: nk_style_edit,
    pub chart: nk_style_chart,
    pub scrollh: nk_style_scrollbar,
    pub scrollv: nk_style_scrollbar,
    pub tab: nk_style_tab,
    pub combo: nk_style_combo,
    pub window: nk_style_window,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_window {
    pub header: nk_style_window_header,
    pub fixed_background: nk_style_item,
    pub background: nk_color,
    pub border_color: nk_color,
    pub popup_border_color: nk_color,
    pub combo_border_color: nk_color,
    pub contextual_border_color: nk_color,
    pub menu_border_color: nk_color,
    pub group_border_color: nk_color,
    pub tooltip_border_color: nk_color,
    pub scaler: nk_style_item,
    pub border: f32,
    pub combo_border: f32,
    pub contextual_border: f32,
    pub menu_border: f32,
    pub group_border: f32,
    pub tooltip_border: f32,
    pub popup_border: f32,
    pub min_row_height_padding: f32,
    pub rounding: f32,
    pub spacing: nk_vec2,
    pub scrollbar_size: nk_vec2,
    pub min_size: nk_vec2,
    pub padding: nk_vec2,
    pub group_padding: nk_vec2,
    pub popup_padding: nk_vec2,
    pub combo_padding: nk_vec2,
    pub contextual_padding: nk_vec2,
    pub menu_padding: nk_vec2,
    pub tooltip_padding: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_window_header {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub close_button: nk_style_button,
    pub minimize_button: nk_style_button,
    pub close_symbol: nk_symbol_type,
    pub minimize_symbol: nk_symbol_type,
    pub maximize_symbol: nk_symbol_type,
    pub label_normal: nk_color,
    pub label_hover: nk_color,
    pub label_active: nk_color,
    pub align: nk_style_header_align,
    pub padding: nk_vec2,
    pub label_padding: nk_vec2,
    pub spacing: nk_vec2,
}
pub type nk_style_header_align = libc::c_uint;
pub const NK_HEADER_RIGHT: nk_style_header_align = 1;
pub const NK_HEADER_LEFT: nk_style_header_align = 0;
pub type nk_symbol_type = libc::c_uint;
pub const NK_SYMBOL_MAX: nk_symbol_type = 13;
pub const NK_SYMBOL_MINUS: nk_symbol_type = 12;
pub const NK_SYMBOL_PLUS: nk_symbol_type = 11;
pub const NK_SYMBOL_TRIANGLE_RIGHT: nk_symbol_type = 10;
pub const NK_SYMBOL_TRIANGLE_LEFT: nk_symbol_type = 9;
pub const NK_SYMBOL_TRIANGLE_DOWN: nk_symbol_type = 8;
pub const NK_SYMBOL_TRIANGLE_UP: nk_symbol_type = 7;
pub const NK_SYMBOL_RECT_OUTLINE: nk_symbol_type = 6;
pub const NK_SYMBOL_RECT_SOLID: nk_symbol_type = 5;
pub const NK_SYMBOL_CIRCLE_OUTLINE: nk_symbol_type = 4;
pub const NK_SYMBOL_CIRCLE_SOLID: nk_symbol_type = 3;
pub const NK_SYMBOL_UNDERSCORE: nk_symbol_type = 2;
pub const NK_SYMBOL_X: nk_symbol_type = 1;
pub const NK_SYMBOL_NONE: nk_symbol_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_button {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub text_background: nk_color,
    pub text_normal: nk_color,
    pub text_hover: nk_color,
    pub text_active: nk_color,
    pub text_alignment: nk_flags,
    pub border: f32,
    pub rounding: f32,
    pub padding: nk_vec2,
    pub image_padding: nk_vec2,
    pub touch_padding: nk_vec2,
    pub userdata: nk_handle,
    pub draw_begin: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_combo {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub label_normal: nk_color,
    pub label_hover: nk_color,
    pub label_active: nk_color,
    pub symbol_normal: nk_color,
    pub symbol_hover: nk_color,
    pub symbol_active: nk_color,
    pub button: nk_style_button,
    pub sym_normal: nk_symbol_type,
    pub sym_hover: nk_symbol_type,
    pub sym_active: nk_symbol_type,
    pub border: f32,
    pub rounding: f32,
    pub content_padding: nk_vec2,
    pub button_padding: nk_vec2,
    pub spacing: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_tab {
    pub background: nk_style_item,
    pub border_color: nk_color,
    pub text: nk_color,
    pub tab_maximize_button: nk_style_button,
    pub tab_minimize_button: nk_style_button,
    pub node_maximize_button: nk_style_button,
    pub node_minimize_button: nk_style_button,
    pub sym_minimize: nk_symbol_type,
    pub sym_maximize: nk_symbol_type,
    pub border: f32,
    pub rounding: f32,
    pub indent: f32,
    pub padding: nk_vec2,
    pub spacing: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_scrollbar {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub cursor_normal: nk_style_item,
    pub cursor_hover: nk_style_item,
    pub cursor_active: nk_style_item,
    pub cursor_border_color: nk_color,
    pub border: f32,
    pub rounding: f32,
    pub border_cursor: f32,
    pub rounding_cursor: f32,
    pub padding: nk_vec2,
    pub show_buttons: libc::c_int,
    pub inc_button: nk_style_button,
    pub dec_button: nk_style_button,
    pub inc_symbol: nk_symbol_type,
    pub dec_symbol: nk_symbol_type,
    pub userdata: nk_handle,
    pub draw_begin: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_chart {
    pub background: nk_style_item,
    pub border_color: nk_color,
    pub selected_color: nk_color,
    pub color: nk_color,
    pub border: f32,
    pub rounding: f32,
    pub padding: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_edit {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub scrollbar: nk_style_scrollbar,
    pub cursor_normal: nk_color,
    pub cursor_hover: nk_color,
    pub cursor_text_normal: nk_color,
    pub cursor_text_hover: nk_color,
    pub text_normal: nk_color,
    pub text_hover: nk_color,
    pub text_active: nk_color,
    pub selected_normal: nk_color,
    pub selected_hover: nk_color,
    pub selected_text_normal: nk_color,
    pub selected_text_hover: nk_color,
    pub border: f32,
    pub rounding: f32,
    pub cursor_size: f32,
    pub scrollbar_size: nk_vec2,
    pub padding: nk_vec2,
    pub row_padding: f32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_property {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub label_normal: nk_color,
    pub label_hover: nk_color,
    pub label_active: nk_color,
    pub sym_left: nk_symbol_type,
    pub sym_right: nk_symbol_type,
    pub border: f32,
    pub rounding: f32,
    pub padding: nk_vec2,
    pub edit: nk_style_edit,
    pub inc_button: nk_style_button,
    pub dec_button: nk_style_button,
    pub userdata: nk_handle,
    pub draw_begin: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_progress {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub cursor_normal: nk_style_item,
    pub cursor_hover: nk_style_item,
    pub cursor_active: nk_style_item,
    pub cursor_border_color: nk_color,
    pub rounding: f32,
    pub border: f32,
    pub cursor_border: f32,
    pub cursor_rounding: f32,
    pub padding: nk_vec2,
    pub userdata: nk_handle,
    pub draw_begin: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_slider {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub bar_normal: nk_color,
    pub bar_hover: nk_color,
    pub bar_active: nk_color,
    pub bar_filled: nk_color,
    pub cursor_normal: nk_style_item,
    pub cursor_hover: nk_style_item,
    pub cursor_active: nk_style_item,
    pub border: f32,
    pub rounding: f32,
    pub bar_height: f32,
    pub padding: nk_vec2,
    pub spacing: nk_vec2,
    pub cursor_size: nk_vec2,
    pub show_buttons: libc::c_int,
    pub inc_button: nk_style_button,
    pub dec_button: nk_style_button,
    pub inc_symbol: nk_symbol_type,
    pub dec_symbol: nk_symbol_type,
    pub userdata: nk_handle,
    pub draw_begin: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_selectable {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub pressed: nk_style_item,
    pub normal_active: nk_style_item,
    pub hover_active: nk_style_item,
    pub pressed_active: nk_style_item,
    pub text_normal: nk_color,
    pub text_hover: nk_color,
    pub text_pressed: nk_color,
    pub text_normal_active: nk_color,
    pub text_hover_active: nk_color,
    pub text_pressed_active: nk_color,
    pub text_background: nk_color,
    pub text_alignment: nk_flags,
    pub rounding: f32,
    pub padding: nk_vec2,
    pub touch_padding: nk_vec2,
    pub image_padding: nk_vec2,
    pub userdata: nk_handle,
    pub draw_begin: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_toggle {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub cursor_normal: nk_style_item,
    pub cursor_hover: nk_style_item,
    pub text_normal: nk_color,
    pub text_hover: nk_color,
    pub text_active: nk_color,
    pub text_background: nk_color,
    pub text_alignment: nk_flags,
    pub padding: nk_vec2,
    pub touch_padding: nk_vec2,
    pub spacing: f32,
    pub border: f32,
    pub userdata: nk_handle,
    pub draw_begin: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut nk_command_buffer, _: nk_handle) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_style_text {
    pub color: nk_color,
    pub padding: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_cursor {
    pub img: nk_image,
    pub size: nk_vec2,
    pub offset: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_input {
    pub keyboard: nk_keyboard,
    pub mouse: nk_mouse,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_mouse {
    pub buttons: [nk_mouse_button; 4],
    pub pos: nk_vec2,
    pub prev: nk_vec2,
    pub delta: nk_vec2,
    pub scroll_delta: nk_vec2,
    pub grab: libc::c_uchar,
    pub grabbed: libc::c_uchar,
    pub ungrab: libc::c_uchar,
}
/* shape outlines */
/* filled shades */
/* misc */
/* ===============================================================
 *
 *                          INPUT
 *
 * ===============================================================*/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_mouse_button {
    pub down: libc::c_int,
    pub clicked: libc::c_uint,
    pub clicked_pos: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_keyboard {
    pub keys: [nk_key; 30],
    pub text: [libc::c_char; 16],
    pub text_len: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_key {
    pub down: libc::c_int,
    pub clicked: libc::c_uint,
}
pub type unnamed = libc::c_uint;
pub const nk_true: unnamed = 1;
pub const nk_false: unnamed = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_colorf {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_vec2i {
    pub x: libc::c_short,
    pub y: libc::c_short,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_recti {
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub w: libc::c_short,
    pub h: libc::c_short,
}
pub type nk_glyph = [libc::c_char; 4];
pub type nk_heading = libc::c_uint;
pub const NK_LEFT: nk_heading = 3;
pub const NK_DOWN: nk_heading = 2;
pub const NK_RIGHT: nk_heading = 1;
pub const NK_UP: nk_heading = 0;
pub type nk_orientation = libc::c_uint;
pub const NK_HORIZONTAL: nk_orientation = 1;
pub const NK_VERTICAL: nk_orientation = 0;
pub type nk_collapse_states = libc::c_uint;
pub const NK_MAXIMIZED: nk_collapse_states = 1;
pub const NK_MINIMIZED: nk_collapse_states = 0;
pub type nk_show_states = libc::c_uint;
pub const NK_SHOWN: nk_show_states = 1;
pub const NK_HIDDEN: nk_show_states = 0;
pub type nk_chart_event = libc::c_uint;
pub const NK_CHART_CLICKED: nk_chart_event = 2;
pub const NK_CHART_HOVERING: nk_chart_event = 1;
pub type nk_color_format = libc::c_uint;
pub const NK_RGBA: nk_color_format = 1;
pub const NK_RGB: nk_color_format = 0;
pub type nk_popup_type = libc::c_uint;
pub const NK_POPUP_DYNAMIC: nk_popup_type = 1;
pub const NK_POPUP_STATIC: nk_popup_type = 0;
pub type nk_layout_format = libc::c_uint;
pub const NK_STATIC: nk_layout_format = 1;
pub const NK_DYNAMIC: nk_layout_format = 0;
pub type nk_tree_type = libc::c_uint;
pub const NK_TREE_TAB: nk_tree_type = 1;
pub const NK_TREE_NODE: nk_tree_type = 0;
pub const NK_COLOR_TEXT: nk_style_colors = 0;
pub const NK_COLOR_BORDER: nk_style_colors = 3;
pub const NK_COLOR_WINDOW: nk_style_colors = 1;
pub const NK_TEXT_CENTERED: nk_text_alignment = 18;
pub const NK_COLOR_HEADER: nk_style_colors = 2;
pub const NK_COLOR_TAB_HEADER: nk_style_colors = 27;
pub const NK_COLOR_COMBO: nk_style_colors = 19;
pub const NK_COLOR_CHART_COLOR: nk_style_colors = 21;
pub const NK_COLOR_CHART_COLOR_HIGHLIGHT: nk_style_colors = 22;
pub const NK_COLOR_CHART: nk_style_colors = 20;
pub const NK_COLOR_EDIT: nk_style_colors = 17;
pub const NK_COLOR_PROPERTY: nk_style_colors = 16;
pub const NK_COLOR_SCROLLBAR: nk_style_colors = 23;
pub const NK_COLOR_SCROLLBAR_CURSOR_ACTIVE: nk_style_colors = 26;
pub const NK_COLOR_SCROLLBAR_CURSOR_HOVER: nk_style_colors = 25;
pub const NK_COLOR_SCROLLBAR_CURSOR: nk_style_colors = 24;
pub const NK_COLOR_SLIDER_CURSOR_ACTIVE: nk_style_colors = 15;
pub const NK_COLOR_SLIDER_CURSOR_HOVER: nk_style_colors = 14;
pub const NK_COLOR_SLIDER_CURSOR: nk_style_colors = 13;
pub const NK_COLOR_SLIDER: nk_style_colors = 12;
pub const NK_COLOR_SELECT_ACTIVE: nk_style_colors = 11;
pub const NK_COLOR_SELECT: nk_style_colors = 10;
pub const NK_COLOR_TOGGLE_CURSOR: nk_style_colors = 9;
pub const NK_COLOR_TOGGLE_HOVER: nk_style_colors = 8;
pub const NK_COLOR_TOGGLE: nk_style_colors = 7;
pub const NK_COLOR_BUTTON_ACTIVE: nk_style_colors = 6;
pub const NK_COLOR_BUTTON_HOVER: nk_style_colors = 5;
pub const NK_COLOR_BUTTON: nk_style_colors = 4;
/* special window type growing up in height while being filled to a certain maximum height */
pub const NK_WINDOW_ROM: nk_window_flags = 4096;
/* Hides window and stops any window interaction and drawing */
pub const NK_WINDOW_CLOSED: nk_window_flags = 16384;
/* prevents all interaction caused by input to either window or widgets inside */
pub const NK_WINDOW_HIDDEN: nk_window_flags = 8192;
/* Directly closes and frees the window at the end of the frame */
pub const NK_WINDOW_MINIMIZED: nk_window_flags = 32768;
pub const NK_CURSOR_ARROW: nk_style_cursor = 0;
pub type nk_buffer_allocation_type = libc::c_uint;
pub const NK_BUFFER_MAX: nk_buffer_allocation_type = 2;
pub const NK_BUFFER_BACK: nk_buffer_allocation_type = 1;
pub const NK_BUFFER_FRONT: nk_buffer_allocation_type = 0;
pub type nk_keys = libc::c_uint;
pub const NK_KEY_MAX: nk_keys = 30;
pub const NK_KEY_SCROLL_UP: nk_keys = 29;
pub const NK_KEY_SCROLL_DOWN: nk_keys = 28;
pub const NK_KEY_SCROLL_END: nk_keys = 27;
/* Shortcuts: scrollbar */
pub const NK_KEY_SCROLL_START: nk_keys = 26;
pub const NK_KEY_TEXT_WORD_RIGHT: nk_keys = 25;
pub const NK_KEY_TEXT_WORD_LEFT: nk_keys = 24;
pub const NK_KEY_TEXT_SELECT_ALL: nk_keys = 23;
pub const NK_KEY_TEXT_REDO: nk_keys = 22;
pub const NK_KEY_TEXT_UNDO: nk_keys = 21;
pub const NK_KEY_TEXT_END: nk_keys = 20;
pub const NK_KEY_TEXT_START: nk_keys = 19;
pub const NK_KEY_TEXT_LINE_END: nk_keys = 18;
pub const NK_KEY_TEXT_LINE_START: nk_keys = 17;
pub const NK_KEY_TEXT_RESET_MODE: nk_keys = 16;
pub const NK_KEY_TEXT_REPLACE_MODE: nk_keys = 15;
/* Shortcuts: text field */
pub const NK_KEY_TEXT_INSERT_MODE: nk_keys = 14;
pub const NK_KEY_RIGHT: nk_keys = 13;
pub const NK_KEY_LEFT: nk_keys = 12;
pub const NK_KEY_DOWN: nk_keys = 11;
pub const NK_KEY_UP: nk_keys = 10;
pub const NK_KEY_PASTE: nk_keys = 9;
pub const NK_KEY_CUT: nk_keys = 8;
pub const NK_KEY_COPY: nk_keys = 7;
pub const NK_KEY_BACKSPACE: nk_keys = 6;
pub const NK_KEY_TAB: nk_keys = 5;
pub const NK_KEY_ENTER: nk_keys = 4;
pub const NK_KEY_DEL: nk_keys = 3;
pub const NK_KEY_CTRL: nk_keys = 2;
pub const NK_KEY_SHIFT: nk_keys = 1;
pub const NK_KEY_NONE: nk_keys = 0;
pub type nk_buttons = libc::c_uint;
pub const NK_BUTTON_MAX: nk_buttons = 4;
pub const NK_BUTTON_DOUBLE: nk_buttons = 3;
pub const NK_BUTTON_RIGHT: nk_buttons = 2;
pub const NK_BUTTON_MIDDLE: nk_buttons = 1;
pub const NK_BUTTON_LEFT: nk_buttons = 0;
pub type nk_convert_result = libc::c_uint;
pub const NK_CONVERT_ELEMENT_BUFFER_FULL: nk_convert_result = 8;
pub const NK_CONVERT_VERTEX_BUFFER_FULL: nk_convert_result = 4;
pub const NK_CONVERT_COMMAND_BUFFER_FULL: nk_convert_result = 2;
pub const NK_CONVERT_INVALID_PARAM: nk_convert_result = 1;
pub const NK_CONVERT_SUCCESS: nk_convert_result = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command {
    pub type_0: nk_command_type,
    pub next: nk_size,
    pub userdata: nk_handle,
}
pub type nk_command_type = libc::c_uint;
pub const NK_COMMAND_CUSTOM: nk_command_type = 18;
pub const NK_COMMAND_IMAGE: nk_command_type = 17;
pub const NK_COMMAND_TEXT: nk_command_type = 16;
pub const NK_COMMAND_POLYLINE: nk_command_type = 15;
pub const NK_COMMAND_POLYGON_FILLED: nk_command_type = 14;
pub const NK_COMMAND_POLYGON: nk_command_type = 13;
pub const NK_COMMAND_TRIANGLE_FILLED: nk_command_type = 12;
pub const NK_COMMAND_TRIANGLE: nk_command_type = 11;
pub const NK_COMMAND_ARC_FILLED: nk_command_type = 10;
pub const NK_COMMAND_ARC: nk_command_type = 9;
pub const NK_COMMAND_CIRCLE_FILLED: nk_command_type = 8;
pub const NK_COMMAND_CIRCLE: nk_command_type = 7;
pub const NK_COMMAND_RECT_MULTI_COLOR: nk_command_type = 6;
pub const NK_COMMAND_RECT_FILLED: nk_command_type = 5;
pub const NK_COMMAND_RECT: nk_command_type = 4;
pub const NK_COMMAND_CURVE: nk_command_type = 3;
pub const NK_COMMAND_LINE: nk_command_type = 2;
pub const NK_COMMAND_SCISSOR: nk_command_type = 1;
pub const NK_COMMAND_NOP: nk_command_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_image {
    pub header: nk_command,
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub w: libc::c_ushort,
    pub h: libc::c_ushort,
    pub img: nk_image,
    pub col: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_0 {
    pub c: libc::c_char,
    pub _h: nk_command,
}
pub type nk_command_clipping = libc::c_uint;
pub const NK_CLIPPING_ON: nk_command_clipping = 1;
pub const NK_CLIPPING_OFF: nk_command_clipping = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_custom {
    pub header: nk_command,
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub w: libc::c_ushort,
    pub h: libc::c_ushort,
    pub callback_data: nk_handle,
    pub callback: nk_command_custom_callback,
}
pub type nk_command_custom_callback = Option<
    unsafe fn(
        _: *mut libc::c_void,
        _: libc::c_short,
        _: libc::c_short,
        _: libc::c_ushort,
        _: libc::c_ushort,
        _: nk_handle,
    ) -> (),
>;
pub type nk_draw_index = nk_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_1 {
    pub c: libc::c_char,
    pub _h: nk_draw_index,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_2 {
    pub c: libc::c_char,
    pub _h: nk_draw_command,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_text {
    pub header: nk_command,
    pub font: *const nk_user_font,
    pub background: nk_color,
    pub foreground: nk_color,
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub w: libc::c_ushort,
    pub h: libc::c_ushort,
    pub height: f32,
    pub length: libc::c_int,
    pub string: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_polyline {
    pub header: nk_command,
    pub color: nk_color,
    pub line_thickness: libc::c_ushort,
    pub point_count: libc::c_ushort,
    pub points: [nk_vec2i; 1],
}
pub type nk_draw_list_stroke = libc::c_uint;
/* build up path has no connection back to the beginning */
pub const NK_STROKE_CLOSED: nk_draw_list_stroke = 1;
pub const NK_STROKE_OPEN: nk_draw_list_stroke = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union unnamed_3 {
    i: nk_uint,
    f: f32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_4 {
    pub c: libc::c_char,
    pub _h: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_5 {
    pub c: libc::c_char,
    pub _h: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_polygon_filled {
    pub header: nk_command,
    pub color: nk_color,
    pub point_count: libc::c_ushort,
    pub points: [nk_vec2i; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_6 {
    pub c: libc::c_char,
    pub _h: nk_vec2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_polygon {
    pub header: nk_command,
    pub color: nk_color,
    pub line_thickness: libc::c_ushort,
    pub point_count: libc::c_ushort,
    pub points: [nk_vec2i; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_triangle_filled {
    pub header: nk_command,
    pub a: nk_vec2i,
    pub b: nk_vec2i,
    pub c: nk_vec2i,
    pub color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_triangle {
    pub header: nk_command,
    pub line_thickness: libc::c_ushort,
    pub a: nk_vec2i,
    pub b: nk_vec2i,
    pub c: nk_vec2i,
    pub color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_arc_filled {
    pub header: nk_command,
    pub cx: libc::c_short,
    pub cy: libc::c_short,
    pub r: libc::c_ushort,
    pub a: [f32; 2],
    pub color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_arc {
    pub header: nk_command,
    pub cx: libc::c_short,
    pub cy: libc::c_short,
    pub r: libc::c_ushort,
    pub line_thickness: libc::c_ushort,
    pub a: [f32; 2],
    pub color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_circle_filled {
    pub header: nk_command,
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub w: libc::c_ushort,
    pub h: libc::c_ushort,
    pub color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_circle {
    pub header: nk_command,
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub line_thickness: libc::c_ushort,
    pub w: libc::c_ushort,
    pub h: libc::c_ushort,
    pub color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_rect_multi_color {
    pub header: nk_command,
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub w: libc::c_ushort,
    pub h: libc::c_ushort,
    pub left: nk_color,
    pub top: nk_color,
    pub bottom: nk_color,
    pub right: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_rect_filled {
    pub header: nk_command,
    pub rounding: libc::c_ushort,
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub w: libc::c_ushort,
    pub h: libc::c_ushort,
    pub color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_rect {
    pub header: nk_command,
    pub rounding: libc::c_ushort,
    pub line_thickness: libc::c_ushort,
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub w: libc::c_ushort,
    pub h: libc::c_ushort,
    pub color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_curve {
    pub header: nk_command,
    pub line_thickness: libc::c_ushort,
    pub begin: nk_vec2i,
    pub end: nk_vec2i,
    pub ctrl: [nk_vec2i; 2],
    pub color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_line {
    pub header: nk_command,
    pub line_thickness: libc::c_ushort,
    pub begin: nk_vec2i,
    pub end: nk_vec2i,
    pub color: nk_color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_command_scissor {
    pub header: nk_command,
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub w: libc::c_ushort,
    pub h: libc::c_ushort,
}
pub type nk_panel_flags = libc::c_uint;
pub const NK_WINDOW_NO_INPUT: nk_panel_flags = 1024;
pub const NK_WINDOW_SCALE_LEFT: nk_panel_flags = 512;
pub const NK_WINDOW_BACKGROUND: nk_panel_flags = 256;
pub const NK_WINDOW_SCROLL_AUTO_HIDE: nk_panel_flags = 128;
pub const NK_WINDOW_TITLE: nk_panel_flags = 64;
pub const NK_WINDOW_NO_SCROLLBAR: nk_panel_flags = 32;
pub const NK_WINDOW_MINIMIZABLE: nk_panel_flags = 16;
pub const NK_WINDOW_CLOSABLE: nk_panel_flags = 8;
pub const NK_WINDOW_SCALABLE: nk_panel_flags = 4;
pub const NK_WINDOW_MOVABLE: nk_panel_flags = 2;
pub const NK_WINDOW_BORDER: nk_panel_flags = 1;
pub const NK_WINDOW_DYNAMIC: nk_window_flags = 2048;
pub const NK_TEXT_LEFT: nk_text_alignment = 17;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_text {
    pub padding: nk_vec2,
    pub background: nk_color,
    pub text: nk_color,
}
pub const NK_TEXT_ALIGN_BOTTOM: nk_text_align = 32;
pub const NK_TEXT_ALIGN_MIDDLE: nk_text_align = 16;
pub const NK_TEXT_ALIGN_RIGHT: nk_text_align = 4;
pub const NK_TEXT_ALIGN_CENTERED: nk_text_align = 2;
pub const NK_TEXT_ALIGN_LEFT: nk_text_align = 1;
/* widget is currently activated */
pub const NK_WIDGET_STATE_ACTIVED: nk_widget_states = 32;
/* widget is being hovered */
pub const NK_WIDGET_STATE_HOVER: nk_widget_states = 16;
/* widget is from this frame on not hovered anymore */
pub const NK_WIDGET_STATE_LEFT: nk_widget_states = 64;
/* widget has been hovered on the current frame */
pub const NK_WIDGET_STATE_ENTERED: nk_widget_states = 8;
/* widget is currently activated */
pub const NK_WIDGET_STATE_ACTIVE: nk_widget_states = 34;
/* widget is being hovered */
pub const NK_WIDGET_STATE_HOVERED: nk_widget_states = 18;
/* widget is neither active nor hovered */
pub const NK_WIDGET_STATE_INACTIVE: nk_widget_states = 4;
pub const NK_WIDGET_STATE_MODIFIED: nk_widget_states = 2;
pub const NK_PANEL_SET_NONBLOCK: nk_panel_set = 240;
pub const NK_CURSOR_MOVE: nk_style_cursor = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_7 {
    pub c: libc::c_char,
    pub _h: nk_page_element,
}
pub type nk_window_insert_location = libc::c_uint;
/* inserts window into the front of list (back of screen) */
pub const NK_INSERT_FRONT: nk_window_insert_location = 1;
/* inserts window into the back of list (front of screen) */
pub const NK_INSERT_BACK: nk_window_insert_location = 0;
pub const NK_WINDOW_PRIVATE: nk_window_flags = 2048;
#[derive(Copy, Clone)]
#[repr(C)]
pub union unnamed_8 {
    i: *const nk_uint,
    b: *const nk_byte,
}
/* marks the window as minimized */
pub const NK_WINDOW_REMOVE_ROM: nk_window_flags = 65536;
pub const NK_PANEL_SET_SUB: nk_panel_set = 246;
pub const NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT: nk_style_cursor = 6;
/* The widget is completely inside the window and can be updated and drawn */
pub const NK_WIDGET_VALID: nk_widget_layout_states = 1;
pub type nk_widget_layout_states = libc::c_uint;
/* The widget is partially visible and cannot be updated */
pub const NK_WIDGET_ROM: nk_widget_layout_states = 2;
/* The widget cannot be seen and is completely out of view */
pub const NK_WIDGET_INVALID: nk_widget_layout_states = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_list_view {
    pub begin: libc::c_int,
    pub end: libc::c_int,
    pub count: libc::c_int,
    pub total_height: libc::c_int,
    pub ctx: *mut nk_context,
    pub scroll_pointer: *mut nk_uint,
    pub scroll_value: nk_uint,
}
pub type nk_widget_states = libc::c_uint;
pub type nk_text_align = libc::c_uint;
pub const NK_TEXT_ALIGN_TOP: nk_text_align = 8;
pub type nk_text_alignment = libc::c_uint;
pub const NK_TEXT_RIGHT: nk_text_alignment = 20;
/* button */
/* toggle */
pub type nk_toggle_type = libc::c_uint;
pub const NK_TOGGLE_OPTION: nk_toggle_type = 1;
pub const NK_TOGGLE_CHECK: nk_toggle_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union nk_property {
    i: libc::c_int,
    f: f32,
    d: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_property_variant {
    pub kind: nk_property_kind,
    pub value: nk_property,
    pub min_value: nk_property,
    pub max_value: nk_property,
    pub step: nk_property,
}
pub type nk_property_kind = libc::c_uint;
pub const NK_PROPERTY_DOUBLE: nk_property_kind = 2;
pub const NK_PROPERTY_FLOAT: nk_property_kind = 1;
pub const NK_PROPERTY_INT: nk_property_kind = 0;
pub type nk_property_filter = libc::c_uint;
pub const NK_FILTER_FLOAT: nk_property_filter = 1;
pub const NK_FILTER_INT: nk_property_filter = 0;
pub const NK_PROPERTY_DRAG: nk_property_status = 2;
pub const NK_PROPERTY_DEFAULT: nk_property_status = 0;
pub const NK_PROPERTY_EDIT: nk_property_status = 1;
pub const NK_EDIT_AUTO_SELECT: nk_edit_flags = 2;
pub const NK_EDIT_FIELD: nk_edit_types = 608;
pub const NK_EDIT_MULTILINE: nk_edit_flags = 1024;
pub const NK_EDIT_NO_HORIZONTAL_SCROLL: nk_edit_flags = 256;
pub const NK_STOP_ON_NEW_LINE: unnamed_15 = 1;
pub const NK_TEXT_EDIT_MODE_REPLACE: nk_text_edit_mode = 2;
pub const NK_TEXT_EDIT_MODE_VIEW: nk_text_edit_mode = 0;
pub const NK_EDIT_ALLOW_TAB: nk_edit_flags = 8;
pub const NK_EDIT_CLIPBOARD: nk_edit_flags = 64;
pub const NK_EDIT_READ_ONLY: nk_edit_flags = 1;
/* edit widget has received an enter and lost focus */
pub const NK_EDIT_COMMITED: nk_edit_events = 16;
pub const NK_EDIT_SIG_ENTER: nk_edit_flags = 4;
pub const NK_EDIT_CTRL_ENTER_NEWLINE: nk_edit_flags = 128;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_text_find {
    pub x: f32,
    pub y: f32,
    pub height: f32,
    pub first_char: libc::c_int,
    pub length: libc::c_int,
    pub prev_first: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_text_edit_row {
    pub x0: f32,
    pub x1: f32,
    pub baseline_y_delta: f32,
    pub ymin: f32,
    pub ymax: f32,
    pub num_chars: libc::c_int,
}
pub const NK_TEXT_EDIT_MODE_INSERT: nk_text_edit_mode = 1;
/* edit widget went from state active to state inactive */
pub const NK_EDIT_DEACTIVATED: nk_edit_events = 8;
/* edit widget went from state inactive to state active */
pub const NK_EDIT_ACTIVATED: nk_edit_events = 4;
/* edit widget is not active and is not being modified */
pub const NK_EDIT_INACTIVE: nk_edit_events = 2;
/* edit widget is currently being modified */
pub const NK_EDIT_ACTIVE: nk_edit_events = 1;
pub const NK_EDIT_ALWAYS_INSERT_MODE: nk_edit_flags = 512;
pub const NK_EDIT_GOTO_END_ON_ACTIVATE: nk_edit_flags = 2048;
pub type nk_text_edit_type = libc::c_uint;
pub const NK_TEXT_EDIT_MULTI_LINE: nk_text_edit_type = 1;
pub const NK_TEXT_EDIT_SINGLE_LINE: nk_text_edit_type = 0;
pub type nk_edit_flags = libc::c_uint;
pub const NK_EDIT_SELECTABLE: nk_edit_flags = 32;
pub const NK_EDIT_NO_CURSOR: nk_edit_flags = 16;
pub const NK_EDIT_DEFAULT: nk_edit_flags = 0;
pub type nk_edit_types = libc::c_uint;
pub const NK_EDIT_EDITOR: nk_edit_types = 1128;
pub const NK_EDIT_BOX: nk_edit_types = 1640;
pub const NK_EDIT_SIMPLE: nk_edit_types = 512;
pub type nk_edit_events = libc::c_uint;
pub const NK_CURSOR_TEXT: nk_style_cursor = 1;
pub type nk_style_colors = libc::c_uint;
pub const NK_COLOR_COUNT: nk_style_colors = 28;
pub const NK_COLOR_EDIT_CURSOR: nk_style_colors = 18;
pub type nk_style_cursor = libc::c_uint;
pub const NK_CURSOR_COUNT: nk_style_cursor = 7;
pub const NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT: nk_style_cursor = 5;
pub const NK_CURSOR_RESIZE_HORIZONTAL: nk_style_cursor = 4;
pub const NK_CURSOR_RESIZE_VERTICAL: nk_style_cursor = 3;
/* texture handle to the used font atlas or texture */
pub type nk_font_coord_type = libc::c_uint;
/* texture coordinates inside font glyphs are in absolute pixel */
pub const NK_COORD_PIXEL: nk_font_coord_type = 1;
/* texture coordinates inside font glyphs are clamped between 0-1 */
pub const NK_COORD_UV: nk_font_coord_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_font {
    pub next: *mut nk_font,
    pub handle: nk_user_font,
    pub info: nk_baked_font,
    pub scale: f32,
    pub glyphs: *mut nk_font_glyph,
    pub fallback: *const nk_font_glyph,
    pub fallback_codepoint: nk_rune,
    pub texture: nk_handle,
    pub config: *mut nk_font_config,
}
/* font codepoint ranges as pairs of (from/to) and 0 as last element */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_font_config {
    pub next: *mut nk_font_config,
    pub ttf_blob: *mut libc::c_void,
    pub ttf_size: nk_size,
    pub ttf_data_owned_by_atlas: libc::c_uchar,
    pub merge_mode: libc::c_uchar,
    pub pixel_snap: libc::c_uchar,
    pub oversample_v: libc::c_uchar,
    pub oversample_h: libc::c_uchar,
    pub padding: [libc::c_uchar; 3],
    pub size: f32,
    pub coord_type: nk_font_coord_type,
    pub spacing: nk_vec2,
    pub range: *const nk_rune,
    pub font: *mut nk_baked_font,
    pub fallback_glyph: nk_rune,
    pub n: *mut nk_font_config,
    pub p: *mut nk_font_config,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_baked_font {
    pub height: f32,
    pub ascent: f32,
    pub descent: f32,
    pub glyph_offset: nk_rune,
    pub glyph_count: nk_rune,
    pub ranges: *const nk_rune,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_font_glyph {
    pub codepoint: nk_rune,
    pub xadvance: f32,
    pub x0: f32,
    pub y0: f32,
    pub x1: f32,
    pub y1: f32,
    pub w: f32,
    pub h: f32,
    pub u0: f32,
    pub v0: f32,
    pub u1: f32,
    pub v1: f32,
}
pub type nk_font_atlas_format = libc::c_uint;
pub const NK_FONT_ATLAS_RGBA32: nk_font_atlas_format = 1;
pub const NK_FONT_ATLAS_ALPHA8: nk_font_atlas_format = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_font_atlas {
    pub pixel: *mut libc::c_void,
    pub tex_width: libc::c_int,
    pub tex_height: libc::c_int,
    pub permanent: nk_allocator,
    pub temporary: nk_allocator,
    pub custom: nk_recti,
    pub cursors: [nk_cursor; 7],
    pub glyph_count: libc::c_int,
    pub glyphs: *mut nk_font_glyph,
    pub default_font: *mut nk_font,
    pub fonts: *mut nk_font,
    pub config: *mut nk_font_config,
    pub font_num: libc::c_int,
}
pub type FILE = libc::FILE;
pub type size_t = libc::c_ulong;
pub type __off64_t = libc::c_long;
pub type _IO_lock_t = ();
pub type __off_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_font_baker {
    pub alloc: nk_allocator,
    pub spc: nk_tt_pack_context,
    pub build: *mut nk_font_bake_data,
    pub packed_chars: *mut nk_tt_packedchar,
    pub rects: *mut nk_rp_rect,
    pub ranges: *mut nk_tt_pack_range,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt_pack_range {
    pub font_size: f32,
    pub first_unicode_codepoint_in_range: libc::c_int,
    pub array_of_unicode_codepoints: *mut libc::c_int,
    pub num_chars: libc::c_int,
    pub chardata_for_range: *mut nk_tt_packedchar,
    pub h_oversample: libc::c_uchar,
    pub v_oversample: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt_packedchar {
    pub x0: libc::c_ushort,
    pub y0: libc::c_ushort,
    pub x1: libc::c_ushort,
    pub y1: libc::c_ushort,
    pub xoff: f32,
    pub yoff: f32,
    pub xadvance: f32,
    pub xoff2: f32,
    pub yoff2: f32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_rp_rect {
    pub id: libc::c_int,
    pub w: nk_rp_coord,
    pub h: nk_rp_coord,
    pub x: nk_rp_coord,
    pub y: nk_rp_coord,
    pub was_packed: libc::c_int,
}
/* -------------------------------------------------------------
 *
 *                          RECT PACK
 *
 * --------------------------------------------------------------*/
/* stb_rect_pack.h - v0.05 - public domain - rectangle packing */
/* Sean Barrett 2014 */
pub type nk_rp_coord = libc::c_ushort;
/* -------------------------------------------------------------
 *
 *                          FONT BAKING
 *
 * --------------------------------------------------------------*/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_font_bake_data {
    pub info: nk_tt_fontinfo,
    pub rects: *mut nk_rp_rect,
    pub ranges: *mut nk_tt_pack_range,
    pub range_count: nk_rune,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt_fontinfo {
    pub data: *const libc::c_uchar,
    pub fontstart: libc::c_int,
    pub numGlyphs: libc::c_int,
    pub loca: libc::c_int,
    pub head: libc::c_int,
    pub glyf: libc::c_int,
    pub hhea: libc::c_int,
    pub hmtx: libc::c_int,
    pub kern: libc::c_int,
    pub index_map: libc::c_int,
    pub indexToLocFormat: libc::c_int,
}
/* don't set these, they're used internally */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt_pack_context {
    pub pack_info: *mut libc::c_void,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub stride_in_bytes: libc::c_int,
    pub padding: libc::c_int,
    pub h_oversample: libc::c_uint,
    pub v_oversample: libc::c_uint,
    pub pixels: *mut libc::c_uchar,
    pub nodes: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt_aligned_quad {
    pub x0: f32,
    pub y0: f32,
    pub s0: f32,
    pub t0: f32,
    pub x1: f32,
    pub y1: f32,
    pub s1: f32,
    pub t1: f32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt_vertex {
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub cx: libc::c_short,
    pub cy: libc::c_short,
    pub type_0: libc::c_uchar,
    pub padding: libc::c_uchar,
}
pub const NK_TT_vline: unnamed_16 = 2;
pub const NK_TT_vcurve: unnamed_16 = 3;
pub const NK_TT_vmove: unnamed_16 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt__bitmap {
    pub w: libc::c_int,
    pub h: libc::c_int,
    pub stride: libc::c_int,
    pub pixels: *mut libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt__point {
    pub x: f32,
    pub y: f32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt__edge {
    pub x0: f32,
    pub y0: f32,
    pub x1: f32,
    pub y1: f32,
    pub invert: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt__hheap {
    pub alloc: nk_allocator,
    pub head: *mut nk_tt__hheap_chunk,
    pub first_free: *mut libc::c_void,
    pub num_remaining_in_head_chunk: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt__hheap_chunk {
    pub next: *mut nk_tt__hheap_chunk,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_tt__active_edge {
    pub next: *mut nk_tt__active_edge,
    pub fx: f32,
    pub fdx: f32,
    pub fdy: f32,
    pub direction: f32,
    pub sy: f32,
    pub ey: f32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_rp_context {
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub align: libc::c_int,
    pub init_mode: libc::c_int,
    pub heuristic: libc::c_int,
    pub num_nodes: libc::c_int,
    pub active_head: *mut nk_rp_node,
    pub free_head: *mut nk_rp_node,
    pub extra: [nk_rp_node; 2],
}
/* non-zero if valid packing */
/* 16 bytes, nominally */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_rp_node {
    pub x: nk_rp_coord,
    pub y: nk_rp_coord,
    pub next: *mut nk_rp_node,
}
/* we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2' */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_rp__findresult {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub prev_link: *mut *mut nk_rp_node,
}
pub const NK_RP_HEURISTIC_Skyline_BF_sortHeight: NK_RP_HEURISTIC = 1;
pub const NK_RP_HEURISTIC_Skyline_BL_sortHeight: NK_RP_HEURISTIC = 0;
pub const NK_RP_HEURISTIC_Skyline_default: NK_RP_HEURISTIC = 0;
pub const NK_RP__INIT_skyline: NK_RP_INIT_STATE = 1;
pub const NK_TT_PLATFORM_ID_UNICODE: unnamed_14 = 0;
pub const NK_TT_MS_EID_UNICODE_FULL: unnamed_17 = 10;
pub const NK_TT_MS_EID_UNICODE_BMP: unnamed_17 = 1;
pub const NK_TT_PLATFORM_ID_MICROSOFT: unnamed_14 = 3;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_9 {
    pub c: libc::c_char,
    pub _h: nk_tt_pack_range,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_10 {
    pub c: libc::c_char,
    pub _h: nk_rp_rect,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_11 {
    pub c: libc::c_char,
    pub _h: nk_tt_packedchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_12 {
    pub c: libc::c_char,
    pub _h: nk_font_bake_data,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_13 {
    pub c: libc::c_char,
    pub _h: nk_font_baker,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nk_memory_status {
    pub memory: *mut libc::c_void,
    pub type_0: libc::c_uint,
    pub size: nk_size,
    pub allocated: nk_size,
    pub needed: nk_size,
    pub calls: nk_size,
}
pub type nk_text_edit_mode = libc::c_uint;
pub type nk_panel_set = libc::c_uint;
pub const NK_PANEL_SET_POPUP: nk_panel_set = 244;
pub type nk_window_flags = libc::c_uint;
/* sets window widgets into a read only mode and does not allow input changes */
pub const NK_WINDOW_NOT_INTERACTIVE: nk_window_flags = 5120;
pub const NK_TT_PLATFORM_ID_ISO: unnamed_14 = 2;
/* <= not same as 0, this makes us check the bitfield is 0 */
pub type unnamed_14 = libc::c_uint;
pub type unnamed_15 = libc::c_uint;
pub type NK_RP_HEURISTIC = libc::c_uint;
pub type nk_property_status = libc::c_uint;
pub const NK_DO_NOT_STOP_ON_NEW_LINE: unnamed_15 = 0;
pub const NK_TT_PLATFORM_ID_MAC: unnamed_14 = 1;
pub type NK_RP_INIT_STATE = libc::c_uint;
pub const NK_TT_MS_EID_SHIFTJIS: unnamed_17 = 2;
pub type unnamed_16 = libc::c_uint;
pub const NK_TT_MS_EID_SYMBOL: unnamed_17 = 0;
/* encodingID for NK_TT_PLATFORM_ID_MICROSOFT */
pub type unnamed_17 = libc::c_uint;
#[no_mangle]
pub unsafe fn nk_init_default(
    mut ctx: *mut nk_context,
    mut font: *const nk_user_font,
) -> libc::c_int {
    let mut alloc: nk_allocator = nk_allocator {
        userdata: nk_handle {
            ptr: 0 as *mut libc::c_void,
        },
        alloc: None,
        free: None,
    };
    alloc.userdata.ptr = 0 as *mut libc::c_void;
    alloc.alloc = Some(nk_malloc);
    alloc.free = Some(nk_mfree);
    return nk_init(ctx, &mut alloc, font);
}
#[no_mangle]
pub unsafe fn nk_init(
    mut ctx: *mut nk_context,
    mut alloc: *mut nk_allocator,
    mut font: *const nk_user_font,
) -> libc::c_int {
    if alloc.is_null() {
        return 0i32;
    } else {
        nk_setup(ctx, font);
        nk_buffer_init(&mut (*ctx).memory, alloc, (4i32 * 1024i32) as nk_size);
        nk_pool_init(&mut (*ctx).pool, alloc, 16i32 as libc::c_uint);
        (*ctx).use_pool = nk_true as libc::c_int;
        return 1i32;
    };
}
unsafe fn nk_pool_init(
    mut pool: *mut nk_pool,
    mut alloc: *mut nk_allocator,
    mut capacity: libc::c_uint,
) -> () {
    nk_zero(
        pool as *mut libc::c_void,
        ::std::mem::size_of::<nk_pool>() as libc::c_ulong,
    );
    (*pool).alloc = *alloc;
    (*pool).capacity = capacity;
    (*pool).type_0 = NK_BUFFER_DYNAMIC;
    (*pool).pages = 0 as *mut nk_page;
}
unsafe fn nk_zero(mut ptr: *mut libc::c_void, mut size: nk_size) -> () {
    nk_memset(ptr, 0i32, size);
}
unsafe fn nk_memset(mut ptr: *mut libc::c_void, mut c0: libc::c_int, mut size: nk_size) -> () {
    let mut dst: *mut nk_byte = ptr as *mut nk_byte;
    let mut c: libc::c_uint = 0i32 as libc::c_uint;
    let mut t: nk_size = 0i32 as nk_size;
    c = c0 as nk_byte as libc::c_uint;
    if c != 0i32 as libc::c_uint {
        /* at least 16-bits  */
        c = c << 8i32 | c;
        if ::std::mem::size_of::<libc::c_uint>() as libc::c_ulong > 2i32 as libc::c_ulong {
            /* at least 32-bits*/
            c = c << 16i32 | c
        }
    }
    /* too small of a word count */
    dst = ptr as *mut nk_byte;
    if size < (3i32 as libc::c_ulong)
        .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong)
    {
        loop {
            let fresh0 = size;
            size = size.wrapping_sub(1);
            if !(0 != fresh0) {
                break;
            }
            let fresh1 = dst;
            dst = dst.offset(1);
            *fresh1 = c0 as nk_byte
        }
        return;
    } else {
        /* align destination */
        t = dst as libc::c_long as nk_size
            & (::std::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                .wrapping_sub(1i32 as libc::c_ulong);
        if t != 0i32 as libc::c_ulong {
            t = (::std::mem::size_of::<libc::c_uint>() as libc::c_ulong).wrapping_sub(t);
            size = (size as libc::c_ulong).wrapping_sub(t) as nk_size as nk_size;
            loop {
                let fresh2 = dst;
                dst = dst.offset(1);
                *fresh2 = c0 as nk_byte;
                t = t.wrapping_sub(1);
                if !(t != 0i32 as libc::c_ulong) {
                    break;
                }
            }
        }
        /* fill word */
        t = size.wrapping_div(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong);
        loop {
            *(dst as *mut libc::c_void as *mut libc::c_uint) = c;
            dst = dst.offset(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong as isize);
            t = t.wrapping_sub(1);
            if !(t != 0i32 as libc::c_ulong) {
                break;
            }
        }
        /* fill trailing bytes */
        t = size & (::std::mem::size_of::<libc::c_uint>() as libc::c_ulong)
            .wrapping_sub(1i32 as libc::c_ulong);
        if t != 0i32 as libc::c_ulong {
            loop {
                let fresh3 = dst;
                dst = dst.offset(1);
                *fresh3 = c0 as nk_byte;
                t = t.wrapping_sub(1);
                if !(t != 0i32 as libc::c_ulong) {
                    break;
                }
            }
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_buffer_init(
    mut b: *mut nk_buffer,
    mut a: *const nk_allocator,
    mut initial_size: nk_size,
) -> () {
    if b.is_null() || a.is_null() || 0 == initial_size {
        return;
    } else {
        nk_zero(
            b as *mut libc::c_void,
            ::std::mem::size_of::<nk_buffer>() as libc::c_ulong,
        );
        (*b).type_0 = NK_BUFFER_DYNAMIC;
        (*b).memory.ptr = (*a).alloc.expect("non-null function pointer")(
            (*a).userdata,
            0 as *mut libc::c_void,
            initial_size,
        );
        (*b).memory.size = initial_size;
        (*b).size = initial_size;
        (*b).grow_factor = 2.0f32;
        (*b).pool = *a;
        return;
    };
}
unsafe fn nk_setup(mut ctx: *mut nk_context, mut font: *const nk_user_font) -> () {
    if ctx.is_null() {
        return;
    } else {
        nk_zero(
            ctx as *mut libc::c_void,
            ::std::mem::size_of::<nk_context>() as libc::c_ulong,
        );
        nk_style_default(ctx);
        (*ctx).seq = 1i32 as libc::c_uint;
        if !font.is_null() {
            (*ctx).style.font = font
        }
        nk_draw_list_init(&mut (*ctx).draw_list);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_init(mut list: *mut nk_draw_list) -> () {
    let mut i: nk_size = 0i32 as nk_size;
    if list.is_null() {
        return;
    } else {
        nk_zero(
            list as *mut libc::c_void,
            ::std::mem::size_of::<nk_draw_list>() as libc::c_ulong,
        );
        i = 0i32 as nk_size;
        while i < (::std::mem::size_of::<[nk_vec2; 12]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<nk_vec2>() as libc::c_ulong)
        {
            let a: f32 = i as f32
                / (::std::mem::size_of::<[nk_vec2; 12]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<nk_vec2>() as libc::c_ulong)
                    as f32 * 2i32 as f32
                * 3.1415927410125734f32;
            (*list).circle_vtx[i as usize].x = nk_cos(a);
            (*list).circle_vtx[i as usize].y = nk_sin(a);
            i = i.wrapping_add(1)
        }
        return;
    };
}
unsafe fn nk_sin(mut x: f32) -> f32 {
    static mut a0: f32 = unsafe { 1.9105930344931874e-31f32 };
    static mut a1: f32 = unsafe { 1.0008676052093506f32 };
    static mut a2: f32 = unsafe { -0.012127612717449665f32 };
    static mut a3: f32 = unsafe { -0.13807877898216248f32 };
    static mut a4: f32 = unsafe { -0.0267353393137455f32 };
    static mut a5: f32 = unsafe { 0.020802659913897516f32 };
    static mut a6: f32 = unsafe { -0.003039960516616702f32 };
    static mut a7: f32 = unsafe { 0.00013823564222548157f32 };
    return a0 + x * (a1 + x * (a2 + x * (a3 + x * (a4 + x * (a5 + x * (a6 + x * a7))))));
}
unsafe fn nk_cos(mut x: f32) -> f32 {
    static mut a0: f32 = unsafe { 1.0023859739303589f32 };
    static mut a1: f32 = unsafe { -0.03819199651479721f32 };
    static mut a2: f32 = unsafe { -0.3943823277950287f32 };
    static mut a3: f32 = unsafe { -0.1181340366601944f32 };
    static mut a4: f32 = unsafe { 0.10712379962205887f32 };
    static mut a5: f32 = unsafe { -0.018663715571165086f32 };
    static mut a6: f32 = unsafe { 0.00099014095030725f32 };
    static mut a7: f32 = unsafe { -5.2302214344429959e-14f32 };
    return a0 + x * (a1 + x * (a2 + x * (a3 + x * (a4 + x * (a5 + x * (a6 + x * a7))))));
}
#[no_mangle]
pub unsafe fn nk_style_default(mut ctx: *mut nk_context) -> () {
    nk_style_from_table(ctx, 0 as *const nk_color);
}
#[no_mangle]
pub unsafe fn nk_style_from_table(mut ctx: *mut nk_context, mut table: *const nk_color) -> () {
    let mut style: *mut nk_style = 0 as *mut nk_style;
    let mut text: *mut nk_style_text = 0 as *mut nk_style_text;
    let mut button: *mut nk_style_button = 0 as *mut nk_style_button;
    let mut toggle: *mut nk_style_toggle = 0 as *mut nk_style_toggle;
    let mut select: *mut nk_style_selectable = 0 as *mut nk_style_selectable;
    let mut slider: *mut nk_style_slider = 0 as *mut nk_style_slider;
    let mut prog: *mut nk_style_progress = 0 as *mut nk_style_progress;
    let mut scroll: *mut nk_style_scrollbar = 0 as *mut nk_style_scrollbar;
    let mut edit: *mut nk_style_edit = 0 as *mut nk_style_edit;
    let mut property: *mut nk_style_property = 0 as *mut nk_style_property;
    let mut combo: *mut nk_style_combo = 0 as *mut nk_style_combo;
    let mut chart: *mut nk_style_chart = 0 as *mut nk_style_chart;
    let mut tab: *mut nk_style_tab = 0 as *mut nk_style_tab;
    let mut win: *mut nk_style_window = 0 as *mut nk_style_window;
    if ctx.is_null() {
        return;
    } else {
        style = &mut (*ctx).style as *mut nk_style;
        table = if table.is_null() {
            nk_default_color_style.as_ptr()
        } else {
            table
        };
        /* default text */
        text = &mut (*style).text as *mut nk_style_text;
        (*text).color = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*text).padding = nk_vec2(0i32 as f32, 0i32 as f32);
        /* default button */
        button = &mut (*style).button as *mut nk_style_button;
        nk_zero(
            button as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_button>() as libc::c_ulong,
        );
        (*button).normal =
            nk_style_item_color(*table.offset(NK_COLOR_BUTTON as libc::c_int as isize));
        (*button).hover =
            nk_style_item_color(*table.offset(NK_COLOR_BUTTON_HOVER as libc::c_int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_BUTTON_ACTIVE as libc::c_int as isize));
        (*button).border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*button).text_background = *table.offset(NK_COLOR_BUTTON as libc::c_int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).padding = nk_vec2(2.0f32, 2.0f32);
        (*button).image_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 1.0f32;
        (*button).rounding = 4.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* contextual button */
        button = &mut (*style).contextual_button as *mut nk_style_button;
        nk_zero(
            button as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_button>() as libc::c_ulong,
        );
        (*button).normal =
            nk_style_item_color(*table.offset(NK_COLOR_WINDOW as libc::c_int as isize));
        (*button).hover =
            nk_style_item_color(*table.offset(NK_COLOR_BUTTON_HOVER as libc::c_int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_BUTTON_ACTIVE as libc::c_int as isize));
        (*button).border_color = *table.offset(NK_COLOR_WINDOW as libc::c_int as isize);
        (*button).text_background = *table.offset(NK_COLOR_WINDOW as libc::c_int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).padding = nk_vec2(2.0f32, 2.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* menu button */
        button = &mut (*style).menu_button as *mut nk_style_button;
        nk_zero(
            button as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_button>() as libc::c_ulong,
        );
        (*button).normal =
            nk_style_item_color(*table.offset(NK_COLOR_WINDOW as libc::c_int as isize));
        (*button).hover =
            nk_style_item_color(*table.offset(NK_COLOR_WINDOW as libc::c_int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_WINDOW as libc::c_int as isize));
        (*button).border_color = *table.offset(NK_COLOR_WINDOW as libc::c_int as isize);
        (*button).text_background = *table.offset(NK_COLOR_WINDOW as libc::c_int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).padding = nk_vec2(2.0f32, 2.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 0.0f32;
        (*button).rounding = 1.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* checkbox toggle */
        toggle = &mut (*style).checkbox as *mut nk_style_toggle;
        nk_zero(
            toggle as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_toggle>() as libc::c_ulong,
        );
        (*toggle).normal =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE as libc::c_int as isize));
        (*toggle).hover =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_HOVER as libc::c_int as isize));
        (*toggle).active =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_HOVER as libc::c_int as isize));
        (*toggle).cursor_normal =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_CURSOR as libc::c_int as isize));
        (*toggle).cursor_hover =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_CURSOR as libc::c_int as isize));
        (*toggle).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*toggle).text_background = *table.offset(NK_COLOR_WINDOW as libc::c_int as isize);
        (*toggle).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*toggle).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*toggle).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*toggle).padding = nk_vec2(2.0f32, 2.0f32);
        (*toggle).touch_padding = nk_vec2(0i32 as f32, 0i32 as f32);
        (*toggle).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*toggle).border = 0.0f32;
        (*toggle).spacing = 4i32 as f32;
        /* option toggle */
        toggle = &mut (*style).option as *mut nk_style_toggle;
        nk_zero(
            toggle as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_toggle>() as libc::c_ulong,
        );
        (*toggle).normal =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE as libc::c_int as isize));
        (*toggle).hover =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_HOVER as libc::c_int as isize));
        (*toggle).active =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_HOVER as libc::c_int as isize));
        (*toggle).cursor_normal =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_CURSOR as libc::c_int as isize));
        (*toggle).cursor_hover =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_CURSOR as libc::c_int as isize));
        (*toggle).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*toggle).text_background = *table.offset(NK_COLOR_WINDOW as libc::c_int as isize);
        (*toggle).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*toggle).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*toggle).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*toggle).padding = nk_vec2(3.0f32, 3.0f32);
        (*toggle).touch_padding = nk_vec2(0i32 as f32, 0i32 as f32);
        (*toggle).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*toggle).border = 0.0f32;
        (*toggle).spacing = 4i32 as f32;
        /* selectable */
        select = &mut (*style).selectable as *mut nk_style_selectable;
        nk_zero(
            select as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_selectable>() as libc::c_ulong,
        );
        (*select).normal =
            nk_style_item_color(*table.offset(NK_COLOR_SELECT as libc::c_int as isize));
        (*select).hover =
            nk_style_item_color(*table.offset(NK_COLOR_SELECT as libc::c_int as isize));
        (*select).pressed =
            nk_style_item_color(*table.offset(NK_COLOR_SELECT as libc::c_int as isize));
        (*select).normal_active =
            nk_style_item_color(*table.offset(NK_COLOR_SELECT_ACTIVE as libc::c_int as isize));
        (*select).hover_active =
            nk_style_item_color(*table.offset(NK_COLOR_SELECT_ACTIVE as libc::c_int as isize));
        (*select).pressed_active =
            nk_style_item_color(*table.offset(NK_COLOR_SELECT_ACTIVE as libc::c_int as isize));
        (*select).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*select).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*select).text_pressed = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*select).text_normal_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*select).text_hover_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*select).text_pressed_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*select).padding = nk_vec2(2.0f32, 2.0f32);
        (*select).image_padding = nk_vec2(2.0f32, 2.0f32);
        (*select).touch_padding = nk_vec2(0i32 as f32, 0i32 as f32);
        (*select).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*select).rounding = 0.0f32;
        (*select).draw_begin = None;
        (*select).draw_end = None;
        /* slider */
        slider = &mut (*style).slider as *mut nk_style_slider;
        nk_zero(
            slider as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_slider>() as libc::c_ulong,
        );
        (*slider).normal = nk_style_item_hide();
        (*slider).hover = nk_style_item_hide();
        (*slider).active = nk_style_item_hide();
        (*slider).bar_normal = *table.offset(NK_COLOR_SLIDER as libc::c_int as isize);
        (*slider).bar_hover = *table.offset(NK_COLOR_SLIDER as libc::c_int as isize);
        (*slider).bar_active = *table.offset(NK_COLOR_SLIDER as libc::c_int as isize);
        (*slider).bar_filled = *table.offset(NK_COLOR_SLIDER_CURSOR as libc::c_int as isize);
        (*slider).cursor_normal =
            nk_style_item_color(*table.offset(NK_COLOR_SLIDER_CURSOR as libc::c_int as isize));
        (*slider).cursor_hover = nk_style_item_color(
            *table.offset(NK_COLOR_SLIDER_CURSOR_HOVER as libc::c_int as isize),
        );
        (*slider).cursor_active = nk_style_item_color(
            *table.offset(NK_COLOR_SLIDER_CURSOR_ACTIVE as libc::c_int as isize),
        );
        (*slider).inc_symbol = NK_SYMBOL_TRIANGLE_RIGHT;
        (*slider).dec_symbol = NK_SYMBOL_TRIANGLE_LEFT;
        (*slider).cursor_size = nk_vec2(16i32 as f32, 16i32 as f32);
        (*slider).padding = nk_vec2(2i32 as f32, 2i32 as f32);
        (*slider).spacing = nk_vec2(2i32 as f32, 2i32 as f32);
        (*slider).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*slider).show_buttons = nk_false as libc::c_int;
        (*slider).bar_height = 8i32 as f32;
        (*slider).rounding = 0i32 as f32;
        (*slider).draw_begin = None;
        (*slider).draw_end = None;
        /* slider buttons */
        button = &mut (*style).slider.inc_button as *mut nk_style_button;
        (*button).normal = nk_style_item_color(nk_rgb(40i32, 40i32, 40i32));
        (*button).hover = nk_style_item_color(nk_rgb(42i32, 42i32, 42i32));
        (*button).active = nk_style_item_color(nk_rgb(44i32, 44i32, 44i32));
        (*button).border_color = nk_rgb(65i32, 65i32, 65i32);
        (*button).text_background = nk_rgb(40i32, 40i32, 40i32);
        (*button).text_normal = nk_rgb(175i32, 175i32, 175i32);
        (*button).text_hover = nk_rgb(175i32, 175i32, 175i32);
        (*button).text_active = nk_rgb(175i32, 175i32, 175i32);
        (*button).padding = nk_vec2(8.0f32, 8.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 1.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        (*style).slider.dec_button = (*style).slider.inc_button;
        /* progressbar */
        prog = &mut (*style).progress as *mut nk_style_progress;
        nk_zero(
            prog as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_progress>() as libc::c_ulong,
        );
        (*prog).normal =
            nk_style_item_color(*table.offset(NK_COLOR_SLIDER as libc::c_int as isize));
        (*prog).hover = nk_style_item_color(*table.offset(NK_COLOR_SLIDER as libc::c_int as isize));
        (*prog).active =
            nk_style_item_color(*table.offset(NK_COLOR_SLIDER as libc::c_int as isize));
        (*prog).cursor_normal =
            nk_style_item_color(*table.offset(NK_COLOR_SLIDER_CURSOR as libc::c_int as isize));
        (*prog).cursor_hover = nk_style_item_color(
            *table.offset(NK_COLOR_SLIDER_CURSOR_HOVER as libc::c_int as isize),
        );
        (*prog).cursor_active = nk_style_item_color(
            *table.offset(NK_COLOR_SLIDER_CURSOR_ACTIVE as libc::c_int as isize),
        );
        (*prog).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*prog).cursor_border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*prog).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*prog).padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*prog).rounding = 0i32 as f32;
        (*prog).border = 0i32 as f32;
        (*prog).cursor_rounding = 0i32 as f32;
        (*prog).cursor_border = 0i32 as f32;
        (*prog).draw_begin = None;
        (*prog).draw_end = None;
        /* scrollbars */
        scroll = &mut (*style).scrollh as *mut nk_style_scrollbar;
        nk_zero(
            scroll as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_scrollbar>() as libc::c_ulong,
        );
        (*scroll).normal =
            nk_style_item_color(*table.offset(NK_COLOR_SCROLLBAR as libc::c_int as isize));
        (*scroll).hover =
            nk_style_item_color(*table.offset(NK_COLOR_SCROLLBAR as libc::c_int as isize));
        (*scroll).active =
            nk_style_item_color(*table.offset(NK_COLOR_SCROLLBAR as libc::c_int as isize));
        (*scroll).cursor_normal =
            nk_style_item_color(*table.offset(NK_COLOR_SCROLLBAR_CURSOR as libc::c_int as isize));
        (*scroll).cursor_hover = nk_style_item_color(
            *table.offset(NK_COLOR_SCROLLBAR_CURSOR_HOVER as libc::c_int as isize),
        );
        (*scroll).cursor_active = nk_style_item_color(
            *table.offset(NK_COLOR_SCROLLBAR_CURSOR_ACTIVE as libc::c_int as isize),
        );
        (*scroll).dec_symbol = NK_SYMBOL_CIRCLE_SOLID;
        (*scroll).inc_symbol = NK_SYMBOL_CIRCLE_SOLID;
        (*scroll).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*scroll).border_color = *table.offset(NK_COLOR_SCROLLBAR as libc::c_int as isize);
        (*scroll).cursor_border_color = *table.offset(NK_COLOR_SCROLLBAR as libc::c_int as isize);
        (*scroll).padding = nk_vec2(0i32 as f32, 0i32 as f32);
        (*scroll).show_buttons = nk_false as libc::c_int;
        (*scroll).border = 0i32 as f32;
        (*scroll).rounding = 0i32 as f32;
        (*scroll).border_cursor = 0i32 as f32;
        (*scroll).rounding_cursor = 0i32 as f32;
        (*scroll).draw_begin = None;
        (*scroll).draw_end = None;
        (*style).scrollv = (*style).scrollh;
        /* scrollbars buttons */
        button = &mut (*style).scrollh.inc_button as *mut nk_style_button;
        (*button).normal = nk_style_item_color(nk_rgb(40i32, 40i32, 40i32));
        (*button).hover = nk_style_item_color(nk_rgb(42i32, 42i32, 42i32));
        (*button).active = nk_style_item_color(nk_rgb(44i32, 44i32, 44i32));
        (*button).border_color = nk_rgb(65i32, 65i32, 65i32);
        (*button).text_background = nk_rgb(40i32, 40i32, 40i32);
        (*button).text_normal = nk_rgb(175i32, 175i32, 175i32);
        (*button).text_hover = nk_rgb(175i32, 175i32, 175i32);
        (*button).text_active = nk_rgb(175i32, 175i32, 175i32);
        (*button).padding = nk_vec2(4.0f32, 4.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 1.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        (*style).scrollh.dec_button = (*style).scrollh.inc_button;
        (*style).scrollv.inc_button = (*style).scrollh.inc_button;
        (*style).scrollv.dec_button = (*style).scrollh.inc_button;
        /* edit */
        edit = &mut (*style).edit as *mut nk_style_edit;
        nk_zero(
            edit as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_edit>() as libc::c_ulong,
        );
        (*edit).normal = nk_style_item_color(*table.offset(NK_COLOR_EDIT as libc::c_int as isize));
        (*edit).hover = nk_style_item_color(*table.offset(NK_COLOR_EDIT as libc::c_int as isize));
        (*edit).active = nk_style_item_color(*table.offset(NK_COLOR_EDIT as libc::c_int as isize));
        (*edit).cursor_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).cursor_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).cursor_text_normal = *table.offset(NK_COLOR_EDIT as libc::c_int as isize);
        (*edit).cursor_text_hover = *table.offset(NK_COLOR_EDIT as libc::c_int as isize);
        (*edit).border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*edit).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).selected_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).selected_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).selected_text_normal = *table.offset(NK_COLOR_EDIT as libc::c_int as isize);
        (*edit).selected_text_hover = *table.offset(NK_COLOR_EDIT as libc::c_int as isize);
        (*edit).scrollbar_size = nk_vec2(10i32 as f32, 10i32 as f32);
        (*edit).scrollbar = (*style).scrollv;
        (*edit).padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*edit).row_padding = 2i32 as f32;
        (*edit).cursor_size = 4i32 as f32;
        (*edit).border = 1i32 as f32;
        (*edit).rounding = 0i32 as f32;
        /* property */
        property = &mut (*style).property as *mut nk_style_property;
        nk_zero(
            property as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_property>() as libc::c_ulong,
        );
        (*property).normal =
            nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as libc::c_int as isize));
        (*property).hover =
            nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as libc::c_int as isize));
        (*property).active =
            nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as libc::c_int as isize));
        (*property).border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*property).label_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*property).label_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*property).label_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*property).sym_left = NK_SYMBOL_TRIANGLE_LEFT;
        (*property).sym_right = NK_SYMBOL_TRIANGLE_RIGHT;
        (*property).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*property).padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*property).border = 1i32 as f32;
        (*property).rounding = 10i32 as f32;
        (*property).draw_begin = None;
        (*property).draw_end = None;
        /* property buttons */
        button = &mut (*style).property.dec_button as *mut nk_style_button;
        nk_zero(
            button as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_button>() as libc::c_ulong,
        );
        (*button).normal =
            nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as libc::c_int as isize));
        (*button).hover =
            nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as libc::c_int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as libc::c_int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_PROPERTY as libc::c_int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).padding = nk_vec2(0.0f32, 0.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        (*style).property.inc_button = (*style).property.dec_button;
        /* property edit */
        edit = &mut (*style).property.edit as *mut nk_style_edit;
        nk_zero(
            edit as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_edit>() as libc::c_ulong,
        );
        (*edit).normal =
            nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as libc::c_int as isize));
        (*edit).hover =
            nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as libc::c_int as isize));
        (*edit).active =
            nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as libc::c_int as isize));
        (*edit).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*edit).cursor_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).cursor_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).cursor_text_normal = *table.offset(NK_COLOR_EDIT as libc::c_int as isize);
        (*edit).cursor_text_hover = *table.offset(NK_COLOR_EDIT as libc::c_int as isize);
        (*edit).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).selected_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).selected_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*edit).selected_text_normal = *table.offset(NK_COLOR_EDIT as libc::c_int as isize);
        (*edit).selected_text_hover = *table.offset(NK_COLOR_EDIT as libc::c_int as isize);
        (*edit).padding = nk_vec2(0i32 as f32, 0i32 as f32);
        (*edit).cursor_size = 8i32 as f32;
        (*edit).border = 0i32 as f32;
        (*edit).rounding = 0i32 as f32;
        /* chart */
        chart = &mut (*style).chart as *mut nk_style_chart;
        nk_zero(
            chart as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_chart>() as libc::c_ulong,
        );
        (*chart).background =
            nk_style_item_color(*table.offset(NK_COLOR_CHART as libc::c_int as isize));
        (*chart).border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*chart).selected_color =
            *table.offset(NK_COLOR_CHART_COLOR_HIGHLIGHT as libc::c_int as isize);
        (*chart).color = *table.offset(NK_COLOR_CHART_COLOR as libc::c_int as isize);
        (*chart).padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*chart).border = 0i32 as f32;
        (*chart).rounding = 0i32 as f32;
        /* combo */
        combo = &mut (*style).combo as *mut nk_style_combo;
        (*combo).normal =
            nk_style_item_color(*table.offset(NK_COLOR_COMBO as libc::c_int as isize));
        (*combo).hover = nk_style_item_color(*table.offset(NK_COLOR_COMBO as libc::c_int as isize));
        (*combo).active =
            nk_style_item_color(*table.offset(NK_COLOR_COMBO as libc::c_int as isize));
        (*combo).border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*combo).label_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*combo).label_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*combo).label_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*combo).sym_normal = NK_SYMBOL_TRIANGLE_DOWN;
        (*combo).sym_hover = NK_SYMBOL_TRIANGLE_DOWN;
        (*combo).sym_active = NK_SYMBOL_TRIANGLE_DOWN;
        (*combo).content_padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*combo).button_padding = nk_vec2(0i32 as f32, 4i32 as f32);
        (*combo).spacing = nk_vec2(4i32 as f32, 0i32 as f32);
        (*combo).border = 1i32 as f32;
        (*combo).rounding = 0i32 as f32;
        /* combo button */
        button = &mut (*style).combo.button as *mut nk_style_button;
        nk_zero(
            button as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_button>() as libc::c_ulong,
        );
        (*button).normal =
            nk_style_item_color(*table.offset(NK_COLOR_COMBO as libc::c_int as isize));
        (*button).hover =
            nk_style_item_color(*table.offset(NK_COLOR_COMBO as libc::c_int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_COMBO as libc::c_int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_COMBO as libc::c_int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).padding = nk_vec2(2.0f32, 2.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* tab */
        tab = &mut (*style).tab as *mut nk_style_tab;
        (*tab).background =
            nk_style_item_color(*table.offset(NK_COLOR_TAB_HEADER as libc::c_int as isize));
        (*tab).border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*tab).text = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*tab).sym_minimize = NK_SYMBOL_TRIANGLE_RIGHT;
        (*tab).sym_maximize = NK_SYMBOL_TRIANGLE_DOWN;
        (*tab).padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*tab).spacing = nk_vec2(4i32 as f32, 4i32 as f32);
        (*tab).indent = 10.0f32;
        (*tab).border = 1i32 as f32;
        (*tab).rounding = 0i32 as f32;
        /* tab button */
        button = &mut (*style).tab.tab_minimize_button as *mut nk_style_button;
        nk_zero(
            button as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_button>() as libc::c_ulong,
        );
        (*button).normal =
            nk_style_item_color(*table.offset(NK_COLOR_TAB_HEADER as libc::c_int as isize));
        (*button).hover =
            nk_style_item_color(*table.offset(NK_COLOR_TAB_HEADER as libc::c_int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_TAB_HEADER as libc::c_int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_TAB_HEADER as libc::c_int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).padding = nk_vec2(2.0f32, 2.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        (*style).tab.tab_maximize_button = *button;
        /* node button */
        button = &mut (*style).tab.node_minimize_button as *mut nk_style_button;
        nk_zero(
            button as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_button>() as libc::c_ulong,
        );
        (*button).normal =
            nk_style_item_color(*table.offset(NK_COLOR_WINDOW as libc::c_int as isize));
        (*button).hover =
            nk_style_item_color(*table.offset(NK_COLOR_WINDOW as libc::c_int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_WINDOW as libc::c_int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_TAB_HEADER as libc::c_int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).padding = nk_vec2(2.0f32, 2.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        (*style).tab.node_maximize_button = *button;
        /* window header */
        win = &mut (*style).window as *mut nk_style_window;
        (*win).header.align = NK_HEADER_RIGHT;
        (*win).header.close_symbol = NK_SYMBOL_X;
        (*win).header.minimize_symbol = NK_SYMBOL_MINUS;
        (*win).header.maximize_symbol = NK_SYMBOL_PLUS;
        (*win).header.normal =
            nk_style_item_color(*table.offset(NK_COLOR_HEADER as libc::c_int as isize));
        (*win).header.hover =
            nk_style_item_color(*table.offset(NK_COLOR_HEADER as libc::c_int as isize));
        (*win).header.active =
            nk_style_item_color(*table.offset(NK_COLOR_HEADER as libc::c_int as isize));
        (*win).header.label_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*win).header.label_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*win).header.label_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*win).header.label_padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*win).header.padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*win).header.spacing = nk_vec2(0i32 as f32, 0i32 as f32);
        /* window header close button */
        button = &mut (*style).window.header.close_button as *mut nk_style_button;
        nk_zero(
            button as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_button>() as libc::c_ulong,
        );
        (*button).normal =
            nk_style_item_color(*table.offset(NK_COLOR_HEADER as libc::c_int as isize));
        (*button).hover =
            nk_style_item_color(*table.offset(NK_COLOR_HEADER as libc::c_int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_HEADER as libc::c_int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_HEADER as libc::c_int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).padding = nk_vec2(0.0f32, 0.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* window header minimize button */
        button = &mut (*style).window.header.minimize_button as *mut nk_style_button;
        nk_zero(
            button as *mut libc::c_void,
            ::std::mem::size_of::<nk_style_button>() as libc::c_ulong,
        );
        (*button).normal =
            nk_style_item_color(*table.offset(NK_COLOR_HEADER as libc::c_int as isize));
        (*button).hover =
            nk_style_item_color(*table.offset(NK_COLOR_HEADER as libc::c_int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_HEADER as libc::c_int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_HEADER as libc::c_int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as libc::c_int as isize);
        (*button).padding = nk_vec2(0.0f32, 0.0f32);
        (*button).touch_padding = nk_vec2(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut libc::c_void);
        (*button).text_alignment = NK_TEXT_CENTERED as libc::c_int as nk_flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* window */
        (*win).background = *table.offset(NK_COLOR_WINDOW as libc::c_int as isize);
        (*win).fixed_background =
            nk_style_item_color(*table.offset(NK_COLOR_WINDOW as libc::c_int as isize));
        (*win).border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*win).popup_border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*win).combo_border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*win).contextual_border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*win).menu_border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*win).group_border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*win).tooltip_border_color = *table.offset(NK_COLOR_BORDER as libc::c_int as isize);
        (*win).scaler = nk_style_item_color(*table.offset(NK_COLOR_TEXT as libc::c_int as isize));
        (*win).rounding = 0.0f32;
        (*win).spacing = nk_vec2(4i32 as f32, 4i32 as f32);
        (*win).scrollbar_size = nk_vec2(10i32 as f32, 10i32 as f32);
        (*win).min_size = nk_vec2(64i32 as f32, 64i32 as f32);
        (*win).combo_border = 1.0f32;
        (*win).contextual_border = 1.0f32;
        (*win).menu_border = 1.0f32;
        (*win).group_border = 1.0f32;
        (*win).tooltip_border = 1.0f32;
        (*win).popup_border = 1.0f32;
        (*win).border = 2.0f32;
        (*win).min_row_height_padding = 8i32 as f32;
        (*win).padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*win).group_padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*win).popup_padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*win).combo_padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*win).contextual_padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*win).menu_padding = nk_vec2(4i32 as f32, 4i32 as f32);
        (*win).tooltip_padding = nk_vec2(4i32 as f32, 4i32 as f32);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_vec2(mut x: f32, mut y: f32) -> nk_vec2 {
    let mut ret: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    ret.x = x;
    ret.y = y;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_style_item_color(mut col: nk_color) -> nk_style_item {
    let mut i: nk_style_item = nk_style_item {
        type_0: NK_STYLE_ITEM_COLOR,
        data: nk_style_item_data {
            image: nk_image {
                handle: nk_handle {
                    ptr: 0 as *mut libc::c_void,
                },
                w: 0,
                h: 0,
                region: [0; 4],
            },
        },
    };
    i.type_0 = NK_STYLE_ITEM_COLOR;
    i.data.color = col;
    return i;
}
#[no_mangle]
pub unsafe fn nk_handle_ptr(mut ptr: *mut libc::c_void) -> nk_handle {
    let mut handle: nk_handle = nk_handle {
        ptr: 0 as *mut libc::c_void,
    };
    handle.ptr = ptr;
    return handle;
}
#[no_mangle]
pub unsafe fn nk_rgba(
    mut r: libc::c_int,
    mut g: libc::c_int,
    mut b: libc::c_int,
    mut a: libc::c_int,
) -> nk_color {
    let mut ret: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    ret.r = (if if r < 255i32 { r } else { 255i32 } < 0i32 {
        0i32
    } else if r < 255i32 {
        r
    } else {
        255i32
    }) as nk_byte;
    ret.g = (if if g < 255i32 { g } else { 255i32 } < 0i32 {
        0i32
    } else if g < 255i32 {
        g
    } else {
        255i32
    }) as nk_byte;
    ret.b = (if if b < 255i32 { b } else { 255i32 } < 0i32 {
        0i32
    } else if b < 255i32 {
        b
    } else {
        255i32
    }) as nk_byte;
    ret.a = (if if a < 255i32 { a } else { 255i32 } < 0i32 {
        0i32
    } else if a < 255i32 {
        a
    } else {
        255i32
    }) as nk_byte;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_rgb(mut r: libc::c_int, mut g: libc::c_int, mut b: libc::c_int) -> nk_color {
    let mut ret: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    ret.r = (if if r < 255i32 { r } else { 255i32 } < 0i32 {
        0i32
    } else if r < 255i32 {
        r
    } else {
        255i32
    }) as nk_byte;
    ret.g = (if if g < 255i32 { g } else { 255i32 } < 0i32 {
        0i32
    } else if g < 255i32 {
        g
    } else {
        255i32
    }) as nk_byte;
    ret.b = (if if b < 255i32 { b } else { 255i32 } < 0i32 {
        0i32
    } else if b < 255i32 {
        b
    } else {
        255i32
    }) as nk_byte;
    ret.a = 255i32 as nk_byte;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_style_item_hide() -> nk_style_item {
    let mut i: nk_style_item = nk_style_item {
        type_0: NK_STYLE_ITEM_COLOR,
        data: nk_style_item_data {
            image: nk_image {
                handle: nk_handle {
                    ptr: 0 as *mut libc::c_void,
                },
                w: 0,
                h: 0,
                region: [0; 4],
            },
        },
    };
    i.type_0 = NK_STYLE_ITEM_COLOR;
    i.data.color = nk_rgba(0i32, 0i32, 0i32, 0i32);
    return i;
}
static mut nk_default_color_style: [nk_color; 28] = unsafe {
    [
        nk_color {
            r: 175i32 as nk_byte,
            g: 175i32 as nk_byte,
            b: 175i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 45i32 as nk_byte,
            g: 45i32 as nk_byte,
            b: 45i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 40i32 as nk_byte,
            g: 40i32 as nk_byte,
            b: 40i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 65i32 as nk_byte,
            g: 65i32 as nk_byte,
            b: 65i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 50i32 as nk_byte,
            g: 50i32 as nk_byte,
            b: 50i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 40i32 as nk_byte,
            g: 40i32 as nk_byte,
            b: 40i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 35i32 as nk_byte,
            g: 35i32 as nk_byte,
            b: 35i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 100i32 as nk_byte,
            g: 100i32 as nk_byte,
            b: 100i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 120i32 as nk_byte,
            g: 120i32 as nk_byte,
            b: 120i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 45i32 as nk_byte,
            g: 45i32 as nk_byte,
            b: 45i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 45i32 as nk_byte,
            g: 45i32 as nk_byte,
            b: 45i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 35i32 as nk_byte,
            g: 35i32 as nk_byte,
            b: 35i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 38i32 as nk_byte,
            g: 38i32 as nk_byte,
            b: 38i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 100i32 as nk_byte,
            g: 100i32 as nk_byte,
            b: 100i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 120i32 as nk_byte,
            g: 120i32 as nk_byte,
            b: 120i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 150i32 as nk_byte,
            g: 150i32 as nk_byte,
            b: 150i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 38i32 as nk_byte,
            g: 38i32 as nk_byte,
            b: 38i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 38i32 as nk_byte,
            g: 38i32 as nk_byte,
            b: 38i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 175i32 as nk_byte,
            g: 175i32 as nk_byte,
            b: 175i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 45i32 as nk_byte,
            g: 45i32 as nk_byte,
            b: 45i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 120i32 as nk_byte,
            g: 120i32 as nk_byte,
            b: 120i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 45i32 as nk_byte,
            g: 45i32 as nk_byte,
            b: 45i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 255i32 as nk_byte,
            g: 0i32 as nk_byte,
            b: 0i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 40i32 as nk_byte,
            g: 40i32 as nk_byte,
            b: 40i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 100i32 as nk_byte,
            g: 100i32 as nk_byte,
            b: 100i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 120i32 as nk_byte,
            g: 120i32 as nk_byte,
            b: 120i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 150i32 as nk_byte,
            g: 150i32 as nk_byte,
            b: 150i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
        nk_color {
            r: 40i32 as nk_byte,
            g: 40i32 as nk_byte,
            b: 40i32 as nk_byte,
            a: 255i32 as nk_byte,
        },
    ]
};
unsafe fn nk_mfree(mut unused: nk_handle, mut ptr: *mut libc::c_void) -> () {
    libc::free(ptr);
}
unsafe fn nk_malloc(
    mut unused: nk_handle,
    mut old: *mut libc::c_void,
    mut size: nk_size,
) -> *mut libc::c_void {
    return libc::malloc(size as _);
}
#[no_mangle]
pub unsafe fn nk_init_fixed(
    mut ctx: *mut nk_context,
    mut memory: *mut libc::c_void,
    mut size: nk_size,
    mut font: *const nk_user_font,
) -> libc::c_int {
    if memory.is_null() {
        return 0i32;
    } else {
        nk_setup(ctx, font);
        nk_buffer_init_fixed(&mut (*ctx).memory, memory, size);
        (*ctx).use_pool = nk_false as libc::c_int;
        return 1i32;
    };
}
#[no_mangle]
pub unsafe fn nk_buffer_init_fixed(
    mut b: *mut nk_buffer,
    mut m: *mut libc::c_void,
    mut size: nk_size,
) -> () {
    if b.is_null() || m.is_null() || 0 == size {
        return;
    } else {
        nk_zero(
            b as *mut libc::c_void,
            ::std::mem::size_of::<nk_buffer>() as libc::c_ulong,
        );
        (*b).type_0 = NK_BUFFER_FIXED;
        (*b).memory.ptr = m;
        (*b).memory.size = size;
        (*b).size = size;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_init_custom(
    mut ctx: *mut nk_context,
    mut cmds: *mut nk_buffer,
    mut pool: *mut nk_buffer,
    mut font: *const nk_user_font,
) -> libc::c_int {
    let mut alloc: *mut nk_allocator = 0 as *mut nk_allocator;
    if cmds.is_null() || pool.is_null() {
        return 0i32;
    } else {
        nk_setup(ctx, font);
        (*ctx).memory = *cmds;
        if (*pool).type_0 as libc::c_uint == NK_BUFFER_FIXED as libc::c_int as libc::c_uint {
            /* take memory from buffer and alloc fixed pool */
            nk_pool_init_fixed(&mut (*ctx).pool, (*pool).memory.ptr, (*pool).memory.size);
        } else {
            /* create dynamic pool from buffer allocator */
            alloc = &mut (*pool).pool as *mut nk_allocator;
            nk_pool_init(&mut (*ctx).pool, alloc, 16i32 as libc::c_uint);
        }
        (*ctx).use_pool = nk_true as libc::c_int;
        return 1i32;
    };
}
unsafe fn nk_pool_init_fixed(
    mut pool: *mut nk_pool,
    mut memory: *mut libc::c_void,
    mut size: nk_size,
) -> () {
    nk_zero(
        pool as *mut libc::c_void,
        ::std::mem::size_of::<nk_pool>() as libc::c_ulong,
    );
    if size < ::std::mem::size_of::<nk_page>() as libc::c_ulong {
        return;
    } else {
        (*pool).capacity = (size.wrapping_sub(::std::mem::size_of::<nk_page>() as libc::c_ulong)
            as libc::c_uint as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<nk_page_element>() as libc::c_ulong)
            as libc::c_uint;
        (*pool).pages = memory as *mut nk_page;
        (*pool).type_0 = NK_BUFFER_FIXED;
        (*pool).size = size;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_clear(mut ctx: *mut nk_context) -> () {
    let mut iter: *mut nk_window = 0 as *mut nk_window;
    let mut next: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return;
    } else {
        if 0 != (*ctx).use_pool {
            nk_buffer_clear(&mut (*ctx).memory);
        } else {
            nk_buffer_reset(&mut (*ctx).memory, NK_BUFFER_FRONT);
        }
        (*ctx).build = 0i32;
        (*ctx).memory.calls = 0i32 as nk_size;
        (*ctx).last_widget_state = 0i32 as nk_flags;
        (*ctx).style.cursor_active = (*ctx).style.cursors[NK_CURSOR_ARROW as libc::c_int as usize];
        nk_memset(
            &mut (*ctx).overlay as *mut nk_command_buffer as *mut libc::c_void,
            0i32,
            ::std::mem::size_of::<nk_command_buffer>() as libc::c_ulong,
        );
        /* garbage collector */
        iter = (*ctx).begin;
        while !iter.is_null() {
            /* make sure valid minimized windows do not get removed */
            if 0 != (*iter).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
                && 0 == (*iter).flags & NK_WINDOW_CLOSED as libc::c_int as libc::c_uint
                && (*iter).seq == (*ctx).seq
            {
                iter = (*iter).next
            } else {
                /* remove hotness from hidden or closed windows*/
                if (0 != (*iter).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
                    || 0 != (*iter).flags & NK_WINDOW_CLOSED as libc::c_int as libc::c_uint)
                    && iter == (*ctx).active
                {
                    (*ctx).active = (*iter).prev;
                    (*ctx).end = (*iter).prev;
                    if (*ctx).end.is_null() {
                        (*ctx).begin = 0 as *mut nk_window
                    }
                    if !(*ctx).active.is_null() {
                        (*(*ctx).active).flags &= !(NK_WINDOW_ROM as libc::c_int as libc::c_uint)
                    }
                }
                /* free unused popup windows */
                if !(*iter).popup.win.is_null() && (*(*iter).popup.win).seq != (*ctx).seq {
                    nk_free_window(ctx, (*iter).popup.win);
                    (*iter).popup.win = 0 as *mut nk_window
                }
                /* remove unused window state tables */
                let mut n: *mut nk_table = 0 as *mut nk_table;
                let mut it: *mut nk_table = (*iter).tables;
                while !it.is_null() {
                    n = (*it).next;
                    if (*it).seq != (*ctx).seq {
                        nk_remove_table(iter, it);
                        nk_zero(
                            it as *mut libc::c_void,
                            ::std::mem::size_of::<nk_page_data>() as libc::c_ulong,
                        );
                        nk_free_table(ctx, it);
                        if it == (*iter).tables {
                            (*iter).tables = n
                        }
                    }
                    it = n
                }
                /* window itself is not used anymore so free */
                if (*iter).seq != (*ctx).seq
                    || 0 != (*iter).flags & NK_WINDOW_CLOSED as libc::c_int as libc::c_uint
                {
                    next = (*iter).next;
                    nk_remove_window(ctx, iter);
                    nk_free_window(ctx, iter);
                    iter = next
                } else {
                    iter = (*iter).next
                }
            }
        }
        (*ctx).seq = (*ctx).seq.wrapping_add(1);
        return;
    };
}
unsafe fn nk_free_window(mut ctx: *mut nk_context, mut win: *mut nk_window) -> () {
    /* unlink windows from list */
    let mut it: *mut nk_table = (*win).tables;
    if !(*win).popup.win.is_null() {
        nk_free_window(ctx, (*win).popup.win);
        (*win).popup.win = 0 as *mut nk_window
    }
    (*win).next = 0 as *mut nk_window;
    (*win).prev = 0 as *mut nk_window;
    while !it.is_null() {
        /*free window state tables */
        let mut n: *mut nk_table = (*it).next;
        nk_remove_table(win, it);
        nk_free_table(ctx, it);
        if it == (*win).tables {
            (*win).tables = n
        }
        it = n
    }
    /* link windows into freelist */
    let mut pd: *mut nk_page_data = ((if 0 != 1i32 {
        win
    } else {
        &mut (*(0 as *mut nk_page_data)).win as *mut nk_window
    }) as *mut libc::c_char)
        .offset(-(&mut (*(0 as *mut nk_page_data)).win as *mut nk_window as nk_ptr as isize))
        as *mut libc::c_void as *mut nk_page_data;
    let mut pe: *mut nk_page_element = ((if 0 != 1i32 {
        pd
    } else {
        &mut (*(0 as *mut nk_page_element)).data as *mut nk_page_data
    }) as *mut libc::c_char)
        .offset(-(&mut (*(0 as *mut nk_page_element)).data as *mut nk_page_data as nk_ptr as isize))
        as *mut libc::c_void as *mut nk_page_element;
    nk_free_page_element(ctx, pe);
}
unsafe fn nk_free_page_element(mut ctx: *mut nk_context, mut elem: *mut nk_page_element) -> () {
    /* we have a pool so just add to free list */
    if 0 != (*ctx).use_pool {
        nk_link_page_element_into_freelist(ctx, elem);
        return;
    } else {
        /* if possible remove last element from back of fixed memory buffer */
        let mut elem_end: *mut libc::c_void = elem.offset(1isize) as *mut libc::c_void;
        let mut buffer_end: *mut libc::c_void = ((*ctx).memory.memory.ptr as *mut nk_byte)
            .offset((*ctx).memory.size as isize)
            as *mut libc::c_void;
        if elem_end == buffer_end {
            (*ctx).memory.size = ((*ctx).memory.size as libc::c_ulong)
                .wrapping_sub(::std::mem::size_of::<nk_page_element>() as libc::c_ulong)
                as nk_size as nk_size
        } else {
            nk_link_page_element_into_freelist(ctx, elem);
        }
        return;
    };
}
unsafe fn nk_link_page_element_into_freelist(
    mut ctx: *mut nk_context,
    mut elem: *mut nk_page_element,
) -> () {
    /* link table into freelist */
    if (*ctx).freelist.is_null() {
        (*ctx).freelist = elem
    } else {
        (*elem).next = (*ctx).freelist;
        (*ctx).freelist = elem
    };
}
unsafe fn nk_free_table(mut ctx: *mut nk_context, mut tbl: *mut nk_table) -> () {
    let mut pd: *mut nk_page_data = ((if 0 != 1i32 {
        tbl
    } else {
        &mut (*(0 as *mut nk_page_data)).tbl as *mut nk_table
    }) as *mut libc::c_char)
        .offset(-(&mut (*(0 as *mut nk_page_data)).tbl as *mut nk_table as nk_ptr as isize))
        as *mut libc::c_void as *mut nk_page_data;
    let mut pe: *mut nk_page_element = ((if 0 != 1i32 {
        pd
    } else {
        &mut (*(0 as *mut nk_page_element)).data as *mut nk_page_data
    }) as *mut libc::c_char)
        .offset(-(&mut (*(0 as *mut nk_page_element)).data as *mut nk_page_data as nk_ptr as isize))
        as *mut libc::c_void as *mut nk_page_element;
    nk_free_page_element(ctx, pe);
}
unsafe fn nk_remove_table(mut win: *mut nk_window, mut tbl: *mut nk_table) -> () {
    if (*win).tables == tbl {
        (*win).tables = (*tbl).next
    }
    if !(*tbl).next.is_null() {
        (*(*tbl).next).prev = (*tbl).prev
    }
    if !(*tbl).prev.is_null() {
        (*(*tbl).prev).next = (*tbl).next
    }
    (*tbl).next = 0 as *mut nk_table;
    (*tbl).prev = 0 as *mut nk_table;
}
unsafe fn nk_remove_window(mut ctx: *mut nk_context, mut win: *mut nk_window) -> () {
    if win == (*ctx).begin || win == (*ctx).end {
        if win == (*ctx).begin {
            (*ctx).begin = (*win).next;
            if !(*win).next.is_null() {
                (*(*win).next).prev = 0 as *mut nk_window
            }
        }
        if win == (*ctx).end {
            (*ctx).end = (*win).prev;
            if !(*win).prev.is_null() {
                (*(*win).prev).next = 0 as *mut nk_window
            }
        }
    } else {
        if !(*win).next.is_null() {
            (*(*win).next).prev = (*win).prev
        }
        if !(*win).prev.is_null() {
            (*(*win).prev).next = (*win).next
        }
    }
    if win == (*ctx).active || (*ctx).active.is_null() {
        (*ctx).active = (*ctx).end;
        if !(*ctx).end.is_null() {
            (*(*ctx).end).flags &= !(NK_WINDOW_ROM as libc::c_int as nk_flags)
        }
    }
    (*win).next = 0 as *mut nk_window;
    (*win).prev = 0 as *mut nk_window;
    (*ctx).count = (*ctx).count.wrapping_sub(1);
}
#[no_mangle]
pub unsafe fn nk_buffer_reset(
    mut buffer: *mut nk_buffer,
    mut type_0: nk_buffer_allocation_type,
) -> () {
    if buffer.is_null() {
        return;
    } else {
        if type_0 as libc::c_uint == NK_BUFFER_BACK as libc::c_int as libc::c_uint {
            /* reset back buffer either back to marker or empty */
            (*buffer).needed = ((*buffer).needed as libc::c_ulong).wrapping_sub(
                (*buffer)
                    .memory
                    .size
                    .wrapping_sub((*buffer).marker[type_0 as usize].offset),
            ) as nk_size as nk_size;
            if 0 != (*buffer).marker[type_0 as usize].active {
                (*buffer).size = (*buffer).marker[type_0 as usize].offset
            } else {
                (*buffer).size = (*buffer).memory.size
            }
            (*buffer).marker[type_0 as usize].active = nk_false as libc::c_int
        } else {
            /* reset front buffer either back to back marker or empty */
            (*buffer).needed = ((*buffer).needed as libc::c_ulong).wrapping_sub(
                (*buffer)
                    .allocated
                    .wrapping_sub((*buffer).marker[type_0 as usize].offset),
            ) as nk_size as nk_size;
            if 0 != (*buffer).marker[type_0 as usize].active {
                (*buffer).allocated = (*buffer).marker[type_0 as usize].offset
            } else {
                (*buffer).allocated = 0i32 as nk_size
            }
            (*buffer).marker[type_0 as usize].active = nk_false as libc::c_int
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_buffer_clear(mut b: *mut nk_buffer) -> () {
    if b.is_null() {
        return;
    } else {
        (*b).allocated = 0i32 as nk_size;
        (*b).size = (*b).memory.size;
        (*b).calls = 0i32 as nk_size;
        (*b).needed = 0i32 as nk_size;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_free(mut ctx: *mut nk_context) -> () {
    if ctx.is_null() {
        return;
    } else {
        nk_buffer_free(&mut (*ctx).memory);
        if 0 != (*ctx).use_pool {
            nk_pool_free(&mut (*ctx).pool);
        }
        nk_zero(
            &mut (*ctx).input as *mut nk_input as *mut libc::c_void,
            ::std::mem::size_of::<nk_input>() as libc::c_ulong,
        );
        nk_zero(
            &mut (*ctx).style as *mut nk_style as *mut libc::c_void,
            ::std::mem::size_of::<nk_style>() as libc::c_ulong,
        );
        nk_zero(
            &mut (*ctx).memory as *mut nk_buffer as *mut libc::c_void,
            ::std::mem::size_of::<nk_buffer>() as libc::c_ulong,
        );
        (*ctx).seq = 0i32 as libc::c_uint;
        (*ctx).build = 0i32;
        (*ctx).begin = 0 as *mut nk_window;
        (*ctx).end = 0 as *mut nk_window;
        (*ctx).active = 0 as *mut nk_window;
        (*ctx).current = 0 as *mut nk_window;
        (*ctx).freelist = 0 as *mut nk_page_element;
        (*ctx).count = 0i32 as libc::c_uint;
        return;
    };
}
unsafe fn nk_pool_free(mut pool: *mut nk_pool) -> () {
    let mut iter: *mut nk_page = (*pool).pages;
    if pool.is_null() {
        return;
    } else if (*pool).type_0 as libc::c_uint == NK_BUFFER_FIXED as libc::c_int as libc::c_uint {
        return;
    } else {
        while !iter.is_null() {
            let mut next: *mut nk_page = (*iter).next;
            (*pool).alloc.free.expect("non-null function pointer")(
                (*pool).alloc.userdata,
                iter as *mut libc::c_void,
            );
            iter = next
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_buffer_free(mut b: *mut nk_buffer) -> () {
    if b.is_null() || (*b).memory.ptr.is_null() {
        return;
    } else if (*b).type_0 as libc::c_uint == NK_BUFFER_FIXED as libc::c_int as libc::c_uint {
        return;
    } else if (*b).pool.free.is_none() {
        return;
    } else {
        (*b).pool.free.expect("non-null function pointer")((*b).pool.userdata, (*b).memory.ptr);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_set_user_data(mut ctx: *mut nk_context, mut handle: nk_handle) -> () {
    if ctx.is_null() {
        return;
    } else {
        (*ctx).userdata = handle;
        if !(*ctx).current.is_null() {
            (*(*ctx).current).buffer.userdata = handle
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_input_begin(mut ctx: *mut nk_context) -> () {
    let mut i: libc::c_int = 0;
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut nk_input;
        i = 0i32;
        while i < NK_BUTTON_MAX as libc::c_int {
            (*in_0).mouse.buttons[i as usize].clicked = 0i32 as libc::c_uint;
            i += 1
        }
        (*in_0).keyboard.text_len = 0i32;
        (*in_0).mouse.scroll_delta = nk_vec2(0i32 as f32, 0i32 as f32);
        (*in_0).mouse.prev.x = (*in_0).mouse.pos.x;
        (*in_0).mouse.prev.y = (*in_0).mouse.pos.y;
        (*in_0).mouse.delta.x = 0i32 as f32;
        (*in_0).mouse.delta.y = 0i32 as f32;
        i = 0i32;
        while i < NK_KEY_MAX as libc::c_int {
            (*in_0).keyboard.keys[i as usize].clicked = 0i32 as libc::c_uint;
            i += 1
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_input_motion(
    mut ctx: *mut nk_context,
    mut x: libc::c_int,
    mut y: libc::c_int,
) -> () {
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut nk_input;
        (*in_0).mouse.pos.x = x as f32;
        (*in_0).mouse.pos.y = y as f32;
        (*in_0).mouse.delta.x = (*in_0).mouse.pos.x - (*in_0).mouse.prev.x;
        (*in_0).mouse.delta.y = (*in_0).mouse.pos.y - (*in_0).mouse.prev.y;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_input_key(
    mut ctx: *mut nk_context,
    mut key: nk_keys,
    mut down: libc::c_int,
) -> () {
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut nk_input;
        if (*in_0).keyboard.keys[key as usize].down != down {
            (*in_0).keyboard.keys[key as usize].clicked =
                (*in_0).keyboard.keys[key as usize].clicked.wrapping_add(1)
        }
        (*in_0).keyboard.keys[key as usize].down = down;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_input_button(
    mut ctx: *mut nk_context,
    mut id: nk_buttons,
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut down: libc::c_int,
) -> () {
    let mut btn: *mut nk_mouse_button = 0 as *mut nk_mouse_button;
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut nk_input;
        if (*in_0).mouse.buttons[id as usize].down == down {
            return;
        } else {
            btn = &mut (*in_0).mouse.buttons[id as usize] as *mut nk_mouse_button;
            (*btn).clicked_pos.x = x as f32;
            (*btn).clicked_pos.y = y as f32;
            (*btn).down = down;
            (*btn).clicked = (*btn).clicked.wrapping_add(1);
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_input_scroll(mut ctx: *mut nk_context, mut val: nk_vec2) -> () {
    if ctx.is_null() {
        return;
    } else {
        (*ctx).input.mouse.scroll_delta.x += val.x;
        (*ctx).input.mouse.scroll_delta.y += val.y;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_input_char(mut ctx: *mut nk_context, mut c: libc::c_char) -> () {
    let mut glyph: nk_glyph = [0; 4];
    if ctx.is_null() {
        return;
    } else {
        glyph[0usize] = c;
        nk_input_glyph(ctx, glyph.as_mut_ptr() as *const libc::c_char);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_input_glyph(mut ctx: *mut nk_context, mut glyph: *const libc::c_char) -> () {
    let mut len: libc::c_int = 0i32;
    let mut unicode: nk_rune = 0;
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut nk_input;
        len = nk_utf_decode(glyph, &mut unicode, 4i32);
        if 0 != len && (*in_0).keyboard.text_len + len < 16i32 {
            nk_utf_encode(
                unicode,
                &mut (*in_0).keyboard.text[(*in_0).keyboard.text_len as usize],
                16i32 - (*in_0).keyboard.text_len,
            );
            (*in_0).keyboard.text_len += len
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_utf_encode(
    mut u: nk_rune,
    mut c: *mut libc::c_char,
    mut clen: libc::c_int,
) -> libc::c_int {
    let mut len: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    len = nk_utf_validate(&mut u, 0i32);
    if clen < len || 0 == len || len > 4i32 {
        return 0i32;
    } else {
        i = len - 1i32;
        while i != 0i32 {
            *c.offset(i as isize) = nk_utf_encode_byte(u, 0i32);
            u >>= 6i32;
            i -= 1
        }
        *c.offset(0isize) = nk_utf_encode_byte(u, len);
        return len;
    };
}
unsafe fn nk_utf_encode_byte(mut u: nk_rune, mut i: libc::c_int) -> libc::c_char {
    return (nk_utfbyte[i as usize] as libc::c_int
        | u as nk_byte as libc::c_int & !(nk_utfmask[i as usize] as libc::c_int))
        as libc::c_char;
}
static mut nk_utfmask: [nk_byte; 5] = unsafe {
    [
        192i32 as nk_byte,
        128i32 as nk_byte,
        224i32 as nk_byte,
        240i32 as nk_byte,
        248i32 as nk_byte,
    ]
};
static mut nk_utfbyte: [nk_byte; 5] = unsafe {
    [
        128i32 as nk_byte,
        0i32 as nk_byte,
        192i32 as nk_byte,
        224i32 as nk_byte,
        240i32 as nk_byte,
    ]
};
unsafe fn nk_utf_validate(mut u: *mut nk_rune, mut i: libc::c_int) -> libc::c_int {
    if u.is_null() {
        return 0i32;
    } else {
        if !(nk_utfmin[i as usize] <= *u && *u < nk_utfmax[i as usize])
            || 55296i32 as libc::c_uint <= *u && *u < 57343i32 as libc::c_uint
        {
            *u = 65533i32 as nk_rune
        }
        i = 1i32;
        while *u > nk_utfmax[i as usize] {
            i += 1
        }
        return i;
    };
}
static mut nk_utfmax: [nk_uint; 5] = unsafe {
    [
        1114111i32 as nk_uint,
        127i32 as nk_uint,
        2047i32 as nk_uint,
        65535i32 as nk_uint,
        1114111i32 as nk_uint,
    ]
};
static mut nk_utfmin: [nk_uint; 5] = unsafe {
    [
        0i32 as nk_uint,
        0i32 as nk_uint,
        128i32 as nk_uint,
        2048i32 as nk_uint,
        65536i32 as nk_uint,
    ]
};
#[no_mangle]
pub unsafe fn nk_utf_decode(
    mut c: *const libc::c_char,
    mut u: *mut nk_rune,
    mut clen: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut type_0: libc::c_int = 0i32;
    let mut udecoded: nk_rune = 0;
    if c.is_null() || u.is_null() {
        return 0i32;
    } else if 0 == clen {
        return 0i32;
    } else {
        *u = 65533i32 as nk_rune;
        udecoded = nk_utf_decode_byte(*c.offset(0isize), &mut len);
        if !(1i32 <= len && len < 4i32) {
            return 1i32;
        } else {
            i = 1i32;
            j = 1i32;
            while i < clen && j < len {
                udecoded =
                    udecoded << 6i32 | nk_utf_decode_byte(*c.offset(i as isize), &mut type_0);
                if type_0 != 0i32 {
                    return j;
                } else {
                    i += 1;
                    j += 1
                }
            }
            if j < len {
                return 0i32;
            } else {
                *u = udecoded;
                nk_utf_validate(u, len);
                return len;
            }
        }
    };
}
unsafe fn nk_utf_decode_byte(mut c: libc::c_char, mut i: *mut libc::c_int) -> nk_rune {
    if i.is_null() {
        return 0i32 as nk_rune;
    } else {
        *i = 0i32;
        while *i < (::std::mem::size_of::<[nk_byte; 5]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<nk_byte>() as libc::c_ulong)
            as libc::c_int
        {
            if c as nk_byte as libc::c_int & nk_utfmask[*i as usize] as libc::c_int
                == nk_utfbyte[*i as usize] as libc::c_int
            {
                return (c as libc::c_int & !(nk_utfmask[*i as usize] as libc::c_int)) as nk_byte
                    as nk_rune;
            } else {
                *i += 1
            }
        }
        return 0i32 as nk_rune;
    };
}
#[no_mangle]
pub unsafe fn nk_input_unicode(mut ctx: *mut nk_context, mut unicode: nk_rune) -> () {
    let mut rune: nk_glyph = [0; 4];
    if ctx.is_null() {
        return;
    } else {
        nk_utf_encode(unicode, rune.as_mut_ptr(), 4i32);
        nk_input_glyph(ctx, rune.as_mut_ptr() as *const libc::c_char);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_input_end(mut ctx: *mut nk_context) -> () {
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut nk_input;
        if 0 != (*in_0).mouse.grab {
            (*in_0).mouse.grab = 0i32 as libc::c_uchar
        }
        if 0 != (*in_0).mouse.ungrab {
            (*in_0).mouse.grabbed = 0i32 as libc::c_uchar;
            (*in_0).mouse.ungrab = 0i32 as libc::c_uchar;
            (*in_0).mouse.grab = 0i32 as libc::c_uchar
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk__begin(mut ctx: *mut nk_context) -> *const nk_command {
    let mut iter: *mut nk_window = 0 as *mut nk_window;
    let mut buffer: *mut nk_byte = 0 as *mut nk_byte;
    if ctx.is_null() {
        return 0 as *const nk_command;
    } else if 0 == (*ctx).count {
        return 0 as *const nk_command;
    } else {
        buffer = (*ctx).memory.memory.ptr as *mut nk_byte;
        if 0 == (*ctx).build {
            nk_build(ctx);
            (*ctx).build = nk_true as libc::c_int
        }
        iter = (*ctx).begin;
        while !iter.is_null()
            && ((*iter).buffer.begin == (*iter).buffer.end
                || 0 != (*iter).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
                || (*iter).seq != (*ctx).seq)
        {
            iter = (*iter).next
        }
        if iter.is_null() {
            return 0 as *const nk_command;
        } else {
            return (buffer as *const nk_byte).offset((*iter).buffer.begin as isize)
                as *const libc::c_void as *const nk_command;
        }
    };
}
unsafe fn nk_build(mut ctx: *mut nk_context) -> () {
    let mut mouse_bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut cursor: *const nk_cursor = 0 as *const nk_cursor;
    let mut it: *mut nk_window = 0 as *mut nk_window;
    let mut cmd: *mut nk_command = 0 as *mut nk_command;
    let mut buffer: *mut nk_byte = 0 as *mut nk_byte;
    /* draw cursor overlay */
    if (*ctx).style.cursor_active.is_null() {
        (*ctx).style.cursor_active = (*ctx).style.cursors[NK_CURSOR_ARROW as libc::c_int as usize]
    }
    if !(*ctx).style.cursor_active.is_null()
        && 0 == (*ctx).input.mouse.grabbed
        && 0 != (*ctx).style.cursor_visible
    {
        mouse_bounds = nk_rect {
            x: 0.,
            y: 0.,
            w: 0.,
            h: 0.,
        };
        cursor = (*ctx).style.cursor_active;
        nk_command_buffer_init(&mut (*ctx).overlay, &mut (*ctx).memory, NK_CLIPPING_OFF);
        nk_start_buffer(ctx, &mut (*ctx).overlay);
        mouse_bounds.x = (*ctx).input.mouse.pos.x - (*cursor).offset.x;
        mouse_bounds.y = (*ctx).input.mouse.pos.y - (*cursor).offset.y;
        mouse_bounds.w = (*cursor).size.x;
        mouse_bounds.h = (*cursor).size.y;
        nk_draw_image(&mut (*ctx).overlay, mouse_bounds, &(*cursor).img, nk_white);
        nk_finish_buffer(ctx, &mut (*ctx).overlay);
    }
    /* build one big draw command list out of all window buffers */
    it = (*ctx).begin;
    buffer = (*ctx).memory.memory.ptr as *mut nk_byte;
    while !it.is_null() {
        let mut next: *mut nk_window = (*it).next;
        if !((*it).buffer.last == (*it).buffer.begin
            || 0 != (*it).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
            || (*it).seq != (*ctx).seq)
        {
            cmd = buffer.offset((*it).buffer.last as isize) as *mut libc::c_void as *mut nk_command;
            while !next.is_null()
                && ((*next).buffer.last == (*next).buffer.begin
                    || 0 != (*next).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
                    || (*next).seq != (*ctx).seq)
            {
                /* skip empty command buffers */
                next = (*next).next
            }
            if !next.is_null() {
                (*cmd).next = (*next).buffer.begin
            }
        }
        it = next
    }
    /* append all popup draw commands into lists */
    it = (*ctx).begin;
    while !it.is_null() {
        let mut next_0: *mut nk_window = (*it).next;
        let mut buf: *mut nk_popup_buffer = 0 as *mut nk_popup_buffer;
        if !(0 == (*it).popup.buf.active) {
            buf = &mut (*it).popup.buf as *mut nk_popup_buffer;
            (*cmd).next = (*buf).begin;
            cmd = buffer.offset((*buf).last as isize) as *mut libc::c_void as *mut nk_command;
            (*buf).active = nk_false as libc::c_int
        }
        it = next_0
    }
    if !cmd.is_null() {
        /* append overlay commands */
        if (*ctx).overlay.end != (*ctx).overlay.begin {
            (*cmd).next = (*ctx).overlay.begin
        } else {
            (*cmd).next = (*ctx).memory.allocated
        }
    };
}
unsafe fn nk_finish_buffer(mut ctx: *mut nk_context, mut buffer: *mut nk_command_buffer) -> () {
    if ctx.is_null() || buffer.is_null() {
        return;
    } else {
        (*buffer).end = (*ctx).memory.allocated;
        return;
    };
}
static mut nk_white: nk_color = unsafe {
    nk_color {
        r: 255i32 as nk_byte,
        g: 255i32 as nk_byte,
        b: 255i32 as nk_byte,
        a: 255i32 as nk_byte,
    }
};
#[no_mangle]
pub unsafe fn nk_draw_image(
    mut b: *mut nk_command_buffer,
    mut r: nk_rect,
    mut img: *const nk_image,
    mut col: nk_color,
) -> () {
    let mut cmd: *mut nk_command_image = 0 as *mut nk_command_image;
    if b.is_null() {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut c: *const nk_rect = &mut (*b).clip as *mut nk_rect;
            if (*c).w == 0i32 as f32 || (*c).h == 0i32 as f32
                || ((*c).x > r.x + r.w
                    || (*c).x + (*c).w < r.x
                    || (*c).y > r.y + r.h
                    || (*c).y + (*c).h < r.y)
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_IMAGE,
            ::std::mem::size_of::<nk_command_image>() as libc::c_ulong,
        ) as *mut nk_command_image;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).x = r.x as libc::c_short;
            (*cmd).y = r.y as libc::c_short;
            (*cmd).w = (if (0i32 as f32) < r.w {
                r.w
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).h = (if (0i32 as f32) < r.h {
                r.h
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).img = *img;
            (*cmd).col = col;
            return;
        }
    };
}
unsafe fn nk_command_buffer_push(
    mut b: *mut nk_command_buffer,
    mut t: nk_command_type,
    mut size: nk_size,
) -> *mut libc::c_void {
    const align: nk_size = ::std::mem::align_of::<nk_command>() as nk_size;
    let mut cmd: *mut nk_command = 0 as *mut nk_command;
    let mut alignment: nk_size = 0;
    let mut unaligned: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut memory: *mut libc::c_void = 0 as *mut libc::c_void;
    if b.is_null() {
        return 0 as *mut libc::c_void;
    } else {
        cmd = nk_buffer_alloc((*b).base, NK_BUFFER_FRONT, size, align) as *mut nk_command;
        if cmd.is_null() {
            return 0 as *mut libc::c_void;
        } else {
            /* make sure the offset to the next command is aligned */
            (*b).last = ((*(*b).base).memory.ptr as *mut nk_byte)
                .ptr_offset_to(cmd as *mut nk_byte)
                .expect("bad offset_to") as libc::c_long as nk_size;
            unaligned = (cmd as *mut nk_byte).offset(size as isize) as *mut libc::c_void;
            memory = ((unaligned as *mut nk_byte)
                .offset(align.wrapping_sub(1i32 as libc::c_ulong) as isize)
                as libc::c_long as nk_size
                & !align.wrapping_sub(1i32 as libc::c_ulong)) as libc::c_long
                as *mut libc::c_void;
            alignment = (unaligned as *mut nk_byte)
                .ptr_offset_to(memory as *mut nk_byte)
                .expect("bad offset_to") as libc::c_long as nk_size;
            nk_memset(cmd as *mut libc::c_void, 0i32, size.wrapping_add(alignment));
            (*cmd).type_0 = t;
            (*cmd).next = (*(*b).base).allocated.wrapping_add(alignment);
            (*cmd).userdata = (*b).userdata;
            (*b).end = (*cmd).next;
            return cmd as *mut libc::c_void;
        }
    };
}
unsafe fn nk_buffer_alloc(
    mut b: *mut nk_buffer,
    mut type_0: nk_buffer_allocation_type,
    mut size: nk_size,
    mut align: nk_size,
) -> *mut libc::c_void {
    let mut full: libc::c_int = 0;
    let mut alignment: nk_size = 0;
    let mut unaligned: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut memory: *mut libc::c_void = 0 as *mut libc::c_void;
    if b.is_null() || 0 == size {
        return 0 as *mut libc::c_void;
    } else {
        (*b).needed = ((*b).needed as libc::c_ulong).wrapping_add(size) as nk_size as nk_size;
        /* calculate total size with needed alignment + size */
        if type_0 as libc::c_uint == NK_BUFFER_FRONT as libc::c_int as libc::c_uint {
            unaligned = ((*b).memory.ptr as *mut nk_byte).offset((*b).allocated as isize)
                as *mut libc::c_void
        } else {
            unaligned = ((*b).memory.ptr as *mut nk_byte)
                .offset((*b).size.wrapping_sub(size) as isize)
                as *mut libc::c_void
        }
        memory = nk_buffer_align(unaligned, align, &mut alignment, type_0);
        /* check if buffer has enough memory*/
        if type_0 as libc::c_uint == NK_BUFFER_FRONT as libc::c_int as libc::c_uint {
            full = ((*b).allocated.wrapping_add(size).wrapping_add(alignment) > (*b).size)
                as libc::c_int
        } else {
            full = ((*b)
                .size
                .wrapping_sub(if (*b).size < size.wrapping_add(alignment) {
                    (*b).size
                } else {
                    size.wrapping_add(alignment)
                }) <= (*b).allocated) as libc::c_int
        }
        if 0 != full {
            let mut capacity: nk_size = 0;
            if (*b).type_0 as libc::c_uint != NK_BUFFER_DYNAMIC as libc::c_int as libc::c_uint {
                return 0 as *mut libc::c_void;
            } else if (*b).type_0 as libc::c_uint
                != NK_BUFFER_DYNAMIC as libc::c_int as libc::c_uint
                || (*b).pool.alloc.is_none() || (*b).pool.free.is_none()
            {
                return 0 as *mut libc::c_void;
            } else {
                /* buffer is full so allocate bigger buffer if dynamic */
                capacity = ((*b).memory.size as f32 * (*b).grow_factor) as nk_size;
                capacity = if capacity
                    < nk_round_up_pow2((*b).allocated.wrapping_add(size) as nk_uint)
                        as libc::c_ulong
                {
                    nk_round_up_pow2((*b).allocated.wrapping_add(size) as nk_uint) as libc::c_ulong
                } else {
                    capacity
                };
                (*b).memory.ptr = nk_buffer_realloc(b, capacity, &mut (*b).memory.size);
                if (*b).memory.ptr.is_null() {
                    return 0 as *mut libc::c_void;
                } else {
                    /* align newly allocated pointer */
                    if type_0 as libc::c_uint == NK_BUFFER_FRONT as libc::c_int as libc::c_uint {
                        unaligned = ((*b).memory.ptr as *mut nk_byte)
                            .offset((*b).allocated as isize)
                            as *mut libc::c_void
                    } else {
                        unaligned = ((*b).memory.ptr as *mut nk_byte)
                            .offset((*b).size.wrapping_sub(size) as isize)
                            as *mut libc::c_void
                    }
                    memory = nk_buffer_align(unaligned, align, &mut alignment, type_0)
                }
            }
        }
        if type_0 as libc::c_uint == NK_BUFFER_FRONT as libc::c_int as libc::c_uint {
            (*b).allocated = ((*b).allocated as libc::c_ulong)
                .wrapping_add(size.wrapping_add(alignment)) as nk_size
                as nk_size
        } else {
            (*b).size = ((*b).size as libc::c_ulong).wrapping_sub(size.wrapping_add(alignment))
                as nk_size as nk_size
        }
        (*b).needed = ((*b).needed as libc::c_ulong).wrapping_add(alignment) as nk_size as nk_size;
        (*b).calls = (*b).calls.wrapping_add(1);
        return memory;
    };
}
unsafe fn nk_buffer_align(
    mut unaligned: *mut libc::c_void,
    mut align: nk_size,
    mut alignment: *mut nk_size,
    mut type_0: nk_buffer_allocation_type,
) -> *mut libc::c_void {
    let mut memory: *mut libc::c_void = 0 as *mut libc::c_void;
    match type_0 as libc::c_uint {
        1 => {
            if 0 != align {
                memory = (unaligned as *mut nk_byte as libc::c_long as nk_size
                    & !align.wrapping_sub(1i32 as libc::c_ulong))
                    as libc::c_long as *mut libc::c_void;
                *alignment = (memory as *mut nk_byte)
                    .ptr_offset_to(unaligned as *mut nk_byte)
                    .expect("bad offset_to") as libc::c_long as nk_size
            } else {
                memory = unaligned;
                *alignment = 0i32 as nk_size
            }
        }
        2 | 0 | _ => {
            if 0 != align {
                memory = ((unaligned as *mut nk_byte)
                    .offset(align.wrapping_sub(1i32 as libc::c_ulong) as isize)
                    as libc::c_long as nk_size
                    & !align.wrapping_sub(1i32 as libc::c_ulong))
                    as libc::c_long as *mut libc::c_void;
                *alignment = (unaligned as *mut nk_byte)
                    .ptr_offset_to(memory as *mut nk_byte)
                    .expect("bad offset_to") as libc::c_long as nk_size
            } else {
                memory = unaligned;
                *alignment = 0i32 as nk_size
            }
        }
    }
    return memory;
}
unsafe fn nk_buffer_realloc(
    mut b: *mut nk_buffer,
    mut capacity: nk_size,
    mut size: *mut nk_size,
) -> *mut libc::c_void {
    let mut temp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut buffer_size: nk_size = 0;
    if b.is_null() || size.is_null() || (*b).pool.alloc.is_none() || (*b).pool.free.is_none() {
        return 0 as *mut libc::c_void;
    } else {
        buffer_size = (*b).memory.size;
        temp = (*b).pool.alloc.expect("non-null function pointer")(
            (*b).pool.userdata,
            (*b).memory.ptr,
            capacity,
        );
        if temp.is_null() {
            return 0 as *mut libc::c_void;
        } else {
            *size = capacity;
            if temp != (*b).memory.ptr {
                nk_memcopy(temp, (*b).memory.ptr, buffer_size);
                (*b).pool.free.expect("non-null function pointer")(
                    (*b).pool.userdata,
                    (*b).memory.ptr,
                );
            }
            if (*b).size == buffer_size {
                /* no back buffer so just set correct size */
                (*b).size = capacity;
                return temp;
            } else {
                let mut dst: *mut libc::c_void = 0 as *mut libc::c_void;
                /* copy back buffer to the end of the new buffer */
                let mut src: *mut libc::c_void = 0 as *mut libc::c_void;
                let mut back_size: nk_size = 0;
                back_size = buffer_size.wrapping_sub((*b).size);
                dst = (temp as *mut nk_byte).offset(capacity.wrapping_sub(back_size) as isize)
                    as *mut libc::c_void;
                src = (temp as *mut nk_byte).offset((*b).size as isize) as *mut libc::c_void;
                nk_memcopy(dst, src, back_size);
                (*b).size = capacity.wrapping_sub(back_size);
                return temp;
            }
        }
    };
}
unsafe fn nk_memcopy(
    mut dst0: *mut libc::c_void,
    mut src0: *const libc::c_void,
    mut length: nk_size,
) -> *mut libc::c_void {
    let mut t: nk_ptr = 0;
    let mut dst: *mut libc::c_char = dst0 as *mut libc::c_char;
    let mut src: *const libc::c_char = src0 as *const libc::c_char;
    if !(length == 0i32 as libc::c_ulong || dst == src as *mut libc::c_char) {
        if dst < src as *mut libc::c_char {
            /* only need low bits */
            t = src as nk_ptr;
            if 0 != (t | dst as nk_ptr)
                & (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    .wrapping_sub(1i32 as libc::c_ulong)
            {
                if 0 != (t ^ dst as nk_ptr)
                    & (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                        .wrapping_sub(1i32 as libc::c_ulong)
                    || length < ::std::mem::size_of::<libc::c_int>() as libc::c_ulong
                {
                    t = length
                } else {
                    t = (::std::mem::size_of::<libc::c_int>() as libc::c_ulong).wrapping_sub(
                        t & (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                            .wrapping_sub(1i32 as libc::c_ulong),
                    )
                }
                length = (length as libc::c_ulong).wrapping_sub(t) as nk_size as nk_size;
                loop {
                    let fresh5 = dst;
                    dst = dst.offset(1);
                    let fresh4 = src;
                    src = src.offset(1);
                    *fresh5 = *fresh4;
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
            t = length.wrapping_div(::std::mem::size_of::<libc::c_int>() as libc::c_ulong);
            if 0 != t {
                loop {
                    *(dst as *mut libc::c_void as *mut libc::c_int) =
                        *(src as *const libc::c_void as *const libc::c_int);
                    src =
                        src.offset(::std::mem::size_of::<libc::c_int>() as libc::c_ulong as isize);
                    dst =
                        dst.offset(::std::mem::size_of::<libc::c_int>() as libc::c_ulong as isize);
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
            t = length
                & (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    .wrapping_sub(1i32 as libc::c_ulong);
            if 0 != t {
                loop {
                    let fresh7 = dst;
                    dst = dst.offset(1);
                    let fresh6 = src;
                    src = src.offset(1);
                    *fresh7 = *fresh6;
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
        } else {
            src = src.offset(length as isize);
            dst = dst.offset(length as isize);
            t = src as nk_ptr;
            if 0 != (t | dst as nk_ptr)
                & (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    .wrapping_sub(1i32 as libc::c_ulong)
            {
                if 0 != (t ^ dst as nk_ptr)
                    & (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                        .wrapping_sub(1i32 as libc::c_ulong)
                    || length <= ::std::mem::size_of::<libc::c_int>() as libc::c_ulong
                {
                    t = length
                } else {
                    t &= (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                        .wrapping_sub(1i32 as libc::c_ulong)
                }
                length = (length as libc::c_ulong).wrapping_sub(t) as nk_size as nk_size;
                loop {
                    dst = dst.offset(-1isize);
                    src = src.offset(-1isize);
                    *dst = *src;
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
            t = length.wrapping_div(::std::mem::size_of::<libc::c_int>() as libc::c_ulong);
            if 0 != t {
                loop {
                    src = src
                        .offset(-(::std::mem::size_of::<libc::c_int>() as libc::c_ulong as isize));
                    dst = dst
                        .offset(-(::std::mem::size_of::<libc::c_int>() as libc::c_ulong as isize));
                    *(dst as *mut libc::c_void as *mut libc::c_int) =
                        *(src as *const libc::c_void as *const libc::c_int);
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
            t = length
                & (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    .wrapping_sub(1i32 as libc::c_ulong);
            if 0 != t {
                loop {
                    dst = dst.offset(-1isize);
                    src = src.offset(-1isize);
                    *dst = *src;
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
        }
    }
    return dst0;
}
unsafe fn nk_round_up_pow2(mut v: nk_uint) -> nk_uint {
    v = v.wrapping_sub(1);
    v |= v >> 1i32;
    v |= v >> 2i32;
    v |= v >> 4i32;
    v |= v >> 8i32;
    v |= v >> 16i32;
    v = v.wrapping_add(1);
    return v;
}
unsafe fn nk_start_buffer(mut ctx: *mut nk_context, mut buffer: *mut nk_command_buffer) -> () {
    if ctx.is_null() || buffer.is_null() {
        return;
    } else {
        (*buffer).begin = (*ctx).memory.allocated;
        (*buffer).end = (*buffer).begin;
        (*buffer).last = (*buffer).begin;
        (*buffer).clip = nk_null_rect;
        return;
    };
}
static mut nk_null_rect: nk_rect = unsafe {
    nk_rect {
        x: -8192.0f32,
        y: -8192.0f32,
        w: 16384i32 as f32,
        h: 16384i32 as f32,
    }
};
unsafe fn nk_command_buffer_init(
    mut cb: *mut nk_command_buffer,
    mut b: *mut nk_buffer,
    mut clip: nk_command_clipping,
) -> () {
    if cb.is_null() || b.is_null() {
        return;
    } else {
        (*cb).base = b;
        (*cb).use_clipping = clip as libc::c_int;
        (*cb).begin = (*b).allocated;
        (*cb).end = (*b).allocated;
        (*cb).last = (*b).allocated;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk__next(mut ctx: *mut nk_context, mut cmd: *const nk_command) -> *const nk_command {
    let mut buffer: *mut nk_byte = 0 as *mut nk_byte;
    let mut next: *const nk_command = 0 as *const nk_command;
    if ctx.is_null() || cmd.is_null() || 0 == (*ctx).count {
        return 0 as *const nk_command;
    } else if (*cmd).next >= (*ctx).memory.allocated {
        return 0 as *const nk_command;
    } else {
        buffer = (*ctx).memory.memory.ptr as *mut nk_byte;
        next = (buffer as *const nk_byte).offset((*cmd).next as isize) as *const libc::c_void
            as *const nk_command;
        return next;
    };
}
#[no_mangle]
pub unsafe fn nk_convert(
    mut ctx: *mut nk_context,
    mut cmds: *mut nk_buffer,
    mut vertices: *mut nk_buffer,
    mut elements: *mut nk_buffer,
    mut config: *const nk_convert_config,
) -> nk_flags {
    let mut t_1: *const nk_command_text = 0 as *const nk_command_text;
    let mut i_2: *const nk_command_image = 0 as *const nk_command_image;
    let mut t_0: *const nk_command_triangle_filled = 0 as *const nk_command_triangle_filled;
    let mut s: *const nk_command_scissor = 0 as *const nk_command_scissor;
    let mut c_2: *const nk_command_arc_filled = 0 as *const nk_command_arc_filled;
    let mut r: *const nk_command_rect = 0 as *const nk_command_rect;
    let mut r_1: *const nk_command_rect_multi_color = 0 as *const nk_command_rect_multi_color;
    let mut c_1: *const nk_command_arc = 0 as *const nk_command_arc;
    let mut c: *const nk_command_circle = 0 as *const nk_command_circle;
    let mut q: *const nk_command_curve = 0 as *const nk_command_curve;
    let mut r_0: *const nk_command_rect_filled = 0 as *const nk_command_rect_filled;
    let mut c_0: *const nk_command_circle_filled = 0 as *const nk_command_circle_filled;
    let mut t: *const nk_command_triangle = 0 as *const nk_command_triangle;
    let mut l: *const nk_command_line = 0 as *const nk_command_line;
    let mut res: nk_flags = NK_CONVERT_SUCCESS as libc::c_int as nk_flags;
    let mut cmd: *const nk_command = 0 as *const nk_command;
    if ctx.is_null()
        || cmds.is_null()
        || vertices.is_null()
        || elements.is_null()
        || config.is_null()
        || (*config).vertex_layout.is_null()
    {
        return NK_CONVERT_INVALID_PARAM as libc::c_int as nk_flags;
    } else {
        nk_draw_list_setup(
            &mut (*ctx).draw_list,
            config,
            cmds,
            vertices,
            elements,
            (*config).line_AA,
            (*config).shape_AA,
        );
        cmd = nk__begin(ctx);
        while !cmd.is_null() {
            (*ctx).draw_list.userdata = (*cmd).userdata;
            match (*cmd).type_0 as libc::c_uint {
                1 => {
                    s = cmd as *const nk_command_scissor;
                    nk_draw_list_add_clip(
                        &mut (*ctx).draw_list,
                        nk_rect(
                            (*s).x as f32,
                            (*s).y as f32,
                            (*s).w as f32,
                            (*s).h as f32,
                        ),
                    );
                }
                2 => {
                    l = cmd as *const nk_command_line;
                    nk_draw_list_stroke_line(
                        &mut (*ctx).draw_list,
                        nk_vec2((*l).begin.x as f32, (*l).begin.y as f32),
                        nk_vec2((*l).end.x as f32, (*l).end.y as f32),
                        (*l).color,
                        (*l).line_thickness as f32,
                    );
                }
                3 => {
                    q = cmd as *const nk_command_curve;
                    nk_draw_list_stroke_curve(
                        &mut (*ctx).draw_list,
                        nk_vec2((*q).begin.x as f32, (*q).begin.y as f32),
                        nk_vec2(
                            (*q).ctrl[0usize].x as f32,
                            (*q).ctrl[0usize].y as f32,
                        ),
                        nk_vec2(
                            (*q).ctrl[1usize].x as f32,
                            (*q).ctrl[1usize].y as f32,
                        ),
                        nk_vec2((*q).end.x as f32, (*q).end.y as f32),
                        (*q).color,
                        (*config).curve_segment_count,
                        (*q).line_thickness as f32,
                    );
                }
                4 => {
                    r = cmd as *const nk_command_rect;
                    nk_draw_list_stroke_rect(
                        &mut (*ctx).draw_list,
                        nk_rect(
                            (*r).x as f32,
                            (*r).y as f32,
                            (*r).w as f32,
                            (*r).h as f32,
                        ),
                        (*r).color,
                        (*r).rounding as f32,
                        (*r).line_thickness as f32,
                    );
                }
                5 => {
                    r_0 = cmd as *const nk_command_rect_filled;
                    nk_draw_list_fill_rect(
                        &mut (*ctx).draw_list,
                        nk_rect(
                            (*r_0).x as f32,
                            (*r_0).y as f32,
                            (*r_0).w as f32,
                            (*r_0).h as f32,
                        ),
                        (*r_0).color,
                        (*r_0).rounding as f32,
                    );
                }
                6 => {
                    r_1 = cmd as *const nk_command_rect_multi_color;
                    nk_draw_list_fill_rect_multi_color(
                        &mut (*ctx).draw_list,
                        nk_rect(
                            (*r_1).x as f32,
                            (*r_1).y as f32,
                            (*r_1).w as f32,
                            (*r_1).h as f32,
                        ),
                        (*r_1).left,
                        (*r_1).top,
                        (*r_1).right,
                        (*r_1).bottom,
                    );
                }
                7 => {
                    c = cmd as *const nk_command_circle;
                    nk_draw_list_stroke_circle(
                        &mut (*ctx).draw_list,
                        nk_vec2(
                            (*c).x as f32
                                + (*c).w as f32 / 2i32 as f32,
                            (*c).y as f32
                                + (*c).h as f32 / 2i32 as f32,
                        ),
                        (*c).w as f32 / 2i32 as f32,
                        (*c).color,
                        (*config).circle_segment_count,
                        (*c).line_thickness as f32,
                    );
                }
                8 => {
                    c_0 = cmd as *const nk_command_circle_filled;
                    nk_draw_list_fill_circle(
                        &mut (*ctx).draw_list,
                        nk_vec2(
                            (*c_0).x as f32
                                + (*c_0).w as f32 / 2i32 as f32,
                            (*c_0).y as f32
                                + (*c_0).h as f32 / 2i32 as f32,
                        ),
                        (*c_0).w as f32 / 2i32 as f32,
                        (*c_0).color,
                        (*config).circle_segment_count,
                    );
                }
                9 => {
                    c_1 = cmd as *const nk_command_arc;
                    nk_draw_list_path_line_to(
                        &mut (*ctx).draw_list,
                        nk_vec2((*c_1).cx as f32, (*c_1).cy as f32),
                    );
                    nk_draw_list_path_arc_to(
                        &mut (*ctx).draw_list,
                        nk_vec2((*c_1).cx as f32, (*c_1).cy as f32),
                        (*c_1).r as f32,
                        (*c_1).a[0usize],
                        (*c_1).a[1usize],
                        (*config).arc_segment_count,
                    );
                    nk_draw_list_path_stroke(
                        &mut (*ctx).draw_list,
                        (*c_1).color,
                        NK_STROKE_CLOSED,
                        (*c_1).line_thickness as f32,
                    );
                }
                10 => {
                    c_2 = cmd as *const nk_command_arc_filled;
                    nk_draw_list_path_line_to(
                        &mut (*ctx).draw_list,
                        nk_vec2((*c_2).cx as f32, (*c_2).cy as f32),
                    );
                    nk_draw_list_path_arc_to(
                        &mut (*ctx).draw_list,
                        nk_vec2((*c_2).cx as f32, (*c_2).cy as f32),
                        (*c_2).r as f32,
                        (*c_2).a[0usize],
                        (*c_2).a[1usize],
                        (*config).arc_segment_count,
                    );
                    nk_draw_list_path_fill(&mut (*ctx).draw_list, (*c_2).color);
                }
                11 => {
                    t = cmd as *const nk_command_triangle;
                    nk_draw_list_stroke_triangle(
                        &mut (*ctx).draw_list,
                        nk_vec2((*t).a.x as f32, (*t).a.y as f32),
                        nk_vec2((*t).b.x as f32, (*t).b.y as f32),
                        nk_vec2((*t).c.x as f32, (*t).c.y as f32),
                        (*t).color,
                        (*t).line_thickness as f32,
                    );
                }
                12 => {
                    t_0 = cmd as *const nk_command_triangle_filled;
                    nk_draw_list_fill_triangle(
                        &mut (*ctx).draw_list,
                        nk_vec2((*t_0).a.x as f32, (*t_0).a.y as f32),
                        nk_vec2((*t_0).b.x as f32, (*t_0).b.y as f32),
                        nk_vec2((*t_0).c.x as f32, (*t_0).c.y as f32),
                        (*t_0).color,
                    );
                }
                13 => {
                    let mut i: libc::c_int = 0;
                    let mut p: *const nk_command_polygon = cmd as *const nk_command_polygon;
                    i = 0i32;
                    while i < (*p).point_count as libc::c_int {
                        let mut pnt: nk_vec2 = nk_vec2(
                            (*p).points[i as usize].x as f32,
                            (*p).points[i as usize].y as f32,
                        );
                        nk_draw_list_path_line_to(&mut (*ctx).draw_list, pnt);
                        i += 1
                    }
                    nk_draw_list_path_stroke(
                        &mut (*ctx).draw_list,
                        (*p).color,
                        NK_STROKE_CLOSED,
                        (*p).line_thickness as f32,
                    );
                }
                14 => {
                    let mut i_0: libc::c_int = 0;
                    let mut p_0: *const nk_command_polygon_filled =
                        cmd as *const nk_command_polygon_filled;
                    i_0 = 0i32;
                    while i_0 < (*p_0).point_count as libc::c_int {
                        let mut pnt_0: nk_vec2 = nk_vec2(
                            (*p_0).points[i_0 as usize].x as f32,
                            (*p_0).points[i_0 as usize].y as f32,
                        );
                        nk_draw_list_path_line_to(&mut (*ctx).draw_list, pnt_0);
                        i_0 += 1
                    }
                    nk_draw_list_path_fill(&mut (*ctx).draw_list, (*p_0).color);
                }
                15 => {
                    let mut i_1: libc::c_int = 0;
                    let mut p_1: *const nk_command_polyline = cmd as *const nk_command_polyline;
                    i_1 = 0i32;
                    while i_1 < (*p_1).point_count as libc::c_int {
                        let mut pnt_1: nk_vec2 = nk_vec2(
                            (*p_1).points[i_1 as usize].x as f32,
                            (*p_1).points[i_1 as usize].y as f32,
                        );
                        nk_draw_list_path_line_to(&mut (*ctx).draw_list, pnt_1);
                        i_1 += 1
                    }
                    nk_draw_list_path_stroke(
                        &mut (*ctx).draw_list,
                        (*p_1).color,
                        NK_STROKE_OPEN,
                        (*p_1).line_thickness as f32,
                    );
                }
                16 => {
                    t_1 = cmd as *const nk_command_text;
                    nk_draw_list_add_text(
                        &mut (*ctx).draw_list,
                        (*t_1).font,
                        nk_rect(
                            (*t_1).x as f32,
                            (*t_1).y as f32,
                            (*t_1).w as f32,
                            (*t_1).h as f32,
                        ),
                        (*t_1).string.as_ptr(),
                        (*t_1).length,
                        (*t_1).height,
                        (*t_1).foreground,
                    );
                }
                17 => {
                    i_2 = cmd as *const nk_command_image;
                    nk_draw_list_add_image(
                        &mut (*ctx).draw_list,
                        (*i_2).img,
                        nk_rect(
                            (*i_2).x as f32,
                            (*i_2).y as f32,
                            (*i_2).w as f32,
                            (*i_2).h as f32,
                        ),
                        (*i_2).col,
                    );
                }
                18 => {
                    let mut c_3: *const nk_command_custom = cmd as *const nk_command_custom;
                    (*c_3).callback.expect("non-null function pointer")(
                        &mut (*ctx).draw_list as *mut nk_draw_list as *mut libc::c_void,
                        (*c_3).x,
                        (*c_3).y,
                        (*c_3).w,
                        (*c_3).h,
                        (*c_3).callback_data,
                    );
                }
                0 | _ => {}
            }
            cmd = nk__next(ctx, cmd)
        }
        res |= (if (*cmds).needed
            > (*cmds)
                .allocated
                .wrapping_add((*cmds).memory.size.wrapping_sub((*cmds).size))
        {
            NK_CONVERT_COMMAND_BUFFER_FULL as libc::c_int
        } else {
            0i32
        }) as libc::c_uint;
        res |= (if (*vertices).needed > (*vertices).allocated {
            NK_CONVERT_VERTEX_BUFFER_FULL as libc::c_int
        } else {
            0i32
        }) as libc::c_uint;
        res |= (if (*elements).needed > (*elements).allocated {
            NK_CONVERT_ELEMENT_BUFFER_FULL as libc::c_int
        } else {
            0i32
        }) as libc::c_uint;
        return res;
    };
}
#[no_mangle]
pub unsafe fn nk_rect(
    mut x: f32,
    mut y: f32,
    mut w: f32,
    mut h: f32,
) -> nk_rect {
    let mut r: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    r.x = x;
    r.y = y;
    r.w = w;
    r.h = h;
    return r;
}
#[no_mangle]
pub unsafe fn nk_draw_list_add_image(
    mut list: *mut nk_draw_list,
    mut texture: nk_image,
    mut rect: nk_rect,
    mut color: nk_color,
) -> () {
    let mut uv: [nk_vec2; 2] = [nk_vec2 { x: 0., y: 0. }; 2];
    if list.is_null() {
        return;
    } else {
        /* push new command with given texture */
        nk_draw_list_push_image(list, texture.handle);
        if 0 != nk_image_is_subimage(&mut texture) {
            /* add region inside of the texture  */
            uv = [nk_vec2 { x: 0., y: 0. }; 2];
            uv[0usize].x = texture.region[0usize] as f32 / texture.w as f32;
            uv[0usize].y = texture.region[1usize] as f32 / texture.h as f32;
            uv[1usize].x = (texture.region[0usize] as libc::c_int
                + texture.region[2usize] as libc::c_int) as f32
                / texture.w as f32;
            uv[1usize].y = (texture.region[1usize] as libc::c_int
                + texture.region[3usize] as libc::c_int) as f32
                / texture.h as f32;
            nk_draw_list_push_rect_uv(
                list,
                nk_vec2(rect.x, rect.y),
                nk_vec2(rect.x + rect.w, rect.y + rect.h),
                uv[0usize],
                uv[1usize],
                color,
            );
        } else {
            nk_draw_list_push_rect_uv(
                list,
                nk_vec2(rect.x, rect.y),
                nk_vec2(rect.x + rect.w, rect.y + rect.h),
                nk_vec2(0.0f32, 0.0f32),
                nk_vec2(1.0f32, 1.0f32),
                color,
            );
        }
        return;
    };
}
unsafe fn nk_draw_list_push_rect_uv(
    mut list: *mut nk_draw_list,
    mut a: nk_vec2,
    mut c: nk_vec2,
    mut uva: nk_vec2,
    mut uvc: nk_vec2,
    mut color: nk_color,
) -> () {
    let mut vtx: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut uvb: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut uvd: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut b: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut d: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut col: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut idx: *mut nk_draw_index = 0 as *mut nk_draw_index;
    let mut index: nk_draw_index = 0;
    if list.is_null() {
        return;
    } else {
        nk_color_fv(&mut col.r, color);
        uvb = nk_vec2(uvc.x, uva.y);
        uvd = nk_vec2(uva.x, uvc.y);
        b = nk_vec2(c.x, a.y);
        d = nk_vec2(a.x, c.y);
        index = (*list).vertex_count as nk_draw_index;
        vtx = nk_draw_list_alloc_vertices(list, 4i32 as nk_size);
        idx = nk_draw_list_alloc_elements(list, 6i32 as nk_size);
        if vtx.is_null() || idx.is_null() {
            return;
        } else {
            *idx.offset(0isize) = (index as libc::c_int + 0i32) as nk_draw_index;
            *idx.offset(1isize) = (index as libc::c_int + 1i32) as nk_draw_index;
            *idx.offset(2isize) = (index as libc::c_int + 2i32) as nk_draw_index;
            *idx.offset(3isize) = (index as libc::c_int + 0i32) as nk_draw_index;
            *idx.offset(4isize) = (index as libc::c_int + 2i32) as nk_draw_index;
            *idx.offset(5isize) = (index as libc::c_int + 3i32) as nk_draw_index;
            vtx = nk_draw_vertex(vtx, &mut (*list).config, a, uva, col);
            vtx = nk_draw_vertex(vtx, &mut (*list).config, b, uvb, col);
            vtx = nk_draw_vertex(vtx, &mut (*list).config, c, uvc, col);
            vtx = nk_draw_vertex(vtx, &mut (*list).config, d, uvd, col);
            return;
        }
    };
}
unsafe fn nk_draw_vertex(
    mut dst: *mut libc::c_void,
    mut config: *const nk_convert_config,
    mut pos: nk_vec2,
    mut uv: nk_vec2,
    mut color: nk_colorf,
) -> *mut libc::c_void {
    let mut result: *mut libc::c_void =
        (dst as *mut libc::c_char).offset((*config).vertex_size as isize) as *mut libc::c_void;
    let mut elem_iter: *const nk_draw_vertex_layout_element = (*config).vertex_layout;
    while 0 == nk_draw_vertex_layout_element_is_end_of_layout(elem_iter) {
        let mut address: *mut libc::c_void =
            (dst as *mut libc::c_char).offset((*elem_iter).offset as isize) as *mut libc::c_void;
        match (*elem_iter).attribute as libc::c_uint {
            0 => {
                nk_draw_vertex_element(address, &mut pos.x, 2i32, (*elem_iter).format);
            }
            2 => {
                nk_draw_vertex_element(address, &mut uv.x, 2i32, (*elem_iter).format);
            }
            1 => {
                nk_draw_vertex_color(address, &mut color.r, (*elem_iter).format);
            }
            3 | _ => {}
        }
        elem_iter = elem_iter.offset(1isize)
    }
    return result;
}
unsafe fn nk_draw_vertex_color(
    mut attr: *mut libc::c_void,
    mut vals: *const f32,
    mut format: nk_draw_vertex_layout_format,
) -> () {
    let mut col_5: [libc::c_double; 4] = [0.; 4];
    let mut col: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut col_3: [nk_uint; 3] = [0; 3];
    let mut col_2: [nk_ushort; 4] = [0; 4];
    let mut col_0: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut col_4: [nk_uint; 4] = [0; 4];
    let mut bgra: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut col_1: [nk_ushort; 3] = [0; 3];
    /* if this triggers you tried to provide a value format for a color */
    let mut val: [f32; 4] = [0.; 4];
    if (format as libc::c_uint) < NK_FORMAT_COLOR_BEGIN as libc::c_int as libc::c_uint
        || format as libc::c_uint > NK_FORMAT_COLOR_END as libc::c_int as libc::c_uint
    {
        return;
    } else {
        val[0usize] = if (0i32 as f32) < if 1.0f32 < *vals.offset(0isize) {
            1.0f32
        } else {
            *vals.offset(0isize)
        } {
            if 1.0f32 < *vals.offset(0isize) {
                1.0f32
            } else {
                *vals.offset(0isize)
            }
        } else {
            0i32 as f32
        };
        val[1usize] = if (0i32 as f32) < if 1.0f32 < *vals.offset(1isize) {
            1.0f32
        } else {
            *vals.offset(1isize)
        } {
            if 1.0f32 < *vals.offset(1isize) {
                1.0f32
            } else {
                *vals.offset(1isize)
            }
        } else {
            0i32 as f32
        };
        val[2usize] = if (0i32 as f32) < if 1.0f32 < *vals.offset(2isize) {
            1.0f32
        } else {
            *vals.offset(2isize)
        } {
            if 1.0f32 < *vals.offset(2isize) {
                1.0f32
            } else {
                *vals.offset(2isize)
            }
        } else {
            0i32 as f32
        };
        val[3usize] = if (0i32 as f32) < if 1.0f32 < *vals.offset(3isize) {
            1.0f32
        } else {
            *vals.offset(3isize)
        } {
            if 1.0f32 < *vals.offset(3isize) {
                1.0f32
            } else {
                *vals.offset(3isize)
            }
        } else {
            0i32 as f32
        };
        match format as libc::c_uint {
            11 | 8 => {
                col = nk_rgba_fv(val.as_mut_ptr());
                nk_memcopy(
                    attr,
                    &mut col.r as *mut nk_byte as *const libc::c_void,
                    ::std::mem::size_of::<nk_color>() as libc::c_ulong,
                );
            }
            12 => {
                col_0 = nk_rgba_fv(val.as_mut_ptr());
                bgra = nk_rgba(
                    col_0.b as libc::c_int,
                    col_0.g as libc::c_int,
                    col_0.r as libc::c_int,
                    col_0.a as libc::c_int,
                );
                nk_memcopy(
                    attr,
                    &mut bgra as *mut nk_color as *const libc::c_void,
                    ::std::mem::size_of::<nk_color>() as libc::c_ulong,
                );
            }
            9 => {
                col_1 = [0; 3];
                col_1[0usize] = (val[0usize] * 65535i32 as f32) as nk_ushort;
                col_1[1usize] = (val[1usize] * 65535i32 as f32) as nk_ushort;
                col_1[2usize] = (val[2usize] * 65535i32 as f32) as nk_ushort;
                nk_memcopy(
                    attr,
                    col_1.as_mut_ptr() as *const libc::c_void,
                    ::std::mem::size_of::<[nk_ushort; 3]>() as libc::c_ulong,
                );
            }
            13 => {
                col_2 = [0; 4];
                col_2[0usize] = (val[0usize] * 65535i32 as f32) as nk_ushort;
                col_2[1usize] = (val[1usize] * 65535i32 as f32) as nk_ushort;
                col_2[2usize] = (val[2usize] * 65535i32 as f32) as nk_ushort;
                col_2[3usize] = (val[3usize] * 65535i32 as f32) as nk_ushort;
                nk_memcopy(
                    attr,
                    col_2.as_mut_ptr() as *const libc::c_void,
                    ::std::mem::size_of::<[nk_ushort; 4]>() as libc::c_ulong,
                );
            }
            10 => {
                col_3 = [0; 3];
                col_3[0usize] = (val[0usize] * 4294967295u32 as f32) as nk_uint;
                col_3[1usize] = (val[1usize] * 4294967295u32 as f32) as nk_uint;
                col_3[2usize] = (val[2usize] * 4294967295u32 as f32) as nk_uint;
                nk_memcopy(
                    attr,
                    col_3.as_mut_ptr() as *const libc::c_void,
                    ::std::mem::size_of::<[nk_uint; 3]>() as libc::c_ulong,
                );
            }
            14 => {
                col_4 = [0; 4];
                col_4[0usize] = (val[0usize] * 4294967295u32 as f32) as nk_uint;
                col_4[1usize] = (val[1usize] * 4294967295u32 as f32) as nk_uint;
                col_4[2usize] = (val[2usize] * 4294967295u32 as f32) as nk_uint;
                col_4[3usize] = (val[3usize] * 4294967295u32 as f32) as nk_uint;
                nk_memcopy(
                    attr,
                    col_4.as_mut_ptr() as *const libc::c_void,
                    ::std::mem::size_of::<[nk_uint; 4]>() as libc::c_ulong,
                );
            }
            15 => {
                nk_memcopy(
                    attr,
                    val.as_mut_ptr() as *const libc::c_void,
                    (::std::mem::size_of::<f32>() as libc::c_ulong)
                        .wrapping_mul(4i32 as libc::c_ulong),
                );
            }
            16 => {
                col_5 = [0.; 4];
                col_5[0usize] = val[0usize] as libc::c_double;
                col_5[1usize] = val[1usize] as libc::c_double;
                col_5[2usize] = val[2usize] as libc::c_double;
                col_5[3usize] = val[3usize] as libc::c_double;
                nk_memcopy(
                    attr,
                    col_5.as_mut_ptr() as *const libc::c_void,
                    ::std::mem::size_of::<[libc::c_double; 4]>() as libc::c_ulong,
                );
            }
            17 | 18 => {
                let mut col_6: nk_color = nk_rgba_fv(val.as_mut_ptr());
                let mut color: nk_uint = nk_color_u32(col_6);
                nk_memcopy(
                    attr,
                    &mut color as *mut nk_uint as *const libc::c_void,
                    ::std::mem::size_of::<nk_uint>() as libc::c_ulong,
                );
            }
            _ => {}
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_rgba_fv(mut c: *const f32) -> nk_color {
    return nk_rgba_f(
        *c.offset(0isize),
        *c.offset(1isize),
        *c.offset(2isize),
        *c.offset(3isize),
    );
}
#[no_mangle]
pub unsafe fn nk_rgba_f(
    mut r: f32,
    mut g: f32,
    mut b: f32,
    mut a: f32,
) -> nk_color {
    let mut ret: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    ret.r = (if (0i32 as f32) < if 1.0f32 < r { 1.0f32 } else { r } {
        if 1.0f32 < r {
            1.0f32
        } else {
            r
        }
    } else {
        0i32 as f32
    } * 255.0f32) as nk_byte;
    ret.g = (if (0i32 as f32) < if 1.0f32 < g { 1.0f32 } else { g } {
        if 1.0f32 < g {
            1.0f32
        } else {
            g
        }
    } else {
        0i32 as f32
    } * 255.0f32) as nk_byte;
    ret.b = (if (0i32 as f32) < if 1.0f32 < b { 1.0f32 } else { b } {
        if 1.0f32 < b {
            1.0f32
        } else {
            b
        }
    } else {
        0i32 as f32
    } * 255.0f32) as nk_byte;
    ret.a = (if (0i32 as f32) < if 1.0f32 < a { 1.0f32 } else { a } {
        if 1.0f32 < a {
            1.0f32
        } else {
            a
        }
    } else {
        0i32 as f32
    } * 255.0f32) as nk_byte;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_color_u32(mut in_0: nk_color) -> nk_uint {
    let mut out: nk_uint = in_0.r as nk_uint;
    out |= (in_0.g as nk_uint) << 8i32;
    out |= (in_0.b as nk_uint) << 16i32;
    out |= (in_0.a as nk_uint) << 24i32;
    return out;
}
unsafe fn nk_draw_vertex_element(
    mut dst: *mut libc::c_void,
    mut values: *const f32,
    mut value_count: libc::c_int,
    mut format: nk_draw_vertex_layout_format,
) -> () {
    let mut value_4: nk_uint = 0;
    let mut value: libc::c_char = 0;
    let mut value_3: nk_ushort = 0;
    let mut value_1: nk_int = 0;
    let mut value_2: libc::c_uchar = 0;
    let mut value_0: nk_short = 0;
    let mut value_index: libc::c_int = 0;
    let mut attribute: *mut libc::c_void = dst;
    /* if this triggers you tried to provide a color format for a value */
    if format as libc::c_uint >= NK_FORMAT_COLOR_BEGIN as libc::c_int as libc::c_uint
        && format as libc::c_uint <= NK_FORMAT_COLOR_END as libc::c_int as libc::c_uint
    {
        return;
    } else {
        value_index = 0i32;
        while value_index < value_count {
            match format as libc::c_uint {
                0 => {
                    value = (if if *values.offset(value_index as isize) < 127i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        127i32 as f32
                    } < -127i32 as f32
                    {
                        -127i32 as f32
                    } else if *values.offset(value_index as isize) < 127i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        127i32 as f32
                    }) as libc::c_char;
                    nk_memcopy(
                        attribute,
                        &mut value as *mut libc::c_char as *const libc::c_void,
                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    );
                    attribute =
                        (attribute as *mut libc::c_char)
                            .offset(::std::mem::size_of::<libc::c_char>() as libc::c_ulong as isize)
                            as *mut libc::c_void
                }
                1 => {
                    value_0 =
                        (if if *values.offset(value_index as isize) < 32767i32 as f32 {
                            *values.offset(value_index as isize)
                        } else {
                            32767i32 as f32
                        } < -32767i32 as f32
                        {
                            -32767i32 as f32
                        } else if *values.offset(value_index as isize) < 32767i32 as f32 {
                            *values.offset(value_index as isize)
                        } else {
                            32767i32 as f32
                        }) as nk_short;
                    nk_memcopy(
                        attribute,
                        &mut value_0 as *mut nk_short as *const libc::c_void,
                        ::std::mem::size_of::<nk_short>() as libc::c_ulong,
                    );
                    attribute =
                        (attribute as *mut libc::c_char)
                            .offset(::std::mem::size_of::<nk_short>() as libc::c_ulong as isize)
                            as *mut libc::c_void
                }
                2 => {
                    value_1 = (if if *values.offset(value_index as isize)
                        < 2147483647i32 as f32
                    {
                        *values.offset(value_index as isize)
                    } else {
                        2147483647i32 as f32
                    } < -2147483647i32 as f32
                    {
                        -2147483647i32 as f32
                    } else if *values.offset(value_index as isize) < 2147483647i32 as f32
                    {
                        *values.offset(value_index as isize)
                    } else {
                        2147483647i32 as f32
                    }) as nk_int;
                    nk_memcopy(
                        attribute,
                        &mut value_1 as *mut nk_int as *const libc::c_void,
                        ::std::mem::size_of::<nk_int>() as libc::c_ulong,
                    );
                    attribute = (attribute as *mut libc::c_char)
                        .offset(::std::mem::size_of::<nk_int>() as libc::c_ulong as isize)
                        as *mut libc::c_void
                }
                3 => {
                    value_2 = (if if *values.offset(value_index as isize) < 256i32 as f32
                    {
                        *values.offset(value_index as isize)
                    } else {
                        256i32 as f32
                    } < 0i32 as f32
                    {
                        0i32 as f32
                    } else if *values.offset(value_index as isize) < 256i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        256i32 as f32
                    }) as libc::c_uchar;
                    nk_memcopy(
                        attribute,
                        &mut value_2 as *mut libc::c_uchar as *const libc::c_void,
                        ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong,
                    );
                    attribute = (attribute as *mut libc::c_char).offset(::std::mem::size_of::<
                        libc::c_uchar,
                    >()
                        as libc::c_ulong
                        as isize) as *mut libc::c_void
                }
                4 => {
                    value_3 =
                        (if if *values.offset(value_index as isize) < 65535i32 as f32 {
                            *values.offset(value_index as isize)
                        } else {
                            65535i32 as f32
                        } < 0i32 as f32
                        {
                            0i32 as f32
                        } else if *values.offset(value_index as isize) < 65535i32 as f32 {
                            *values.offset(value_index as isize)
                        } else {
                            65535i32 as f32
                        }) as nk_ushort;
                    nk_memcopy(
                        attribute,
                        &mut value_3 as *mut nk_ushort as *const libc::c_void,
                        ::std::mem::size_of::<nk_ushort>() as libc::c_ulong,
                    );
                    attribute =
                        (attribute as *mut libc::c_char)
                            .offset(::std::mem::size_of::<nk_ushort>() as libc::c_ulong as isize)
                            as *mut libc::c_void
                }
                5 => {
                    value_4 = (if if *values.offset(value_index as isize)
                        < 4294967295u32 as f32
                    {
                        *values.offset(value_index as isize)
                    } else {
                        4294967295u32 as f32
                    } < 0i32 as f32
                    {
                        0i32 as f32
                    } else if *values.offset(value_index as isize) < 4294967295u32 as f32
                    {
                        *values.offset(value_index as isize)
                    } else {
                        4294967295u32 as f32
                    }) as nk_uint;
                    nk_memcopy(
                        attribute,
                        &mut value_4 as *mut nk_uint as *const libc::c_void,
                        ::std::mem::size_of::<nk_uint>() as libc::c_ulong,
                    );
                    attribute = (attribute as *mut libc::c_char)
                        .offset(::std::mem::size_of::<nk_uint>() as libc::c_ulong as isize)
                        as *mut libc::c_void
                }
                6 => {
                    nk_memcopy(
                        attribute,
                        &*values.offset(value_index as isize) as *const f32
                            as *const libc::c_void,
                        ::std::mem::size_of::<f32>() as libc::c_ulong,
                    );
                    attribute = (attribute as *mut libc::c_char).offset(::std::mem::size_of::<
                        f32,
                    >()
                        as libc::c_ulong
                        as isize) as *mut libc::c_void
                }
                7 => {
                    let mut value_5: libc::c_double =
                        *values.offset(value_index as isize) as libc::c_double;
                    nk_memcopy(
                        attribute,
                        &mut value_5 as *mut libc::c_double as *const libc::c_void,
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    );
                    attribute =
                        (attribute as *mut libc::c_char).offset(
                            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong as isize,
                        ) as *mut libc::c_void
                }
                _ => {}
            }
            value_index += 1
        }
        return;
    };
}
unsafe fn nk_draw_vertex_layout_element_is_end_of_layout(
    mut element: *const nk_draw_vertex_layout_element,
) -> libc::c_int {
    return ((*element).attribute as libc::c_uint
        == NK_VERTEX_ATTRIBUTE_COUNT as libc::c_int as libc::c_uint
        || (*element).format as libc::c_uint == NK_FORMAT_COUNT as libc::c_int as libc::c_uint)
        as libc::c_int;
}
unsafe fn nk_draw_list_alloc_elements(
    mut list: *mut nk_draw_list,
    mut count: nk_size,
) -> *mut nk_draw_index {
    let mut ids: *mut nk_draw_index = 0 as *mut nk_draw_index;
    let mut cmd: *mut nk_draw_command = 0 as *mut nk_draw_command;
    const elem_align: nk_size = ::std::mem::align_of::<nk_draw_index>() as nk_size;
    const elem_size: nk_size = ::std::mem::size_of::<nk_draw_index>() as nk_size;
    if list.is_null() {
        return 0 as *mut nk_draw_index;
    } else {
        ids = nk_buffer_alloc(
            (*list).elements,
            NK_BUFFER_FRONT,
            elem_size.wrapping_mul(count),
            elem_align,
        ) as *mut nk_draw_index;
        if ids.is_null() {
            return 0 as *mut nk_draw_index;
        } else {
            cmd = nk_draw_list_command_last(list);
            (*list).element_count = (*list).element_count.wrapping_add(count as libc::c_uint);
            (*cmd).elem_count = (*cmd).elem_count.wrapping_add(count as libc::c_uint);
            return ids;
        }
    };
}
unsafe fn nk_draw_list_command_last(mut list: *mut nk_draw_list) -> *mut nk_draw_command {
    let mut memory: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut size: nk_size = 0;
    let mut cmd: *mut nk_draw_command = 0 as *mut nk_draw_command;
    memory = nk_buffer_memory((*list).buffer);
    size = nk_buffer_total((*list).buffer);
    cmd = (memory as *mut nk_byte).offset(size.wrapping_sub((*list).cmd_offset) as isize)
        as *mut libc::c_void as *mut nk_draw_command;
    return cmd.offset(-((*list).cmd_count.wrapping_sub(1i32 as libc::c_uint) as isize));
}
#[no_mangle]
pub unsafe fn nk_buffer_total(mut buffer: *mut nk_buffer) -> nk_size {
    if buffer.is_null() {
        return 0i32 as nk_size;
    } else {
        return (*buffer).memory.size;
    };
}
#[no_mangle]
pub unsafe fn nk_buffer_memory(mut buffer: *mut nk_buffer) -> *mut libc::c_void {
    if buffer.is_null() {
        return 0 as *mut libc::c_void;
    } else {
        return (*buffer).memory.ptr;
    };
}
unsafe fn nk_draw_list_alloc_vertices(
    mut list: *mut nk_draw_list,
    mut count: nk_size,
) -> *mut libc::c_void {
    let mut vtx: *mut libc::c_void = 0 as *mut libc::c_void;
    if list.is_null() {
        return 0 as *mut libc::c_void;
    } else {
        vtx = nk_buffer_alloc(
            (*list).vertices,
            NK_BUFFER_FRONT,
            (*list).config.vertex_size.wrapping_mul(count),
            (*list).config.vertex_alignment,
        );
        if vtx.is_null() {
            return 0 as *mut libc::c_void;
        } else {
            (*list).vertex_count = (*list).vertex_count.wrapping_add(count as libc::c_uint);
            /* This assert triggers because your are drawing a lot of stuff and nuklear
             * defined `nk_draw_index` as `nk_ushort` to safe space be default.
             *
             * So you reached the maximum number of indicies or rather vertexes.
             * To solve this issue please change typdef `nk_draw_index` to `nk_uint`
             * and don't forget to specify the new element size in your drawing
             * backend (OpenGL, DirectX, ...). For example in OpenGL for `glDrawElements`
             * instead of specifing `GL_UNSIGNED_SHORT` you have to define `GL_UNSIGNED_INT`.
             * Sorry for the inconvenience. */
            assert_eq!(2, ::std::mem::size_of::<nk_draw_index>());
            return vtx;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_color_fv(mut c: *mut f32, mut in_0: nk_color) -> () {
    nk_color_f(
        &mut *c.offset(0isize),
        &mut *c.offset(1isize),
        &mut *c.offset(2isize),
        &mut *c.offset(3isize),
        in_0,
    );
}
#[no_mangle]
pub unsafe fn nk_color_f(
    mut r: *mut f32,
    mut g: *mut f32,
    mut b: *mut f32,
    mut a: *mut f32,
    mut in_0: nk_color,
) -> () {
    static mut s: f32 = unsafe { 1.0f32 / 255.0f32 };
    *r = in_0.r as f32 * s;
    *g = in_0.g as f32 * s;
    *b = in_0.b as f32 * s;
    *a = in_0.a as f32 * s;
}
#[no_mangle]
pub unsafe fn nk_image_is_subimage(mut img: *const nk_image) -> libc::c_int {
    return !((*img).w as libc::c_int == 0i32 && (*img).h as libc::c_int == 0i32) as libc::c_int;
}
unsafe fn nk_draw_list_push_image(mut list: *mut nk_draw_list, mut texture: nk_handle) -> () {
    if list.is_null() {
        return;
    } else {
        if 0 == (*list).cmd_count {
            nk_draw_list_push_command(list, nk_null_rect, texture);
        } else {
            let mut prev: *mut nk_draw_command = nk_draw_list_command_last(list);
            if (*prev).elem_count == 0i32 as libc::c_uint {
                (*prev).texture = texture;
                (*prev).userdata = (*list).userdata
            } else if (*prev).texture.id != texture.id || (*prev).userdata.id != (*list).userdata.id
            {
                nk_draw_list_push_command(list, (*prev).clip_rect, texture);
            }
        }
        return;
    };
}
unsafe fn nk_draw_list_push_command(
    mut list: *mut nk_draw_list,
    mut clip: nk_rect,
    mut texture: nk_handle,
) -> *mut nk_draw_command {
    let mut total: nk_size = 0;
    let mut memory: *mut nk_byte = 0 as *mut nk_byte;
    const cmd_align: nk_size = ::std::mem::align_of::<nk_draw_command>() as nk_size;
    const cmd_size: nk_size = ::std::mem::size_of::<nk_draw_command>() as nk_size;
    let mut cmd: *mut nk_draw_command = 0 as *mut nk_draw_command;
    cmd = nk_buffer_alloc((*list).buffer, NK_BUFFER_BACK, cmd_size, cmd_align)
        as *mut nk_draw_command;
    if cmd.is_null() {
        return 0 as *mut nk_draw_command;
    } else {
        if 0 == (*list).cmd_count {
            memory = nk_buffer_memory((*list).buffer) as *mut nk_byte;
            total = nk_buffer_total((*list).buffer);
            memory = memory.offset(total as isize) as *mut libc::c_void as *mut nk_byte;
            (*list).cmd_offset = (cmd as *mut nk_byte)
                .ptr_offset_to(memory)
                .expect("bad offset_to") as libc::c_long as nk_size
        }
        (*cmd).elem_count = 0i32 as libc::c_uint;
        (*cmd).clip_rect = clip;
        (*cmd).texture = texture;
        (*cmd).userdata = (*list).userdata;
        (*list).cmd_count = (*list).cmd_count.wrapping_add(1);
        (*list).clip_rect = clip;
        return cmd;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_add_text(
    mut list: *mut nk_draw_list,
    mut font: *const nk_user_font,
    mut rect: nk_rect,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut font_height: f32,
    mut fg: nk_color,
) -> () {
    let mut x: f32 = 0i32 as f32;
    let mut text_len: libc::c_int = 0i32;
    let mut unicode: nk_rune = 0i32 as nk_rune;
    let mut next: nk_rune = 0i32 as nk_rune;
    let mut glyph_len: libc::c_int = 0i32;
    let mut next_glyph_len: libc::c_int = 0i32;
    let mut g: nk_user_font_glyph = nk_user_font_glyph {
        uv: [nk_vec2 { x: 0., y: 0. }; 2],
        offset: nk_vec2 { x: 0., y: 0. },
        width: 0.,
        height: 0.,
        xadvance: 0.,
    };
    if list.is_null() || 0 == len || text.is_null() {
        return;
    } else if (*list).clip_rect.x > rect.x + rect.w
        || (*list).clip_rect.x + (*list).clip_rect.w < rect.x
        || (*list).clip_rect.y > rect.y + rect.h
        || (*list).clip_rect.y + (*list).clip_rect.h < rect.y
    {
        return;
    } else {
        nk_draw_list_push_image(list, (*font).texture);
        x = rect.x;
        glyph_len = nk_utf_decode(text, &mut unicode, len);
        if 0 == glyph_len {
            return;
        } else {
            /* draw every glyph image */
            fg.a = (fg.a as f32 * (*list).config.global_alpha) as nk_byte;
            while text_len < len && 0 != glyph_len {
                let mut gx: f32 = 0.;
                let mut gy: f32 = 0.;
                let mut gh: f32 = 0.;
                let mut gw: f32 = 0.;
                let mut char_width: f32 = 0i32 as f32;
                if unicode == 65533i32 as libc::c_uint {
                    break;
                }
                /* query currently drawn glyph information */
                next_glyph_len = nk_utf_decode(
                    text.offset(text_len as isize).offset(glyph_len as isize),
                    &mut next,
                    len - text_len,
                );
                (*font).query.expect("non-null function pointer")(
                    (*font).userdata,
                    font_height,
                    &mut g,
                    unicode,
                    if next == 65533i32 as libc::c_uint {
                        '\u{0}' as i32 as libc::c_uint
                    } else {
                        next
                    },
                );
                /* calculate and draw glyph drawing rectangle and image */
                gx = x + g.offset.x;
                gy = rect.y + g.offset.y;
                gw = g.width;
                gh = g.height;
                char_width = g.xadvance;
                nk_draw_list_push_rect_uv(
                    list,
                    nk_vec2(gx, gy),
                    nk_vec2(gx + gw, gy + gh),
                    g.uv[0usize],
                    g.uv[1usize],
                    fg,
                );
                /* offset next glyph */
                text_len += glyph_len;
                x += char_width;
                glyph_len = next_glyph_len;
                unicode = next
            }
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_path_stroke(
    mut list: *mut nk_draw_list,
    mut color: nk_color,
    mut closed: nk_draw_list_stroke,
    mut thickness: f32,
) -> () {
    let mut points: *mut nk_vec2 = 0 as *mut nk_vec2;
    if list.is_null() {
        return;
    } else {
        points = nk_buffer_memory((*list).buffer) as *mut nk_vec2;
        nk_draw_list_stroke_poly_line(
            list,
            points,
            (*list).path_count,
            color,
            closed,
            thickness,
            (*list).config.line_AA,
        );
        nk_draw_list_path_clear(list);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_path_clear(mut list: *mut nk_draw_list) -> () {
    if list.is_null() {
        return;
    } else {
        nk_buffer_reset((*list).buffer, NK_BUFFER_FRONT);
        (*list).path_count = 0i32 as libc::c_uint;
        (*list).path_offset = 0i32 as libc::c_uint;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_stroke_poly_line(
    mut list: *mut nk_draw_list,
    mut points: *const nk_vec2,
    points_count: libc::c_uint,
    mut color: nk_color,
    mut closed: nk_draw_list_stroke,
    mut thickness: f32,
    mut aliasing: nk_anti_aliasing,
) -> () {
    let mut d: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut d1: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut scale: f32 = 0.;
    let mut d2: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut scale_0: f32 = 0.;
    let mut count: nk_size = 0;
    let mut thick_line: libc::c_int = 0;
    let mut col: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut col_trans: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    if list.is_null() || points_count < 2i32 as libc::c_uint {
        return;
    } else {
        color.a = (color.a as f32 * (*list).config.global_alpha) as nk_byte;
        count = points_count as nk_size;
        if 0 == closed as u64 {
            count = points_count.wrapping_sub(1i32 as libc::c_uint) as nk_size
        }
        thick_line = (thickness > 1.0f32) as libc::c_int;
        nk_draw_list_push_userdata(list, (*list).userdata);
        color.a = (color.a as f32 * (*list).config.global_alpha) as nk_byte;
        nk_color_fv(&mut col.r, color);
        col_trans = col;
        col_trans.a = 0i32 as f32;
        if aliasing as libc::c_uint == NK_ANTI_ALIASING_ON as libc::c_int as libc::c_uint {
            /* ANTI-ALIASED STROKE */
            let AA_SIZE: f32 = 1.0f32;
            const pnt_align: nk_size = ::std::mem::align_of::<nk_vec2>() as nk_size;
            const pnt_size: nk_size = ::std::mem::size_of::<nk_vec2>() as nk_size;
            /* allocate vertices and elements  */
            let mut i1: nk_size = 0i32 as nk_size;
            let mut vertex_offset: nk_size = 0;
            let mut index: nk_size = (*list).vertex_count as nk_size;
            let idx_count: nk_size = if 0 != thick_line {
                count.wrapping_mul(18i32 as libc::c_ulong)
            } else {
                count.wrapping_mul(12i32 as libc::c_ulong)
            };
            let vtx_count: nk_size = (if 0 != thick_line {
                points_count.wrapping_mul(4i32 as libc::c_uint)
            } else {
                points_count.wrapping_mul(3i32 as libc::c_uint)
            }) as nk_size;
            let mut vtx: *mut libc::c_void = nk_draw_list_alloc_vertices(list, vtx_count);
            let mut ids: *mut nk_draw_index = nk_draw_list_alloc_elements(list, idx_count);
            let mut size: nk_size = 0;
            let mut normals: *mut nk_vec2 = 0 as *mut nk_vec2;
            let mut temp: *mut nk_vec2 = 0 as *mut nk_vec2;
            if vtx.is_null() || ids.is_null() {
                return;
            } else {
                /* temporary allocate normals + points */
                vertex_offset = ((*(*list).vertices).memory.ptr as *mut nk_byte)
                    .ptr_offset_to(vtx as *mut nk_byte)
                    .expect("bad offset_to") as libc::c_long
                    as nk_size;
                nk_buffer_mark((*list).vertices, NK_BUFFER_FRONT);
                size = pnt_size
                    .wrapping_mul((if 0 != thick_line { 5i32 } else { 3i32 }) as libc::c_ulong)
                    .wrapping_mul(points_count as libc::c_ulong);
                normals = nk_buffer_alloc((*list).vertices, NK_BUFFER_FRONT, size, pnt_align)
                    as *mut nk_vec2;
                if normals.is_null() {
                    return;
                } else {
                    temp = normals.offset(points_count as isize);
                    /* make sure vertex pointer is still correct */
                    vtx = ((*(*list).vertices).memory.ptr as *mut nk_byte)
                        .offset(vertex_offset as isize)
                        as *mut libc::c_void;
                    /* calculate normals */
                    i1 = 0i32 as nk_size;
                    while i1 < count {
                        let i2: nk_size = if i1.wrapping_add(1i32 as libc::c_ulong)
                            == points_count as libc::c_ulong
                        {
                            0i32 as libc::c_ulong
                        } else {
                            i1.wrapping_add(1i32 as libc::c_ulong)
                        };
                        let mut diff: nk_vec2 = nk_vec2(
                            (*points.offset(i2 as isize)).x - (*points.offset(i1 as isize)).x,
                            (*points.offset(i2 as isize)).y - (*points.offset(i1 as isize)).y,
                        );
                        let mut len: f32 = 0.;
                        /* vec2 inverted length  */
                        len = diff.x * diff.x + diff.y * diff.y;
                        if len != 0.0f32 {
                            len = nk_inv_sqrt(len)
                        } else {
                            len = 1.0f32
                        }
                        diff = nk_vec2(diff.x * len, diff.y * len);
                        (*normals.offset(i1 as isize)).x = diff.y;
                        (*normals.offset(i1 as isize)).y = -diff.x;
                        i1 = i1.wrapping_add(1)
                    }
                    if 0 == closed as u64 {
                        *normals.offset(points_count.wrapping_sub(1i32 as libc::c_uint) as isize) =
                            *normals
                                .offset(points_count.wrapping_sub(2i32 as libc::c_uint) as isize)
                    }
                    if 0 == thick_line {
                        let mut idx1: nk_size = 0;
                        let mut i: nk_size = 0;
                        if 0 == closed as u64 {
                            d = nk_vec2 { x: 0., y: 0. };
                            *temp.offset(0isize) = nk_vec2(
                                (*points.offset(0isize)).x
                                    + nk_vec2(
                                        (*normals.offset(0isize)).x * AA_SIZE,
                                        (*normals.offset(0isize)).y * AA_SIZE,
                                    ).x,
                                (*points.offset(0isize)).y
                                    + nk_vec2(
                                        (*normals.offset(0isize)).x * AA_SIZE,
                                        (*normals.offset(0isize)).y * AA_SIZE,
                                    ).y,
                            );
                            *temp.offset(1isize) = nk_vec2(
                                (*points.offset(0isize)).x
                                    - nk_vec2(
                                        (*normals.offset(0isize)).x * AA_SIZE,
                                        (*normals.offset(0isize)).y * AA_SIZE,
                                    ).x,
                                (*points.offset(0isize)).y
                                    - nk_vec2(
                                        (*normals.offset(0isize)).x * AA_SIZE,
                                        (*normals.offset(0isize)).y * AA_SIZE,
                                    ).y,
                            );
                            d = nk_vec2(
                                (*normals.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).x * AA_SIZE,
                                (*normals.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).y * AA_SIZE,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as libc::c_uint)
                                    .wrapping_mul(2i32 as libc::c_uint)
                                    .wrapping_add(0i32 as libc::c_uint)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).x + d.x,
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).y + d.y,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as libc::c_uint)
                                    .wrapping_mul(2i32 as libc::c_uint)
                                    .wrapping_add(1i32 as libc::c_uint)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).x - d.x,
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).y - d.y,
                            )
                        }
                        /* fill elements */
                        idx1 = index;
                        i1 = 0i32 as nk_size;
                        while i1 < count {
                            let mut dm: nk_vec2 = nk_vec2 { x: 0., y: 0. };
                            let mut dmr2: f32 = 0.;
                            let mut i2_0: nk_size = if i1.wrapping_add(1i32 as libc::c_ulong)
                                == points_count as libc::c_ulong
                            {
                                0i32 as libc::c_ulong
                            } else {
                                i1.wrapping_add(1i32 as libc::c_ulong)
                            };
                            let mut idx2: nk_size = if i1.wrapping_add(1i32 as libc::c_ulong)
                                == points_count as libc::c_ulong
                            {
                                index
                            } else {
                                idx1.wrapping_add(3i32 as libc::c_ulong)
                            };
                            /* average normals */
                            dm = nk_vec2(
                                nk_vec2(
                                    (*normals.offset(i1 as isize)).x
                                        + (*normals.offset(i2_0 as isize)).x,
                                    (*normals.offset(i1 as isize)).y
                                        + (*normals.offset(i2_0 as isize)).y,
                                ).x * 0.5f32,
                                nk_vec2(
                                    (*normals.offset(i1 as isize)).x
                                        + (*normals.offset(i2_0 as isize)).x,
                                    (*normals.offset(i1 as isize)).y
                                        + (*normals.offset(i2_0 as isize)).y,
                                ).y * 0.5f32,
                            );
                            dmr2 = dm.x * dm.x + dm.y * dm.y;
                            if dmr2 > 9.999999974752428e-7f32 {
                                scale = 1.0f32 / dmr2;
                                scale = if 100.0f32 < scale { 100.0f32 } else { scale };
                                dm = nk_vec2(dm.x * scale, dm.y * scale)
                            }
                            dm = nk_vec2(dm.x * AA_SIZE, dm.y * AA_SIZE);
                            *temp.offset(
                                i2_0.wrapping_mul(2i32 as libc::c_ulong)
                                    .wrapping_add(0i32 as libc::c_ulong)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(i2_0 as isize)).x + dm.x,
                                (*points.offset(i2_0 as isize)).y + dm.y,
                            );
                            *temp.offset(
                                i2_0.wrapping_mul(2i32 as libc::c_ulong)
                                    .wrapping_add(1i32 as libc::c_ulong)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(i2_0 as isize)).x - dm.x,
                                (*points.offset(i2_0 as isize)).y - dm.y,
                            );
                            *ids.offset(0isize) =
                                idx2.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(1isize) =
                                idx1.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(2isize) =
                                idx1.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(3isize) =
                                idx1.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(4isize) =
                                idx2.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(5isize) =
                                idx2.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(6isize) =
                                idx2.wrapping_add(1i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(7isize) =
                                idx1.wrapping_add(1i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(8isize) =
                                idx1.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(9isize) =
                                idx1.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(10isize) =
                                idx2.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(11isize) =
                                idx2.wrapping_add(1i32 as libc::c_ulong) as nk_draw_index;
                            ids = ids.offset(12isize);
                            idx1 = idx2;
                            i1 = i1.wrapping_add(1)
                        }
                        /* fill vertices */
                        i = 0i32 as nk_size;
                        while i < points_count as libc::c_ulong {
                            let uv: nk_vec2 = (*list).config.null.uv;
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *points.offset(i as isize),
                                uv,
                                col,
                            );
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i.wrapping_mul(2i32 as libc::c_ulong)
                                        .wrapping_add(0i32 as libc::c_ulong)
                                        as isize,
                                ),
                                uv,
                                col_trans,
                            );
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i.wrapping_mul(2i32 as libc::c_ulong)
                                        .wrapping_add(1i32 as libc::c_ulong)
                                        as isize,
                                ),
                                uv,
                                col_trans,
                            );
                            i = i.wrapping_add(1)
                        }
                    } else {
                        let mut idx1_0: nk_size = 0;
                        let mut i_0: nk_size = 0;
                        let half_inner_thickness: f32 = (thickness - AA_SIZE) * 0.5f32;
                        if 0 == closed as u64 {
                            d1 = nk_vec2(
                                (*normals.offset(0isize)).x * (half_inner_thickness + AA_SIZE),
                                (*normals.offset(0isize)).y * (half_inner_thickness + AA_SIZE),
                            );
                            d2 = nk_vec2(
                                (*normals.offset(0isize)).x * half_inner_thickness,
                                (*normals.offset(0isize)).y * half_inner_thickness,
                            );
                            *temp.offset(0isize) = nk_vec2(
                                (*points.offset(0isize)).x + d1.x,
                                (*points.offset(0isize)).y + d1.y,
                            );
                            *temp.offset(1isize) = nk_vec2(
                                (*points.offset(0isize)).x + d2.x,
                                (*points.offset(0isize)).y + d2.y,
                            );
                            *temp.offset(2isize) = nk_vec2(
                                (*points.offset(0isize)).x - d2.x,
                                (*points.offset(0isize)).y - d2.y,
                            );
                            *temp.offset(3isize) = nk_vec2(
                                (*points.offset(0isize)).x - d1.x,
                                (*points.offset(0isize)).y - d1.y,
                            );
                            d1 = nk_vec2(
                                (*normals.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).x
                                    * (half_inner_thickness + AA_SIZE),
                                (*normals.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).y
                                    * (half_inner_thickness + AA_SIZE),
                            );
                            d2 = nk_vec2(
                                (*normals.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).x * half_inner_thickness,
                                (*normals.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).y * half_inner_thickness,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as libc::c_uint)
                                    .wrapping_mul(4i32 as libc::c_uint)
                                    .wrapping_add(0i32 as libc::c_uint)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).x + d1.x,
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).y + d1.y,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as libc::c_uint)
                                    .wrapping_mul(4i32 as libc::c_uint)
                                    .wrapping_add(1i32 as libc::c_uint)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).x + d2.x,
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).y + d2.y,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as libc::c_uint)
                                    .wrapping_mul(4i32 as libc::c_uint)
                                    .wrapping_add(2i32 as libc::c_uint)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).x - d2.x,
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).y - d2.y,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as libc::c_uint)
                                    .wrapping_mul(4i32 as libc::c_uint)
                                    .wrapping_add(3i32 as libc::c_uint)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).x - d1.x,
                                (*points.offset(
                                    points_count.wrapping_sub(1i32 as libc::c_uint) as isize
                                )).y - d1.y,
                            )
                        }
                        /* add all elements */
                        idx1_0 = index;
                        i1 = 0i32 as nk_size;
                        while i1 < count {
                            let mut dm_out: nk_vec2 = nk_vec2 { x: 0., y: 0. };
                            let mut dm_in: nk_vec2 = nk_vec2 { x: 0., y: 0. };
                            let i2_1: nk_size = if i1.wrapping_add(1i32 as libc::c_ulong)
                                == points_count as libc::c_ulong
                            {
                                0i32 as libc::c_ulong
                            } else {
                                i1.wrapping_add(1i32 as libc::c_ulong)
                            };
                            let mut idx2_0: nk_size = if i1.wrapping_add(1i32 as libc::c_ulong)
                                == points_count as libc::c_ulong
                            {
                                index
                            } else {
                                idx1_0.wrapping_add(4i32 as libc::c_ulong)
                            };
                            /* average normals */
                            let mut dm_0: nk_vec2 = nk_vec2(
                                nk_vec2(
                                    (*normals.offset(i1 as isize)).x
                                        + (*normals.offset(i2_1 as isize)).x,
                                    (*normals.offset(i1 as isize)).y
                                        + (*normals.offset(i2_1 as isize)).y,
                                ).x * 0.5f32,
                                nk_vec2(
                                    (*normals.offset(i1 as isize)).x
                                        + (*normals.offset(i2_1 as isize)).x,
                                    (*normals.offset(i1 as isize)).y
                                        + (*normals.offset(i2_1 as isize)).y,
                                ).y * 0.5f32,
                            );
                            let mut dmr2_0: f32 = dm_0.x * dm_0.x + dm_0.y * dm_0.y;
                            if dmr2_0 > 9.999999974752428e-7f32 {
                                scale_0 = 1.0f32 / dmr2_0;
                                scale_0 = if 100.0f32 < scale_0 {
                                    100.0f32
                                } else {
                                    scale_0
                                };
                                dm_0 = nk_vec2(dm_0.x * scale_0, dm_0.y * scale_0)
                            }
                            dm_out = nk_vec2(
                                dm_0.x * (half_inner_thickness + AA_SIZE),
                                dm_0.y * (half_inner_thickness + AA_SIZE),
                            );
                            dm_in = nk_vec2(
                                dm_0.x * half_inner_thickness,
                                dm_0.y * half_inner_thickness,
                            );
                            *temp.offset(
                                i2_1.wrapping_mul(4i32 as libc::c_ulong)
                                    .wrapping_add(0i32 as libc::c_ulong)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(i2_1 as isize)).x + dm_out.x,
                                (*points.offset(i2_1 as isize)).y + dm_out.y,
                            );
                            *temp.offset(
                                i2_1.wrapping_mul(4i32 as libc::c_ulong)
                                    .wrapping_add(1i32 as libc::c_ulong)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(i2_1 as isize)).x + dm_in.x,
                                (*points.offset(i2_1 as isize)).y + dm_in.y,
                            );
                            *temp.offset(
                                i2_1.wrapping_mul(4i32 as libc::c_ulong)
                                    .wrapping_add(2i32 as libc::c_ulong)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(i2_1 as isize)).x - dm_in.x,
                                (*points.offset(i2_1 as isize)).y - dm_in.y,
                            );
                            *temp.offset(
                                i2_1.wrapping_mul(4i32 as libc::c_ulong)
                                    .wrapping_add(3i32 as libc::c_ulong)
                                    as isize,
                            ) = nk_vec2(
                                (*points.offset(i2_1 as isize)).x - dm_out.x,
                                (*points.offset(i2_1 as isize)).y - dm_out.y,
                            );
                            /* add indexes */
                            *ids.offset(0isize) =
                                idx2_0.wrapping_add(1i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(1isize) =
                                idx1_0.wrapping_add(1i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(2isize) =
                                idx1_0.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(3isize) =
                                idx1_0.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(4isize) =
                                idx2_0.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(5isize) =
                                idx2_0.wrapping_add(1i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(6isize) =
                                idx2_0.wrapping_add(1i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(7isize) =
                                idx1_0.wrapping_add(1i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(8isize) =
                                idx1_0.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(9isize) =
                                idx1_0.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(10isize) =
                                idx2_0.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(11isize) =
                                idx2_0.wrapping_add(1i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(12isize) =
                                idx2_0.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(13isize) =
                                idx1_0.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(14isize) =
                                idx1_0.wrapping_add(3i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(15isize) =
                                idx1_0.wrapping_add(3i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(16isize) =
                                idx2_0.wrapping_add(3i32 as libc::c_ulong) as nk_draw_index;
                            *ids.offset(17isize) =
                                idx2_0.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                            ids = ids.offset(18isize);
                            idx1_0 = idx2_0;
                            i1 = i1.wrapping_add(1)
                        }
                        /* add vertices */
                        i_0 = 0i32 as nk_size;
                        while i_0 < points_count as libc::c_ulong {
                            let uv_0: nk_vec2 = (*list).config.null.uv;
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i_0.wrapping_mul(4i32 as libc::c_ulong)
                                        .wrapping_add(0i32 as libc::c_ulong)
                                        as isize,
                                ),
                                uv_0,
                                col_trans,
                            );
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i_0.wrapping_mul(4i32 as libc::c_ulong)
                                        .wrapping_add(1i32 as libc::c_ulong)
                                        as isize,
                                ),
                                uv_0,
                                col,
                            );
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i_0.wrapping_mul(4i32 as libc::c_ulong)
                                        .wrapping_add(2i32 as libc::c_ulong)
                                        as isize,
                                ),
                                uv_0,
                                col,
                            );
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i_0.wrapping_mul(4i32 as libc::c_ulong)
                                        .wrapping_add(3i32 as libc::c_ulong)
                                        as isize,
                                ),
                                uv_0,
                                col_trans,
                            );
                            i_0 = i_0.wrapping_add(1)
                        }
                    }
                    /* free temporary normals + points */
                    nk_buffer_reset((*list).vertices, NK_BUFFER_FRONT);
                }
            }
        } else {
            /* NON ANTI-ALIASED STROKE */
            let mut i1_0: nk_size = 0i32 as nk_size;
            let mut idx: nk_size = (*list).vertex_count as nk_size;
            let idx_count_0: nk_size = count.wrapping_mul(6i32 as libc::c_ulong);
            let vtx_count_0: nk_size = count.wrapping_mul(4i32 as libc::c_ulong);
            let mut vtx_0: *mut libc::c_void = nk_draw_list_alloc_vertices(list, vtx_count_0);
            let mut ids_0: *mut nk_draw_index = nk_draw_list_alloc_elements(list, idx_count_0);
            if vtx_0.is_null() || ids_0.is_null() {
                return;
            } else {
                i1_0 = 0i32 as nk_size;
                while i1_0 < count {
                    let mut dx: f32 = 0.;
                    let mut dy: f32 = 0.;
                    let uv_1: nk_vec2 = (*list).config.null.uv;
                    let i2_2: nk_size = if i1_0.wrapping_add(1i32 as libc::c_ulong)
                        == points_count as libc::c_ulong
                    {
                        0i32 as libc::c_ulong
                    } else {
                        i1_0.wrapping_add(1i32 as libc::c_ulong)
                    };
                    let p1: nk_vec2 = *points.offset(i1_0 as isize);
                    let p2: nk_vec2 = *points.offset(i2_2 as isize);
                    let mut diff_0: nk_vec2 = nk_vec2(p2.x - p1.x, p2.y - p1.y);
                    let mut len_0: f32 = 0.;
                    /* vec2 inverted length  */
                    len_0 = diff_0.x * diff_0.x + diff_0.y * diff_0.y;
                    if len_0 != 0.0f32 {
                        len_0 = nk_inv_sqrt(len_0)
                    } else {
                        len_0 = 1.0f32
                    }
                    diff_0 = nk_vec2(diff_0.x * len_0, diff_0.y * len_0);
                    /* add vertices */
                    dx = diff_0.x * (thickness * 0.5f32);
                    dy = diff_0.y * (thickness * 0.5f32);
                    vtx_0 = nk_draw_vertex(
                        vtx_0,
                        &mut (*list).config,
                        nk_vec2(p1.x + dy, p1.y - dx),
                        uv_1,
                        col,
                    );
                    vtx_0 = nk_draw_vertex(
                        vtx_0,
                        &mut (*list).config,
                        nk_vec2(p2.x + dy, p2.y - dx),
                        uv_1,
                        col,
                    );
                    vtx_0 = nk_draw_vertex(
                        vtx_0,
                        &mut (*list).config,
                        nk_vec2(p2.x - dy, p2.y + dx),
                        uv_1,
                        col,
                    );
                    vtx_0 = nk_draw_vertex(
                        vtx_0,
                        &mut (*list).config,
                        nk_vec2(p1.x - dy, p1.y + dx),
                        uv_1,
                        col,
                    );
                    *ids_0.offset(0isize) =
                        idx.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                    *ids_0.offset(1isize) =
                        idx.wrapping_add(1i32 as libc::c_ulong) as nk_draw_index;
                    *ids_0.offset(2isize) =
                        idx.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                    *ids_0.offset(3isize) =
                        idx.wrapping_add(0i32 as libc::c_ulong) as nk_draw_index;
                    *ids_0.offset(4isize) =
                        idx.wrapping_add(2i32 as libc::c_ulong) as nk_draw_index;
                    *ids_0.offset(5isize) =
                        idx.wrapping_add(3i32 as libc::c_ulong) as nk_draw_index;
                    ids_0 = ids_0.offset(6isize);
                    idx = (idx as libc::c_ulong).wrapping_add(4i32 as libc::c_ulong) as nk_size
                        as nk_size;
                    i1_0 = i1_0.wrapping_add(1)
                }
            }
        }
        return;
    };
}
unsafe fn nk_inv_sqrt(mut n: f32) -> f32 {
    let mut x2: f32 = 0.;
    let threehalfs: f32 = 1.5f32;
    let mut conv: unnamed_3 = unnamed_3 { i: 0i32 as nk_uint };
    conv.f = n;
    x2 = n * 0.5f32;
    conv.i = (1597463172i32 as libc::c_uint).wrapping_sub(conv.i >> 1i32);
    conv.f = conv.f * (threehalfs - x2 * conv.f * conv.f);
    return conv.f;
}
#[no_mangle]
pub unsafe fn nk_buffer_mark(
    mut buffer: *mut nk_buffer,
    mut type_0: nk_buffer_allocation_type,
) -> () {
    if buffer.is_null() {
        return;
    } else {
        (*buffer).marker[type_0 as usize].active = nk_true as libc::c_int;
        if type_0 as libc::c_uint == NK_BUFFER_BACK as libc::c_int as libc::c_uint {
            (*buffer).marker[type_0 as usize].offset = (*buffer).size
        } else {
            (*buffer).marker[type_0 as usize].offset = (*buffer).allocated
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_push_userdata(
    mut list: *mut nk_draw_list,
    mut userdata: nk_handle,
) -> () {
    (*list).userdata = userdata;
}
#[no_mangle]
pub unsafe fn nk_draw_list_path_line_to(mut list: *mut nk_draw_list, mut pos: nk_vec2) -> () {
    let mut points: *mut nk_vec2 = 0 as *mut nk_vec2;
    let mut cmd: *mut nk_draw_command = 0 as *mut nk_draw_command;
    if list.is_null() {
        return;
    } else {
        if 0 == (*list).cmd_count {
            nk_draw_list_add_clip(list, nk_null_rect);
        }
        cmd = nk_draw_list_command_last(list);
        if !cmd.is_null() && (*cmd).texture.ptr != (*list).config.null.texture.ptr {
            nk_draw_list_push_image(list, (*list).config.null.texture);
        }
        points = nk_draw_list_alloc_path(list, 1i32);
        if points.is_null() {
            return;
        } else {
            *points.offset(0isize) = pos;
            return;
        }
    };
}
unsafe fn nk_draw_list_alloc_path(
    mut list: *mut nk_draw_list,
    mut count: libc::c_int,
) -> *mut nk_vec2 {
    let mut memory: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut points: *mut nk_vec2 = 0 as *mut nk_vec2;
    const point_align: nk_size = ::std::mem::align_of::<nk_vec2>() as nk_size;
    const point_size: nk_size = ::std::mem::size_of::<nk_vec2>() as nk_size;
    points = nk_buffer_alloc(
        (*list).buffer,
        NK_BUFFER_FRONT,
        point_size.wrapping_mul(count as nk_size),
        point_align,
    ) as *mut nk_vec2;
    if points.is_null() {
        return 0 as *mut nk_vec2;
    } else {
        if 0 == (*list).path_offset {
            memory = nk_buffer_memory((*list).buffer);
            (*list).path_offset = (memory as *mut nk_byte)
                .ptr_offset_to(points as *mut nk_byte)
                .expect("bad offset_to") as libc::c_long
                as libc::c_uint
        }
        (*list).path_count = (*list).path_count.wrapping_add(count as libc::c_uint);
        return points;
    };
}
unsafe fn nk_draw_list_add_clip(mut list: *mut nk_draw_list, mut rect: nk_rect) -> () {
    if list.is_null() {
        return;
    } else {
        if 0 == (*list).cmd_count {
            nk_draw_list_push_command(list, rect, (*list).config.null.texture);
        } else {
            let mut prev: *mut nk_draw_command = nk_draw_list_command_last(list);
            if (*prev).elem_count == 0i32 as libc::c_uint {
                (*prev).clip_rect = rect
            }
            nk_draw_list_push_command(list, rect, (*prev).texture);
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_path_fill(mut list: *mut nk_draw_list, mut color: nk_color) -> () {
    let mut points: *mut nk_vec2 = 0 as *mut nk_vec2;
    if list.is_null() {
        return;
    } else {
        points = nk_buffer_memory((*list).buffer) as *mut nk_vec2;
        nk_draw_list_fill_poly_convex(
            list,
            points,
            (*list).path_count,
            color,
            (*list).config.shape_AA,
        );
        nk_draw_list_path_clear(list);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_fill_poly_convex(
    mut list: *mut nk_draw_list,
    mut points: *const nk_vec2,
    points_count: libc::c_uint,
    mut color: nk_color,
    mut aliasing: nk_anti_aliasing,
) -> () {
    let mut scale: f32 = 0.;
    let mut col: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut col_trans: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    const pnt_align: nk_size = ::std::mem::align_of::<nk_vec2>() as nk_size;
    const pnt_size: nk_size = ::std::mem::size_of::<nk_vec2>() as nk_size;
    if list.is_null() || points_count < 3i32 as libc::c_uint {
        return;
    } else {
        nk_draw_list_push_userdata(list, (*list).userdata);
        color.a = (color.a as f32 * (*list).config.global_alpha) as nk_byte;
        nk_color_fv(&mut col.r, color);
        col_trans = col;
        col_trans.a = 0i32 as f32;
        if aliasing as libc::c_uint == NK_ANTI_ALIASING_ON as libc::c_int as libc::c_uint {
            let mut i: nk_size = 0i32 as nk_size;
            let mut i0: nk_size = 0i32 as nk_size;
            let mut i1: nk_size = 0i32 as nk_size;
            let AA_SIZE: f32 = 1.0f32;
            let mut vertex_offset: nk_size = 0i32 as nk_size;
            let mut index: nk_size = (*list).vertex_count as nk_size;
            let idx_count: nk_size = points_count
                .wrapping_sub(2i32 as libc::c_uint)
                .wrapping_mul(3i32 as libc::c_uint)
                .wrapping_add(points_count.wrapping_mul(6i32 as libc::c_uint))
                as nk_size;
            let vtx_count: nk_size = points_count.wrapping_mul(2i32 as libc::c_uint) as nk_size;
            let mut vtx: *mut libc::c_void = nk_draw_list_alloc_vertices(list, vtx_count);
            let mut ids: *mut nk_draw_index = nk_draw_list_alloc_elements(list, idx_count);
            let mut size: nk_size = 0i32 as nk_size;
            let mut normals: *mut nk_vec2 = 0 as *mut nk_vec2;
            let mut vtx_inner_idx: libc::c_uint =
                index.wrapping_add(0i32 as libc::c_ulong) as libc::c_uint;
            let mut vtx_outer_idx: libc::c_uint =
                index.wrapping_add(1i32 as libc::c_ulong) as libc::c_uint;
            if vtx.is_null() || ids.is_null() {
                return;
            } else {
                /* temporary allocate normals */
                vertex_offset = ((*(*list).vertices).memory.ptr as *mut nk_byte)
                    .ptr_offset_to(vtx as *mut nk_byte)
                    .expect("bad offset_to") as libc::c_long
                    as nk_size;
                nk_buffer_mark((*list).vertices, NK_BUFFER_FRONT);
                size = pnt_size.wrapping_mul(points_count as libc::c_ulong);
                normals = nk_buffer_alloc((*list).vertices, NK_BUFFER_FRONT, size, pnt_align)
                    as *mut nk_vec2;
                if normals.is_null() {
                    return;
                } else {
                    vtx = ((*(*list).vertices).memory.ptr as *mut nk_byte)
                        .offset(vertex_offset as isize)
                        as *mut libc::c_void;
                    /* add elements */
                    i = 2i32 as nk_size;
                    while i < points_count as libc::c_ulong {
                        *ids.offset(0isize) = vtx_inner_idx as nk_draw_index;
                        *ids.offset(1isize) = (vtx_inner_idx as libc::c_ulong)
                            .wrapping_add(i.wrapping_sub(1i32 as libc::c_ulong) << 1i32)
                            as nk_draw_index;
                        *ids.offset(2isize) = (vtx_inner_idx as libc::c_ulong)
                            .wrapping_add(i << 1i32)
                            as nk_draw_index;
                        ids = ids.offset(3isize);
                        i = i.wrapping_add(1)
                    }
                    /* compute normals */
                    i0 = points_count.wrapping_sub(1i32 as libc::c_uint) as nk_size;
                    i1 = 0i32 as nk_size;
                    while i1 < points_count as libc::c_ulong {
                        let mut p0: nk_vec2 = *points.offset(i0 as isize);
                        let mut p1: nk_vec2 = *points.offset(i1 as isize);
                        let mut diff: nk_vec2 = nk_vec2(p1.x - p0.x, p1.y - p0.y);
                        /* vec2 inverted length  */
                        let mut len: f32 = diff.x * diff.x + diff.y * diff.y;
                        if len != 0.0f32 {
                            len = nk_inv_sqrt(len)
                        } else {
                            len = 1.0f32
                        }
                        diff = nk_vec2(diff.x * len, diff.y * len);
                        (*normals.offset(i0 as isize)).x = diff.y;
                        (*normals.offset(i0 as isize)).y = -diff.x;
                        let fresh8 = i1;
                        i1 = i1.wrapping_add(1);
                        i0 = fresh8
                    }
                    /* add vertices + indexes */
                    i0 = points_count.wrapping_sub(1i32 as libc::c_uint) as nk_size;
                    i1 = 0i32 as nk_size;
                    while i1 < points_count as libc::c_ulong {
                        let uv: nk_vec2 = (*list).config.null.uv;
                        let mut n0: nk_vec2 = *normals.offset(i0 as isize);
                        let mut n1: nk_vec2 = *normals.offset(i1 as isize);
                        let mut dm: nk_vec2 = nk_vec2(
                            nk_vec2(n0.x + n1.x, n0.y + n1.y).x * 0.5f32,
                            nk_vec2(n0.x + n1.x, n0.y + n1.y).y * 0.5f32,
                        );
                        let mut dmr2: f32 = dm.x * dm.x + dm.y * dm.y;
                        if dmr2 > 9.999999974752428e-7f32 {
                            scale = 1.0f32 / dmr2;
                            scale = if scale < 100.0f32 { scale } else { 100.0f32 };
                            dm = nk_vec2(dm.x * scale, dm.y * scale)
                        }
                        dm = nk_vec2(dm.x * (AA_SIZE * 0.5f32), dm.y * (AA_SIZE * 0.5f32));
                        /* add vertices */
                        vtx = nk_draw_vertex(
                            vtx,
                            &mut (*list).config,
                            nk_vec2(
                                (*points.offset(i1 as isize)).x - dm.x,
                                (*points.offset(i1 as isize)).y - dm.y,
                            ),
                            uv,
                            col,
                        );
                        vtx = nk_draw_vertex(
                            vtx,
                            &mut (*list).config,
                            nk_vec2(
                                (*points.offset(i1 as isize)).x + dm.x,
                                (*points.offset(i1 as isize)).y + dm.y,
                            ),
                            uv,
                            col_trans,
                        );
                        /* add indexes */
                        *ids.offset(0isize) = (vtx_inner_idx as libc::c_ulong)
                            .wrapping_add(i1 << 1i32)
                            as nk_draw_index;
                        *ids.offset(1isize) = (vtx_inner_idx as libc::c_ulong)
                            .wrapping_add(i0 << 1i32)
                            as nk_draw_index;
                        *ids.offset(2isize) = (vtx_outer_idx as libc::c_ulong)
                            .wrapping_add(i0 << 1i32)
                            as nk_draw_index;
                        *ids.offset(3isize) = (vtx_outer_idx as libc::c_ulong)
                            .wrapping_add(i0 << 1i32)
                            as nk_draw_index;
                        *ids.offset(4isize) = (vtx_outer_idx as libc::c_ulong)
                            .wrapping_add(i1 << 1i32)
                            as nk_draw_index;
                        *ids.offset(5isize) = (vtx_inner_idx as libc::c_ulong)
                            .wrapping_add(i1 << 1i32)
                            as nk_draw_index;
                        ids = ids.offset(6isize);
                        let fresh9 = i1;
                        i1 = i1.wrapping_add(1);
                        i0 = fresh9
                    }
                    /* free temporary normals + points */
                    nk_buffer_reset((*list).vertices, NK_BUFFER_FRONT);
                }
            }
        } else {
            let mut i_0: nk_size = 0i32 as nk_size;
            let mut index_0: nk_size = (*list).vertex_count as nk_size;
            let idx_count_0: nk_size = points_count
                .wrapping_sub(2i32 as libc::c_uint)
                .wrapping_mul(3i32 as libc::c_uint)
                as nk_size;
            let vtx_count_0: nk_size = points_count as nk_size;
            let mut vtx_0: *mut libc::c_void = nk_draw_list_alloc_vertices(list, vtx_count_0);
            let mut ids_0: *mut nk_draw_index = nk_draw_list_alloc_elements(list, idx_count_0);
            if vtx_0.is_null() || ids_0.is_null() {
                return;
            } else {
                i_0 = 0i32 as nk_size;
                while i_0 < vtx_count_0 {
                    vtx_0 = nk_draw_vertex(
                        vtx_0,
                        &mut (*list).config,
                        *points.offset(i_0 as isize),
                        (*list).config.null.uv,
                        col,
                    );
                    i_0 = i_0.wrapping_add(1)
                }
                i_0 = 2i32 as nk_size;
                while i_0 < points_count as libc::c_ulong {
                    *ids_0.offset(0isize) = index_0 as nk_draw_index;
                    *ids_0.offset(1isize) = index_0
                        .wrapping_add(i_0)
                        .wrapping_sub(1i32 as libc::c_ulong)
                        as nk_draw_index;
                    *ids_0.offset(2isize) = index_0.wrapping_add(i_0) as nk_draw_index;
                    ids_0 = ids_0.offset(3isize);
                    i_0 = i_0.wrapping_add(1)
                }
            }
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_fill_triangle(
    mut list: *mut nk_draw_list,
    mut a: nk_vec2,
    mut b: nk_vec2,
    mut c: nk_vec2,
    mut col: nk_color,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        nk_draw_list_path_line_to(list, a);
        nk_draw_list_path_line_to(list, b);
        nk_draw_list_path_line_to(list, c);
        nk_draw_list_path_fill(list, col);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_stroke_triangle(
    mut list: *mut nk_draw_list,
    mut a: nk_vec2,
    mut b: nk_vec2,
    mut c: nk_vec2,
    mut col: nk_color,
    mut thickness: f32,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        nk_draw_list_path_line_to(list, a);
        nk_draw_list_path_line_to(list, b);
        nk_draw_list_path_line_to(list, c);
        nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_path_arc_to(
    mut list: *mut nk_draw_list,
    mut center: nk_vec2,
    mut radius: f32,
    mut a_min: f32,
    mut a_max: f32,
    mut segments: libc::c_uint,
) -> () {
    let mut i: libc::c_uint = 0i32 as libc::c_uint;
    if list.is_null() {
        return;
    } else if radius == 0.0f32 {
        return;
    } else {
        /*  This algorithm for arc drawing relies on these two trigonometric identities[1]:
            sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)
            cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b)

        Two coordinates (x, y) of a point on a circle centered on
        the origin can be written in polar form as:
            x = r * cos(a)
            y = r * sin(a)
        where r is the radius of the circle,
            a is the angle between (x, y) and the origin.

        This allows us to rotate the coordinates around the
        origin by an angle b using the following transformation:
            x' = r * cos(a + b) = x * cos(b) - y * sin(b)
            y' = r * sin(a + b) = y * cos(b) + x * sin(b)

        [1] https://en.wikipedia.org/wiki/List_of_trigonometric_identities#Angle_sum_and_difference_identities
    */
        let d_angle: f32 = (a_max - a_min) / segments as f32;
        let sin_d: f32 = nk_sin(d_angle);
        let cos_d: f32 = nk_cos(d_angle);
        let mut cx: f32 = nk_cos(a_min) * radius;
        let mut cy: f32 = nk_sin(a_min) * radius;
        i = 0i32 as libc::c_uint;
        while i <= segments {
            let mut new_cx: f32 = 0.;
            let mut new_cy: f32 = 0.;
            let x: f32 = center.x + cx;
            let y: f32 = center.y + cy;
            nk_draw_list_path_line_to(list, nk_vec2(x, y));
            new_cx = cx * cos_d - cy * sin_d;
            new_cy = cy * cos_d + cx * sin_d;
            cx = new_cx;
            cy = new_cy;
            i = i.wrapping_add(1)
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_fill_circle(
    mut list: *mut nk_draw_list,
    mut center: nk_vec2,
    mut radius: f32,
    mut col: nk_color,
    mut segs: libc::c_uint,
) -> () {
    let mut a_max: f32 = 0.;
    if list.is_null() || 0 == col.a {
        return;
    } else {
        a_max = 3.1415927410125734f32 * 2.0f32 * (segs as f32 - 1.0f32)
            / segs as f32;
        nk_draw_list_path_arc_to(list, center, radius, 0.0f32, a_max, segs);
        nk_draw_list_path_fill(list, col);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_stroke_circle(
    mut list: *mut nk_draw_list,
    mut center: nk_vec2,
    mut radius: f32,
    mut col: nk_color,
    mut segs: libc::c_uint,
    mut thickness: f32,
) -> () {
    let mut a_max: f32 = 0.;
    if list.is_null() || 0 == col.a {
        return;
    } else {
        a_max = 3.1415927410125734f32 * 2.0f32 * (segs as f32 - 1.0f32)
            / segs as f32;
        nk_draw_list_path_arc_to(list, center, radius, 0.0f32, a_max, segs);
        nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_fill_rect_multi_color(
    mut list: *mut nk_draw_list,
    mut rect: nk_rect,
    mut left: nk_color,
    mut top: nk_color,
    mut right: nk_color,
    mut bottom: nk_color,
) -> () {
    let mut vtx: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut col_left: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut col_top: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut col_right: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut col_bottom: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut idx: *mut nk_draw_index = 0 as *mut nk_draw_index;
    let mut index: nk_draw_index = 0;
    nk_color_fv(&mut col_left.r, left);
    nk_color_fv(&mut col_right.r, right);
    nk_color_fv(&mut col_top.r, top);
    nk_color_fv(&mut col_bottom.r, bottom);
    if list.is_null() {
        return;
    } else {
        nk_draw_list_push_image(list, (*list).config.null.texture);
        index = (*list).vertex_count as nk_draw_index;
        vtx = nk_draw_list_alloc_vertices(list, 4i32 as nk_size);
        idx = nk_draw_list_alloc_elements(list, 6i32 as nk_size);
        if vtx.is_null() || idx.is_null() {
            return;
        } else {
            *idx.offset(0isize) = (index as libc::c_int + 0i32) as nk_draw_index;
            *idx.offset(1isize) = (index as libc::c_int + 1i32) as nk_draw_index;
            *idx.offset(2isize) = (index as libc::c_int + 2i32) as nk_draw_index;
            *idx.offset(3isize) = (index as libc::c_int + 0i32) as nk_draw_index;
            *idx.offset(4isize) = (index as libc::c_int + 2i32) as nk_draw_index;
            *idx.offset(5isize) = (index as libc::c_int + 3i32) as nk_draw_index;
            vtx = nk_draw_vertex(
                vtx,
                &mut (*list).config,
                nk_vec2(rect.x, rect.y),
                (*list).config.null.uv,
                col_left,
            );
            vtx = nk_draw_vertex(
                vtx,
                &mut (*list).config,
                nk_vec2(rect.x + rect.w, rect.y),
                (*list).config.null.uv,
                col_top,
            );
            vtx = nk_draw_vertex(
                vtx,
                &mut (*list).config,
                nk_vec2(rect.x + rect.w, rect.y + rect.h),
                (*list).config.null.uv,
                col_right,
            );
            vtx = nk_draw_vertex(
                vtx,
                &mut (*list).config,
                nk_vec2(rect.x, rect.y + rect.h),
                (*list).config.null.uv,
                col_bottom,
            );
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_fill_rect(
    mut list: *mut nk_draw_list,
    mut rect: nk_rect,
    mut col: nk_color,
    mut rounding: f32,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        if (*list).line_AA as libc::c_uint == NK_ANTI_ALIASING_ON as libc::c_int as libc::c_uint {
            nk_draw_list_path_rect_to(
                list,
                nk_vec2(rect.x, rect.y),
                nk_vec2(rect.x + rect.w, rect.y + rect.h),
                rounding,
            );
        } else {
            nk_draw_list_path_rect_to(
                list,
                nk_vec2(rect.x - 0.5f32, rect.y - 0.5f32),
                nk_vec2(rect.x + rect.w, rect.y + rect.h),
                rounding,
            );
        }
        nk_draw_list_path_fill(list, col);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_path_rect_to(
    mut list: *mut nk_draw_list,
    mut a: nk_vec2,
    mut b: nk_vec2,
    mut rounding: f32,
) -> () {
    let mut r: f32 = 0.;
    if list.is_null() {
        return;
    } else {
        r = rounding;
        r = if r < if b.x - a.x < 0i32 as f32 {
            -(b.x - a.x)
        } else {
            b.x - a.x
        } {
            r
        } else if b.x - a.x < 0i32 as f32 {
            -(b.x - a.x)
        } else {
            b.x - a.x
        };
        r = if r < if b.y - a.y < 0i32 as f32 {
            -(b.y - a.y)
        } else {
            b.y - a.y
        } {
            r
        } else if b.y - a.y < 0i32 as f32 {
            -(b.y - a.y)
        } else {
            b.y - a.y
        };
        if r == 0.0f32 {
            nk_draw_list_path_line_to(list, a);
            nk_draw_list_path_line_to(list, nk_vec2(b.x, a.y));
            nk_draw_list_path_line_to(list, b);
            nk_draw_list_path_line_to(list, nk_vec2(a.x, b.y));
        } else {
            nk_draw_list_path_arc_to_fast(list, nk_vec2(a.x + r, a.y + r), r, 6i32, 9i32);
            nk_draw_list_path_arc_to_fast(list, nk_vec2(b.x - r, a.y + r), r, 9i32, 12i32);
            nk_draw_list_path_arc_to_fast(list, nk_vec2(b.x - r, b.y - r), r, 0i32, 3i32);
            nk_draw_list_path_arc_to_fast(list, nk_vec2(a.x + r, b.y - r), r, 3i32, 6i32);
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_path_arc_to_fast(
    mut list: *mut nk_draw_list,
    mut center: nk_vec2,
    mut radius: f32,
    mut a_min: libc::c_int,
    mut a_max: libc::c_int,
) -> () {
    let mut a: libc::c_int = 0i32;
    if list.is_null() {
        return;
    } else {
        if a_min <= a_max {
            a = a_min;
            while a <= a_max {
                let c: nk_vec2 = (*list).circle_vtx[(a as nk_size).wrapping_rem(
                    (::std::mem::size_of::<[nk_vec2; 12]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<nk_vec2>() as libc::c_ulong),
                ) as usize];
                let x: f32 = center.x + c.x * radius;
                let y: f32 = center.y + c.y * radius;
                nk_draw_list_path_line_to(list, nk_vec2(x, y));
                a += 1
            }
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_stroke_rect(
    mut list: *mut nk_draw_list,
    mut rect: nk_rect,
    mut col: nk_color,
    mut rounding: f32,
    mut thickness: f32,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        if (*list).line_AA as libc::c_uint == NK_ANTI_ALIASING_ON as libc::c_int as libc::c_uint {
            nk_draw_list_path_rect_to(
                list,
                nk_vec2(rect.x, rect.y),
                nk_vec2(rect.x + rect.w, rect.y + rect.h),
                rounding,
            );
        } else {
            nk_draw_list_path_rect_to(
                list,
                nk_vec2(rect.x - 0.5f32, rect.y - 0.5f32),
                nk_vec2(rect.x + rect.w, rect.y + rect.h),
                rounding,
            );
        }
        nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_stroke_curve(
    mut list: *mut nk_draw_list,
    mut p0: nk_vec2,
    mut cp0: nk_vec2,
    mut cp1: nk_vec2,
    mut p1: nk_vec2,
    mut col: nk_color,
    mut segments: libc::c_uint,
    mut thickness: f32,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        nk_draw_list_path_line_to(list, p0);
        nk_draw_list_path_curve_to(list, cp0, cp1, p1, segments);
        nk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_path_curve_to(
    mut list: *mut nk_draw_list,
    mut p2: nk_vec2,
    mut p3: nk_vec2,
    mut p4: nk_vec2,
    mut num_segments: libc::c_uint,
) -> () {
    let mut t_step: f32 = 0.;
    let mut i_step: libc::c_uint = 0;
    let mut p1: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    if list.is_null() || 0 == (*list).path_count {
        return;
    } else {
        num_segments = if num_segments < 1i32 as libc::c_uint {
            1i32 as libc::c_uint
        } else {
            num_segments
        };
        p1 = nk_draw_list_path_last(list);
        t_step = 1.0f32 / num_segments as f32;
        i_step = 1i32 as libc::c_uint;
        while i_step <= num_segments {
            let mut t: f32 = t_step * i_step as f32;
            let mut u: f32 = 1.0f32 - t;
            let mut w1: f32 = u * u * u;
            let mut w2: f32 = 3i32 as f32 * u * u * t;
            let mut w3: f32 = 3i32 as f32 * u * t * t;
            let mut w4: f32 = t * t * t;
            let mut x: f32 = w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x;
            let mut y: f32 = w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y;
            nk_draw_list_path_line_to(list, nk_vec2(x, y));
            i_step = i_step.wrapping_add(1)
        }
        return;
    };
}
unsafe fn nk_draw_list_path_last(mut list: *mut nk_draw_list) -> nk_vec2 {
    let mut memory: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut point: *mut nk_vec2 = 0 as *mut nk_vec2;
    memory = nk_buffer_memory((*list).buffer);
    point = (memory as *mut nk_byte).offset((*list).path_offset as isize) as *mut libc::c_void
        as *mut nk_vec2;
    point = point.offset((*list).path_count.wrapping_sub(1i32 as libc::c_uint) as isize);
    return *point;
}
#[no_mangle]
pub unsafe fn nk_draw_list_stroke_line(
    mut list: *mut nk_draw_list,
    mut a: nk_vec2,
    mut b: nk_vec2,
    mut col: nk_color,
    mut thickness: f32,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        if (*list).line_AA as libc::c_uint == NK_ANTI_ALIASING_ON as libc::c_int as libc::c_uint {
            nk_draw_list_path_line_to(list, a);
            nk_draw_list_path_line_to(list, b);
        } else {
            nk_draw_list_path_line_to(
                list,
                nk_vec2(
                    a.x - nk_vec2(0.5f32, 0.5f32).x,
                    a.y - nk_vec2(0.5f32, 0.5f32).y,
                ),
            );
            nk_draw_list_path_line_to(
                list,
                nk_vec2(
                    b.x - nk_vec2(0.5f32, 0.5f32).x,
                    b.y - nk_vec2(0.5f32, 0.5f32).y,
                ),
            );
        }
        nk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_list_setup(
    mut canvas: *mut nk_draw_list,
    mut config: *const nk_convert_config,
    mut cmds: *mut nk_buffer,
    mut vertices: *mut nk_buffer,
    mut elements: *mut nk_buffer,
    mut line_aa: nk_anti_aliasing,
    mut shape_aa: nk_anti_aliasing,
) -> () {
    if canvas.is_null()
        || config.is_null()
        || cmds.is_null()
        || vertices.is_null()
        || elements.is_null()
    {
        return;
    } else {
        (*canvas).buffer = cmds;
        (*canvas).config = *config;
        (*canvas).elements = elements;
        (*canvas).vertices = vertices;
        (*canvas).line_AA = line_aa;
        (*canvas).shape_AA = shape_aa;
        (*canvas).clip_rect = nk_null_rect;
        (*canvas).cmd_offset = 0i32 as nk_size;
        (*canvas).element_count = 0i32 as libc::c_uint;
        (*canvas).vertex_count = 0i32 as libc::c_uint;
        (*canvas).cmd_offset = 0i32 as nk_size;
        (*canvas).cmd_count = 0i32 as libc::c_uint;
        (*canvas).path_count = 0i32 as libc::c_uint;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk__draw_begin(
    mut ctx: *const nk_context,
    mut buffer: *const nk_buffer,
) -> *const nk_draw_command {
    return nk__draw_list_begin(&(*ctx).draw_list, buffer);
}
#[no_mangle]
pub unsafe fn nk__draw_list_begin(
    mut canvas: *const nk_draw_list,
    mut buffer: *const nk_buffer,
) -> *const nk_draw_command {
    let mut memory: *mut nk_byte = 0 as *mut nk_byte;
    let mut offset: nk_size = 0;
    let mut cmd: *const nk_draw_command = 0 as *const nk_draw_command;
    if buffer.is_null() || 0 == (*buffer).size || 0 == (*canvas).cmd_count {
        return 0 as *const nk_draw_command;
    } else {
        memory = (*buffer).memory.ptr as *mut nk_byte;
        offset = (*buffer).memory.size.wrapping_sub((*canvas).cmd_offset);
        cmd = memory.offset(offset as isize) as *mut libc::c_void as *const nk_draw_command;
        return cmd;
    };
}
#[no_mangle]
pub unsafe fn nk__draw_end(
    mut ctx: *const nk_context,
    mut buffer: *const nk_buffer,
) -> *const nk_draw_command {
    return nk__draw_list_end(&(*ctx).draw_list, buffer);
}
#[no_mangle]
pub unsafe fn nk__draw_list_end(
    mut canvas: *const nk_draw_list,
    mut buffer: *const nk_buffer,
) -> *const nk_draw_command {
    let mut size: nk_size = 0;
    let mut offset: nk_size = 0;
    let mut memory: *mut nk_byte = 0 as *mut nk_byte;
    let mut end: *const nk_draw_command = 0 as *const nk_draw_command;
    if buffer.is_null() || canvas.is_null() {
        return 0 as *const nk_draw_command;
    } else {
        memory = (*buffer).memory.ptr as *mut nk_byte;
        size = (*buffer).memory.size;
        offset = size.wrapping_sub((*canvas).cmd_offset);
        end = memory.offset(offset as isize) as *mut libc::c_void as *const nk_draw_command;
        end = end.offset(-((*canvas).cmd_count.wrapping_sub(1i32 as libc::c_uint) as isize));
        return end;
    };
}
#[no_mangle]
pub unsafe fn nk__draw_next(
    mut cmd: *const nk_draw_command,
    mut buffer: *const nk_buffer,
    mut ctx: *const nk_context,
) -> *const nk_draw_command {
    return nk__draw_list_next(cmd, buffer, &(*ctx).draw_list);
}
#[no_mangle]
pub unsafe fn nk__draw_list_next(
    mut cmd: *const nk_draw_command,
    mut buffer: *const nk_buffer,
    mut canvas: *const nk_draw_list,
) -> *const nk_draw_command {
    let mut end: *const nk_draw_command = 0 as *const nk_draw_command;
    if cmd.is_null() || buffer.is_null() || canvas.is_null() {
        return 0 as *const nk_draw_command;
    } else {
        end = nk__draw_list_end(canvas, buffer);
        if cmd <= end {
            return 0 as *const nk_draw_command;
        } else {
            return cmd.offset(-1isize);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_begin(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
    mut bounds: nk_rect,
    mut flags: nk_flags,
) -> libc::c_int {
    return nk_begin_titled(ctx, title, title, bounds, flags);
}
#[no_mangle]
pub unsafe fn nk_begin_titled(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut title: *const libc::c_char,
    mut bounds: nk_rect,
    mut flags: nk_flags,
) -> libc::c_int {
    let mut name_hash: nk_hash = 0;
    let mut name_len: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    if ctx.is_null() || !(*ctx).current.is_null() || title.is_null() || name.is_null() {
        return 0;
    } else {
        /* find or create window */
        let mut style = &mut (*ctx).style as *mut nk_style;
        name_len = nk_strlen(name);
        name_hash = nk_murmur_hash(
            name as *const libc::c_void,
            name_len,
            NK_WINDOW_TITLE as nk_hash,
        );
        let mut win = nk_find_window(ctx, name_hash, name);
        if win.is_null() {
            /* create new window */
            let mut name_length = name_len as nk_size;
            win = nk_create_window(ctx) as *mut nk_window;
            if win.is_null() {
                return 0;
            } else {
                if 0 != flags & NK_WINDOW_BACKGROUND as libc::c_uint {
                    nk_insert_window(ctx, win, NK_INSERT_FRONT);
                } else {
                    nk_insert_window(ctx, win, NK_INSERT_BACK);
                }
                nk_command_buffer_init(&mut (*win).buffer, &mut (*ctx).memory, NK_CLIPPING_ON);
                (*win).flags = flags;
                (*win).bounds = bounds;
                (*win).name = name_hash;
                name_length = name_length.min(64 - 1);
                nk_memcopy(
                    (*win).name_string.as_mut_ptr() as *mut libc::c_void,
                    name as *const libc::c_void,
                    name_length,
                );
                (*win).name_string[name_length as usize] = 0;
                (*win).popup.win = ptr::null_mut();
                if (*ctx).active.is_null() {
                    (*ctx).active = win
                }
            }
        } else {
            /* update window */
            (*win).flags &= !((NK_WINDOW_PRIVATE as libc::c_int - 1) as nk_flags);
            (*win).flags |= flags;
            if 0 == (*win).flags
                & (NK_WINDOW_MOVABLE as libc::c_int | NK_WINDOW_SCALABLE as libc::c_int)
                    as libc::c_uint
            {
                (*win).bounds = bounds
            }
            /* If this assert triggers you either:
             *
             * I.) Have more than one window with the same name or
             * II.) You forgot to actually draw the window.
             *      More specific you did not call `nk_clear` (nk_clear will be
             *      automatically called for you if you are using one of the
             *      provided demo backends). */
            (*win).seq = (*ctx).seq;
            if (*ctx).active.is_null() && 0 == (*win).flags & NK_WINDOW_HIDDEN as libc::c_uint {
                (*ctx).active = win;
                (*ctx).end = win
            }
        }
        if 0 != (*win).flags & NK_WINDOW_HIDDEN as libc::c_uint {
            (*ctx).current = win;
            (*win).layout = ptr::null_mut();
            return 0;
        } else {
            nk_start(ctx, win);
            /* window overlapping */
            if 0 == (*win).flags & NK_WINDOW_HIDDEN as libc::c_uint
                && 0 == (*win).flags & NK_WINDOW_NO_INPUT as libc::c_uint
            {
                let mut inpanel = 0;
                let mut ishovered = 0;
                let mut iter = win;
                let mut h = (*(*ctx).style.font).height
                    + 2.0 * (*style).window.header.padding.y
                    + 2.0 * (*style).window.header.label_padding.y;
                let mut win_bounds: nk_rect =
                    if 0 == (*win).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint {
                        (*win).bounds
                    } else {
                        nk_rect((*win).bounds.x, (*win).bounds.y, (*win).bounds.w, h)
                    };
                /* activate window if hovered and no other window is overlapping this window */
                inpanel = nk_input_has_mouse_click_down_in_rect(
                    &mut (*ctx).input,
                    NK_BUTTON_LEFT,
                    win_bounds,
                    nk_true as libc::c_int,
                );
                inpanel = (0 != inpanel
                    && 0 != (*ctx).input.mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize]
                        .clicked) as libc::c_int;
                ishovered = nk_input_is_mouse_hovering_rect(&mut (*ctx).input, win_bounds);
                if win != (*ctx).active
                    && 0 != ishovered
                    && 0 == (*ctx).input.mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down
                {
                    iter = (*win).next;
                    while !iter.is_null() {
                        let mut iter_bounds: nk_rect = if 0
                            == (*iter).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
                        {
                            (*iter).bounds
                        } else {
                            nk_rect((*iter).bounds.x, (*iter).bounds.y, (*iter).bounds.w, h)
                        };
                        if !(iter_bounds.x > win_bounds.x + win_bounds.w
                            || iter_bounds.x + iter_bounds.w < win_bounds.x
                            || iter_bounds.y > win_bounds.y + win_bounds.h
                            || iter_bounds.y + iter_bounds.h < win_bounds.y)
                            && 0 == (*iter).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
                        {
                            break;
                        }
                        if !(*iter).popup.win.is_null()
                            && 0 != (*iter).popup.active
                            && 0 == (*iter).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
                            && !((*(*iter).popup.win).bounds.x > (*win).bounds.x + win_bounds.w
                                || (*(*iter).popup.win).bounds.x + (*(*iter).popup.win).bounds.w
                                    < (*win).bounds.x
                                || (*(*iter).popup.win).bounds.y > win_bounds.y + win_bounds.h
                                || (*(*iter).popup.win).bounds.y + (*(*iter).popup.win).bounds.h
                                    < win_bounds.y)
                        {
                            break;
                        }
                        iter = (*iter).next
                    }
                }
                /* activate window if clicked */
                if !iter.is_null() && 0 != inpanel && win != (*ctx).end {
                    iter = (*win).next;
                    while !iter.is_null() {
                        /* try to find a panel with higher priority in the same position */
                        let mut iter_bounds_0: nk_rect = if 0
                            == (*iter).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
                        {
                            (*iter).bounds
                        } else {
                            nk_rect((*iter).bounds.x, (*iter).bounds.y, (*iter).bounds.w, h)
                        };
                        if iter_bounds_0.x <= (*ctx).input.mouse.pos.x
                            && (*ctx).input.mouse.pos.x < iter_bounds_0.x + iter_bounds_0.w
                            && (iter_bounds_0.y <= (*ctx).input.mouse.pos.y
                                && (*ctx).input.mouse.pos.y < iter_bounds_0.y + iter_bounds_0.h)
                            && 0 == (*iter).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
                        {
                            break;
                        }
                        if !(*iter).popup.win.is_null()
                            && 0 != (*iter).popup.active
                            && 0 == (*iter).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
                            && !((*(*iter).popup.win).bounds.x > win_bounds.x + win_bounds.w
                                || (*(*iter).popup.win).bounds.x + (*(*iter).popup.win).bounds.w
                                    < win_bounds.x
                                || (*(*iter).popup.win).bounds.y > win_bounds.y + win_bounds.h
                                || (*(*iter).popup.win).bounds.y + (*(*iter).popup.win).bounds.h
                                    < win_bounds.y)
                        {
                            break;
                        }
                        iter = (*iter).next
                    }
                }
                if !iter.is_null()
                    && 0 == (*win).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
                    && 0 != (*win).flags & NK_WINDOW_BACKGROUND as libc::c_int as libc::c_uint
                {
                    (*win).flags |= NK_WINDOW_ROM as libc::c_int as nk_flags;
                    (*iter).flags &= !(NK_WINDOW_ROM as libc::c_int as nk_flags);
                    (*ctx).active = iter;
                    if 0 == (*iter).flags & NK_WINDOW_BACKGROUND as libc::c_int as libc::c_uint {
                        /* current window is active in that position so transfer to top
                         * at the highest priority in stack */
                        nk_remove_window(ctx, iter);
                        nk_insert_window(ctx, iter, NK_INSERT_BACK);
                    }
                } else {
                    if iter.is_null() && (*ctx).end != win {
                        if 0 == (*win).flags & NK_WINDOW_BACKGROUND as libc::c_int as libc::c_uint {
                            /* current window is active in that position so transfer to top
                             * at the highest priority in stack */
                            nk_remove_window(ctx, win);
                            nk_insert_window(ctx, win, NK_INSERT_BACK);
                        }
                        (*win).flags &= !(NK_WINDOW_ROM as libc::c_int as nk_flags);
                        (*ctx).active = win
                    }
                    if (*ctx).end != win
                        && 0 == (*win).flags & NK_WINDOW_BACKGROUND as libc::c_int as libc::c_uint
                    {
                        (*win).flags |= NK_WINDOW_ROM as libc::c_int as libc::c_uint
                    }
                }
            }
            (*win).layout = nk_create_panel(ctx) as *mut nk_panel;
            (*ctx).current = win;
            ret = nk_panel_begin(ctx, title, NK_PANEL_WINDOW);
            (*(*win).layout).offset_x = &mut (*win).scrollbar.x as *mut nk_uint;
            (*(*win).layout).offset_y = &mut (*win).scrollbar.y as *mut nk_uint;
            return ret;
        }
    };
}
unsafe fn nk_panel_begin(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
    mut panel_type: nk_panel_type,
) -> libc::c_int {
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut out: *mut nk_command_buffer = 0 as *mut nk_command_buffer;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut font: *const nk_user_font = 0 as *const nk_user_font;
    let mut scrollbar_size: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut panel_padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        nk_zero(
            (*(*ctx).current).layout as *mut libc::c_void,
            ::std::mem::size_of::<nk_panel>() as libc::c_ulong,
        );
        if 0 != (*(*ctx).current).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
            || 0 != (*(*ctx).current).flags & NK_WINDOW_CLOSED as libc::c_int as libc::c_uint
        {
            nk_zero(
                (*(*ctx).current).layout as *mut libc::c_void,
                ::std::mem::size_of::<nk_panel>() as libc::c_ulong,
            );
            (*(*(*ctx).current).layout).type_0 = panel_type;
            return 0i32;
        } else {
            /* pull state into local stack */
            style = &mut (*ctx).style as *mut nk_style;
            font = (*style).font;
            win = (*ctx).current;
            layout = (*win).layout;
            out = &mut (*win).buffer as *mut nk_command_buffer;
            in_0 = if 0 != (*win).flags & NK_WINDOW_NO_INPUT as libc::c_int as libc::c_uint {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            (*win).buffer.userdata = (*ctx).userdata;
            /* pull style configuration into local stack */
            scrollbar_size = (*style).window.scrollbar_size;
            panel_padding = nk_panel_get_padding(style, panel_type);
            /* window movement */
            if 0 != (*win).flags & NK_WINDOW_MOVABLE as libc::c_int as libc::c_uint
                && 0 == (*win).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                let mut left_mouse_down: libc::c_int = 0;
                let mut left_mouse_clicked: libc::c_int = 0;
                let mut left_mouse_click_in_cursor: libc::c_int = 0;
                /* calculate draggable window space */
                let mut header: nk_rect = nk_rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                header.x = (*win).bounds.x;
                header.y = (*win).bounds.y;
                header.w = (*win).bounds.w;
                if 0 != nk_panel_has_header((*win).flags, title) {
                    header.h = (*font).height + 2.0f32 * (*style).window.header.padding.y;
                    header.h += 2.0f32 * (*style).window.header.label_padding.y
                } else {
                    header.h = panel_padding.y
                }
                /* window movement by dragging */
                left_mouse_down =
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down;
                left_mouse_clicked = (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize]
                    .clicked as libc::c_int;
                left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(
                    in_0,
                    NK_BUTTON_LEFT,
                    header,
                    nk_true as libc::c_int,
                );
                if 0 != left_mouse_down
                    && 0 != left_mouse_click_in_cursor
                    && 0 == left_mouse_clicked
                {
                    (*win).bounds.x = (*win).bounds.x + (*in_0).mouse.delta.x;
                    (*win).bounds.y = (*win).bounds.y + (*in_0).mouse.delta.y;
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize]
                        .clicked_pos
                        .x += (*in_0).mouse.delta.x;
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize]
                        .clicked_pos
                        .y += (*in_0).mouse.delta.y;
                    (*ctx).style.cursor_active =
                        (*ctx).style.cursors[NK_CURSOR_MOVE as libc::c_int as usize]
                }
            }
            /* setup panel */
            (*layout).type_0 = panel_type;
            (*layout).flags = (*win).flags;
            (*layout).bounds = (*win).bounds;
            (*layout).bounds.x += panel_padding.x;
            (*layout).bounds.w -= 2i32 as f32 * panel_padding.x;
            if 0 != (*win).flags & NK_WINDOW_BORDER as libc::c_int as libc::c_uint {
                (*layout).border = nk_panel_get_border(style, (*win).flags, panel_type);
                (*layout).bounds = nk_shrink_rect((*layout).bounds, (*layout).border)
            } else {
                (*layout).border = 0i32 as f32
            }
            (*layout).at_y = (*layout).bounds.y;
            (*layout).at_x = (*layout).bounds.x;
            (*layout).max_x = 0i32 as f32;
            (*layout).header_height = 0i32 as f32;
            (*layout).footer_height = 0i32 as f32;
            nk_layout_reset_min_row_height(ctx);
            (*layout).row.index = 0i32;
            (*layout).row.columns = 0i32;
            (*layout).row.ratio = 0 as *const f32;
            (*layout).row.item_width = 0i32 as f32;
            (*layout).row.tree_depth = 0i32;
            (*layout).row.height = panel_padding.y;
            (*layout).has_scrolling = nk_true as libc::c_int as libc::c_uint;
            if 0 == (*win).flags & NK_WINDOW_NO_SCROLLBAR as libc::c_int as libc::c_uint {
                (*layout).bounds.w -= scrollbar_size.x
            }
            if 0 == nk_panel_is_nonblock(panel_type) {
                (*layout).footer_height = 0i32 as f32;
                if 0 == (*win).flags & NK_WINDOW_NO_SCROLLBAR as libc::c_int as libc::c_uint
                    || 0 != (*win).flags & NK_WINDOW_SCALABLE as libc::c_int as libc::c_uint
                {
                    (*layout).footer_height = scrollbar_size.y
                }
                (*layout).bounds.h -= (*layout).footer_height
            }
            /* panel header */
            if 0 != nk_panel_has_header((*win).flags, title) {
                let mut text: nk_text = nk_text {
                    padding: nk_vec2 { x: 0., y: 0. },
                    background: nk_color {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0,
                    },
                    text: nk_color {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0,
                    },
                };
                let mut header_0: nk_rect = nk_rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                let mut background: *const nk_style_item = 0 as *const nk_style_item;
                /* calculate header bounds */
                header_0.x = (*win).bounds.x;
                header_0.y = (*win).bounds.y;
                header_0.w = (*win).bounds.w;
                header_0.h = (*font).height + 2.0f32 * (*style).window.header.padding.y;
                header_0.h += 2.0f32 * (*style).window.header.label_padding.y;
                /* shrink panel by header */
                (*layout).header_height = header_0.h;
                (*layout).bounds.y += header_0.h;
                (*layout).bounds.h -= header_0.h;
                (*layout).at_y += header_0.h;
                /* select correct header background and text color */
                if (*ctx).active == win {
                    background = &(*style).window.header.active as *const nk_style_item;
                    text.text = (*style).window.header.label_active
                } else if 0 != nk_input_is_mouse_hovering_rect(&mut (*ctx).input, header_0) {
                    background = &(*style).window.header.hover as *const nk_style_item;
                    text.text = (*style).window.header.label_hover
                } else {
                    background = &(*style).window.header.normal as *const nk_style_item;
                    text.text = (*style).window.header.label_normal
                }
                /* draw header background */
                header_0.h += 1.0f32;
                if (*background).type_0 as libc::c_uint
                    == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
                {
                    text.background = nk_rgba(0i32, 0i32, 0i32, 0i32);
                    nk_draw_image(
                        &mut (*win).buffer,
                        header_0,
                        &(*background).data.image,
                        nk_white,
                    );
                } else {
                    text.background = (*background).data.color;
                    nk_fill_rect(
                        out,
                        header_0,
                        0i32 as f32,
                        (*background).data.color,
                    );
                }
                /* window close button */
                let mut button: nk_rect = nk_rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                button.y = header_0.y + (*style).window.header.padding.y;
                button.h = header_0.h - 2i32 as f32 * (*style).window.header.padding.y;
                button.w = button.h;
                if 0 != (*win).flags & NK_WINDOW_CLOSABLE as libc::c_int as libc::c_uint {
                    let mut ws: nk_flags = 0i32 as nk_flags;
                    if (*style).window.header.align as libc::c_uint
                        == NK_HEADER_RIGHT as libc::c_int as libc::c_uint
                    {
                        button.x =
                            header_0.w + header_0.x - (button.w + (*style).window.header.padding.x);
                        header_0.w -= button.w
                            + (*style).window.header.spacing.x
                            + (*style).window.header.padding.x
                    } else {
                        button.x = header_0.x + (*style).window.header.padding.x;
                        header_0.x += button.w
                            + (*style).window.header.spacing.x
                            + (*style).window.header.padding.x
                    }
                    if 0 != nk_do_button_symbol(
                        &mut ws,
                        &mut (*win).buffer,
                        button,
                        (*style).window.header.close_symbol,
                        NK_BUTTON_DEFAULT,
                        &(*style).window.header.close_button,
                        in_0,
                        (*style).font,
                    )
                        && 0 == (*win).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
                    {
                        (*layout).flags |= NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint;
                        (*layout).flags &= !(NK_WINDOW_MINIMIZED as libc::c_int) as nk_flags
                    }
                }
                /* window minimize button */
                if 0 != (*win).flags & NK_WINDOW_MINIMIZABLE as libc::c_int as libc::c_uint {
                    let mut ws_0: nk_flags = 0i32 as nk_flags;
                    if (*style).window.header.align as libc::c_uint
                        == NK_HEADER_RIGHT as libc::c_int as libc::c_uint
                    {
                        button.x = header_0.w + header_0.x - button.w;
                        if 0 == (*win).flags & NK_WINDOW_CLOSABLE as libc::c_int as libc::c_uint {
                            button.x -= (*style).window.header.padding.x;
                            header_0.w -= (*style).window.header.padding.x
                        }
                        header_0.w -= button.w + (*style).window.header.spacing.x
                    } else {
                        button.x = header_0.x;
                        header_0.x += button.w
                            + (*style).window.header.spacing.x
                            + (*style).window.header.padding.x
                    }
                    if 0 != nk_do_button_symbol(
                        &mut ws_0,
                        &mut (*win).buffer,
                        button,
                        (if 0
                            != (*layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
                        {
                            (*style).window.header.maximize_symbol as libc::c_uint
                        } else {
                            (*style).window.header.minimize_symbol as libc::c_uint
                        }) as nk_symbol_type,
                        NK_BUTTON_DEFAULT,
                        &(*style).window.header.minimize_button,
                        in_0,
                        (*style).font,
                    )
                        && 0 == (*win).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
                    {
                        (*layout).flags = if 0
                            != (*layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
                        {
                            (*layout).flags & !(NK_WINDOW_MINIMIZED as libc::c_int) as nk_flags
                        } else {
                            (*layout).flags | NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
                        }
                    }
                }
                /* window header title */
                let mut text_len: libc::c_int = nk_strlen(title);
                let mut label: nk_rect = nk_rect {
                    x: 0i32 as f32,
                    y: 0i32 as f32,
                    w: 0i32 as f32,
                    h: 0i32 as f32,
                };
                let mut t: f32 = (*font).width.expect("non-null function pointer")(
                    (*font).userdata,
                    (*font).height,
                    title,
                    text_len,
                );
                text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
                label.x = header_0.x + (*style).window.header.padding.x;
                label.x += (*style).window.header.label_padding.x;
                label.y = header_0.y + (*style).window.header.label_padding.y;
                label.h =
                    (*font).height + 2i32 as f32 * (*style).window.header.label_padding.y;
                label.w = t + 2i32 as f32 * (*style).window.header.spacing.x;
                label.w = if if label.w < header_0.x + header_0.w - label.x {
                    label.w
                } else {
                    header_0.x + header_0.w - label.x
                } < 0i32 as f32
                {
                    0i32 as f32
                } else if label.w < header_0.x + header_0.w - label.x {
                    label.w
                } else {
                    header_0.x + header_0.w - label.x
                };
                nk_widget_text(
                    out,
                    label,
                    title,
                    text_len,
                    &mut text,
                    NK_TEXT_LEFT as libc::c_int as nk_flags,
                    font,
                );
            }
            /* draw window background */
            if 0 == (*layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
                && 0 == (*layout).flags & NK_WINDOW_DYNAMIC as libc::c_int as libc::c_uint
            {
                let mut body: nk_rect = nk_rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                body.x = (*win).bounds.x;
                body.w = (*win).bounds.w;
                body.y = (*win).bounds.y + (*layout).header_height;
                body.h = (*win).bounds.h - (*layout).header_height;
                if (*style).window.fixed_background.type_0 as libc::c_uint
                    == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
                {
                    nk_draw_image(
                        out,
                        body,
                        &(*style).window.fixed_background.data.image,
                        nk_white,
                    );
                } else {
                    nk_fill_rect(
                        out,
                        body,
                        0i32 as f32,
                        (*style).window.fixed_background.data.color,
                    );
                }
            }
            /* set clipping rectangle */
            let mut clip: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            (*layout).clip = (*layout).bounds;
            nk_unify(
                &mut clip,
                &mut (*win).buffer.clip,
                (*layout).clip.x,
                (*layout).clip.y,
                (*layout).clip.x + (*layout).clip.w,
                (*layout).clip.y + (*layout).clip.h,
            );
            nk_push_scissor(out, clip);
            (*layout).clip = clip;
            return (0 == (*layout).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
                && 0 == (*layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint)
                as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_push_scissor(mut b: *mut nk_command_buffer, mut r: nk_rect) -> () {
    let mut cmd: *mut nk_command_scissor = 0 as *mut nk_command_scissor;
    if b.is_null() {
        return;
    } else {
        (*b).clip.x = r.x;
        (*b).clip.y = r.y;
        (*b).clip.w = r.w;
        (*b).clip.h = r.h;
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_SCISSOR,
            ::std::mem::size_of::<nk_command_scissor>() as libc::c_ulong,
        ) as *mut nk_command_scissor;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).x = r.x as libc::c_short;
            (*cmd).y = r.y as libc::c_short;
            (*cmd).w = (if (0i32 as f32) < r.w {
                r.w
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).h = (if (0i32 as f32) < r.h {
                r.h
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            return;
        }
    };
}
unsafe fn nk_unify(
    mut clip: *mut nk_rect,
    mut a: *const nk_rect,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
) -> () {
    (*clip).x = if (*a).x < x0 { x0 } else { (*a).x };
    (*clip).y = if (*a).y < y0 { y0 } else { (*a).y };
    (*clip).w = if (*a).x + (*a).w < x1 {
        (*a).x + (*a).w
    } else {
        x1
    } - (*clip).x;
    (*clip).h = if (*a).y + (*a).h < y1 {
        (*a).y + (*a).h
    } else {
        y1
    } - (*clip).y;
    (*clip).w = if (0i32 as f32) < (*clip).w {
        (*clip).w
    } else {
        0i32 as f32
    };
    (*clip).h = if (0i32 as f32) < (*clip).h {
        (*clip).h
    } else {
        0i32 as f32
    };
}
#[no_mangle]
pub unsafe fn nk_fill_rect(
    mut b: *mut nk_command_buffer,
    mut rect: nk_rect,
    mut rounding: f32,
    mut c: nk_color,
) -> () {
    let mut cmd: *mut nk_command_rect_filled = 0 as *mut nk_command_rect_filled;
    if b.is_null()
        || c.a as libc::c_int == 0i32
        || rect.w == 0i32 as f32
        || rect.h == 0i32 as f32
    {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const nk_rect = &mut (*b).clip as *mut nk_rect;
            if (*clip).x > rect.x + rect.w
                || (*clip).x + (*clip).w < rect.x
                || (*clip).y > rect.y + rect.h
                || (*clip).y + (*clip).h < rect.y
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_RECT_FILLED,
            ::std::mem::size_of::<nk_command_rect_filled>() as libc::c_ulong,
        ) as *mut nk_command_rect_filled;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).rounding = rounding as libc::c_ushort;
            (*cmd).x = rect.x as libc::c_short;
            (*cmd).y = rect.y as libc::c_short;
            (*cmd).w = (if (0i32 as f32) < rect.w {
                rect.w
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).h = (if (0i32 as f32) < rect.h {
                rect.h
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).color = c;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_strlen(mut str: *const libc::c_char) -> libc::c_int {
    let mut siz: libc::c_int = 0i32;
    while !str.is_null() && {
        let fresh10 = str;
        str = str.offset(1);
        *fresh10 as libc::c_int != '\u{0}' as i32
    } {
        siz += 1
    }
    return siz;
}
unsafe fn nk_widget_text(
    mut o: *mut nk_command_buffer,
    mut b: nk_rect,
    mut string: *const libc::c_char,
    mut len: libc::c_int,
    mut t: *const nk_text,
    mut a: nk_flags,
    mut f: *const nk_user_font,
) -> () {
    let mut label: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut text_width: f32 = 0.;
    if o.is_null() || t.is_null() {
        return;
    } else {
        b.h = if b.h < 2i32 as f32 * (*t).padding.y {
            2i32 as f32 * (*t).padding.y
        } else {
            b.h
        };
        label.x = 0i32 as f32;
        label.w = 0i32 as f32;
        label.y = b.y + (*t).padding.y;
        label.h = if (*f).height < b.h - 2i32 as f32 * (*t).padding.y {
            (*f).height
        } else {
            b.h - 2i32 as f32 * (*t).padding.y
        };
        text_width =
            (*f).width.expect("non-null function pointer")((*f).userdata, (*f).height, string, len);
        text_width += 2.0f32 * (*t).padding.x;
        /* align in x-axis */
        if 0 != a & NK_TEXT_ALIGN_LEFT as libc::c_int as libc::c_uint {
            label.x = b.x + (*t).padding.x;
            label.w = if (0i32 as f32) < b.w - 2i32 as f32 * (*t).padding.x {
                b.w - 2i32 as f32 * (*t).padding.x
            } else {
                0i32 as f32
            }
        } else if 0 != a & NK_TEXT_ALIGN_CENTERED as libc::c_int as libc::c_uint {
            label.w =
                if (1i32 as f32) < 2i32 as f32 * (*t).padding.x + text_width {
                    2i32 as f32 * (*t).padding.x + text_width
                } else {
                    1i32 as f32
                };
            label.x = b.x
                + (*t).padding.x
                + (b.w - 2i32 as f32 * (*t).padding.x - label.w) / 2i32 as f32;
            label.x = if b.x + (*t).padding.x < label.x {
                label.x
            } else {
                b.x + (*t).padding.x
            };
            label.w = if b.x + b.w < label.x + label.w {
                b.x + b.w
            } else {
                label.x + label.w
            };
            if label.w >= label.x {
                label.w -= label.x
            }
        } else if 0 != a & NK_TEXT_ALIGN_RIGHT as libc::c_int as libc::c_uint {
            label.x = if b.x + (*t).padding.x
                < b.x + b.w - (2i32 as f32 * (*t).padding.x + text_width)
            {
                b.x + b.w - (2i32 as f32 * (*t).padding.x + text_width)
            } else {
                b.x + (*t).padding.x
            };
            label.w = text_width + 2i32 as f32 * (*t).padding.x
        } else {
            return;
        }
        /* align in y-axis */
        if 0 != a & NK_TEXT_ALIGN_MIDDLE as libc::c_int as libc::c_uint {
            label.y = b.y + b.h / 2.0f32 - (*f).height / 2.0f32;
            label.h = if b.h / 2.0f32 < b.h - (b.h / 2.0f32 + (*f).height / 2.0f32) {
                b.h - (b.h / 2.0f32 + (*f).height / 2.0f32)
            } else {
                b.h / 2.0f32
            }
        } else if 0 != a & NK_TEXT_ALIGN_BOTTOM as libc::c_int as libc::c_uint {
            label.y = b.y + b.h - (*f).height;
            label.h = (*f).height
        }
        nk_draw_text(o, label, string, len, f, (*t).background, (*t).text);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_draw_text(
    mut b: *mut nk_command_buffer,
    mut r: nk_rect,
    mut string: *const libc::c_char,
    mut length: libc::c_int,
    mut font: *const nk_user_font,
    mut bg: nk_color,
    mut fg: nk_color,
) -> () {
    let mut glyphs: libc::c_int = 0;
    let mut txt_width: f32 = 0.;
    let mut text_width: f32 = 0i32 as f32;
    let mut cmd: *mut nk_command_text = 0 as *mut nk_command_text;
    if b.is_null()
        || string.is_null()
        || 0 == length
        || bg.a as libc::c_int == 0i32 && fg.a as libc::c_int == 0i32
    {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut c: *const nk_rect = &mut (*b).clip as *mut nk_rect;
            if (*c).w == 0i32 as f32 || (*c).h == 0i32 as f32
                || ((*c).x > r.x + r.w
                    || (*c).x + (*c).w < r.x
                    || (*c).y > r.y + r.h
                    || (*c).y + (*c).h < r.y)
            {
                return;
            }
        }
        /* make sure text fits inside bounds */
        text_width = (*font).width.expect("non-null function pointer")(
            (*font).userdata,
            (*font).height,
            string,
            length,
        );
        if text_width > r.w {
            glyphs = 0i32;
            txt_width = text_width;
            length = nk_text_clamp(
                font,
                string,
                length,
                r.w,
                &mut glyphs,
                &mut txt_width,
                0 as *mut nk_rune,
                0i32,
            )
        }
        if 0 == length {
            return;
        } else {
            cmd = nk_command_buffer_push(
                b,
                NK_COMMAND_TEXT,
                (::std::mem::size_of::<nk_command_text>() as libc::c_ulong)
                    .wrapping_add((length + 1i32) as nk_size),
            ) as *mut nk_command_text;
            if cmd.is_null() {
                return;
            } else {
                (*cmd).x = r.x as libc::c_short;
                (*cmd).y = r.y as libc::c_short;
                (*cmd).w = r.w as libc::c_ushort;
                (*cmd).h = r.h as libc::c_ushort;
                (*cmd).background = bg;
                (*cmd).foreground = fg;
                (*cmd).font = font;
                (*cmd).length = length;
                (*cmd).height = (*font).height;
                nk_memcopy(
                    (*cmd).string.as_mut_ptr() as *mut libc::c_void,
                    string as *const libc::c_void,
                    length as nk_size,
                );
                let string_ptr: *mut libc::c_char = (*cmd).string.as_ptr() as _;
                *string_ptr.offset(length as isize) = '\u{0}' as i32 as libc::c_char;
                return;
            }
        }
    };
}
unsafe fn nk_text_clamp(
    mut font: *const nk_user_font,
    mut text: *const libc::c_char,
    mut text_len: libc::c_int,
    mut space: f32,
    mut glyphs: *mut libc::c_int,
    mut text_width: *mut f32,
    mut sep_list: *mut nk_rune,
    mut sep_count: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0i32;
    let mut glyph_len: libc::c_int = 0i32;
    let mut last_width: f32 = 0i32 as f32;
    let mut unicode: nk_rune = 0i32 as nk_rune;
    let mut width: f32 = 0i32 as f32;
    let mut len: libc::c_int = 0i32;
    let mut g: libc::c_int = 0i32;
    let mut s: f32 = 0.;
    let mut sep_len: libc::c_int = 0i32;
    let mut sep_g: libc::c_int = 0i32;
    let mut sep_width: f32 = 0i32 as f32;
    sep_count = if sep_count < 0i32 { 0i32 } else { sep_count };
    glyph_len = nk_utf_decode(text, &mut unicode, text_len);
    while 0 != glyph_len && width < space && len < text_len {
        len += glyph_len;
        s = (*font).width.expect("non-null function pointer")(
            (*font).userdata,
            (*font).height,
            text,
            len,
        );
        i = 0i32;
        while i < sep_count {
            if unicode != *sep_list.offset(i as isize) {
                i += 1
            } else {
                last_width = width;
                sep_width = last_width;
                sep_g = g + 1i32;
                sep_len = len;
                break;
            }
        }
        if i == sep_count {
            sep_width = width;
            last_width = sep_width;
            sep_g = g + 1i32
        }
        width = s;
        glyph_len = nk_utf_decode(&*text.offset(len as isize), &mut unicode, text_len - len);
        g += 1
    }
    if len >= text_len {
        *glyphs = g;
        *text_width = last_width;
        return len;
    } else {
        *glyphs = sep_g;
        *text_width = sep_width;
        return if 0 == sep_len { len } else { sep_len };
    };
}
unsafe fn nk_do_button_symbol(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut symbol: nk_symbol_type,
    mut behavior: nk_button_behavior,
    mut style: *const nk_style_button,
    mut in_0: *const nk_input,
    mut font: *const nk_user_font,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut content: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() || font.is_null() || state.is_null() {
        return nk_false as libc::c_int;
    } else {
        ret = nk_do_button(state, out, bounds, style, in_0, behavior, &mut content);
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_button_symbol(out, &mut bounds, &mut content, *state, style, symbol, font);
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return ret;
    };
}
unsafe fn nk_draw_button_symbol(
    mut out: *mut nk_command_buffer,
    mut bounds: *const nk_rect,
    mut content: *const nk_rect,
    mut state: nk_flags,
    mut style: *const nk_style_button,
    mut type_0: nk_symbol_type,
    mut font: *const nk_user_font,
) -> () {
    let mut sym: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut bg: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    /* select correct colors/images */
    background = nk_draw_button(out, bounds, state, style);
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint {
        bg = (*background).data.color
    } else {
        bg = (*style).text_background
    }
    if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        sym = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        sym = (*style).text_active
    } else {
        sym = (*style).text_normal
    }
    nk_draw_symbol(out, type_0, *content, bg, sym, 1i32 as f32, font);
}
unsafe fn nk_draw_symbol(
    mut out: *mut nk_command_buffer,
    mut type_0: nk_symbol_type,
    mut content: nk_rect,
    mut background: nk_color,
    mut foreground: nk_color,
    mut border_width: f32,
    mut font: *const nk_user_font,
) -> () {
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut X: *const libc::c_char = 0 as *const libc::c_char;
    match type_0 as libc::c_uint {
        1 | 2 | 11 | 12 => {
            /* single character text symbol */
            X = if type_0 as libc::c_uint == NK_SYMBOL_X as libc::c_int as libc::c_uint {
                b"x\x00" as *const u8 as *const libc::c_char
            } else if type_0 as libc::c_uint == NK_SYMBOL_UNDERSCORE as libc::c_int as libc::c_uint
            {
                b"_\x00" as *const u8 as *const libc::c_char
            } else if type_0 as libc::c_uint == NK_SYMBOL_PLUS as libc::c_int as libc::c_uint {
                b"+\x00" as *const u8 as *const libc::c_char
            } else {
                b"-\x00" as *const u8 as *const libc::c_char
            };
            text = nk_text {
                padding: nk_vec2 { x: 0., y: 0. },
                background: nk_color {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                },
                text: nk_color {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                },
            };
            text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
            text.background = background;
            text.text = foreground;
            nk_widget_text(
                out,
                content,
                X,
                1i32,
                &mut text,
                NK_TEXT_CENTERED as libc::c_int as nk_flags,
                font,
            );
        }
        3 | 4 | 5 | 6 => {
            /* simple empty/filled shapes */
            if type_0 as libc::c_uint == NK_SYMBOL_RECT_SOLID as libc::c_int as libc::c_uint
                || type_0 as libc::c_uint == NK_SYMBOL_RECT_OUTLINE as libc::c_int as libc::c_uint
            {
                nk_fill_rect(out, content, 0i32 as f32, foreground);
                if type_0 as libc::c_uint == NK_SYMBOL_RECT_OUTLINE as libc::c_int as libc::c_uint {
                    nk_fill_rect(
                        out,
                        nk_shrink_rect(content, border_width),
                        0i32 as f32,
                        background,
                    );
                }
            } else {
                nk_fill_circle(out, content, foreground);
                if type_0 as libc::c_uint == NK_SYMBOL_CIRCLE_OUTLINE as libc::c_int as libc::c_uint
                {
                    nk_fill_circle(
                        out,
                        nk_shrink_rect(content, 1i32 as f32),
                        background,
                    );
                }
            }
        }
        7 | 8 | 9 | 10 => {
            let mut heading: nk_heading = NK_UP;
            let mut points: [nk_vec2; 3] = [nk_vec2 { x: 0., y: 0. }; 3];
            heading = (if type_0 as libc::c_uint
                == NK_SYMBOL_TRIANGLE_RIGHT as libc::c_int as libc::c_uint
            {
                NK_RIGHT as libc::c_int
            } else if type_0 as libc::c_uint
                == NK_SYMBOL_TRIANGLE_LEFT as libc::c_int as libc::c_uint
            {
                NK_LEFT as libc::c_int
            } else if type_0 as libc::c_uint == NK_SYMBOL_TRIANGLE_UP as libc::c_int as libc::c_uint
            {
                NK_UP as libc::c_int
            } else {
                NK_DOWN as libc::c_int
            }) as nk_heading;
            nk_triangle_from_direction(
                points.as_mut_ptr(),
                content,
                0i32 as f32,
                0i32 as f32,
                heading,
            );
            nk_fill_triangle(
                out,
                points[0usize].x,
                points[0usize].y,
                points[1usize].x,
                points[1usize].y,
                points[2usize].x,
                points[2usize].y,
                foreground,
            );
        }
        0 | 13 | _ => {}
    };
}
#[no_mangle]
pub unsafe fn nk_fill_triangle(
    mut b: *mut nk_command_buffer,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
    mut x2: f32,
    mut y2: f32,
    mut c: nk_color,
) -> () {
    let mut cmd: *mut nk_command_triangle_filled = 0 as *mut nk_command_triangle_filled;
    if b.is_null() || c.a as libc::c_int == 0i32 {
        return;
    } else if b.is_null() {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const nk_rect = &mut (*b).clip as *mut nk_rect;
            if !((*clip).x <= x0
                && x0 < (*clip).x + (*clip).w
                && ((*clip).y <= y0 && y0 < (*clip).y + (*clip).h))
                && !((*clip).x <= x1
                    && x1 < (*clip).x + (*clip).w
                    && ((*clip).y <= y1 && y1 < (*clip).y + (*clip).h))
                && !((*clip).x <= x2
                    && x2 < (*clip).x + (*clip).w
                    && ((*clip).y <= y2 && y2 < (*clip).y + (*clip).h))
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_TRIANGLE_FILLED,
            ::std::mem::size_of::<nk_command_triangle_filled>() as libc::c_ulong,
        ) as *mut nk_command_triangle_filled;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).a.x = x0 as libc::c_short;
            (*cmd).a.y = y0 as libc::c_short;
            (*cmd).b.x = x1 as libc::c_short;
            (*cmd).b.y = y1 as libc::c_short;
            (*cmd).c.x = x2 as libc::c_short;
            (*cmd).c.y = y2 as libc::c_short;
            (*cmd).color = c;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_triangle_from_direction(
    mut result: *mut nk_vec2,
    mut r: nk_rect,
    mut pad_x: f32,
    mut pad_y: f32,
    mut direction: nk_heading,
) -> () {
    let mut w_half: f32 = 0.;
    let mut h_half: f32 = 0.;
    r.w = if 2i32 as f32 * pad_x < r.w {
        r.w
    } else {
        2i32 as f32 * pad_x
    };
    r.h = if 2i32 as f32 * pad_y < r.h {
        r.h
    } else {
        2i32 as f32 * pad_y
    };
    r.w = r.w - 2i32 as f32 * pad_x;
    r.h = r.h - 2i32 as f32 * pad_y;
    r.x = r.x + pad_x;
    r.y = r.y + pad_y;
    w_half = r.w / 2.0f32;
    h_half = r.h / 2.0f32;
    if direction as libc::c_uint == NK_UP as libc::c_int as libc::c_uint {
        *result.offset(0isize) = nk_vec2(r.x + w_half, r.y);
        *result.offset(1isize) = nk_vec2(r.x + r.w, r.y + r.h);
        *result.offset(2isize) = nk_vec2(r.x, r.y + r.h)
    } else if direction as libc::c_uint == NK_RIGHT as libc::c_int as libc::c_uint {
        *result.offset(0isize) = nk_vec2(r.x, r.y);
        *result.offset(1isize) = nk_vec2(r.x + r.w, r.y + h_half);
        *result.offset(2isize) = nk_vec2(r.x, r.y + r.h)
    } else if direction as libc::c_uint == NK_DOWN as libc::c_int as libc::c_uint {
        *result.offset(0isize) = nk_vec2(r.x, r.y);
        *result.offset(1isize) = nk_vec2(r.x + r.w, r.y);
        *result.offset(2isize) = nk_vec2(r.x + w_half, r.y + r.h)
    } else {
        *result.offset(0isize) = nk_vec2(r.x, r.y + h_half);
        *result.offset(1isize) = nk_vec2(r.x + r.w, r.y);
        *result.offset(2isize) = nk_vec2(r.x + r.w, r.y + r.h)
    };
}
unsafe fn nk_shrink_rect(mut r: nk_rect, mut amount: f32) -> nk_rect {
    let mut res: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    r.w = if r.w < 2i32 as f32 * amount {
        2i32 as f32 * amount
    } else {
        r.w
    };
    r.h = if r.h < 2i32 as f32 * amount {
        2i32 as f32 * amount
    } else {
        r.h
    };
    res.x = r.x + amount;
    res.y = r.y + amount;
    res.w = r.w - 2i32 as f32 * amount;
    res.h = r.h - 2i32 as f32 * amount;
    return res;
}
#[no_mangle]
pub unsafe fn nk_fill_circle(mut b: *mut nk_command_buffer, mut r: nk_rect, mut c: nk_color) -> () {
    let mut cmd: *mut nk_command_circle_filled = 0 as *mut nk_command_circle_filled;
    if b.is_null()
        || c.a as libc::c_int == 0i32
        || r.w == 0i32 as f32
        || r.h == 0i32 as f32
    {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const nk_rect = &mut (*b).clip as *mut nk_rect;
            if (*clip).x > r.x + r.w
                || (*clip).x + (*clip).w < r.x
                || (*clip).y > r.y + r.h
                || (*clip).y + (*clip).h < r.y
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_CIRCLE_FILLED,
            ::std::mem::size_of::<nk_command_circle_filled>() as libc::c_ulong,
        ) as *mut nk_command_circle_filled;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).x = r.x as libc::c_short;
            (*cmd).y = r.y as libc::c_short;
            (*cmd).w = (if r.w < 0i32 as f32 {
                0i32 as f32
            } else {
                r.w
            }) as libc::c_ushort;
            (*cmd).h = (if r.h < 0i32 as f32 {
                0i32 as f32
            } else {
                r.h
            }) as libc::c_ushort;
            (*cmd).color = c;
            return;
        }
    };
}
unsafe fn nk_draw_button(
    mut out: *mut nk_command_buffer,
    mut bounds: *const nk_rect,
    mut state: nk_flags,
    mut style: *const nk_style_button,
) -> *const nk_style_item {
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        background = &(*style).hover as *const nk_style_item
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        background = &(*style).active as *const nk_style_item
    } else {
        background = &(*style).normal as *const nk_style_item
    }
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
    } else {
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        nk_stroke_rect(
            out,
            *bounds,
            (*style).rounding,
            (*style).border,
            (*style).border_color,
        );
    }
    return background;
}
#[no_mangle]
pub unsafe fn nk_stroke_rect(
    mut b: *mut nk_command_buffer,
    mut rect: nk_rect,
    mut rounding: f32,
    mut line_thickness: f32,
    mut c: nk_color,
) -> () {
    let mut cmd: *mut nk_command_rect = 0 as *mut nk_command_rect;
    if b.is_null()
        || c.a as libc::c_int == 0i32
        || rect.w == 0i32 as f32
        || rect.h == 0i32 as f32
        || line_thickness <= 0i32 as f32
    {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const nk_rect = &mut (*b).clip as *mut nk_rect;
            if (*clip).x > rect.x + rect.w
                || (*clip).x + (*clip).w < rect.x
                || (*clip).y > rect.y + rect.h
                || (*clip).y + (*clip).h < rect.y
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_RECT,
            ::std::mem::size_of::<nk_command_rect>() as libc::c_ulong,
        ) as *mut nk_command_rect;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).rounding = rounding as libc::c_ushort;
            (*cmd).line_thickness = line_thickness as libc::c_ushort;
            (*cmd).x = rect.x as libc::c_short;
            (*cmd).y = rect.y as libc::c_short;
            (*cmd).w = (if (0i32 as f32) < rect.w {
                rect.w
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).h = (if (0i32 as f32) < rect.h {
                rect.h
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).color = c;
            return;
        }
    };
}
unsafe fn nk_do_button(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut r: nk_rect,
    mut style: *const nk_style_button,
    mut in_0: *const nk_input,
    mut behavior: nk_button_behavior,
    mut content: *mut nk_rect,
) -> libc::c_int {
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() {
        return nk_false as libc::c_int;
    } else {
        /* calculate button content space */
        (*content).x = r.x + (*style).padding.x + (*style).border + (*style).rounding;
        (*content).y = r.y + (*style).padding.y + (*style).border + (*style).rounding;
        (*content).w = r.w - (2i32 as f32 * (*style).padding.x
            + (*style).border
            + (*style).rounding * 2i32 as f32);
        (*content).h = r.h - (2i32 as f32 * (*style).padding.y
            + (*style).border
            + (*style).rounding * 2i32 as f32);
        /* execute button behavior */
        bounds.x = r.x - (*style).touch_padding.x;
        bounds.y = r.y - (*style).touch_padding.y;
        bounds.w = r.w + 2i32 as f32 * (*style).touch_padding.x;
        bounds.h = r.h + 2i32 as f32 * (*style).touch_padding.y;
        return nk_button_behavior(state, bounds, in_0, behavior);
    };
}
unsafe fn nk_button_behavior(
    mut state: *mut nk_flags,
    mut r: nk_rect,
    mut i: *const nk_input,
    mut behavior: nk_button_behavior,
) -> libc::c_int {
    let mut ret: libc::c_int = 0i32;
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as libc::c_int as libc::c_uint {
        *state = (NK_WIDGET_STATE_INACTIVE as libc::c_int | NK_WIDGET_STATE_MODIFIED as libc::c_int)
            as nk_flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as libc::c_int as nk_flags
    }
    if i.is_null() {
        return 0i32;
    } else {
        if 0 != nk_input_is_mouse_hovering_rect(i, r) {
            *state = NK_WIDGET_STATE_HOVERED as libc::c_int as nk_flags;
            if 0 != nk_input_is_mouse_down(i, NK_BUTTON_LEFT) {
                *state = NK_WIDGET_STATE_ACTIVE as libc::c_int as nk_flags
            }
            if 0 != nk_input_has_mouse_click_in_rect(i, NK_BUTTON_LEFT, r) {
                ret = if behavior as libc::c_uint
                    != NK_BUTTON_DEFAULT as libc::c_int as libc::c_uint
                {
                    nk_input_is_mouse_down(i, NK_BUTTON_LEFT)
                } else {
                    nk_input_is_mouse_pressed(i, NK_BUTTON_LEFT)
                }
            }
        }
        if 0 != *state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            && 0 == nk_input_is_mouse_prev_hovering_rect(i, r)
        {
            *state |= NK_WIDGET_STATE_ENTERED as libc::c_int as libc::c_uint
        } else if 0 != nk_input_is_mouse_prev_hovering_rect(i, r) {
            *state |= NK_WIDGET_STATE_LEFT as libc::c_int as libc::c_uint
        }
        return ret;
    };
}
#[no_mangle]
pub unsafe fn nk_input_is_mouse_prev_hovering_rect(
    mut i: *const nk_input,
    mut rect: nk_rect,
) -> libc::c_int {
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        return (rect.x <= (*i).mouse.prev.x
            && (*i).mouse.prev.x < rect.x + rect.w
            && (rect.y <= (*i).mouse.prev.y && (*i).mouse.prev.y < rect.y + rect.h))
            as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_input_is_mouse_pressed(mut i: *const nk_input, mut id: nk_buttons) -> libc::c_int {
    let mut b: *const nk_mouse_button = 0 as *const nk_mouse_button;
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        b = &(*i).mouse.buttons[id as usize] as *const nk_mouse_button;
        if 0 != (*b).down && 0 != (*b).clicked {
            return nk_true as libc::c_int;
        } else {
            return nk_false as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_input_is_mouse_down(mut i: *const nk_input, mut id: nk_buttons) -> libc::c_int {
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        return (*i).mouse.buttons[id as usize].down;
    };
}
#[no_mangle]
pub unsafe fn nk_input_has_mouse_click_in_rect(
    mut i: *const nk_input,
    mut id: nk_buttons,
    mut b: nk_rect,
) -> libc::c_int {
    let mut btn: *const nk_mouse_button = 0 as *const nk_mouse_button;
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        btn = &(*i).mouse.buttons[id as usize] as *const nk_mouse_button;
        if !(b.x <= (*btn).clicked_pos.x
            && (*btn).clicked_pos.x < b.x + b.w
            && (b.y <= (*btn).clicked_pos.y && (*btn).clicked_pos.y < b.y + b.h))
        {
            return nk_false as libc::c_int;
        } else {
            return nk_true as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_input_is_mouse_hovering_rect(
    mut i: *const nk_input,
    mut rect: nk_rect,
) -> libc::c_int {
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        return (rect.x <= (*i).mouse.pos.x
            && (*i).mouse.pos.x < rect.x + rect.w
            && (rect.y <= (*i).mouse.pos.y && (*i).mouse.pos.y < rect.y + rect.h))
            as libc::c_int;
    };
}
unsafe fn nk_panel_has_header(mut flags: nk_flags, mut title: *const libc::c_char) -> libc::c_int {
    let mut active: libc::c_int = 0i32;
    active = (flags
        & (NK_WINDOW_CLOSABLE as libc::c_int | NK_WINDOW_MINIMIZABLE as libc::c_int)
            as libc::c_uint) as libc::c_int;
    active =
        (0 != active || 0 != flags & NK_WINDOW_TITLE as libc::c_int as libc::c_uint) as libc::c_int;
    active = (0 != active
        && 0 == flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
        && !title.is_null()) as libc::c_int;
    return active;
}
unsafe fn nk_panel_is_nonblock(mut type_0: nk_panel_type) -> libc::c_int {
    return if 0 != type_0 as libc::c_uint & NK_PANEL_SET_NONBLOCK as libc::c_int as libc::c_uint {
        1i32
    } else {
        0i32
    };
}
#[no_mangle]
pub unsafe fn nk_layout_reset_min_row_height(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).row.min_height = (*(*ctx).style.font).height;
        (*layout).row.min_height += (*ctx).style.text.padding.y * 2i32 as f32;
        (*layout).row.min_height +=
            (*ctx).style.window.min_row_height_padding * 2i32 as f32;
        return;
    };
}
unsafe fn nk_panel_get_border(
    mut style: *const nk_style,
    mut flags: nk_flags,
    mut type_0: nk_panel_type,
) -> f32 {
    if 0 != flags & NK_WINDOW_BORDER as libc::c_int as libc::c_uint {
        match type_0 as libc::c_uint {
            2 => return (*style).window.group_border,
            4 => return (*style).window.popup_border,
            16 => return (*style).window.contextual_border,
            32 => return (*style).window.combo_border,
            64 => return (*style).window.menu_border,
            128 => return (*style).window.menu_border,
            1 | _ => return (*style).window.border,
        }
    } else {
        return 0i32 as f32;
    };
}
#[no_mangle]
pub unsafe fn nk_input_has_mouse_click_down_in_rect(
    mut i: *const nk_input,
    mut id: nk_buttons,
    mut b: nk_rect,
    mut down: libc::c_int,
) -> libc::c_int {
    let mut btn: *const nk_mouse_button = 0 as *const nk_mouse_button;
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        btn = &(*i).mouse.buttons[id as usize] as *const nk_mouse_button;
        return (0 != nk_input_has_mouse_click_in_rect(i, id, b) && (*btn).down == down)
            as libc::c_int;
    };
}
unsafe fn nk_panel_get_padding(mut style: *const nk_style, mut type_0: nk_panel_type) -> nk_vec2 {
    match type_0 as libc::c_uint {
        2 => return (*style).window.group_padding,
        4 => return (*style).window.popup_padding,
        16 => return (*style).window.contextual_padding,
        32 => return (*style).window.combo_padding,
        64 => return (*style).window.menu_padding,
        128 => return (*style).window.menu_padding,
        1 | _ => return (*style).window.padding,
    };
}
unsafe fn nk_create_panel(mut ctx: *mut nk_context) -> *mut libc::c_void {
    let mut elem: *mut nk_page_element = 0 as *mut nk_page_element;
    elem = nk_create_page_element(ctx);
    if elem.is_null() {
        return 0 as *mut libc::c_void;
    } else {
        nk_zero(
            elem as *mut libc::c_void,
            ::std::mem::size_of::<nk_page_element>() as libc::c_ulong,
        );
        return &mut (*elem).data.pan as *mut nk_panel as *mut libc::c_void;
    };
}
unsafe fn nk_create_page_element(mut ctx: *mut nk_context) -> *mut nk_page_element {
    let mut elem: *mut nk_page_element = 0 as *mut nk_page_element;
    if !(*ctx).freelist.is_null() {
        /* unlink page element from free list */
        elem = (*ctx).freelist;
        (*ctx).freelist = (*elem).next
    } else if 0 != (*ctx).use_pool {
        /* allocate page element from memory pool */
        elem = nk_pool_alloc(&mut (*ctx).pool);
        if elem.is_null() {
            return 0 as *mut nk_page_element;
        }
    } else {
        const size: nk_size = ::std::mem::size_of::<nk_page_element>() as nk_size;
        const align: nk_size = ::std::mem::size_of::<nk_page_element>() as nk_size;
        /* allocate new page element from back of fixed size memory buffer */
        elem = nk_buffer_alloc(&mut (*ctx).memory, NK_BUFFER_BACK, size, align)
            as *mut nk_page_element;
        if elem.is_null() {
            return 0 as *mut nk_page_element;
        }
    }
    nk_zero(
        elem as *mut libc::c_void,
        ::std::mem::size_of::<nk_page_element>() as libc::c_ulong,
    );
    (*elem).next = 0 as *mut nk_page_element;
    (*elem).prev = 0 as *mut nk_page_element;
    return elem;
}
unsafe fn nk_pool_alloc(mut pool: *mut nk_pool) -> *mut nk_page_element {
    if (*pool).pages.is_null() || (*(*pool).pages).size >= (*pool).capacity {
        /* allocate new page */
        let mut page: *mut nk_page = 0 as *mut nk_page;
        if (*pool).type_0 as libc::c_uint == NK_BUFFER_FIXED as libc::c_int as libc::c_uint {
            if (*pool).pages.is_null() {
                return 0 as *mut nk_page_element;
            } else {
                return 0 as *mut nk_page_element;
            }
        } else {
            let mut size: nk_size = ::std::mem::size_of::<nk_page>() as libc::c_ulong;
            size = (size as libc::c_ulong).wrapping_add(
                (16i32 as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<nk_page_data>() as libc::c_ulong),
            ) as nk_size as nk_size;
            page = (*pool).alloc.alloc.expect("non-null function pointer")(
                (*pool).alloc.userdata,
                0 as *mut libc::c_void,
                size,
            ) as *mut nk_page;
            (*page).next = (*pool).pages;
            (*pool).pages = page;
            (*page).size = 0i32 as libc::c_uint
        }
    }
    let fresh11 = (*(*pool).pages).size;
    (*(*pool).pages).size = (*(*pool).pages).size.wrapping_add(1);
    let win_ptr: *mut nk_page_element = (*(*pool).pages).win.as_ptr() as _;
    return win_ptr.offset(fresh11 as isize);
}
unsafe fn nk_insert_window(
    mut ctx: *mut nk_context,
    mut win: *mut nk_window,
    mut loc: nk_window_insert_location,
) -> () {
    let mut end: *mut nk_window = 0 as *mut nk_window;
    let mut iter: *const nk_window = 0 as *const nk_window;
    if win.is_null() || ctx.is_null() {
        return;
    } else {
        iter = (*ctx).begin;
        while !iter.is_null() {
            if iter == win {
                return;
            } else {
                iter = (*iter).next
            }
        }
        if (*ctx).begin.is_null() {
            (*win).next = 0 as *mut nk_window;
            (*win).prev = 0 as *mut nk_window;
            (*ctx).begin = win;
            (*ctx).end = win;
            (*ctx).count = 1i32 as libc::c_uint;
            return;
        } else {
            if loc as libc::c_uint == NK_INSERT_BACK as libc::c_int as libc::c_uint {
                end = 0 as *mut nk_window;
                end = (*ctx).end;
                (*end).flags |= NK_WINDOW_ROM as libc::c_int as libc::c_uint;
                (*end).next = win;
                (*win).prev = (*ctx).end;
                (*win).next = 0 as *mut nk_window;
                (*ctx).end = win;
                (*ctx).active = (*ctx).end;
                (*(*ctx).end).flags &= !(NK_WINDOW_ROM as libc::c_int as nk_flags)
            } else {
                /*ctx->end->flags |= NK_WINDOW_ROM;*/
                (*(*ctx).begin).prev = win;
                (*win).next = (*ctx).begin;
                (*win).prev = 0 as *mut nk_window;
                (*ctx).begin = win;
                (*(*ctx).begin).flags &= !(NK_WINDOW_ROM as libc::c_int as nk_flags)
            }
            (*ctx).count = (*ctx).count.wrapping_add(1);
            return;
        }
    };
}
unsafe fn nk_start(mut ctx: *mut nk_context, mut win: *mut nk_window) -> () {
    nk_start_buffer(ctx, &mut (*win).buffer);
}
unsafe fn nk_create_window(mut ctx: *mut nk_context) -> *mut libc::c_void {
    let mut elem: *mut nk_page_element = 0 as *mut nk_page_element;
    elem = nk_create_page_element(ctx);
    if elem.is_null() {
        return 0 as *mut libc::c_void;
    } else {
        (*elem).data.win.seq = (*ctx).seq;
        return &mut (*elem).data.win as *mut nk_window as *mut libc::c_void;
    };
}
unsafe fn nk_find_window(
    mut ctx: *mut nk_context,
    mut hash: nk_hash,
    mut name: *const libc::c_char,
) -> *mut nk_window {
    let mut iter: *mut nk_window = 0 as *mut nk_window;
    iter = (*ctx).begin;
    while !iter.is_null() {
        if (*iter).name == hash {
            let mut max_len: libc::c_int = nk_strlen((*iter).name_string.as_mut_ptr());
            if 0 == nk_stricmpn((*iter).name_string.as_mut_ptr(), name, max_len) {
                return iter;
            }
        }
        iter = (*iter).next
    }
    return 0 as *mut nk_window;
}
#[no_mangle]
pub unsafe fn nk_stricmpn(
    mut s1: *const libc::c_char,
    mut s2: *const libc::c_char,
    mut n: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut c1: libc::c_int = 0;
    let mut c2: libc::c_int = 0;
    let mut d: libc::c_int = 0;
    loop {
        let fresh12 = s1;
        s1 = s1.offset(1);
        c1 = *fresh12 as libc::c_int;
        let fresh13 = s2;
        s2 = s2.offset(1);
        c2 = *fresh13 as libc::c_int;
        let fresh14 = n;
        n = n - 1;
        if 0 == fresh14 {
            return 0i32;
        } else {
            d = c1 - c2;
            if 0 != d {
                if c1 <= 'Z' as i32 && c1 >= 'A' as i32 {
                    d += 'a' as i32 - 'A' as i32;
                    if 0 == d {
                        current_block = 11174649648027449784;
                    } else {
                        current_block = 17778012151635330486;
                    }
                } else {
                    current_block = 17778012151635330486;
                }
                match current_block {
                    11174649648027449784 => {}
                    _ => {
                        if c2 <= 'Z' as i32 && c2 >= 'A' as i32 {
                            d -= 'a' as i32 - 'A' as i32;
                            if 0 == d {
                                current_block = 11174649648027449784;
                            } else {
                                current_block = 6873731126896040597;
                            }
                        } else {
                            current_block = 6873731126896040597;
                        }
                        match current_block {
                            11174649648027449784 => {}
                            _ => return (((d >= 0i32) as libc::c_int) << 1i32) - 1i32,
                        }
                    }
                }
            }
            if !(0 != c1) {
                break;
            }
        }
    }
    return 0i32;
}
#[no_mangle]
pub unsafe fn nk_murmur_hash(
    mut key: *const libc::c_void,
    mut len: libc::c_int,
    mut seed: nk_hash,
) -> nk_hash {
    let mut current_block: u64;
    /* 32-Bit MurmurHash3: https://code.google.com/p/smhasher/wiki/MurmurHash3*/
    let mut conv: unnamed_8 = unnamed_8 {
        i: 0 as *const nk_uint,
    };
    let mut data: *const nk_byte = key as *const nk_byte;
    let nblocks: libc::c_int = len / 4i32;
    let mut h1: nk_uint = seed;
    let c1: nk_uint = 3432918353u32;
    let c2: nk_uint = 461845907i32 as nk_uint;
    let mut tail: *const nk_byte = 0 as *const nk_byte;
    let mut blocks: *const nk_uint = 0 as *const nk_uint;
    let mut k1: nk_uint = 0;
    let mut i: libc::c_int = 0;
    /* body */
    if key.is_null() {
        return 0i32 as nk_hash;
    } else {
        conv.b = data.offset((nblocks * 4i32) as isize);
        blocks = conv.i;
        i = -nblocks;
        while 0 != i {
            k1 = *blocks.offset(i as isize);
            k1 = (k1 as libc::c_uint).wrapping_mul(c1) as nk_uint as nk_uint;
            k1 = k1 << 15i32 | k1 >> 32i32 - 15i32;
            k1 = (k1 as libc::c_uint).wrapping_mul(c2) as nk_uint as nk_uint;
            h1 ^= k1;
            h1 = h1 << 13i32 | h1 >> 32i32 - 13i32;
            h1 = h1
                .wrapping_mul(5i32 as libc::c_uint)
                .wrapping_add(3864292196u32);
            i += 1
        }
        /* tail */
        tail = data.offset((nblocks * 4i32) as isize);
        k1 = 0i32 as nk_uint;
        match len & 3i32 {
            3 => {
                /* fallthrough */
                k1 ^= ((*tail.offset(2isize) as libc::c_int) << 16i32) as nk_uint;
                current_block = 12401332213780770671;
            }
            2 => {
                current_block = 12401332213780770671;
            }
            1 => {
                current_block = 9641644719232025533;
            }
            _ => {
                current_block = 4906268039856690917;
            }
        }
        match current_block {
            12401332213780770671 => {
                /* fallthrough */
                k1 ^= ((*tail.offset(1isize) as libc::c_int) << 8u32) as nk_uint;
                current_block = 9641644719232025533;
            }
            _ => {}
        }
        match current_block {
            9641644719232025533 => {
                k1 ^= *tail.offset(0isize) as libc::c_uint;
                k1 = (k1 as libc::c_uint).wrapping_mul(c1) as nk_uint as nk_uint;
                k1 = k1 << 15i32 | k1 >> 32i32 - 15i32;
                k1 = (k1 as libc::c_uint).wrapping_mul(c2) as nk_uint as nk_uint;
                h1 ^= k1
            }
            _ => {}
        }
        /* finalization */
        h1 ^= len as nk_uint;
        /* fmix32 */
        h1 ^= h1 >> 16i32;
        h1 = (h1 as libc::c_uint).wrapping_mul(2246822507u32) as nk_uint as nk_uint;
        h1 ^= h1 >> 13i32;
        h1 = (h1 as libc::c_uint).wrapping_mul(3266489909u32) as nk_uint as nk_uint;
        h1 ^= h1 >> 16i32;
        return h1;
    };
}
#[no_mangle]
pub unsafe fn nk_end(mut ctx: *mut nk_context) -> () {
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        layout = (*(*ctx).current).layout;
        if layout.is_null()
            || (*layout).type_0 as libc::c_uint == NK_PANEL_WINDOW as libc::c_int as libc::c_uint
                && 0 != (*(*ctx).current).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
        {
            (*ctx).current = 0 as *mut nk_window;
            return;
        } else {
            nk_panel_end(ctx);
            nk_free_panel(ctx, (*(*ctx).current).layout);
            (*ctx).current = 0 as *mut nk_window;
            return;
        }
    };
}
unsafe fn nk_free_panel(mut ctx: *mut nk_context, mut pan: *mut nk_panel) -> () {
    let mut pd: *mut nk_page_data = ((if 0 != 1i32 {
        pan
    } else {
        &mut (*(0 as *mut nk_page_data)).pan as *mut nk_panel
    }) as *mut libc::c_char)
        .offset(-(&mut (*(0 as *mut nk_page_data)).pan as *mut nk_panel as nk_ptr as isize))
        as *mut libc::c_void as *mut nk_page_data;
    let mut pe: *mut nk_page_element = ((if 0 != 1i32 {
        pd
    } else {
        &mut (*(0 as *mut nk_page_element)).data as *mut nk_page_data
    }) as *mut libc::c_char)
        .offset(-(&mut (*(0 as *mut nk_page_element)).data as *mut nk_page_data as nk_ptr as isize))
        as *mut libc::c_void as *mut nk_page_element;
    nk_free_page_element(ctx, pe);
}
unsafe fn nk_panel_end(mut ctx: *mut nk_context) -> () {
    let mut padding_y: f32 = 0.;
    let mut border_color: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut b: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    let mut window: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut out: *mut nk_command_buffer = 0 as *mut nk_command_buffer;
    let mut scrollbar_size: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut panel_padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        window = (*ctx).current;
        layout = (*window).layout;
        style = &mut (*ctx).style as *mut nk_style;
        out = &mut (*window).buffer as *mut nk_command_buffer;
        in_0 = if 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            || 0 != (*layout).flags & NK_WINDOW_NO_INPUT as libc::c_int as libc::c_uint
        {
            0 as *mut nk_input
        } else {
            &mut (*ctx).input as *mut nk_input
        };
        if 0 == nk_panel_is_sub((*layout).type_0) {
            nk_push_scissor(out, nk_null_rect);
        }
        /* cache configuration data */
        scrollbar_size = (*style).window.scrollbar_size;
        panel_padding = nk_panel_get_padding(style, (*layout).type_0);
        /* update the current cursor Y-position to point over the last added widget */
        (*layout).at_y += (*layout).row.height;
        /* dynamic panels */
        if 0 != (*layout).flags & NK_WINDOW_DYNAMIC as libc::c_int as libc::c_uint
            && 0 == (*layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
        {
            /* update panel height to fit dynamic growth */
            let mut empty_space: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            if (*layout).at_y < (*layout).bounds.y + (*layout).bounds.h {
                (*layout).bounds.h = (*layout).at_y - (*layout).bounds.y
            }
            /* fill top empty space */
            empty_space.x = (*window).bounds.x;
            empty_space.y = (*layout).bounds.y;
            empty_space.h = panel_padding.y;
            empty_space.w = (*window).bounds.w;
            nk_fill_rect(
                out,
                empty_space,
                0i32 as f32,
                (*style).window.background,
            );
            /* fill left empty space */
            empty_space.x = (*window).bounds.x;
            empty_space.y = (*layout).bounds.y;
            empty_space.w = panel_padding.x + (*layout).border;
            empty_space.h = (*layout).bounds.h;
            nk_fill_rect(
                out,
                empty_space,
                0i32 as f32,
                (*style).window.background,
            );
            /* fill right empty space */
            empty_space.x = (*layout).bounds.x + (*layout).bounds.w - (*layout).border;
            empty_space.y = (*layout).bounds.y;
            empty_space.w = panel_padding.x + (*layout).border;
            empty_space.h = (*layout).bounds.h;
            if *(*layout).offset_y == 0i32 as libc::c_uint
                && 0 == (*layout).flags & NK_WINDOW_NO_SCROLLBAR as libc::c_int as libc::c_uint
            {
                empty_space.w += scrollbar_size.x
            }
            nk_fill_rect(
                out,
                empty_space,
                0i32 as f32,
                (*style).window.background,
            );
            /* fill bottom empty space */
            if (*layout).footer_height > 0i32 as f32 {
                empty_space.x = (*window).bounds.x;
                empty_space.y = (*layout).bounds.y + (*layout).bounds.h;
                empty_space.w = (*window).bounds.w;
                empty_space.h = (*layout).footer_height;
                nk_fill_rect(
                    out,
                    empty_space,
                    0i32 as f32,
                    (*style).window.background,
                );
            }
        }
        /* scrollbars */
        if 0 == (*layout).flags & NK_WINDOW_NO_SCROLLBAR as libc::c_int as libc::c_uint
            && 0 == (*layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
            && (*window).scrollbar_hiding_timer < 4.0f32
        {
            let mut scroll: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut scroll_has_scrolling: libc::c_int = 0;
            let mut scroll_target: f32 = 0.;
            let mut scroll_offset: f32 = 0.;
            let mut scroll_step: f32 = 0.;
            let mut scroll_inc: f32 = 0.;
            /* mouse wheel scrolling */
            if 0 != nk_panel_is_sub((*layout).type_0) {
                /* sub-window mouse wheel scrolling */
                let mut root_window: *mut nk_window = window;
                let mut root_panel: *mut nk_panel = (*window).layout;
                while !(*root_panel).parent.is_null() {
                    root_panel = (*root_panel).parent
                }
                while !(*root_window).parent.is_null() {
                    root_window = (*root_window).parent
                }
                /* only allow scrolling if parent window is active */
                scroll_has_scrolling = 0i32;
                if root_window == (*ctx).active && 0 != (*layout).has_scrolling {
                    /* and panel is being hovered and inside clip rect*/
                    if 0 != nk_input_is_mouse_hovering_rect(in_0, (*layout).bounds)
                        && !((*root_panel).clip.x > (*layout).bounds.x + (*layout).bounds.w
                            || (*root_panel).clip.x + (*root_panel).clip.w < (*layout).bounds.x
                            || (*root_panel).clip.y > (*layout).bounds.y + (*layout).bounds.h
                            || (*root_panel).clip.y + (*root_panel).clip.h < (*layout).bounds.y)
                    {
                        /* deactivate all parent scrolling */
                        root_panel = (*window).layout;
                        while !(*root_panel).parent.is_null() {
                            (*root_panel).has_scrolling = nk_false as libc::c_int as libc::c_uint;
                            root_panel = (*root_panel).parent
                        }
                        (*root_panel).has_scrolling = nk_false as libc::c_int as libc::c_uint;
                        scroll_has_scrolling = nk_true as libc::c_int
                    }
                }
            } else if 0 == nk_panel_is_sub((*layout).type_0) {
                /* window mouse wheel scrolling */
                scroll_has_scrolling =
                    (window == (*ctx).active && 0 != (*layout).has_scrolling) as libc::c_int;
                if !in_0.is_null()
                    && ((*in_0).mouse.scroll_delta.y > 0i32 as f32
                        || (*in_0).mouse.scroll_delta.x > 0i32 as f32)
                    && 0 != scroll_has_scrolling
                {
                    (*window).scrolled = nk_true as libc::c_int as libc::c_uint
                } else {
                    (*window).scrolled = nk_false as libc::c_int as libc::c_uint
                }
            } else {
                scroll_has_scrolling = nk_false as libc::c_int
            }
            /* vertical scrollbar */
            let mut state: nk_flags = 0i32 as nk_flags;
            scroll.x = (*layout).bounds.x + (*layout).bounds.w + panel_padding.x;
            scroll.y = (*layout).bounds.y;
            scroll.w = scrollbar_size.x;
            scroll.h = (*layout).bounds.h;
            scroll_offset = *(*layout).offset_y as f32;
            scroll_step = scroll.h * 0.10000000149011612f32;
            scroll_inc = scroll.h * 0.009999999776482582f32;
            scroll_target = ((*layout).at_y - scroll.y) as libc::c_int as f32;
            scroll_offset = nk_do_scrollbarv(
                &mut state,
                out,
                scroll,
                scroll_has_scrolling,
                scroll_offset,
                scroll_target,
                scroll_step,
                scroll_inc,
                &mut (*ctx).style.scrollv,
                in_0,
                (*style).font,
            );
            *(*layout).offset_y = scroll_offset as nk_uint;
            if !in_0.is_null() && 0 != scroll_has_scrolling {
                (*in_0).mouse.scroll_delta.y = 0i32 as f32
            }
            /* horizontal scrollbar */
            let mut state_0: nk_flags = 0i32 as nk_flags;
            scroll.x = (*layout).bounds.x;
            scroll.y = (*layout).bounds.y + (*layout).bounds.h;
            scroll.w = (*layout).bounds.w;
            scroll.h = scrollbar_size.y;
            scroll_offset = *(*layout).offset_x as f32;
            scroll_target = ((*layout).max_x - scroll.x) as libc::c_int as f32;
            scroll_step = (*layout).max_x * 0.05000000074505806f32;
            scroll_inc = (*layout).max_x * 0.004999999888241291f32;
            scroll_offset = nk_do_scrollbarh(
                &mut state_0,
                out,
                scroll,
                scroll_has_scrolling,
                scroll_offset,
                scroll_target,
                scroll_step,
                scroll_inc,
                &mut (*ctx).style.scrollh,
                in_0,
                (*style).font,
            );
            *(*layout).offset_x = scroll_offset as nk_uint
        }
        /* hide scroll if no user input */
        if 0 != (*window).flags & NK_WINDOW_SCROLL_AUTO_HIDE as libc::c_int as libc::c_uint {
            let mut has_input: libc::c_int = ((*ctx).input.mouse.delta.x != 0i32 as f32
                || (*ctx).input.mouse.delta.y != 0i32 as f32
                || (*ctx).input.mouse.scroll_delta.y != 0i32 as f32)
                as libc::c_int;
            let mut is_window_hovered: libc::c_int = nk_window_is_hovered(ctx);
            let mut any_item_active: libc::c_int = ((*ctx).last_widget_state
                & NK_WIDGET_STATE_MODIFIED as libc::c_int as libc::c_uint)
                as libc::c_int;
            if 0 == has_input && 0 != is_window_hovered
                || 0 == is_window_hovered && 0 == any_item_active
            {
                (*window).scrollbar_hiding_timer += (*ctx).delta_time_seconds
            } else {
                (*window).scrollbar_hiding_timer = 0i32 as f32
            }
        } else {
            (*window).scrollbar_hiding_timer = 0i32 as f32
        }
        /* window border */
        if 0 != (*layout).flags & NK_WINDOW_BORDER as libc::c_int as libc::c_uint {
            border_color = nk_panel_get_border_color(style, (*layout).type_0);
            padding_y = if 0 != (*layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
            {
                (*style).window.border + (*window).bounds.y + (*layout).header_height
            } else if 0 != (*layout).flags & NK_WINDOW_DYNAMIC as libc::c_int as libc::c_uint {
                (*layout).bounds.y + (*layout).bounds.h + (*layout).footer_height
            } else {
                (*window).bounds.y + (*window).bounds.h
            };
            b = (*window).bounds;
            b.h = padding_y - (*window).bounds.y;
            nk_stroke_rect(
                out,
                b,
                0i32 as f32,
                (*layout).border,
                border_color,
            );
        }
        /* scaler */
        if 0 != (*layout).flags & NK_WINDOW_SCALABLE as libc::c_int as libc::c_uint
            && !in_0.is_null()
            && 0 == (*layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
        {
            /* calculate scaler bounds */
            let mut scaler: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            scaler.w = scrollbar_size.x;
            scaler.h = scrollbar_size.y;
            scaler.y = (*layout).bounds.y + (*layout).bounds.h;
            if 0 != (*layout).flags & NK_WINDOW_SCALE_LEFT as libc::c_int as libc::c_uint {
                scaler.x = (*layout).bounds.x - panel_padding.x * 0.5f32
            } else {
                scaler.x = (*layout).bounds.x + (*layout).bounds.w + panel_padding.x
            }
            if 0 != (*layout).flags & NK_WINDOW_NO_SCROLLBAR as libc::c_int as libc::c_uint {
                scaler.x -= scaler.w
            }
            /* draw scaler */
            let mut item: *const nk_style_item = &(*style).window.scaler as *const nk_style_item;
            if (*item).type_0 as libc::c_uint == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                nk_draw_image(out, scaler, &(*item).data.image, nk_white);
            } else if 0 != (*layout).flags & NK_WINDOW_SCALE_LEFT as libc::c_int as libc::c_uint {
                nk_fill_triangle(
                    out,
                    scaler.x,
                    scaler.y,
                    scaler.x,
                    scaler.y + scaler.h,
                    scaler.x + scaler.w,
                    scaler.y + scaler.h,
                    (*item).data.color,
                );
            } else {
                nk_fill_triangle(
                    out,
                    scaler.x + scaler.w,
                    scaler.y,
                    scaler.x + scaler.w,
                    scaler.y + scaler.h,
                    scaler.x,
                    scaler.y + scaler.h,
                    (*item).data.color,
                );
            }
            /* do window scaling */
            if 0 == (*window).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint {
                let mut window_size: nk_vec2 = (*style).window.min_size;
                let mut left_mouse_down: libc::c_int =
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down;
                let mut left_mouse_click_in_scaler: libc::c_int =
                    nk_input_has_mouse_click_down_in_rect(
                        in_0,
                        NK_BUTTON_LEFT,
                        scaler,
                        nk_true as libc::c_int,
                    );
                if 0 != left_mouse_down && 0 != left_mouse_click_in_scaler {
                    let mut delta_x: f32 = (*in_0).mouse.delta.x;
                    if 0 != (*layout).flags & NK_WINDOW_SCALE_LEFT as libc::c_int as libc::c_uint {
                        delta_x = -delta_x;
                        (*window).bounds.x += (*in_0).mouse.delta.x
                    }
                    /* dragging in x-direction  */
                    if (*window).bounds.w + delta_x >= window_size.x {
                        if delta_x < 0i32 as f32
                            || delta_x > 0i32 as f32 && (*in_0).mouse.pos.x >= scaler.x
                        {
                            (*window).bounds.w = (*window).bounds.w + delta_x;
                            scaler.x += (*in_0).mouse.delta.x
                        }
                    }
                    /* dragging in y-direction (only possible if static window) */
                    if 0 == (*layout).flags & NK_WINDOW_DYNAMIC as libc::c_int as libc::c_uint {
                        if window_size.y < (*window).bounds.h + (*in_0).mouse.delta.y {
                            if (*in_0).mouse.delta.y < 0i32 as f32
                                || (*in_0).mouse.delta.y > 0i32 as f32
                                    && (*in_0).mouse.pos.y >= scaler.y
                            {
                                (*window).bounds.h = (*window).bounds.h + (*in_0).mouse.delta.y;
                                scaler.y += (*in_0).mouse.delta.y
                            }
                        }
                    }
                    (*ctx).style.cursor_active = (*ctx).style.cursors
                        [NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT as libc::c_int as usize];
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize]
                        .clicked_pos
                        .x = scaler.x + scaler.w / 2.0f32;
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize]
                        .clicked_pos
                        .y = scaler.y + scaler.h / 2.0f32
                }
            }
        }
        if 0 == nk_panel_is_sub((*layout).type_0) {
            /* window is hidden so clear command buffer  */
            if 0 != (*layout).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint {
                nk_command_buffer_reset(&mut (*window).buffer);
            } else {
                /* window is visible and not tab */
                nk_finish(ctx, window);
            }
        }
        /* NK_WINDOW_REMOVE_ROM flag was set so remove NK_WINDOW_ROM */
        if 0 != (*layout).flags & NK_WINDOW_REMOVE_ROM as libc::c_int as libc::c_uint {
            (*layout).flags &= !(NK_WINDOW_ROM as libc::c_int as nk_flags);
            (*layout).flags &= !(NK_WINDOW_REMOVE_ROM as libc::c_int as nk_flags)
        }
        (*window).flags = (*layout).flags;
        /* property garbage collector */
        if 0 != (*window).property.active
            && (*window).property.old != (*window).property.seq
            && (*window).property.active == (*window).property.prev
        {
            nk_zero(
                &mut (*window).property as *mut nk_property_state as *mut libc::c_void,
                ::std::mem::size_of::<nk_property_state>() as libc::c_ulong,
            );
        } else {
            (*window).property.old = (*window).property.seq;
            (*window).property.prev = (*window).property.active;
            (*window).property.seq = 0i32 as libc::c_uint
        }
        /* edit garbage collector */
        if 0 != (*window).edit.active
            && (*window).edit.old != (*window).edit.seq
            && (*window).edit.active == (*window).edit.prev
        {
            nk_zero(
                &mut (*window).edit as *mut nk_edit_state as *mut libc::c_void,
                ::std::mem::size_of::<nk_edit_state>() as libc::c_ulong,
            );
        } else {
            (*window).edit.old = (*window).edit.seq;
            (*window).edit.prev = (*window).edit.active;
            (*window).edit.seq = 0i32 as libc::c_uint
        }
        /* contextual garbage collector */
        if 0 != (*window).popup.active_con && (*window).popup.con_old != (*window).popup.con_count {
            (*window).popup.con_count = 0i32 as libc::c_uint;
            (*window).popup.con_old = 0i32 as libc::c_uint;
            (*window).popup.active_con = 0i32 as libc::c_uint
        } else {
            (*window).popup.con_old = (*window).popup.con_count;
            (*window).popup.con_count = 0i32 as libc::c_uint
        }
        (*window).popup.combo_count = 0i32 as libc::c_uint;
        return;
    };
}
unsafe fn nk_finish(mut ctx: *mut nk_context, mut win: *mut nk_window) -> () {
    let mut buf: *mut nk_popup_buffer = 0 as *mut nk_popup_buffer;
    let mut parent_last: *mut nk_command = 0 as *mut nk_command;
    let mut memory: *mut libc::c_void = 0 as *mut libc::c_void;
    if ctx.is_null() || win.is_null() {
        return;
    } else {
        nk_finish_buffer(ctx, &mut (*win).buffer);
        if 0 == (*win).popup.buf.active {
            return;
        } else {
            buf = &mut (*win).popup.buf as *mut nk_popup_buffer;
            memory = (*ctx).memory.memory.ptr;
            parent_last = (memory as *mut nk_byte).offset((*buf).parent as isize)
                as *mut libc::c_void as *mut nk_command;
            (*parent_last).next = (*buf).end;
            return;
        }
    };
}
unsafe fn nk_command_buffer_reset(mut b: *mut nk_command_buffer) -> () {
    if b.is_null() {
        return;
    } else {
        (*b).begin = 0i32 as nk_size;
        (*b).end = 0i32 as nk_size;
        (*b).last = 0i32 as nk_size;
        (*b).clip = nk_null_rect;
        (*b).userdata.ptr = 0 as *mut libc::c_void;
        return;
    };
}
unsafe fn nk_panel_is_sub(mut type_0: nk_panel_type) -> libc::c_int {
    return if 0 != type_0 as libc::c_uint & NK_PANEL_SET_SUB as libc::c_int as libc::c_uint {
        1i32
    } else {
        0i32
    };
}
unsafe fn nk_panel_get_border_color(
    mut style: *const nk_style,
    mut type_0: nk_panel_type,
) -> nk_color {
    match type_0 as libc::c_uint {
        2 => return (*style).window.group_border_color,
        4 => return (*style).window.popup_border_color,
        16 => return (*style).window.contextual_border_color,
        32 => return (*style).window.combo_border_color,
        64 => return (*style).window.menu_border_color,
        128 => return (*style).window.menu_border_color,
        1 | _ => return (*style).window.border_color,
    };
}
#[no_mangle]
pub unsafe fn nk_window_is_hovered(mut ctx: *mut nk_context) -> libc::c_int {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32;
    } else if 0 != (*(*ctx).current).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint {
        return 0i32;
    } else {
        return nk_input_is_mouse_hovering_rect(&mut (*ctx).input, (*(*ctx).current).bounds);
    };
}
unsafe fn nk_do_scrollbarh(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut scroll: nk_rect,
    mut has_scrolling: libc::c_int,
    mut offset: f32,
    mut target: f32,
    mut step: f32,
    mut button_pixel_inc: f32,
    mut style: *const nk_style_scrollbar,
    mut in_0: *mut nk_input,
    mut font: *const nk_user_font,
) -> f32 {
    let mut cursor: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut empty_west: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut empty_east: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut scroll_step: f32 = 0.;
    let mut scroll_offset: f32 = 0.;
    let mut scroll_off: f32 = 0.;
    let mut scroll_ratio: f32 = 0.;
    if out.is_null() || style.is_null() {
        return 0i32 as f32;
    } else {
        /* scrollbar background */
        scroll.h = if scroll.h < 1i32 as f32 {
            1i32 as f32
        } else {
            scroll.h
        };
        scroll.w = if scroll.w < 2i32 as f32 * scroll.h {
            2i32 as f32 * scroll.h
        } else {
            scroll.w
        };
        if target <= scroll.w {
            return 0i32 as f32;
        } else {
            /* optional scrollbar buttons */
            if 0 != (*style).show_buttons {
                let mut ws: nk_flags = 0;
                let mut scroll_w: f32 = 0.;
                let mut button: nk_rect = nk_rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                button.y = scroll.y;
                button.w = scroll.h;
                button.h = scroll.h;
                scroll_w = scroll.w - 2i32 as f32 * button.w;
                scroll_step = if step < button_pixel_inc {
                    step
                } else {
                    button_pixel_inc
                };
                /* decrement button */
                button.x = scroll.x;
                if 0 != nk_do_button_symbol(
                    &mut ws,
                    out,
                    button,
                    (*style).dec_symbol,
                    NK_BUTTON_REPEATER,
                    &(*style).dec_button,
                    in_0,
                    font,
                ) {
                    offset = offset - scroll_step
                }
                /* increment button */
                button.x = scroll.x + scroll.w - button.w;
                if 0 != nk_do_button_symbol(
                    &mut ws,
                    out,
                    button,
                    (*style).inc_symbol,
                    NK_BUTTON_REPEATER,
                    &(*style).inc_button,
                    in_0,
                    font,
                ) {
                    offset = offset + scroll_step
                }
                scroll.x = scroll.x + button.w;
                scroll.w = scroll_w
            }
            /* calculate scrollbar constants */
            scroll_step = if step < scroll.w { step } else { scroll.w };
            scroll_offset = if if offset < target - scroll.w {
                offset
            } else {
                target - scroll.w
            } < 0i32 as f32
            {
                0i32 as f32
            } else if offset < target - scroll.w {
                offset
            } else {
                target - scroll.w
            };
            scroll_ratio = scroll.w / target;
            scroll_off = scroll_offset / target;
            /* calculate cursor bounds */
            cursor.w = scroll_ratio * scroll.w
                - (2i32 as f32 * (*style).border
                    + 2i32 as f32 * (*style).padding.x);
            cursor.x = scroll.x + scroll_off * scroll.w + (*style).border + (*style).padding.x;
            cursor.h = scroll.h
                - (2i32 as f32 * (*style).border
                    + 2i32 as f32 * (*style).padding.y);
            cursor.y = scroll.y + (*style).border + (*style).padding.y;
            /* calculate empty space around cursor */
            empty_west.x = scroll.x;
            empty_west.y = scroll.y;
            empty_west.w = cursor.x - scroll.x;
            empty_west.h = scroll.h;
            empty_east.x = cursor.x + cursor.w;
            empty_east.y = scroll.y;
            empty_east.w = scroll.x + scroll.w - (cursor.x + cursor.w);
            empty_east.h = scroll.h;
            /* update scrollbar */
            scroll_offset = nk_scrollbar_behavior(
                state,
                in_0,
                has_scrolling,
                &mut scroll,
                &mut cursor,
                &mut empty_west,
                &mut empty_east,
                scroll_offset,
                target,
                scroll_step,
                NK_HORIZONTAL,
            );
            scroll_off = scroll_offset / target;
            cursor.x = scroll.x + scroll_off * scroll.w;
            /* draw scrollbar */
            if (*style).draw_begin.is_some() {
                (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
            }
            nk_draw_scrollbar(out, *state, style, &mut scroll, &mut cursor);
            if (*style).draw_end.is_some() {
                (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
            }
            return scroll_offset;
        }
    };
}
unsafe fn nk_draw_scrollbar(
    mut out: *mut nk_command_buffer,
    mut state: nk_flags,
    mut style: *const nk_style_scrollbar,
    mut bounds: *const nk_rect,
    mut scroll: *const nk_rect,
) -> () {
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    let mut cursor: *const nk_style_item = 0 as *const nk_style_item;
    /* select correct colors/images to draw */
    if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        background = &(*style).active as *const nk_style_item;
        cursor = &(*style).cursor_active as *const nk_style_item
    } else if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        background = &(*style).hover as *const nk_style_item;
        cursor = &(*style).cursor_hover as *const nk_style_item
    } else {
        background = &(*style).normal as *const nk_style_item;
        cursor = &(*style).cursor_normal as *const nk_style_item
    }
    /* draw background */
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint {
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        nk_stroke_rect(
            out,
            *bounds,
            (*style).rounding,
            (*style).border,
            (*style).border_color,
        );
    } else {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
    }
    /* draw cursor */
    if (*cursor).type_0 as libc::c_uint == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint {
        nk_fill_rect(out, *scroll, (*style).rounding_cursor, (*cursor).data.color);
        nk_stroke_rect(
            out,
            *scroll,
            (*style).rounding_cursor,
            (*style).border_cursor,
            (*style).cursor_border_color,
        );
    } else {
        nk_draw_image(out, *scroll, &(*cursor).data.image, nk_white);
    };
}
unsafe fn nk_scrollbar_behavior(
    mut state: *mut nk_flags,
    mut in_0: *mut nk_input,
    mut has_scrolling: libc::c_int,
    mut scroll: *const nk_rect,
    mut cursor: *const nk_rect,
    mut empty0: *const nk_rect,
    mut empty1: *const nk_rect,
    mut scroll_offset: f32,
    mut target: f32,
    mut scroll_step: f32,
    mut o: nk_orientation,
) -> f32 {
    let mut cursor_y: f32 = 0.;
    let mut ws: nk_flags = 0i32 as nk_flags;
    let mut left_mouse_down: libc::c_int = 0;
    let mut left_mouse_clicked: libc::c_int = 0;
    let mut left_mouse_click_in_cursor: libc::c_int = 0;
    let mut scroll_delta: f32 = 0.;
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as libc::c_int as libc::c_uint {
        *state = (NK_WIDGET_STATE_INACTIVE as libc::c_int | NK_WIDGET_STATE_MODIFIED as libc::c_int)
            as nk_flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as libc::c_int as nk_flags
    }
    if in_0.is_null() {
        return scroll_offset;
    } else {
        left_mouse_down = (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down;
        left_mouse_clicked =
            (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].clicked as libc::c_int;
        left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(
            in_0,
            NK_BUTTON_LEFT,
            *cursor,
            nk_true as libc::c_int,
        );
        if 0 != nk_input_is_mouse_hovering_rect(in_0, *scroll) {
            *state = NK_WIDGET_STATE_HOVERED as libc::c_int as nk_flags
        }
        scroll_delta = if o as libc::c_uint == NK_VERTICAL as libc::c_int as libc::c_uint {
            (*in_0).mouse.scroll_delta.y
        } else {
            (*in_0).mouse.scroll_delta.x
        };
        if 0 != left_mouse_down && 0 != left_mouse_click_in_cursor && 0 == left_mouse_clicked {
            let mut pixel: f32 = 0.;
            /* update cursor by mouse dragging */
            let mut delta: f32 = 0.;
            *state = NK_WIDGET_STATE_ACTIVE as libc::c_int as nk_flags;
            if o as libc::c_uint == NK_VERTICAL as libc::c_int as libc::c_uint {
                cursor_y = 0.;
                pixel = (*in_0).mouse.delta.y;
                delta = pixel / (*scroll).h * target;
                scroll_offset = if if scroll_offset + delta < target - (*scroll).h {
                    scroll_offset + delta
                } else {
                    target - (*scroll).h
                } < 0i32 as f32
                {
                    0i32 as f32
                } else if scroll_offset + delta < target - (*scroll).h {
                    scroll_offset + delta
                } else {
                    target - (*scroll).h
                };
                cursor_y = (*scroll).y + scroll_offset / target * (*scroll).h;
                (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize]
                    .clicked_pos
                    .y = cursor_y + (*cursor).h / 2.0f32
            } else {
                let mut cursor_x: f32 = 0.;
                pixel = (*in_0).mouse.delta.x;
                delta = pixel / (*scroll).w * target;
                scroll_offset = if if scroll_offset + delta < target - (*scroll).w {
                    scroll_offset + delta
                } else {
                    target - (*scroll).w
                } < 0i32 as f32
                {
                    0i32 as f32
                } else if scroll_offset + delta < target - (*scroll).w {
                    scroll_offset + delta
                } else {
                    target - (*scroll).w
                };
                cursor_x = (*scroll).x + scroll_offset / target * (*scroll).w;
                (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize]
                    .clicked_pos
                    .x = cursor_x + (*cursor).w / 2.0f32
            }
        } else if 0 != nk_input_is_key_pressed(in_0, NK_KEY_SCROLL_UP)
            && o as libc::c_uint == NK_VERTICAL as libc::c_int as libc::c_uint
            && 0 != has_scrolling
            || 0 != nk_button_behavior(&mut ws, *empty0, in_0, NK_BUTTON_DEFAULT)
        {
            /* scroll page up by click on empty space or shortcut */
            if o as libc::c_uint == NK_VERTICAL as libc::c_int as libc::c_uint {
                scroll_offset = if (0i32 as f32) < scroll_offset - (*scroll).h {
                    scroll_offset - (*scroll).h
                } else {
                    0i32 as f32
                }
            } else {
                scroll_offset = if (0i32 as f32) < scroll_offset - (*scroll).w {
                    scroll_offset - (*scroll).w
                } else {
                    0i32 as f32
                }
            }
        } else if 0 != nk_input_is_key_pressed(in_0, NK_KEY_SCROLL_DOWN)
            && o as libc::c_uint == NK_VERTICAL as libc::c_int as libc::c_uint
            && 0 != has_scrolling
            || 0 != nk_button_behavior(&mut ws, *empty1, in_0, NK_BUTTON_DEFAULT)
        {
            /* scroll page down by click on empty space or shortcut */
            if o as libc::c_uint == NK_VERTICAL as libc::c_int as libc::c_uint {
                scroll_offset = if scroll_offset + (*scroll).h < target - (*scroll).h {
                    scroll_offset + (*scroll).h
                } else {
                    target - (*scroll).h
                }
            } else {
                scroll_offset = if scroll_offset + (*scroll).w < target - (*scroll).w {
                    scroll_offset + (*scroll).w
                } else {
                    target - (*scroll).w
                }
            }
        } else if 0 != has_scrolling {
            if scroll_delta < 0i32 as f32 || scroll_delta > 0i32 as f32 {
                /* update cursor by mouse scrolling */
                scroll_offset = scroll_offset + scroll_step * -scroll_delta;
                if o as libc::c_uint == NK_VERTICAL as libc::c_int as libc::c_uint {
                    scroll_offset = if if scroll_offset < target - (*scroll).h {
                        scroll_offset
                    } else {
                        target - (*scroll).h
                    } < 0i32 as f32
                    {
                        0i32 as f32
                    } else if scroll_offset < target - (*scroll).h {
                        scroll_offset
                    } else {
                        target - (*scroll).h
                    }
                } else {
                    scroll_offset = if if scroll_offset < target - (*scroll).w {
                        scroll_offset
                    } else {
                        target - (*scroll).w
                    } < 0i32 as f32
                    {
                        0i32 as f32
                    } else if scroll_offset < target - (*scroll).w {
                        scroll_offset
                    } else {
                        target - (*scroll).w
                    }
                }
            } else if 0 != nk_input_is_key_pressed(in_0, NK_KEY_SCROLL_START) {
                /* update cursor to the beginning  */
                if o as libc::c_uint == NK_VERTICAL as libc::c_int as libc::c_uint {
                    scroll_offset = 0i32 as f32
                }
            } else if 0 != nk_input_is_key_pressed(in_0, NK_KEY_SCROLL_END) {
                /* update cursor to the end */
                if o as libc::c_uint == NK_VERTICAL as libc::c_int as libc::c_uint {
                    scroll_offset = target - (*scroll).h
                }
            }
        }
        if 0 != *state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, *scroll)
        {
            *state |= NK_WIDGET_STATE_ENTERED as libc::c_int as libc::c_uint
        } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, *scroll) {
            *state |= NK_WIDGET_STATE_LEFT as libc::c_int as libc::c_uint
        }
        return scroll_offset;
    };
}
#[no_mangle]
pub unsafe fn nk_input_is_key_pressed(mut i: *const nk_input, mut key: nk_keys) -> libc::c_int {
    let mut k: *const nk_key = 0 as *const nk_key;
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        k = &(*i).keyboard.keys[key as usize] as *const nk_key;
        if 0 != (*k).down && 0 != (*k).clicked
            || 0 == (*k).down && (*k).clicked >= 2i32 as libc::c_uint
        {
            return nk_true as libc::c_int;
        } else {
            return nk_false as libc::c_int;
        }
    };
}
unsafe fn nk_do_scrollbarv(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut scroll: nk_rect,
    mut has_scrolling: libc::c_int,
    mut offset: f32,
    mut target: f32,
    mut step: f32,
    mut button_pixel_inc: f32,
    mut style: *const nk_style_scrollbar,
    mut in_0: *mut nk_input,
    mut font: *const nk_user_font,
) -> f32 {
    let mut empty_north: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut empty_south: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut cursor: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut scroll_step: f32 = 0.;
    let mut scroll_offset: f32 = 0.;
    let mut scroll_off: f32 = 0.;
    let mut scroll_ratio: f32 = 0.;
    if out.is_null() || style.is_null() {
        return 0i32 as f32;
    } else {
        scroll.w = if scroll.w < 1i32 as f32 {
            1i32 as f32
        } else {
            scroll.w
        };
        scroll.h = if scroll.h < 0i32 as f32 {
            0i32 as f32
        } else {
            scroll.h
        };
        if target <= scroll.h {
            return 0i32 as f32;
        } else {
            /* optional scrollbar buttons */
            if 0 != (*style).show_buttons {
                let mut ws: nk_flags = 0;
                let mut scroll_h: f32 = 0.;
                let mut button: nk_rect = nk_rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                button.x = scroll.x;
                button.w = scroll.w;
                button.h = scroll.w;
                scroll_h = if scroll.h - 2i32 as f32 * button.h < 0i32 as f32 {
                    0i32 as f32
                } else {
                    scroll.h - 2i32 as f32 * button.h
                };
                scroll_step = if step < button_pixel_inc {
                    step
                } else {
                    button_pixel_inc
                };
                /* decrement button */
                button.y = scroll.y;
                if 0 != nk_do_button_symbol(
                    &mut ws,
                    out,
                    button,
                    (*style).dec_symbol,
                    NK_BUTTON_REPEATER,
                    &(*style).dec_button,
                    in_0,
                    font,
                ) {
                    offset = offset - scroll_step
                }
                /* increment button */
                button.y = scroll.y + scroll.h - button.h;
                if 0 != nk_do_button_symbol(
                    &mut ws,
                    out,
                    button,
                    (*style).inc_symbol,
                    NK_BUTTON_REPEATER,
                    &(*style).inc_button,
                    in_0,
                    font,
                ) {
                    offset = offset + scroll_step
                }
                scroll.y = scroll.y + button.h;
                scroll.h = scroll_h
            }
            /* calculate scrollbar constants */
            scroll_step = if step < scroll.h { step } else { scroll.h };
            scroll_offset = if if offset < target - scroll.h {
                offset
            } else {
                target - scroll.h
            } < 0i32 as f32
            {
                0i32 as f32
            } else if offset < target - scroll.h {
                offset
            } else {
                target - scroll.h
            };
            scroll_ratio = scroll.h / target;
            scroll_off = scroll_offset / target;
            /* calculate scrollbar cursor bounds */
            cursor.h = if scroll_ratio * scroll.h
                - (2i32 as f32 * (*style).border
                    + 2i32 as f32 * (*style).padding.y)
                < 0i32 as f32
            {
                0i32 as f32
            } else {
                scroll_ratio * scroll.h
                    - (2i32 as f32 * (*style).border
                        + 2i32 as f32 * (*style).padding.y)
            };
            cursor.y = scroll.y + scroll_off * scroll.h + (*style).border + (*style).padding.y;
            cursor.w = scroll.w
                - (2i32 as f32 * (*style).border
                    + 2i32 as f32 * (*style).padding.x);
            cursor.x = scroll.x + (*style).border + (*style).padding.x;
            /* calculate empty space around cursor */
            empty_north.x = scroll.x;
            empty_north.y = scroll.y;
            empty_north.w = scroll.w;
            empty_north.h = if cursor.y - scroll.y < 0i32 as f32 {
                0i32 as f32
            } else {
                cursor.y - scroll.y
            };
            empty_south.x = scroll.x;
            empty_south.y = cursor.y + cursor.h;
            empty_south.w = scroll.w;
            empty_south.h = if scroll.y + scroll.h - (cursor.y + cursor.h) < 0i32 as f32 {
                0i32 as f32
            } else {
                scroll.y + scroll.h - (cursor.y + cursor.h)
            };
            /* update scrollbar */
            scroll_offset = nk_scrollbar_behavior(
                state,
                in_0,
                has_scrolling,
                &mut scroll,
                &mut cursor,
                &mut empty_north,
                &mut empty_south,
                scroll_offset,
                target,
                scroll_step,
                NK_VERTICAL,
            );
            scroll_off = scroll_offset / target;
            cursor.y =
                scroll.y + scroll_off * scroll.h + (*style).border_cursor + (*style).padding.y;
            /* draw scrollbar */
            if (*style).draw_begin.is_some() {
                (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
            }
            nk_draw_scrollbar(out, *state, style, &mut scroll, &mut cursor);
            if (*style).draw_end.is_some() {
                (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
            }
            return scroll_offset;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_window_find(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
) -> *mut nk_window {
    let mut title_len: libc::c_int = 0;
    let mut title_hash: nk_hash = 0;
    title_len = nk_strlen(name);
    title_hash = nk_murmur_hash(
        name as *const libc::c_void,
        title_len,
        NK_WINDOW_TITLE as libc::c_int as nk_hash,
    );
    return nk_find_window(ctx, title_hash, name);
}
#[no_mangle]
pub unsafe fn nk_window_get_bounds(mut ctx: *const nk_context) -> nk_rect {
    if ctx.is_null() || (*ctx).current.is_null() {
        return nk_rect(
            0i32 as f32,
            0i32 as f32,
            0i32 as f32,
            0i32 as f32,
        );
    } else {
        return (*(*ctx).current).bounds;
    };
}
#[no_mangle]
pub unsafe fn nk_window_get_position(mut ctx: *const nk_context) -> nk_vec2 {
    if ctx.is_null() || (*ctx).current.is_null() {
        return nk_vec2(0i32 as f32, 0i32 as f32);
    } else {
        return nk_vec2((*(*ctx).current).bounds.x, (*(*ctx).current).bounds.y);
    };
}
#[no_mangle]
pub unsafe fn nk_window_get_size(mut ctx: *const nk_context) -> nk_vec2 {
    if ctx.is_null() || (*ctx).current.is_null() {
        return nk_vec2(0i32 as f32, 0i32 as f32);
    } else {
        return nk_vec2((*(*ctx).current).bounds.w, (*(*ctx).current).bounds.h);
    };
}
#[no_mangle]
pub unsafe fn nk_window_get_width(mut ctx: *const nk_context) -> f32 {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32 as f32;
    } else {
        return (*(*ctx).current).bounds.w;
    };
}
#[no_mangle]
pub unsafe fn nk_window_get_height(mut ctx: *const nk_context) -> f32 {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32 as f32;
    } else {
        return (*(*ctx).current).bounds.h;
    };
}
#[no_mangle]
pub unsafe fn nk_window_get_panel(mut ctx: *mut nk_context) -> *mut nk_panel {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0 as *mut nk_panel;
    } else {
        return (*(*ctx).current).layout;
    };
}
#[no_mangle]
pub unsafe fn nk_window_get_content_region(mut ctx: *mut nk_context) -> nk_rect {
    if ctx.is_null() || (*ctx).current.is_null() {
        return nk_rect(
            0i32 as f32,
            0i32 as f32,
            0i32 as f32,
            0i32 as f32,
        );
    } else {
        return (*(*(*ctx).current).layout).clip;
    };
}
#[no_mangle]
pub unsafe fn nk_window_get_content_region_min(mut ctx: *mut nk_context) -> nk_vec2 {
    if ctx.is_null() || (*ctx).current.is_null() {
        return nk_vec2(0i32 as f32, 0i32 as f32);
    } else {
        return nk_vec2(
            (*(*(*ctx).current).layout).clip.x,
            (*(*(*ctx).current).layout).clip.y,
        );
    };
}
#[no_mangle]
pub unsafe fn nk_window_get_content_region_max(mut ctx: *mut nk_context) -> nk_vec2 {
    if ctx.is_null() || (*ctx).current.is_null() {
        return nk_vec2(0i32 as f32, 0i32 as f32);
    } else {
        return nk_vec2(
            (*(*(*ctx).current).layout).clip.x + (*(*(*ctx).current).layout).clip.w,
            (*(*(*ctx).current).layout).clip.y + (*(*(*ctx).current).layout).clip.h,
        );
    };
}
#[no_mangle]
pub unsafe fn nk_window_get_content_region_size(mut ctx: *mut nk_context) -> nk_vec2 {
    if ctx.is_null() || (*ctx).current.is_null() {
        return nk_vec2(0i32 as f32, 0i32 as f32);
    } else {
        return nk_vec2(
            (*(*(*ctx).current).layout).clip.w,
            (*(*(*ctx).current).layout).clip.h,
        );
    };
}
#[no_mangle]
pub unsafe fn nk_window_get_canvas(mut ctx: *mut nk_context) -> *mut nk_command_buffer {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0 as *mut nk_command_buffer;
    } else {
        return &mut (*(*ctx).current).buffer as *mut nk_command_buffer;
    };
}
#[no_mangle]
pub unsafe fn nk_window_has_focus(mut ctx: *const nk_context) -> libc::c_int {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32;
    } else {
        return ((*ctx).current == (*ctx).active) as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_window_is_collapsed(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
) -> libc::c_int {
    let mut title_len: libc::c_int = 0;
    let mut title_hash: nk_hash = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return 0i32;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const libc::c_void,
            title_len,
            NK_WINDOW_TITLE as libc::c_int as nk_hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return 0i32;
        } else {
            return ((*win).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint)
                as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_window_is_closed(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
) -> libc::c_int {
    let mut title_len: libc::c_int = 0;
    let mut title_hash: nk_hash = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return 1i32;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const libc::c_void,
            title_len,
            NK_WINDOW_TITLE as libc::c_int as nk_hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return 1i32;
        } else {
            return ((*win).flags & NK_WINDOW_CLOSED as libc::c_int as libc::c_uint) as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_window_is_hidden(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
) -> libc::c_int {
    let mut title_len: libc::c_int = 0;
    let mut title_hash: nk_hash = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return 1i32;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const libc::c_void,
            title_len,
            NK_WINDOW_TITLE as libc::c_int as nk_hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return 1i32;
        } else {
            return ((*win).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint) as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_window_is_active(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
) -> libc::c_int {
    let mut title_len: libc::c_int = 0;
    let mut title_hash: nk_hash = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return 0i32;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const libc::c_void,
            title_len,
            NK_WINDOW_TITLE as libc::c_int as nk_hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return 0i32;
        } else {
            return (win == (*ctx).active) as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_window_is_any_hovered(mut ctx: *mut nk_context) -> libc::c_int {
    let mut iter: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return 0i32;
    } else {
        iter = (*ctx).begin;
        while !iter.is_null() {
            /* check if window is being hovered */
            if 0 == (*iter).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint {
                /* check if window popup is being hovered */
                if 0 != (*iter).popup.active && !(*iter).popup.win.is_null()
                    && 0 != nk_input_is_mouse_hovering_rect(
                        &mut (*ctx).input,
                        (*(*iter).popup.win).bounds,
                    ) {
                    return 1i32;
                } else if 0 != (*iter).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint {
                    let mut header: nk_rect = (*iter).bounds;
                    header.h = (*(*ctx).style.font).height
                        + 2i32 as f32 * (*ctx).style.window.header.padding.y;
                    if 0 != nk_input_is_mouse_hovering_rect(&mut (*ctx).input, header) {
                        return 1i32;
                    }
                } else if 0 != nk_input_is_mouse_hovering_rect(&mut (*ctx).input, (*iter).bounds) {
                    return 1i32;
                }
            }
            iter = (*iter).next
        }
        return 0i32;
    };
}
#[no_mangle]
pub unsafe fn nk_item_is_any_active(mut ctx: *mut nk_context) -> libc::c_int {
    let mut any_hovered: libc::c_int = nk_window_is_any_hovered(ctx);
    let mut any_active: libc::c_int = ((*ctx).last_widget_state
        & NK_WIDGET_STATE_MODIFIED as libc::c_int as libc::c_uint)
        as libc::c_int;
    return (0 != any_hovered || 0 != any_active) as libc::c_int;
}
#[no_mangle]
pub unsafe fn nk_window_set_bounds(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut bounds: nk_rect,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return;
    } else {
        win = nk_window_find(ctx, name);
        if win.is_null() {
            return;
        } else {
            (*win).bounds = bounds;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_window_set_position(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut pos: nk_vec2,
) -> () {
    let mut win: *mut nk_window = nk_window_find(ctx, name);
    if win.is_null() {
        return;
    } else {
        (*win).bounds.x = pos.x;
        (*win).bounds.y = pos.y;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_window_set_size(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut size: nk_vec2,
) -> () {
    let mut win: *mut nk_window = nk_window_find(ctx, name);
    if win.is_null() {
        return;
    } else {
        (*win).bounds.w = size.x;
        (*win).bounds.h = size.y;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_window_set_focus(mut ctx: *mut nk_context, mut name: *const libc::c_char) -> () {
    let mut title_len: libc::c_int = 0;
    let mut title_hash: nk_hash = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const libc::c_void,
            title_len,
            NK_WINDOW_TITLE as libc::c_int as nk_hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if !win.is_null() && (*ctx).end != win {
            nk_remove_window(ctx, win);
            nk_insert_window(ctx, win, NK_INSERT_BACK);
        }
        (*ctx).active = win;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_window_close(mut ctx: *mut nk_context, mut name: *const libc::c_char) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return;
    } else {
        win = nk_window_find(ctx, name);
        if win.is_null() {
            return;
        } else if (*ctx).current == win {
            return;
        } else {
            (*win).flags |= NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint;
            (*win).flags |= NK_WINDOW_CLOSED as libc::c_int as libc::c_uint;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_window_collapse(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut c: nk_collapse_states,
) -> () {
    let mut title_len: libc::c_int = 0;
    let mut title_hash: nk_hash = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const libc::c_void,
            title_len,
            NK_WINDOW_TITLE as libc::c_int as nk_hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return;
        } else {
            if c as libc::c_uint == NK_MINIMIZED as libc::c_int as libc::c_uint {
                (*win).flags |= NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
            } else {
                (*win).flags &= !(NK_WINDOW_MINIMIZED as libc::c_int as nk_flags)
            }
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_window_collapse_if(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut c: nk_collapse_states,
    mut cond: libc::c_int,
) -> () {
    if ctx.is_null() || 0 == cond {
        return;
    } else {
        nk_window_collapse(ctx, name, c);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_window_show(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut s: nk_show_states,
) -> () {
    let mut title_len: libc::c_int = 0;
    let mut title_hash: nk_hash = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() {
        return;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const libc::c_void,
            title_len,
            NK_WINDOW_TITLE as libc::c_int as nk_hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return;
        } else {
            if s as libc::c_uint == NK_HIDDEN as libc::c_int as libc::c_uint {
                (*win).flags |= NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
            } else {
                (*win).flags &= !(NK_WINDOW_HIDDEN as libc::c_int as nk_flags)
            }
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_window_show_if(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut s: nk_show_states,
    mut cond: libc::c_int,
) -> () {
    if ctx.is_null() || 0 == cond {
        return;
    } else {
        nk_window_show(ctx, name, s);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_layout_set_min_row_height(
    mut ctx: *mut nk_context,
    mut height: f32,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).row.min_height = height;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_layout_widget_bounds(mut ctx: *mut nk_context) -> nk_rect {
    let mut ret: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x = (*layout).at_x;
    ret.y = (*layout).at_y;
    ret.w = (*layout).bounds.w - if (*layout).at_x - (*layout).bounds.x < 0i32 as f32 {
        0i32 as f32
    } else {
        (*layout).at_x - (*layout).bounds.x
    };
    ret.h = (*layout).row.height;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_layout_ratio_from_pixel(
    mut ctx: *mut nk_context,
    mut pixel_width: f32,
) -> f32 {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32 as f32;
    } else {
        win = (*ctx).current;
        return if if pixel_width / (*win).bounds.x < 1.0f32 {
            pixel_width / (*win).bounds.x
        } else {
            1.0f32
        } < 0.0f32
        {
            0.0f32
        } else if pixel_width / (*win).bounds.x < 1.0f32 {
            pixel_width / (*win).bounds.x
        } else {
            1.0f32
        };
    };
}
#[no_mangle]
pub unsafe fn nk_layout_row_dynamic(
    mut ctx: *mut nk_context,
    mut height: f32,
    mut cols: libc::c_int,
) -> () {
    nk_row_layout(ctx, NK_DYNAMIC, height, cols, 0i32);
}
unsafe fn nk_row_layout(
    mut ctx: *mut nk_context,
    mut fmt: nk_layout_format,
    mut height: f32,
    mut cols: libc::c_int,
    mut width: libc::c_int,
) -> () {
    /* update the current row and set the current row layout */
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        nk_panel_layout(ctx, win, height, cols);
        if fmt as libc::c_uint == NK_DYNAMIC as libc::c_int as libc::c_uint {
            (*(*win).layout).row.type_0 = NK_LAYOUT_DYNAMIC_FIXED
        } else {
            (*(*win).layout).row.type_0 = NK_LAYOUT_STATIC_FIXED
        }
        (*(*win).layout).row.ratio = 0 as *const f32;
        (*(*win).layout).row.filled = 0i32 as f32;
        (*(*win).layout).row.item_offset = 0i32 as f32;
        (*(*win).layout).row.item_width = width as f32;
        return;
    };
}
unsafe fn nk_panel_layout(
    mut ctx: *const nk_context,
    mut win: *mut nk_window,
    mut height: f32,
    mut cols: libc::c_int,
) -> () {
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut out: *mut nk_command_buffer = 0 as *mut nk_command_buffer;
    let mut item_spacing: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut color: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        /* prefetch some configuration data */
        layout = (*win).layout;
        style = &(*ctx).style as *const nk_style;
        out = &mut (*win).buffer as *mut nk_command_buffer;
        color = (*style).window.background;
        item_spacing = (*style).window.spacing;
        /*  if one of these triggers you forgot to add an `if` condition around either
        a window, group, popup, combobox or contextual menu `begin` and `end` block.
        Example:
            if (nk_begin(...) {...} nk_end(...); or
            if (nk_group_begin(...) { nk_group_end(...);} */
        /* update the current row and set the current row layout */
        (*layout).row.index = 0i32;
        (*layout).at_y += (*layout).row.height;
        (*layout).row.columns = cols;
        if height == 0.0f32 {
            (*layout).row.height = if height < (*layout).row.min_height {
                (*layout).row.min_height
            } else {
                height
            } + item_spacing.y
        } else {
            (*layout).row.height = height + item_spacing.y
        }
        (*layout).row.item_offset = 0i32 as f32;
        if 0 != (*layout).flags & NK_WINDOW_DYNAMIC as libc::c_int as libc::c_uint {
            /* draw background for dynamic panels */
            let mut background: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            background.x = (*win).bounds.x;
            background.w = (*win).bounds.w;
            background.y = (*layout).at_y - 1.0f32;
            background.h = (*layout).row.height + 1.0f32;
            nk_fill_rect(out, background, 0i32 as f32, color);
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_layout_row_static(
    mut ctx: *mut nk_context,
    mut height: f32,
    mut item_width: libc::c_int,
    mut cols: libc::c_int,
) -> () {
    nk_row_layout(ctx, NK_STATIC, height, cols, item_width);
}
#[no_mangle]
pub unsafe fn nk_layout_row_begin(
    mut ctx: *mut nk_context,
    mut fmt: nk_layout_format,
    mut row_height: f32,
    mut cols: libc::c_int,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        nk_panel_layout(ctx, win, row_height, cols);
        if fmt as libc::c_uint == NK_DYNAMIC as libc::c_int as libc::c_uint {
            (*layout).row.type_0 = NK_LAYOUT_DYNAMIC_ROW
        } else {
            (*layout).row.type_0 = NK_LAYOUT_STATIC_ROW
        }
        (*layout).row.ratio = 0 as *const f32;
        (*layout).row.filled = 0i32 as f32;
        (*layout).row.item_width = 0i32 as f32;
        (*layout).row.item_offset = 0i32 as f32;
        (*layout).row.columns = cols;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_layout_row_push(
    mut ctx: *mut nk_context,
    mut ratio_or_width: f32,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as libc::c_uint
            != NK_LAYOUT_STATIC_ROW as libc::c_int as libc::c_uint
            && (*layout).row.type_0 as libc::c_uint
                != NK_LAYOUT_DYNAMIC_ROW as libc::c_int as libc::c_uint
        {
            return;
        } else {
            if (*layout).row.type_0 as libc::c_uint
                == NK_LAYOUT_DYNAMIC_ROW as libc::c_int as libc::c_uint
            {
                let mut ratio: f32 = ratio_or_width;
                if ratio + (*layout).row.filled > 1.0f32 {
                    return;
                } else if ratio > 0.0f32 {
                    (*layout).row.item_width =
                        if (0i32 as f32) < if 1.0f32 < ratio { 1.0f32 } else { ratio } {
                            if 1.0f32 < ratio {
                                1.0f32
                            } else {
                                ratio
                            }
                        } else {
                            0i32 as f32
                        }
                } else {
                    (*layout).row.item_width = 1.0f32 - (*layout).row.filled
                }
            } else {
                (*layout).row.item_width = ratio_or_width
            }
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_layout_row_end(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as libc::c_uint
            != NK_LAYOUT_STATIC_ROW as libc::c_int as libc::c_uint
            && (*layout).row.type_0 as libc::c_uint
                != NK_LAYOUT_DYNAMIC_ROW as libc::c_int as libc::c_uint
        {
            return;
        } else {
            (*layout).row.item_width = 0i32 as f32;
            (*layout).row.item_offset = 0i32 as f32;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_layout_row(
    mut ctx: *mut nk_context,
    mut fmt: nk_layout_format,
    mut height: f32,
    mut cols: libc::c_int,
    mut ratio: *const f32,
) -> () {
    let mut i: libc::c_int = 0;
    let mut n_undef: libc::c_int = 0i32;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        nk_panel_layout(ctx, win, height, cols);
        if fmt as libc::c_uint == NK_DYNAMIC as libc::c_int as libc::c_uint {
            /* calculate width of undefined widget ratios */
            let mut r: f32 = 0i32 as f32;
            (*layout).row.ratio = ratio;
            i = 0i32;
            while i < cols {
                if *ratio.offset(i as isize) < 0.0f32 {
                    n_undef += 1
                } else {
                    r += *ratio.offset(i as isize)
                }
                i += 1
            }
            r = if (0i32 as f32) < if 1.0f32 < 1.0f32 - r {
                1.0f32
            } else {
                1.0f32 - r
            } {
                if 1.0f32 < 1.0f32 - r {
                    1.0f32
                } else {
                    1.0f32 - r
                }
            } else {
                0i32 as f32
            };
            (*layout).row.type_0 = NK_LAYOUT_DYNAMIC;
            (*layout).row.item_width = if r > 0i32 as f32 && n_undef > 0i32 {
                r / n_undef as f32
            } else {
                0i32 as f32
            }
        } else {
            (*layout).row.ratio = ratio;
            (*layout).row.type_0 = NK_LAYOUT_STATIC;
            (*layout).row.item_width = 0i32 as f32;
            (*layout).row.item_offset = 0i32 as f32
        }
        (*layout).row.item_offset = 0i32 as f32;
        (*layout).row.filled = 0i32 as f32;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_layout_row_template_begin(
    mut ctx: *mut nk_context,
    mut height: f32,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        nk_panel_layout(ctx, win, height, 1i32);
        (*layout).row.type_0 = NK_LAYOUT_TEMPLATE;
        (*layout).row.columns = 0i32;
        (*layout).row.ratio = 0 as *const f32;
        (*layout).row.item_width = 0i32 as f32;
        (*layout).row.item_height = 0i32 as f32;
        (*layout).row.item_offset = 0i32 as f32;
        (*layout).row.filled = 0i32 as f32;
        (*layout).row.item.x = 0i32 as f32;
        (*layout).row.item.y = 0i32 as f32;
        (*layout).row.item.w = 0i32 as f32;
        (*layout).row.item.h = 0i32 as f32;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_layout_row_template_push_dynamic(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as libc::c_uint != NK_LAYOUT_TEMPLATE as libc::c_int as libc::c_uint
        {
            return;
        } else if (*layout).row.columns >= 16i32 {
            return;
        } else {
            let fresh15 = (*layout).row.columns;
            (*layout).row.columns = (*layout).row.columns + 1;
            (*layout).row.templates[fresh15 as usize] = -1.0f32;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_layout_row_template_push_variable(
    mut ctx: *mut nk_context,
    mut min_width: f32,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as libc::c_uint != NK_LAYOUT_TEMPLATE as libc::c_int as libc::c_uint
        {
            return;
        } else if (*layout).row.columns >= 16i32 {
            return;
        } else {
            let fresh16 = (*layout).row.columns;
            (*layout).row.columns = (*layout).row.columns + 1;
            (*layout).row.templates[fresh16 as usize] = -min_width;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_layout_row_template_push_static(
    mut ctx: *mut nk_context,
    mut width: f32,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as libc::c_uint != NK_LAYOUT_TEMPLATE as libc::c_int as libc::c_uint
        {
            return;
        } else if (*layout).row.columns >= 16i32 {
            return;
        } else {
            let fresh17 = (*layout).row.columns;
            (*layout).row.columns = (*layout).row.columns + 1;
            (*layout).row.templates[fresh17 as usize] = width;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_layout_row_template_end(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut i: libc::c_int = 0i32;
    let mut variable_count: libc::c_int = 0i32;
    let mut min_variable_count: libc::c_int = 0i32;
    let mut min_fixed_width: f32 = 0.0f32;
    let mut total_fixed_width: f32 = 0.0f32;
    let mut max_variable_width: f32 = 0.0f32;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as libc::c_uint != NK_LAYOUT_TEMPLATE as libc::c_int as libc::c_uint
        {
            return;
        } else {
            i = 0i32;
            while i < (*layout).row.columns {
                let mut width: f32 = (*layout).row.templates[i as usize];
                if width >= 0.0f32 {
                    total_fixed_width += width;
                    min_fixed_width += width
                } else if width < -1.0f32 {
                    width = -width;
                    total_fixed_width += width;
                    max_variable_width = if max_variable_width < width {
                        width
                    } else {
                        max_variable_width
                    };
                    variable_count += 1
                } else {
                    min_variable_count += 1;
                    variable_count += 1
                }
                i += 1
            }
            if 0 != variable_count {
                let mut space: f32 = nk_layout_row_calculate_usable_space(
                    &mut (*ctx).style,
                    (*layout).type_0,
                    (*layout).bounds.w,
                    (*layout).row.columns,
                );
                let mut var_width: f32 = if space - min_fixed_width < 0.0f32 {
                    0.0f32
                } else {
                    space - min_fixed_width
                }
                    / variable_count as f32;
                let mut enough_space: libc::c_int =
                    (var_width >= max_variable_width) as libc::c_int;
                if 0 == enough_space {
                    var_width = if space - total_fixed_width < 0i32 as f32 {
                        0i32 as f32
                    } else {
                        space - total_fixed_width
                    } / min_variable_count as f32
                }
                i = 0i32;
                while i < (*layout).row.columns {
                    let mut width_0: *mut f32 =
                        &mut (*layout).row.templates[i as usize] as *mut f32;
                    *width_0 = if *width_0 >= 0.0f32 {
                        *width_0
                    } else if *width_0 < -1.0f32 && 0 == enough_space {
                        -*width_0
                    } else {
                        var_width
                    };
                    i += 1
                }
            }
            return;
        }
    };
}
unsafe fn nk_layout_row_calculate_usable_space(
    mut style: *const nk_style,
    mut type_0: nk_panel_type,
    mut total_space: f32,
    mut columns: libc::c_int,
) -> f32 {
    let mut panel_padding: f32 = 0.;
    let mut panel_spacing: f32 = 0.;
    let mut panel_space: f32 = 0.;
    let mut spacing: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    spacing = (*style).window.spacing;
    padding = nk_panel_get_padding(style, type_0);
    /* calculate the usable panel space */
    panel_padding = 2i32 as f32 * padding.x;
    panel_spacing = (if columns - 1i32 < 0i32 {
        0i32
    } else {
        columns - 1i32
    }) as f32 * spacing.x;
    panel_space = total_space - panel_padding - panel_spacing;
    return panel_space;
}
#[no_mangle]
pub unsafe fn nk_layout_space_begin(
    mut ctx: *mut nk_context,
    mut fmt: nk_layout_format,
    mut height: f32,
    mut widget_count: libc::c_int,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        nk_panel_layout(ctx, win, height, widget_count);
        if fmt as libc::c_uint == NK_STATIC as libc::c_int as libc::c_uint {
            (*layout).row.type_0 = NK_LAYOUT_STATIC_FREE
        } else {
            (*layout).row.type_0 = NK_LAYOUT_DYNAMIC_FREE
        }
        (*layout).row.ratio = 0 as *const f32;
        (*layout).row.filled = 0i32 as f32;
        (*layout).row.item_width = 0i32 as f32;
        (*layout).row.item_offset = 0i32 as f32;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_layout_space_push(mut ctx: *mut nk_context, mut rect: nk_rect) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).row.item = rect;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_layout_space_end(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).row.item_width = 0i32 as f32;
        (*layout).row.item_height = 0i32 as f32;
        (*layout).row.item_offset = 0i32 as f32;
        nk_zero(
            &mut (*layout).row.item as *mut nk_rect as *mut libc::c_void,
            ::std::mem::size_of::<nk_rect>() as libc::c_ulong,
        );
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_layout_space_bounds(mut ctx: *mut nk_context) -> nk_rect {
    let mut ret: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x = (*layout).clip.x;
    ret.y = (*layout).clip.y;
    ret.w = (*layout).clip.w;
    ret.h = (*layout).row.height;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_layout_space_to_screen(mut ctx: *mut nk_context, mut ret: nk_vec2) -> nk_vec2 {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x += (*layout).at_x - *(*layout).offset_x as f32;
    ret.y += (*layout).at_y - *(*layout).offset_y as f32;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_layout_space_to_local(mut ctx: *mut nk_context, mut ret: nk_vec2) -> nk_vec2 {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x += -(*layout).at_x + *(*layout).offset_x as f32;
    ret.y += -(*layout).at_y + *(*layout).offset_y as f32;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_layout_space_rect_to_screen(
    mut ctx: *mut nk_context,
    mut ret: nk_rect,
) -> nk_rect {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x += (*layout).at_x - *(*layout).offset_x as f32;
    ret.y += (*layout).at_y - *(*layout).offset_y as f32;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_layout_space_rect_to_local(mut ctx: *mut nk_context, mut ret: nk_rect) -> nk_rect {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x += -(*layout).at_x + *(*layout).offset_x as f32;
    ret.y += -(*layout).at_y + *(*layout).offset_y as f32;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_group_begin(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
    mut flags: nk_flags,
) -> libc::c_int {
    return nk_group_begin_titled(ctx, title, title, flags);
}
#[no_mangle]
pub unsafe fn nk_group_begin_titled(
    mut ctx: *mut nk_context,
    mut id: *const libc::c_char,
    mut title: *const libc::c_char,
    mut flags: nk_flags,
) -> libc::c_int {
    let mut id_len: libc::c_int = 0;
    let mut id_hash: nk_hash = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut x_offset: *mut nk_uint = 0 as *mut nk_uint;
    let mut y_offset: *mut nk_uint = 0 as *mut nk_uint;
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || id.is_null()
    {
        return 0i32;
    } else {
        /* find persistent group scrollbar value */
        win = (*ctx).current;
        id_len = nk_strlen(id);
        id_hash = nk_murmur_hash(
            id as *const libc::c_void,
            id_len,
            NK_PANEL_GROUP as libc::c_int as nk_hash,
        );
        x_offset = nk_find_value(win, id_hash);
        if x_offset.is_null() {
            x_offset = nk_add_value(ctx, win, id_hash, 0i32 as nk_uint);
            y_offset = nk_add_value(
                ctx,
                win,
                id_hash.wrapping_add(1i32 as libc::c_uint),
                0i32 as nk_uint,
            );
            if x_offset.is_null() || y_offset.is_null() {
                return 0i32;
            } else {
                *y_offset = 0i32 as nk_uint;
                *x_offset = *y_offset
            }
        } else {
            y_offset = nk_find_value(win, id_hash.wrapping_add(1i32 as libc::c_uint))
        }
        return nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);
    };
}
#[no_mangle]
pub unsafe fn nk_group_scrolled_offset_begin(
    mut ctx: *mut nk_context,
    mut x_offset: *mut nk_uint,
    mut y_offset: *mut nk_uint,
    mut title: *const libc::c_char,
    mut flags: nk_flags,
) -> libc::c_int {
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut panel: nk_window = nk_window {
        seq: 0,
        name: 0,
        name_string: [0; 64],
        flags: 0,
        bounds: nk_rect {
            x: 0.,
            y: 0.,
            w: 0.,
            h: 0.,
        },
        scrollbar: nk_scroll { x: 0, y: 0 },
        buffer: nk_command_buffer {
            base: 0 as *mut nk_buffer,
            clip: nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            },
            use_clipping: 0,
            userdata: nk_handle {
                ptr: 0 as *mut libc::c_void,
            },
            begin: 0,
            end: 0,
            last: 0,
        },
        layout: 0 as *mut nk_panel,
        scrollbar_hiding_timer: 0.,
        property: nk_property_state {
            active: 0,
            prev: 0,
            buffer: [0; 64],
            length: 0,
            cursor: 0,
            select_start: 0,
            select_end: 0,
            name: 0,
            seq: 0,
            old: 0,
            state: 0,
        },
        popup: nk_popup_state {
            win: 0 as *mut nk_window,
            type_0: NK_PANEL_NONE,
            buf: nk_popup_buffer {
                begin: 0,
                parent: 0,
                last: 0,
                end: 0,
                active: 0,
            },
            name: 0,
            active: 0,
            combo_count: 0,
            con_count: 0,
            con_old: 0,
            active_con: 0,
            header: nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            },
        },
        edit: nk_edit_state {
            name: 0,
            seq: 0,
            old: 0,
            active: 0,
            prev: 0,
            cursor: 0,
            sel_start: 0,
            sel_end: 0,
            scrollbar: nk_scroll { x: 0, y: 0 },
            mode: 0,
            single_line: 0,
        },
        scrolled: 0,
        tables: 0 as *mut nk_table,
        table_count: 0,
        next: 0 as *mut nk_window,
        prev: 0 as *mut nk_window,
        parent: 0 as *mut nk_window,
    };
    let mut win: *mut nk_window = 0 as *mut nk_window;
    win = (*ctx).current;
    nk_panel_alloc_space(&mut bounds, ctx);
    let mut c: *const nk_rect = &mut (*(*win).layout).clip as *mut nk_rect;
    if (bounds.x > (*c).x + (*c).w
        || bounds.x + bounds.w < (*c).x
        || bounds.y > (*c).y + (*c).h
        || bounds.y + bounds.h < (*c).y)
        && 0 == flags & NK_WINDOW_MOVABLE as libc::c_int as libc::c_uint
    {
        return 0i32;
    } else {
        if 0 != (*win).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint {
            flags |= NK_WINDOW_ROM as libc::c_int as libc::c_uint
        }
        /* initialize a fake window to create the panel from */
        nk_zero(
            &mut panel as *mut nk_window as *mut libc::c_void,
            ::std::mem::size_of::<nk_window>() as libc::c_ulong,
        );
        panel.bounds = bounds;
        panel.flags = flags;
        panel.scrollbar.x = *x_offset;
        panel.scrollbar.y = *y_offset;
        panel.buffer = (*win).buffer;
        panel.layout = nk_create_panel(ctx) as *mut nk_panel;
        (*ctx).current = &mut panel;
        nk_panel_begin(
            ctx,
            if 0 != flags & NK_WINDOW_TITLE as libc::c_int as libc::c_uint {
                title
            } else {
                0 as *const libc::c_char
            },
            NK_PANEL_GROUP,
        );
        (*win).buffer = panel.buffer;
        (*win).buffer.clip = (*panel.layout).clip;
        (*panel.layout).offset_x = x_offset;
        (*panel.layout).offset_y = y_offset;
        (*panel.layout).parent = (*win).layout;
        (*win).layout = panel.layout;
        (*ctx).current = win;
        if 0 != (*panel.layout).flags & NK_WINDOW_CLOSED as libc::c_int as libc::c_uint
            || 0 != (*panel.layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
        {
            let mut f: nk_flags = (*panel.layout).flags;
            nk_group_scrolled_end(ctx);
            if 0 != f & NK_WINDOW_CLOSED as libc::c_int as libc::c_uint {
                return NK_WINDOW_CLOSED as libc::c_int;
            } else if 0 != f & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint {
                return NK_WINDOW_MINIMIZED as libc::c_int;
            }
        }
        return 1i32;
    };
}
#[no_mangle]
pub unsafe fn nk_group_scrolled_end(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut parent: *mut nk_panel = 0 as *mut nk_panel;
    let mut g: *mut nk_panel = 0 as *mut nk_panel;
    let mut clip: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut pan: nk_window = nk_window {
        seq: 0,
        name: 0,
        name_string: [0; 64],
        flags: 0,
        bounds: nk_rect {
            x: 0.,
            y: 0.,
            w: 0.,
            h: 0.,
        },
        scrollbar: nk_scroll { x: 0, y: 0 },
        buffer: nk_command_buffer {
            base: 0 as *mut nk_buffer,
            clip: nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            },
            use_clipping: 0,
            userdata: nk_handle {
                ptr: 0 as *mut libc::c_void,
            },
            begin: 0,
            end: 0,
            last: 0,
        },
        layout: 0 as *mut nk_panel,
        scrollbar_hiding_timer: 0.,
        property: nk_property_state {
            active: 0,
            prev: 0,
            buffer: [0; 64],
            length: 0,
            cursor: 0,
            select_start: 0,
            select_end: 0,
            name: 0,
            seq: 0,
            old: 0,
            state: 0,
        },
        popup: nk_popup_state {
            win: 0 as *mut nk_window,
            type_0: NK_PANEL_NONE,
            buf: nk_popup_buffer {
                begin: 0,
                parent: 0,
                last: 0,
                end: 0,
                active: 0,
            },
            name: 0,
            active: 0,
            combo_count: 0,
            con_count: 0,
            con_old: 0,
            active_con: 0,
            header: nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            },
        },
        edit: nk_edit_state {
            name: 0,
            seq: 0,
            old: 0,
            active: 0,
            prev: 0,
            cursor: 0,
            sel_start: 0,
            sel_end: 0,
            scrollbar: nk_scroll { x: 0, y: 0 },
            mode: 0,
            single_line: 0,
        },
        scrolled: 0,
        tables: 0 as *mut nk_table,
        table_count: 0,
        next: 0 as *mut nk_window,
        prev: 0 as *mut nk_window,
        parent: 0 as *mut nk_window,
    };
    let mut panel_padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        /* make sure nk_group_begin was called correctly */
        win = (*ctx).current;
        g = (*win).layout;
        parent = (*g).parent;
        nk_zero(
            &mut pan as *mut nk_window as *mut libc::c_void,
            ::std::mem::size_of::<nk_window>() as libc::c_ulong,
        );
        /* dummy window */
        panel_padding = nk_panel_get_padding(&mut (*ctx).style, NK_PANEL_GROUP);
        pan.bounds.y = (*g).bounds.y - ((*g).header_height + (*g).menu.h);
        pan.bounds.x = (*g).bounds.x - panel_padding.x;
        pan.bounds.w = (*g).bounds.w + 2i32 as f32 * panel_padding.x;
        pan.bounds.h = (*g).bounds.h + (*g).header_height + (*g).menu.h;
        if 0 != (*g).flags & NK_WINDOW_BORDER as libc::c_int as libc::c_uint {
            pan.bounds.x -= (*g).border;
            pan.bounds.y -= (*g).border;
            pan.bounds.w += 2i32 as f32 * (*g).border;
            pan.bounds.h += 2i32 as f32 * (*g).border
        }
        if 0 == (*g).flags & NK_WINDOW_NO_SCROLLBAR as libc::c_int as libc::c_uint {
            pan.bounds.w += (*ctx).style.window.scrollbar_size.x;
            pan.bounds.h += (*ctx).style.window.scrollbar_size.y
        }
        pan.scrollbar.x = *(*g).offset_x;
        pan.scrollbar.y = *(*g).offset_y;
        pan.flags = (*g).flags;
        pan.buffer = (*win).buffer;
        pan.layout = g;
        pan.parent = win;
        (*ctx).current = &mut pan;
        /* make sure group has correct clipping rectangle */
        nk_unify(
            &mut clip,
            &mut (*parent).clip,
            pan.bounds.x,
            pan.bounds.y,
            pan.bounds.x + pan.bounds.w,
            pan.bounds.y + pan.bounds.h + panel_padding.x,
        );
        nk_push_scissor(&mut pan.buffer, clip);
        nk_end(ctx);
        (*win).buffer = pan.buffer;
        nk_push_scissor(&mut (*win).buffer, (*parent).clip);
        (*ctx).current = win;
        (*win).layout = parent;
        (*g).bounds = pan.bounds;
        return;
    };
}
unsafe fn nk_panel_alloc_space(mut bounds: *mut nk_rect, mut ctx: *const nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        /* check if the end of the row has been hit and begin new row if so */
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.index >= (*layout).row.columns {
            nk_panel_alloc_row(ctx, win);
        }
        /* calculate widget position and size */
        nk_layout_widget_space(bounds, ctx, win, nk_true as libc::c_int);
        (*layout).row.index += 1;
        return;
    };
}
unsafe fn nk_layout_widget_space(
    mut bounds: *mut nk_rect,
    mut ctx: *const nk_context,
    mut win: *mut nk_window,
    mut modify: libc::c_int,
) -> () {
    let mut w: f32 = 0.;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut spacing: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut item_offset: f32 = 0i32 as f32;
    let mut item_width: f32 = 0i32 as f32;
    let mut item_spacing: f32 = 0i32 as f32;
    let mut panel_space: f32 = 0i32 as f32;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        style = &(*ctx).style as *const nk_style;
        spacing = (*style).window.spacing;
        padding = nk_panel_get_padding(style, (*layout).type_0);
        panel_space = nk_layout_row_calculate_usable_space(
            &(*ctx).style,
            (*layout).type_0,
            (*layout).bounds.w,
            (*layout).row.columns,
        );
        /* will be used to remove fookin gaps */
        /* calculate the width of one item inside the current layout space */
        match (*layout).row.type_0 as libc::c_uint {
            0 => {
                /* scaling fixed size widgets item width */
                w = if 1.0f32 < panel_space {
                    panel_space
                } else {
                    1.0f32
                } / (*layout).row.columns as f32;
                item_offset = (*layout).row.index as f32 * w;
                item_width = w + (item_offset - item_offset as libc::c_int as f32);
                item_spacing = (*layout).row.index as f32 * spacing.x
            }
            1 => {
                /* scaling single ratio widget width */
                let mut w_0: f32 = (*layout).row.item_width * panel_space;
                item_offset = (*layout).row.item_offset;
                item_width = w_0 + (item_offset - item_offset as libc::c_int as f32);
                item_spacing = 0i32 as f32;
                if 0 != modify {
                    (*layout).row.item_offset += w_0 + spacing.x;
                    (*layout).row.filled += (*layout).row.item_width;
                    (*layout).row.index = 0i32
                }
            }
            2 => {
                /* panel width depended free widget placing */
                (*bounds).x = (*layout).at_x + (*layout).bounds.w * (*layout).row.item.x;
                (*bounds).x -= *(*layout).offset_x as f32;
                (*bounds).y = (*layout).at_y + (*layout).row.height * (*layout).row.item.y;
                (*bounds).y -= *(*layout).offset_y as f32;
                (*bounds).w = (*layout).bounds.w * (*layout).row.item.w
                    + ((*bounds).x - (*bounds).x as libc::c_int as f32);
                (*bounds).h = (*layout).row.height * (*layout).row.item.h
                    + ((*bounds).y - (*bounds).y as libc::c_int as f32);
                return;
            }
            3 => {
                /* scaling arrays of panel width ratios for every widget */
                let mut ratio: f32 = 0.;
                let mut w_1: f32 = 0.;
                ratio = if *(*layout).row.ratio.offset((*layout).row.index as isize)
                    < 0i32 as f32
                {
                    (*layout).row.item_width
                } else {
                    *(*layout).row.ratio.offset((*layout).row.index as isize)
                };
                w_1 = ratio * panel_space;
                item_spacing = (*layout).row.index as f32 * spacing.x;
                item_offset = (*layout).row.item_offset;
                item_width = w_1 + (item_offset - item_offset as libc::c_int as f32);
                if 0 != modify {
                    (*layout).row.item_offset += w_1;
                    (*layout).row.filled += ratio
                }
            }
            4 => {
                /* non-scaling fixed widgets item width */
                item_width = (*layout).row.item_width;
                item_offset = (*layout).row.index as f32 * item_width;
                item_spacing = (*layout).row.index as f32 * spacing.x
            }
            5 => {
                /* scaling single ratio widget width */
                item_width = (*layout).row.item_width;
                item_offset = (*layout).row.item_offset;
                item_spacing = (*layout).row.index as f32 * spacing.x;
                if 0 != modify {
                    (*layout).row.item_offset += item_width
                }
            }
            6 => {
                /* free widget placing */
                (*bounds).x = (*layout).at_x + (*layout).row.item.x;
                (*bounds).w = (*layout).row.item.w;
                if (*bounds).x + (*bounds).w > (*layout).max_x && 0 != modify {
                    (*layout).max_x = (*bounds).x + (*bounds).w
                }
                (*bounds).x -= *(*layout).offset_x as f32;
                (*bounds).y = (*layout).at_y + (*layout).row.item.y;
                (*bounds).y -= *(*layout).offset_y as f32;
                (*bounds).h = (*layout).row.item.h;
                return;
            }
            7 => {
                /* non-scaling array of panel pixel width for every widget */
                item_spacing = (*layout).row.index as f32 * spacing.x;
                item_width = *(*layout).row.ratio.offset((*layout).row.index as isize);
                item_offset = (*layout).row.item_offset;
                if 0 != modify {
                    (*layout).row.item_offset += item_width
                }
            }
            8 => {
                /* stretchy row layout with combined dynamic/static widget width*/
                let mut w_2: f32 = 0.;
                w_2 = (*layout).row.templates[(*layout).row.index as usize];
                item_offset = (*layout).row.item_offset;
                item_width = w_2 + (item_offset - item_offset as libc::c_int as f32);
                item_spacing = (*layout).row.index as f32 * spacing.x;
                if 0 != modify {
                    (*layout).row.item_offset += w_2
                }
            }
            _ => {}
        }
        /* set the bounds of the newly allocated widget */
        (*bounds).w = item_width;
        (*bounds).h = (*layout).row.height - spacing.y;
        (*bounds).y = (*layout).at_y - *(*layout).offset_y as f32;
        (*bounds).x = (*layout).at_x + item_offset + item_spacing + padding.x;
        if (*bounds).x + (*bounds).w > (*layout).max_x && 0 != modify {
            (*layout).max_x = (*bounds).x + (*bounds).w
        }
        (*bounds).x -= *(*layout).offset_x as f32;
        return;
    };
}
unsafe fn nk_panel_alloc_row(mut ctx: *const nk_context, mut win: *mut nk_window) -> () {
    let mut layout: *mut nk_panel = (*win).layout;
    let mut spacing: nk_vec2 = (*ctx).style.window.spacing;
    let row_height: f32 = (*layout).row.height - spacing.y;
    nk_panel_layout(ctx, win, row_height, (*layout).row.columns);
}
unsafe fn nk_find_value(mut win: *mut nk_window, mut name: nk_hash) -> *mut nk_uint {
    let mut iter: *mut nk_table = (*win).tables;
    while !iter.is_null() {
        let mut i: libc::c_uint = 0i32 as libc::c_uint;
        let mut size: libc::c_uint = (*iter).size;
        i = 0i32 as libc::c_uint;
        while i < size {
            if (*iter).keys[i as usize] == name {
                (*iter).seq = (*win).seq;
                return &mut (*iter).values[i as usize] as *mut nk_uint;
            } else {
                i = i.wrapping_add(1)
            }
        }
        size = if (::std::mem::size_of::<nk_window>() as libc::c_ulong)
            < ::std::mem::size_of::<nk_panel>() as libc::c_ulong
        {
            ::std::mem::size_of::<nk_panel>() as libc::c_ulong
        } else {
            ::std::mem::size_of::<nk_window>() as libc::c_ulong
        }.wrapping_div(::std::mem::size_of::<nk_uint>() as libc::c_ulong)
            .wrapping_div(2i32 as libc::c_ulong) as libc::c_uint;
        iter = (*iter).next
    }
    return 0 as *mut nk_uint;
}
unsafe fn nk_add_value(
    mut ctx: *mut nk_context,
    mut win: *mut nk_window,
    mut name: nk_hash,
    mut value: nk_uint,
) -> *mut nk_uint {
    if win.is_null() || ctx.is_null() {
        return 0 as *mut nk_uint;
    } else {
        if (*win).tables.is_null()
            || (*(*win).tables).size as libc::c_ulong
                >= if (::std::mem::size_of::<nk_window>() as libc::c_ulong)
                    < ::std::mem::size_of::<nk_panel>() as libc::c_ulong
                {
                    ::std::mem::size_of::<nk_panel>() as libc::c_ulong
                } else {
                    ::std::mem::size_of::<nk_window>() as libc::c_ulong
                }.wrapping_div(::std::mem::size_of::<nk_uint>() as libc::c_ulong)
                    .wrapping_div(2i32 as libc::c_ulong)
        {
            let mut tbl: *mut nk_table = nk_create_table(ctx);
            if tbl.is_null() {
                return 0 as *mut nk_uint;
            } else {
                nk_push_table(win, tbl);
            }
        }
        (*(*win).tables).seq = (*win).seq;
        (*(*win).tables).keys[(*(*win).tables).size as usize] = name;
        (*(*win).tables).values[(*(*win).tables).size as usize] = value;
        let fresh18 = (*(*win).tables).size;
        (*(*win).tables).size = (*(*win).tables).size.wrapping_add(1);
        return &mut (*(*win).tables).values[fresh18 as usize] as *mut nk_uint;
    };
}
unsafe fn nk_create_table(mut ctx: *mut nk_context) -> *mut nk_table {
    let mut elem: *mut nk_page_element = 0 as *mut nk_page_element;
    elem = nk_create_page_element(ctx);
    if elem.is_null() {
        return 0 as *mut nk_table;
    } else {
        nk_zero(
            elem as *mut libc::c_void,
            ::std::mem::size_of::<nk_page_element>() as libc::c_ulong,
        );
        return &mut (*elem).data.tbl as *mut nk_table;
    };
}
unsafe fn nk_push_table(mut win: *mut nk_window, mut tbl: *mut nk_table) -> () {
    if (*win).tables.is_null() {
        (*win).tables = tbl;
        (*tbl).next = 0 as *mut nk_table;
        (*tbl).prev = 0 as *mut nk_table;
        (*tbl).size = 0i32 as libc::c_uint;
        (*win).table_count = 1i32 as libc::c_uint;
        return;
    } else {
        (*(*win).tables).prev = tbl;
        (*tbl).next = (*win).tables;
        (*tbl).prev = 0 as *mut nk_table;
        (*tbl).size = 0i32 as libc::c_uint;
        (*win).tables = tbl;
        (*win).table_count = (*win).table_count.wrapping_add(1);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_group_end(mut ctx: *mut nk_context) -> () {
    nk_group_scrolled_end(ctx);
}
#[no_mangle]
pub unsafe fn nk_group_scrolled_begin(
    mut ctx: *mut nk_context,
    mut scroll: *mut nk_scroll,
    mut title: *const libc::c_char,
    mut flags: nk_flags,
) -> libc::c_int {
    return nk_group_scrolled_offset_begin(ctx, &mut (*scroll).x, &mut (*scroll).y, title, flags);
}
#[no_mangle]
pub unsafe fn nk_tree_push_hashed(
    mut ctx: *mut nk_context,
    mut type_0: nk_tree_type,
    mut title: *const libc::c_char,
    mut initial_state: nk_collapse_states,
    mut hash: *const libc::c_char,
    mut len: libc::c_int,
    mut line: libc::c_int,
) -> libc::c_int {
    return nk_tree_base(
        ctx,
        type_0,
        0 as *mut nk_image,
        title,
        initial_state,
        hash,
        len,
        line,
    );
}
unsafe fn nk_tree_base(
    mut ctx: *mut nk_context,
    mut type_0: nk_tree_type,
    mut img: *mut nk_image,
    mut title: *const libc::c_char,
    mut initial_state: nk_collapse_states,
    mut hash: *const libc::c_char,
    mut len: libc::c_int,
    mut line: libc::c_int,
) -> libc::c_int {
    let mut win: *mut nk_window = (*ctx).current;
    let mut title_len: libc::c_int = 0i32;
    let mut tree_hash: nk_hash = 0i32 as nk_hash;
    let mut state: *mut nk_uint = 0 as *mut nk_uint;
    /* retrieve tree state from internal widget state tables */
    if hash.is_null() {
        title_len = nk_strlen(title);
        tree_hash = nk_murmur_hash(title as *const libc::c_void, title_len, line as nk_hash)
    } else {
        tree_hash = nk_murmur_hash(hash as *const libc::c_void, len, line as nk_hash)
    }
    state = nk_find_value(win, tree_hash);
    if state.is_null() {
        state = nk_add_value(ctx, win, tree_hash, 0i32 as nk_uint);
        *state = initial_state as nk_uint
    }
    return nk_tree_state_base(ctx, type_0, img, title, state as *mut nk_collapse_states);
}
unsafe fn nk_tree_state_base(
    mut ctx: *mut nk_context,
    mut type_0: nk_tree_type,
    mut img: *mut nk_image,
    mut title: *const libc::c_char,
    mut state: *mut nk_collapse_states,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut out: *mut nk_command_buffer = 0 as *mut nk_command_buffer;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut button: *const nk_style_button = 0 as *const nk_style_button;
    let mut symbol: nk_symbol_type = NK_SYMBOL_NONE;
    let mut row_height: f32 = 0.;
    let mut item_spacing: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut header: nk_rect = nk_rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    let mut sym: nk_rect = nk_rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut ws: nk_flags = 0i32 as nk_flags;
    let mut widget_state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        /* cache some data */
        win = (*ctx).current;
        layout = (*win).layout;
        out = &mut (*win).buffer as *mut nk_command_buffer;
        style = &mut (*ctx).style as *mut nk_style;
        item_spacing = (*style).window.spacing;
        /* calculate header bounds and draw background */
        row_height = (*(*style).font).height + 2i32 as f32 * (*style).tab.padding.y;
        nk_layout_set_min_row_height(ctx, row_height);
        nk_layout_row_dynamic(ctx, row_height, 1i32);
        nk_layout_reset_min_row_height(ctx);
        widget_state = nk_widget(&mut header, ctx);
        if type_0 as libc::c_uint == NK_TREE_TAB as libc::c_int as libc::c_uint {
            let mut background: *const nk_style_item =
                &(*style).tab.background as *const nk_style_item;
            if (*background).type_0 as libc::c_uint
                == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                nk_draw_image(out, header, &(*background).data.image, nk_white);
                text.background = nk_rgba(0i32, 0i32, 0i32, 0i32)
            } else {
                text.background = (*background).data.color;
                nk_fill_rect(
                    out,
                    header,
                    0i32 as f32,
                    (*style).tab.border_color,
                );
                nk_fill_rect(
                    out,
                    nk_shrink_rect(header, (*style).tab.border),
                    (*style).tab.rounding,
                    (*background).data.color,
                );
            }
        } else {
            text.background = (*style).window.background
        }
        /* update node state */
        in_0 = if 0 == (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint {
            &mut (*ctx).input as *mut nk_input
        } else {
            0 as *mut nk_input
        };
        in_0 = if !in_0.is_null()
            && widget_state as libc::c_uint == NK_WIDGET_VALID as libc::c_int as libc::c_uint
        {
            &mut (*ctx).input as *mut nk_input
        } else {
            0 as *mut nk_input
        };
        if 0 != nk_button_behavior(&mut ws, header, in_0, NK_BUTTON_DEFAULT) {
            *state = (if *state as libc::c_uint == NK_MAXIMIZED as libc::c_int as libc::c_uint {
                NK_MINIMIZED as libc::c_int
            } else {
                NK_MAXIMIZED as libc::c_int
            }) as nk_collapse_states
        }
        /* select correct button style */
        if *state as libc::c_uint == NK_MAXIMIZED as libc::c_int as libc::c_uint {
            symbol = (*style).tab.sym_maximize;
            if type_0 as libc::c_uint == NK_TREE_TAB as libc::c_int as libc::c_uint {
                button = &(*style).tab.tab_maximize_button as *const nk_style_button
            } else {
                button = &(*style).tab.node_maximize_button as *const nk_style_button
            }
        } else {
            symbol = (*style).tab.sym_minimize;
            if type_0 as libc::c_uint == NK_TREE_TAB as libc::c_int as libc::c_uint {
                button = &(*style).tab.tab_minimize_button as *const nk_style_button
            } else {
                button = &(*style).tab.node_minimize_button as *const nk_style_button
            }
        }
        /* draw triangle button */
        sym.h = (*(*style).font).height;
        sym.w = sym.h;
        sym.y = header.y + (*style).tab.padding.y;
        sym.x = header.x + (*style).tab.padding.x;
        nk_do_button_symbol(
            &mut ws,
            &mut (*win).buffer,
            sym,
            symbol,
            NK_BUTTON_DEFAULT,
            button,
            0 as *const nk_input,
            (*style).font,
        );
        if !img.is_null() {
            /* draw optional image icon */
            sym.x = sym.x + sym.w + 4i32 as f32 * item_spacing.x;
            nk_draw_image(&mut (*win).buffer, sym, img, nk_white);
            sym.w = (*(*style).font).height + (*style).tab.spacing.x
        }
        /* draw label */
        let mut label: nk_rect = nk_rect {
            x: 0.,
            y: 0.,
            w: 0.,
            h: 0.,
        };
        header.w = if header.w < sym.w + item_spacing.x {
            sym.w + item_spacing.x
        } else {
            header.w
        };
        label.x = sym.x + sym.w + item_spacing.x;
        label.y = sym.y;
        label.w = header.w - (sym.w + item_spacing.y + (*style).tab.indent);
        label.h = (*(*style).font).height;
        text.text = (*style).tab.text;
        text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
        nk_widget_text(
            out,
            label,
            title,
            nk_strlen(title),
            &mut text,
            NK_TEXT_LEFT as libc::c_int as nk_flags,
            (*style).font,
        );
        /* increase x-axis cursor widget position pointer */
        if *state as libc::c_uint == NK_MAXIMIZED as libc::c_int as libc::c_uint {
            (*layout).at_x = header.x + *(*layout).offset_x as f32 + (*style).tab.indent;
            (*layout).bounds.w = if (*layout).bounds.w < (*style).tab.indent {
                (*style).tab.indent
            } else {
                (*layout).bounds.w
            };
            (*layout).bounds.w -= (*style).tab.indent + (*style).window.padding.x;
            (*layout).row.tree_depth += 1;
            return nk_true as libc::c_int;
        } else {
            return nk_false as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_widget(
    mut bounds: *mut nk_rect,
    mut ctx: *const nk_context,
) -> nk_widget_layout_states {
    let mut c: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut v: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return NK_WIDGET_INVALID;
    } else {
        /* allocate space and check if the widget needs to be updated and drawn */
        nk_panel_alloc_space(bounds, ctx);
        win = (*ctx).current;
        layout = (*win).layout;
        in_0 = &(*ctx).input as *const nk_input;
        c = (*layout).clip;
        /*  if one of these triggers you forgot to add an `if` condition around either
        a window, group, popup, combobox or contextual menu `begin` and `end` block.
        Example:
            if (nk_begin(...) {...} nk_end(...); or
            if (nk_group_begin(...) { nk_group_end(...);} */
        /* need to convert to int here to remove floating point errors */
        (*bounds).x = (*bounds).x as libc::c_int as f32;
        (*bounds).y = (*bounds).y as libc::c_int as f32;
        (*bounds).w = (*bounds).w as libc::c_int as f32;
        (*bounds).h = (*bounds).h as libc::c_int as f32;
        c.x = c.x as libc::c_int as f32;
        c.y = c.y as libc::c_int as f32;
        c.w = c.w as libc::c_int as f32;
        c.h = c.h as libc::c_int as f32;
        nk_unify(
            &mut v,
            &mut c,
            (*bounds).x,
            (*bounds).y,
            (*bounds).x + (*bounds).w,
            (*bounds).y + (*bounds).h,
        );
        if (*bounds).x > c.x + c.w
            || (*bounds).x + (*bounds).w < c.x
            || (*bounds).y > c.y + c.h
            || (*bounds).y + (*bounds).h < c.y
        {
            return NK_WIDGET_INVALID;
        } else if !(v.x <= (*in_0).mouse.pos.x
            && (*in_0).mouse.pos.x < v.x + v.w
            && (v.y <= (*in_0).mouse.pos.y && (*in_0).mouse.pos.y < v.y + v.h))
        {
            return NK_WIDGET_ROM;
        } else {
            return NK_WIDGET_VALID;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_tree_image_push_hashed(
    mut ctx: *mut nk_context,
    mut type_0: nk_tree_type,
    mut img: nk_image,
    mut title: *const libc::c_char,
    mut initial_state: nk_collapse_states,
    mut hash: *const libc::c_char,
    mut len: libc::c_int,
    mut seed: libc::c_int,
) -> libc::c_int {
    return nk_tree_base(ctx, type_0, &mut img, title, initial_state, hash, len, seed);
}
#[no_mangle]
pub unsafe fn nk_tree_pop(mut ctx: *mut nk_context) -> () {
    nk_tree_state_pop(ctx);
}
#[no_mangle]
pub unsafe fn nk_tree_state_pop(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).at_x -= (*ctx).style.tab.indent + (*ctx).style.window.padding.x;
        (*layout).bounds.w += (*ctx).style.tab.indent + (*ctx).style.window.padding.x;
        (*layout).row.tree_depth -= 1;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_tree_state_push(
    mut ctx: *mut nk_context,
    mut type_0: nk_tree_type,
    mut title: *const libc::c_char,
    mut state: *mut nk_collapse_states,
) -> libc::c_int {
    return nk_tree_state_base(ctx, type_0, 0 as *mut nk_image, title, state);
}
#[no_mangle]
pub unsafe fn nk_tree_state_image_push(
    mut ctx: *mut nk_context,
    mut type_0: nk_tree_type,
    mut img: nk_image,
    mut title: *const libc::c_char,
    mut state: *mut nk_collapse_states,
) -> libc::c_int {
    return nk_tree_state_base(ctx, type_0, &mut img, title, state);
}
#[no_mangle]
pub unsafe fn nk_tree_element_push_hashed(
    mut ctx: *mut nk_context,
    mut type_0: nk_tree_type,
    mut title: *const libc::c_char,
    mut initial_state: nk_collapse_states,
    mut selected: *mut libc::c_int,
    mut hash: *const libc::c_char,
    mut len: libc::c_int,
    mut seed: libc::c_int,
) -> libc::c_int {
    return nk_tree_element_base(
        ctx,
        type_0,
        0 as *mut nk_image,
        title,
        initial_state,
        selected,
        hash,
        len,
        seed,
    );
}
unsafe fn nk_tree_element_base(
    mut ctx: *mut nk_context,
    mut type_0: nk_tree_type,
    mut img: *mut nk_image,
    mut title: *const libc::c_char,
    mut initial_state: nk_collapse_states,
    mut selected: *mut libc::c_int,
    mut hash: *const libc::c_char,
    mut len: libc::c_int,
    mut line: libc::c_int,
) -> libc::c_int {
    let mut win: *mut nk_window = (*ctx).current;
    let mut title_len: libc::c_int = 0i32;
    let mut tree_hash: nk_hash = 0i32 as nk_hash;
    let mut state: *mut nk_uint = 0 as *mut nk_uint;
    /* retrieve tree state from internal widget state tables */
    if hash.is_null() {
        title_len = nk_strlen(title);
        tree_hash = nk_murmur_hash(title as *const libc::c_void, title_len, line as nk_hash)
    } else {
        tree_hash = nk_murmur_hash(hash as *const libc::c_void, len, line as nk_hash)
    }
    state = nk_find_value(win, tree_hash);
    if state.is_null() {
        state = nk_add_value(ctx, win, tree_hash, 0i32 as nk_uint);
        *state = initial_state as nk_uint
    }
    return nk_tree_element_image_push_hashed_base(
        ctx,
        type_0,
        img,
        title,
        nk_strlen(title),
        state as *mut nk_collapse_states,
        selected,
    );
}
unsafe fn nk_tree_element_image_push_hashed_base(
    mut ctx: *mut nk_context,
    mut type_0: nk_tree_type,
    mut img: *mut nk_image,
    mut title: *const libc::c_char,
    mut title_len: libc::c_int,
    mut state: *mut nk_collapse_states,
    mut selected: *mut libc::c_int,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut out: *mut nk_command_buffer = 0 as *mut nk_command_buffer;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut button: *const nk_style_button = 0 as *const nk_style_button;
    let mut symbol: nk_symbol_type = NK_SYMBOL_NONE;
    let mut row_height: f32 = 0.;
    let mut padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut text_len: libc::c_int = 0;
    let mut text_width: f32 = 0.;
    let mut item_spacing: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut header: nk_rect = nk_rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    let mut sym: nk_rect = nk_rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut ws: nk_flags = 0i32 as nk_flags;
    let mut widget_state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        /* cache some data */
        win = (*ctx).current;
        layout = (*win).layout;
        out = &mut (*win).buffer as *mut nk_command_buffer;
        style = &mut (*ctx).style as *mut nk_style;
        item_spacing = (*style).window.spacing;
        padding = (*style).selectable.padding;
        /* calculate header bounds and draw background */
        row_height = (*(*style).font).height + 2i32 as f32 * (*style).tab.padding.y;
        nk_layout_set_min_row_height(ctx, row_height);
        nk_layout_row_dynamic(ctx, row_height, 1i32);
        nk_layout_reset_min_row_height(ctx);
        widget_state = nk_widget(&mut header, ctx);
        if type_0 as libc::c_uint == NK_TREE_TAB as libc::c_int as libc::c_uint {
            let mut background: *const nk_style_item =
                &(*style).tab.background as *const nk_style_item;
            if (*background).type_0 as libc::c_uint
                == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                nk_draw_image(out, header, &(*background).data.image, nk_white);
                text.background = nk_rgba(0i32, 0i32, 0i32, 0i32)
            } else {
                text.background = (*background).data.color;
                nk_fill_rect(
                    out,
                    header,
                    0i32 as f32,
                    (*style).tab.border_color,
                );
                nk_fill_rect(
                    out,
                    nk_shrink_rect(header, (*style).tab.border),
                    (*style).tab.rounding,
                    (*background).data.color,
                );
            }
        } else {
            text.background = (*style).window.background
        }
        in_0 = if 0 == (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint {
            &mut (*ctx).input as *mut nk_input
        } else {
            0 as *mut nk_input
        };
        in_0 = if !in_0.is_null()
            && widget_state as libc::c_uint == NK_WIDGET_VALID as libc::c_int as libc::c_uint
        {
            &mut (*ctx).input as *mut nk_input
        } else {
            0 as *mut nk_input
        };
        /* select correct button style */
        if *state as libc::c_uint == NK_MAXIMIZED as libc::c_int as libc::c_uint {
            symbol = (*style).tab.sym_maximize;
            if type_0 as libc::c_uint == NK_TREE_TAB as libc::c_int as libc::c_uint {
                button = &(*style).tab.tab_maximize_button as *const nk_style_button
            } else {
                button = &(*style).tab.node_maximize_button as *const nk_style_button
            }
        } else {
            symbol = (*style).tab.sym_minimize;
            if type_0 as libc::c_uint == NK_TREE_TAB as libc::c_int as libc::c_uint {
                button = &(*style).tab.tab_minimize_button as *const nk_style_button
            } else {
                button = &(*style).tab.node_minimize_button as *const nk_style_button
            }
        }
        /* draw triangle button */
        sym.h = (*(*style).font).height;
        sym.w = sym.h;
        sym.y = header.y + (*style).tab.padding.y;
        sym.x = header.x + (*style).tab.padding.x;
        if 0 != nk_do_button_symbol(
            &mut ws,
            &mut (*win).buffer,
            sym,
            symbol,
            NK_BUTTON_DEFAULT,
            button,
            in_0,
            (*style).font,
        ) {
            *state = (if *state as libc::c_uint == NK_MAXIMIZED as libc::c_int as libc::c_uint {
                NK_MINIMIZED as libc::c_int
            } else {
                NK_MAXIMIZED as libc::c_int
            }) as nk_collapse_states
        }
        /* draw label */
        let mut dummy: nk_flags = 0i32 as nk_flags;
        let mut label: nk_rect = nk_rect {
            x: 0.,
            y: 0.,
            w: 0.,
            h: 0.,
        };
        /* calculate size of the text and tooltip */
        text_len = nk_strlen(title);
        text_width = (*(*style).font).width.expect("non-null function pointer")(
            (*(*style).font).userdata,
            (*(*style).font).height,
            title,
            text_len,
        );
        text_width += 4i32 as f32 * padding.x;
        header.w = if header.w < sym.w + item_spacing.x {
            sym.w + item_spacing.x
        } else {
            header.w
        };
        label.x = sym.x + sym.w + item_spacing.x;
        label.y = sym.y;
        label.w = if header.w - (sym.w + item_spacing.y + (*style).tab.indent) < text_width {
            header.w - (sym.w + item_spacing.y + (*style).tab.indent)
        } else {
            text_width
        };
        label.h = (*(*style).font).height;
        if !img.is_null() {
            nk_do_selectable_image(
                &mut dummy,
                &mut (*win).buffer,
                label,
                title,
                title_len,
                NK_TEXT_LEFT as libc::c_int as nk_flags,
                selected,
                img,
                &(*style).selectable,
                in_0,
                (*style).font,
            );
        } else {
            nk_do_selectable(
                &mut dummy,
                &mut (*win).buffer,
                label,
                title,
                title_len,
                NK_TEXT_LEFT as libc::c_int as nk_flags,
                selected,
                &(*style).selectable,
                in_0,
                (*style).font,
            );
        }
        /* increase x-axis cursor widget position pointer */
        if *state as libc::c_uint == NK_MAXIMIZED as libc::c_int as libc::c_uint {
            (*layout).at_x = header.x + *(*layout).offset_x as f32 + (*style).tab.indent;
            (*layout).bounds.w = if (*layout).bounds.w < (*style).tab.indent {
                (*style).tab.indent
            } else {
                (*layout).bounds.w
            };
            (*layout).bounds.w -= (*style).tab.indent + (*style).window.padding.x;
            (*layout).row.tree_depth += 1;
            return nk_true as libc::c_int;
        } else {
            return nk_false as libc::c_int;
        }
    };
}
unsafe fn nk_do_selectable(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut value: *mut libc::c_int,
    mut style: *const nk_style_selectable,
    mut in_0: *const nk_input,
    mut font: *const nk_user_font,
) -> libc::c_int {
    let mut old_value: libc::c_int = 0;
    let mut touch: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if state.is_null()
        || out.is_null()
        || str.is_null()
        || 0 == len
        || value.is_null()
        || style.is_null()
        || font.is_null()
    {
        return 0i32;
    } else {
        old_value = *value;
        /* remove padding */
        touch.x = bounds.x - (*style).touch_padding.x;
        touch.y = bounds.y - (*style).touch_padding.y;
        touch.w = bounds.w + (*style).touch_padding.x * 2i32 as f32;
        touch.h = bounds.h + (*style).touch_padding.y * 2i32 as f32;
        /* update button */
        if 0 != nk_button_behavior(state, touch, in_0, NK_BUTTON_DEFAULT) {
            *value = (0 == *value) as libc::c_int
        }
        /* draw selectable */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_selectable(
            out,
            *state,
            style,
            *value,
            &mut bounds,
            0 as *const nk_rect,
            0 as *const nk_image,
            NK_SYMBOL_NONE,
            str,
            len,
            align,
            font,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return (old_value != *value) as libc::c_int;
    };
}
unsafe fn nk_draw_selectable(
    mut out: *mut nk_command_buffer,
    mut state: nk_flags,
    mut style: *const nk_style_selectable,
    mut active: libc::c_int,
    mut bounds: *const nk_rect,
    mut icon: *const nk_rect,
    mut img: *const nk_image,
    mut sym: nk_symbol_type,
    mut string: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut font: *const nk_user_font,
) -> () {
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    text.padding = (*style).padding;
    /* select correct colors/images */
    if 0 == active {
        if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
            background = &(*style).pressed as *const nk_style_item;
            text.text = (*style).text_pressed
        } else if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
            background = &(*style).hover as *const nk_style_item;
            text.text = (*style).text_hover
        } else {
            background = &(*style).normal as *const nk_style_item;
            text.text = (*style).text_normal
        }
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        background = &(*style).pressed_active as *const nk_style_item;
        text.text = (*style).text_pressed_active
    } else if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        background = &(*style).hover_active as *const nk_style_item;
        text.text = (*style).text_hover_active
    } else {
        background = &(*style).normal_active as *const nk_style_item;
        text.text = (*style).text_normal_active
    }
    /* draw selectable background and text */
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
        text.background = nk_rgba(0i32, 0i32, 0i32, 0i32)
    } else {
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        text.background = (*background).data.color
    }
    if !icon.is_null() {
        if !img.is_null() {
            nk_draw_image(out, *icon, img, nk_white);
        } else {
            nk_draw_symbol(
                out,
                sym,
                *icon,
                text.background,
                text.text,
                1i32 as f32,
                font,
            );
        }
    }
    nk_widget_text(out, *bounds, string, len, &mut text, align, font);
}
unsafe fn nk_do_selectable_image(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut value: *mut libc::c_int,
    mut img: *const nk_image,
    mut style: *const nk_style_selectable,
    mut in_0: *const nk_input,
    mut font: *const nk_user_font,
) -> libc::c_int {
    let mut old_value: libc::c_int = 0;
    let mut touch: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut icon: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if state.is_null()
        || out.is_null()
        || str.is_null()
        || 0 == len
        || value.is_null()
        || style.is_null()
        || font.is_null()
    {
        return 0i32;
    } else {
        old_value = *value;
        /* toggle behavior */
        touch.x = bounds.x - (*style).touch_padding.x;
        touch.y = bounds.y - (*style).touch_padding.y;
        touch.w = bounds.w + (*style).touch_padding.x * 2i32 as f32;
        touch.h = bounds.h + (*style).touch_padding.y * 2i32 as f32;
        if 0 != nk_button_behavior(state, touch, in_0, NK_BUTTON_DEFAULT) {
            *value = (0 == *value) as libc::c_int
        }
        icon.y = bounds.y + (*style).padding.y;
        icon.h = bounds.h - 2i32 as f32 * (*style).padding.y;
        icon.w = icon.h;
        if 0 != align & NK_TEXT_ALIGN_LEFT as libc::c_int as libc::c_uint {
            icon.x = bounds.x + bounds.w - (2i32 as f32 * (*style).padding.x + icon.w);
            icon.x = if icon.x < 0i32 as f32 {
                0i32 as f32
            } else {
                icon.x
            }
        } else {
            icon.x = bounds.x + 2i32 as f32 * (*style).padding.x
        }
        icon.x += (*style).image_padding.x;
        icon.y += (*style).image_padding.y;
        icon.w -= 2i32 as f32 * (*style).image_padding.x;
        icon.h -= 2i32 as f32 * (*style).image_padding.y;
        /* draw selectable */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_selectable(
            out,
            *state,
            style,
            *value,
            &mut bounds,
            &mut icon,
            img,
            NK_SYMBOL_NONE,
            str,
            len,
            align,
            font,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return (old_value != *value) as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_tree_element_image_push_hashed(
    mut ctx: *mut nk_context,
    mut type_0: nk_tree_type,
    mut img: nk_image,
    mut title: *const libc::c_char,
    mut initial_state: nk_collapse_states,
    mut selected: *mut libc::c_int,
    mut hash: *const libc::c_char,
    mut len: libc::c_int,
    mut seed: libc::c_int,
) -> libc::c_int {
    return nk_tree_element_base(
        ctx,
        type_0,
        &mut img,
        title,
        initial_state,
        selected,
        hash,
        len,
        seed,
    );
}
#[no_mangle]
pub unsafe fn nk_tree_element_pop(mut ctx: *mut nk_context) -> () {
    nk_tree_state_pop(ctx);
}
#[no_mangle]
pub unsafe fn nk_list_view_begin(
    mut ctx: *mut nk_context,
    mut view: *mut nk_list_view,
    mut title: *const libc::c_char,
    mut flags: nk_flags,
    mut row_height: libc::c_int,
    mut row_count: libc::c_int,
) -> libc::c_int {
    let mut title_len: libc::c_int = 0;
    let mut title_hash: nk_hash = 0;
    let mut x_offset: *mut nk_uint = 0 as *mut nk_uint;
    let mut y_offset: *mut nk_uint = 0 as *mut nk_uint;
    let mut result: libc::c_int = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut item_spacing: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    if ctx.is_null() || view.is_null() || title.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        item_spacing = (*style).window.spacing;
        row_height += if 0i32 < item_spacing.y as libc::c_int {
            item_spacing.y as libc::c_int
        } else {
            0i32
        };
        /* find persistent list view scrollbar offset */
        title_len = nk_strlen(title);
        title_hash = nk_murmur_hash(
            title as *const libc::c_void,
            title_len,
            NK_PANEL_GROUP as libc::c_int as nk_hash,
        );
        x_offset = nk_find_value(win, title_hash);
        if x_offset.is_null() {
            x_offset = nk_add_value(ctx, win, title_hash, 0i32 as nk_uint);
            y_offset = nk_add_value(
                ctx,
                win,
                title_hash.wrapping_add(1i32 as libc::c_uint),
                0i32 as nk_uint,
            );
            if x_offset.is_null() || y_offset.is_null() {
                return 0i32;
            } else {
                *y_offset = 0i32 as nk_uint;
                *x_offset = *y_offset
            }
        } else {
            y_offset = nk_find_value(win, title_hash.wrapping_add(1i32 as libc::c_uint))
        }
        (*view).scroll_value = *y_offset;
        (*view).scroll_pointer = y_offset;
        *y_offset = 0i32 as nk_uint;
        result = nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);
        win = (*ctx).current;
        layout = (*win).layout;
        (*view).total_height = row_height * if row_count < 1i32 { 1i32 } else { row_count };
        (*view).begin =
            (if ((*view).scroll_value as f32 / row_height as f32) < 0.0f32 {
                0.0f32
            } else {
                (*view).scroll_value as f32 / row_height as f32
            }) as libc::c_int;
        (*view).count = if nk_iceilf((*layout).clip.h / row_height as f32) < 0i32 {
            0i32
        } else {
            nk_iceilf((*layout).clip.h / row_height as f32)
        };
        (*view).count = if (*view).count < row_count - (*view).begin {
            (*view).count
        } else {
            row_count - (*view).begin
        };
        (*view).end = (*view).begin + (*view).count;
        (*view).ctx = ctx;
        return result;
    };
}
unsafe fn nk_iceilf(mut x: f32) -> libc::c_int {
    if x >= 0i32 as f32 {
        let mut i: libc::c_int = x as libc::c_int;
        return if x > i as f32 { i + 1i32 } else { i };
    } else {
        let mut t: libc::c_int = x as libc::c_int;
        let mut r: f32 = x - t as f32;
        return if r > 0.0f32 { t + 1i32 } else { t };
    };
}
#[no_mangle]
pub unsafe fn nk_list_view_end(mut view: *mut nk_list_view) -> () {
    let mut ctx: *mut nk_context = 0 as *mut nk_context;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if view.is_null() || (*view).ctx.is_null() {
        return;
    } else {
        ctx = (*view).ctx;
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).at_y = (*layout).bounds.y + (*view).total_height as f32;
        *(*view).scroll_pointer = (*(*view).scroll_pointer).wrapping_add((*view).scroll_value);
        nk_group_end((*view).ctx);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_widget_fitting(
    mut bounds: *mut nk_rect,
    mut ctx: *mut nk_context,
    mut item_padding: nk_vec2,
) -> nk_widget_layout_states {
    /* update the bounds to stand without padding  */
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut style: *mut nk_style = 0 as *mut nk_style;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut panel_padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return NK_WIDGET_INVALID;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        layout = (*win).layout;
        state = nk_widget(bounds, ctx);
        panel_padding = nk_panel_get_padding(style, (*layout).type_0);
        if (*layout).row.index == 1i32 {
            (*bounds).w += panel_padding.x;
            (*bounds).x -= panel_padding.x
        } else {
            (*bounds).x -= item_padding.x
        }
        if (*layout).row.index == (*layout).row.columns {
            (*bounds).w += panel_padding.x
        } else {
            (*bounds).w += item_padding.x
        }
        return state;
    };
}
#[no_mangle]
pub unsafe fn nk_widget_bounds(mut ctx: *mut nk_context) -> nk_rect {
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() {
        return nk_rect(
            0i32 as f32,
            0i32 as f32,
            0i32 as f32,
            0i32 as f32,
        );
    } else {
        nk_layout_peek(&mut bounds, ctx);
        return bounds;
    };
}
unsafe fn nk_layout_peek(mut bounds: *mut nk_rect, mut ctx: *mut nk_context) -> () {
    let mut y: f32 = 0.;
    let mut index: libc::c_int = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        y = (*layout).at_y;
        index = (*layout).row.index;
        if (*layout).row.index >= (*layout).row.columns {
            (*layout).at_y += (*layout).row.height;
            (*layout).row.index = 0i32
        }
        nk_layout_widget_space(bounds, ctx, win, nk_false as libc::c_int);
        if 0 == (*layout).row.index {
            (*bounds).x -= (*layout).row.item_offset
        }
        (*layout).at_y = y;
        (*layout).row.index = index;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_widget_position(mut ctx: *mut nk_context) -> nk_vec2 {
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() {
        return nk_vec2(0i32 as f32, 0i32 as f32);
    } else {
        nk_layout_peek(&mut bounds, ctx);
        return nk_vec2(bounds.x, bounds.y);
    };
}
#[no_mangle]
pub unsafe fn nk_widget_size(mut ctx: *mut nk_context) -> nk_vec2 {
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() {
        return nk_vec2(0i32 as f32, 0i32 as f32);
    } else {
        nk_layout_peek(&mut bounds, ctx);
        return nk_vec2(bounds.w, bounds.h);
    };
}
#[no_mangle]
pub unsafe fn nk_widget_width(mut ctx: *mut nk_context) -> f32 {
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32 as f32;
    } else {
        nk_layout_peek(&mut bounds, ctx);
        return bounds.w;
    };
}
#[no_mangle]
pub unsafe fn nk_widget_height(mut ctx: *mut nk_context) -> f32 {
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32 as f32;
    } else {
        nk_layout_peek(&mut bounds, ctx);
        return bounds.h;
    };
}
#[no_mangle]
pub unsafe fn nk_widget_is_hovered(mut ctx: *mut nk_context) -> libc::c_int {
    let mut c: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut v: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*ctx).active != (*ctx).current {
        return 0i32;
    } else {
        c = (*(*(*ctx).current).layout).clip;
        c.x = c.x as libc::c_int as f32;
        c.y = c.y as libc::c_int as f32;
        c.w = c.w as libc::c_int as f32;
        c.h = c.h as libc::c_int as f32;
        nk_layout_peek(&mut bounds, ctx);
        nk_unify(
            &mut v,
            &mut c,
            bounds.x,
            bounds.y,
            bounds.x + bounds.w,
            bounds.y + bounds.h,
        );
        if bounds.x > c.x + c.w
            || bounds.x + bounds.w < c.x
            || bounds.y > c.y + c.h
            || bounds.y + bounds.h < c.y
        {
            return 0i32;
        } else {
            return nk_input_is_mouse_hovering_rect(&mut (*ctx).input, bounds);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_widget_is_mouse_clicked(
    mut ctx: *mut nk_context,
    mut btn: nk_buttons,
) -> libc::c_int {
    let mut c: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut v: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*ctx).active != (*ctx).current {
        return 0i32;
    } else {
        c = (*(*(*ctx).current).layout).clip;
        c.x = c.x as libc::c_int as f32;
        c.y = c.y as libc::c_int as f32;
        c.w = c.w as libc::c_int as f32;
        c.h = c.h as libc::c_int as f32;
        nk_layout_peek(&mut bounds, ctx);
        nk_unify(
            &mut v,
            &mut c,
            bounds.x,
            bounds.y,
            bounds.x + bounds.w,
            bounds.y + bounds.h,
        );
        if bounds.x > c.x + c.w
            || bounds.x + bounds.w < c.x
            || bounds.y > c.y + c.h
            || bounds.y + bounds.h < c.y
        {
            return 0i32;
        } else {
            return nk_input_mouse_clicked(&mut (*ctx).input, btn, bounds);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_input_mouse_clicked(
    mut i: *const nk_input,
    mut id: nk_buttons,
    mut rect: nk_rect,
) -> libc::c_int {
    if i.is_null() {
        return nk_false as libc::c_int;
    } else if 0 == nk_input_is_mouse_hovering_rect(i, rect) {
        return nk_false as libc::c_int;
    } else {
        return nk_input_is_mouse_click_in_rect(i, id, rect);
    };
}
#[no_mangle]
pub unsafe fn nk_input_is_mouse_click_in_rect(
    mut i: *const nk_input,
    mut id: nk_buttons,
    mut b: nk_rect,
) -> libc::c_int {
    let mut btn: *const nk_mouse_button = 0 as *const nk_mouse_button;
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        btn = &(*i).mouse.buttons[id as usize] as *const nk_mouse_button;
        return if 0 != nk_input_has_mouse_click_down_in_rect(i, id, b, nk_false as libc::c_int)
            && 0 != (*btn).clicked
        {
            nk_true as libc::c_int
        } else {
            nk_false as libc::c_int
        };
    };
}
#[no_mangle]
pub unsafe fn nk_widget_has_mouse_click_down(
    mut ctx: *mut nk_context,
    mut btn: nk_buttons,
    mut down: libc::c_int,
) -> libc::c_int {
    let mut c: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut v: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*ctx).active != (*ctx).current {
        return 0i32;
    } else {
        c = (*(*(*ctx).current).layout).clip;
        c.x = c.x as libc::c_int as f32;
        c.y = c.y as libc::c_int as f32;
        c.w = c.w as libc::c_int as f32;
        c.h = c.h as libc::c_int as f32;
        nk_layout_peek(&mut bounds, ctx);
        nk_unify(
            &mut v,
            &mut c,
            bounds.x,
            bounds.y,
            bounds.x + bounds.w,
            bounds.y + bounds.h,
        );
        if bounds.x > c.x + c.w
            || bounds.x + bounds.w < c.x
            || bounds.y > c.y + c.h
            || bounds.y + bounds.h < c.y
        {
            return 0i32;
        } else {
            return nk_input_has_mouse_click_down_in_rect(&mut (*ctx).input, btn, bounds, down);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_spacing(mut ctx: *mut nk_context, mut cols: libc::c_int) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut none: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut i: libc::c_int = 0;
    let mut index: libc::c_int = 0;
    let mut rows: libc::c_int = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        /* spacing over row boundaries */
        win = (*ctx).current;
        layout = (*win).layout;
        index = ((*layout).row.index + cols) % (*layout).row.columns;
        rows = ((*layout).row.index + cols) / (*layout).row.columns;
        if 0 != rows {
            i = 0i32;
            while i < rows {
                nk_panel_alloc_row(ctx, win);
                i += 1
            }
            cols = index
        }
        /* non table layout need to allocate space */
        if (*layout).row.type_0 as libc::c_uint
            != NK_LAYOUT_DYNAMIC_FIXED as libc::c_int as libc::c_uint
            && (*layout).row.type_0 as libc::c_uint
                != NK_LAYOUT_STATIC_FIXED as libc::c_int as libc::c_uint
        {
            i = 0i32;
            while i < cols {
                nk_panel_alloc_space(&mut none, ctx);
                i += 1
            }
        }
        (*layout).row.index = index;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_text(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut alignment: nk_flags,
) -> () {
    if ctx.is_null() {
        return;
    } else {
        nk_text_colored(ctx, str, len, alignment, (*ctx).style.text.color);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_text_colored(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut alignment: nk_flags,
    mut color: nk_color,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut item_padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        nk_panel_alloc_space(&mut bounds, ctx);
        item_padding = (*style).text.padding;
        text.padding.x = item_padding.x;
        text.padding.y = item_padding.y;
        text.background = (*style).window.background;
        text.text = color;
        nk_widget_text(
            &mut (*win).buffer,
            bounds,
            str,
            len,
            &mut text,
            alignment,
            (*style).font,
        );
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_text_wrap(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
) -> () {
    if ctx.is_null() {
        return;
    } else {
        nk_text_wrap_colored(ctx, str, len, (*ctx).style.text.color);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_text_wrap_colored(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut color: nk_color,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut item_padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        nk_panel_alloc_space(&mut bounds, ctx);
        item_padding = (*style).text.padding;
        text.padding.x = item_padding.x;
        text.padding.y = item_padding.y;
        text.background = (*style).window.background;
        text.text = color;
        nk_widget_text_wrap(
            &mut (*win).buffer,
            bounds,
            str,
            len,
            &mut text,
            (*style).font,
        );
        return;
    };
}
unsafe fn nk_widget_text_wrap(
    mut o: *mut nk_command_buffer,
    mut b: nk_rect,
    mut string: *const libc::c_char,
    mut len: libc::c_int,
    mut t: *const nk_text,
    mut f: *const nk_user_font,
) -> () {
    let mut width: f32 = 0.;
    let mut glyphs: libc::c_int = 0i32;
    let mut fitting: libc::c_int = 0i32;
    let mut done: libc::c_int = 0i32;
    let mut line: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    static mut seperator: [nk_rune; 1] = unsafe { [' ' as i32 as nk_rune] };
    if o.is_null() || t.is_null() {
        return;
    } else {
        text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
        text.background = (*t).background;
        text.text = (*t).text;
        b.w = if b.w < 2i32 as f32 * (*t).padding.x {
            2i32 as f32 * (*t).padding.x
        } else {
            b.w
        };
        b.h = if b.h < 2i32 as f32 * (*t).padding.y {
            2i32 as f32 * (*t).padding.y
        } else {
            b.h
        };
        b.h = b.h - 2i32 as f32 * (*t).padding.y;
        line.x = b.x + (*t).padding.x;
        line.y = b.y + (*t).padding.y;
        line.w = b.w - 2i32 as f32 * (*t).padding.x;
        line.h = 2i32 as f32 * (*t).padding.y + (*f).height;
        fitting = nk_text_clamp(
            f,
            string,
            len,
            line.w,
            &mut glyphs,
            &mut width,
            seperator.as_mut_ptr(),
            (::std::mem::size_of::<[nk_rune; 1]>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<nk_rune>() as libc::c_ulong)
                as libc::c_int,
        );
        while done < len {
            if 0 == fitting || line.y + line.h >= b.y + b.h {
                break;
            }
            nk_widget_text(
                o,
                line,
                &*string.offset(done as isize),
                fitting,
                &mut text,
                NK_TEXT_LEFT as libc::c_int as nk_flags,
                f,
            );
            done += fitting;
            line.y += (*f).height + 2i32 as f32 * (*t).padding.y;
            fitting = nk_text_clamp(
                f,
                &*string.offset(done as isize),
                len - done,
                line.w,
                &mut glyphs,
                &mut width,
                seperator.as_mut_ptr(),
                (::std::mem::size_of::<[nk_rune; 1]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<nk_rune>() as libc::c_ulong)
                    as libc::c_int,
            )
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_label(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut alignment: nk_flags,
) -> () {
    nk_text(ctx, str, nk_strlen(str), alignment);
}
#[no_mangle]
pub unsafe fn nk_label_colored(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut align: nk_flags,
    mut color: nk_color,
) -> () {
    nk_text_colored(ctx, str, nk_strlen(str), align, color);
}
#[no_mangle]
pub unsafe fn nk_label_wrap(mut ctx: *mut nk_context, mut str: *const libc::c_char) -> () {
    nk_text_wrap(ctx, str, nk_strlen(str));
}
#[no_mangle]
pub unsafe fn nk_label_colored_wrap(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut color: nk_color,
) -> () {
    nk_text_wrap_colored(ctx, str, nk_strlen(str), color);
}
#[no_mangle]
pub unsafe fn nk_image(mut ctx: *mut nk_context, mut img: nk_image) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        if 0 == nk_widget(&mut bounds, ctx) as u64 {
            return;
        } else {
            nk_draw_image(&mut (*win).buffer, bounds, &mut img, nk_white);
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_image_color(mut ctx: *mut nk_context, mut img: nk_image, mut col: nk_color) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        if 0 == nk_widget(&mut bounds, ctx) as u64 {
            return;
        } else {
            nk_draw_image(&mut (*win).buffer, bounds, &mut img, col);
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_button_text(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    if ctx.is_null() {
        return 0i32;
    } else {
        return nk_button_text_styled(ctx, &mut (*ctx).style.button, title, len);
    };
}
#[no_mangle]
pub unsafe fn nk_button_text_styled(
    mut ctx: *mut nk_context,
    mut style: *const nk_style_button,
    mut title: *const libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if style.is_null()
        || ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            return nk_do_button_text(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                title,
                len,
                (*style).text_alignment,
                (*ctx).button_behavior,
                style,
                in_0,
                (*ctx).style.font,
            );
        }
    };
}
unsafe fn nk_do_button_text(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut string: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut behavior: nk_button_behavior,
    mut style: *const nk_style_button,
    mut in_0: *const nk_input,
    mut font: *const nk_user_font,
) -> libc::c_int {
    let mut content: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut ret: libc::c_int = nk_false as libc::c_int;
    if out.is_null() || style.is_null() || font.is_null() || string.is_null() {
        return nk_false as libc::c_int;
    } else {
        ret = nk_do_button(state, out, bounds, style, in_0, behavior, &mut content);
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_button_text(
            out,
            &mut bounds,
            &mut content,
            *state,
            style,
            string,
            len,
            align,
            font,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return ret;
    };
}
unsafe fn nk_draw_button_text(
    mut out: *mut nk_command_buffer,
    mut bounds: *const nk_rect,
    mut content: *const nk_rect,
    mut state: nk_flags,
    mut style: *const nk_style_button,
    mut txt: *const libc::c_char,
    mut len: libc::c_int,
    mut text_alignment: nk_flags,
    mut font: *const nk_user_font,
) -> () {
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    background = nk_draw_button(out, bounds, state, style);
    /* select correct colors/images */
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint {
        text.background = (*background).data.color
    } else {
        text.background = (*style).text_background
    }
    if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        text.text = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        text.text = (*style).text_active
    } else {
        text.text = (*style).text_normal
    }
    text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
    nk_widget_text(out, *content, txt, len, &mut text, text_alignment, font);
}
#[no_mangle]
pub unsafe fn nk_button_label(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
) -> libc::c_int {
    return nk_button_text(ctx, title, nk_strlen(title));
}
#[no_mangle]
pub unsafe fn nk_button_color(mut ctx: *mut nk_context, mut color: nk_color) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut button: nk_style_button = nk_style_button {
        normal: nk_style_item {
            type_0: NK_STYLE_ITEM_COLOR,
            data: nk_style_item_data {
                image: nk_image {
                    handle: nk_handle {
                        ptr: 0 as *mut libc::c_void,
                    },
                    w: 0,
                    h: 0,
                    region: [0; 4],
                },
            },
        },
        hover: nk_style_item {
            type_0: NK_STYLE_ITEM_COLOR,
            data: nk_style_item_data {
                image: nk_image {
                    handle: nk_handle {
                        ptr: 0 as *mut libc::c_void,
                    },
                    w: 0,
                    h: 0,
                    region: [0; 4],
                },
            },
        },
        active: nk_style_item {
            type_0: NK_STYLE_ITEM_COLOR,
            data: nk_style_item_data {
                image: nk_image {
                    handle: nk_handle {
                        ptr: 0 as *mut libc::c_void,
                    },
                    w: 0,
                    h: 0,
                    region: [0; 4],
                },
            },
        },
        border_color: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text_background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text_normal: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text_hover: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text_active: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text_alignment: 0,
        border: 0.,
        rounding: 0.,
        padding: nk_vec2 { x: 0., y: 0. },
        image_padding: nk_vec2 { x: 0., y: 0. },
        touch_padding: nk_vec2 { x: 0., y: 0. },
        userdata: nk_handle {
            ptr: 0 as *mut libc::c_void,
        },
        draw_begin: None,
        draw_end: None,
    };
    let mut ret: libc::c_int = 0i32;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut content: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            button = (*ctx).style.button;
            button.normal = nk_style_item_color(color);
            button.hover = nk_style_item_color(color);
            button.active = nk_style_item_color(color);
            ret = nk_do_button(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                &mut button,
                in_0,
                (*ctx).button_behavior,
                &mut content,
            );
            nk_draw_button(
                &mut (*win).buffer,
                &mut bounds,
                (*ctx).last_widget_state,
                &mut button,
            );
            return ret;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_button_symbol(
    mut ctx: *mut nk_context,
    mut symbol: nk_symbol_type,
) -> libc::c_int {
    if ctx.is_null() {
        return 0i32;
    } else {
        return nk_button_symbol_styled(ctx, &mut (*ctx).style.button, symbol);
    };
}
#[no_mangle]
pub unsafe fn nk_button_symbol_styled(
    mut ctx: *mut nk_context,
    mut style: *const nk_style_button,
    mut symbol: nk_symbol_type,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            return nk_do_button_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                symbol,
                (*ctx).button_behavior,
                style,
                in_0,
                (*ctx).style.font,
            );
        }
    };
}
#[no_mangle]
pub unsafe fn nk_button_image(mut ctx: *mut nk_context, mut img: nk_image) -> libc::c_int {
    if ctx.is_null() {
        return 0i32;
    } else {
        return nk_button_image_styled(ctx, &mut (*ctx).style.button, img);
    };
}
#[no_mangle]
pub unsafe fn nk_button_image_styled(
    mut ctx: *mut nk_context,
    mut style: *const nk_style_button,
    mut img: nk_image,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            return nk_do_button_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                img,
                (*ctx).button_behavior,
                style,
                in_0,
            );
        }
    };
}
unsafe fn nk_do_button_image(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut img: nk_image,
    mut b: nk_button_behavior,
    mut style: *const nk_style_button,
    mut in_0: *const nk_input,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut content: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() || state.is_null() {
        return nk_false as libc::c_int;
    } else {
        ret = nk_do_button(state, out, bounds, style, in_0, b, &mut content);
        content.x += (*style).image_padding.x;
        content.y += (*style).image_padding.y;
        content.w -= 2i32 as f32 * (*style).image_padding.x;
        content.h -= 2i32 as f32 * (*style).image_padding.y;
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_button_image(out, &mut bounds, &mut content, *state, style, &mut img);
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return ret;
    };
}
unsafe fn nk_draw_button_image(
    mut out: *mut nk_command_buffer,
    mut bounds: *const nk_rect,
    mut content: *const nk_rect,
    mut state: nk_flags,
    mut style: *const nk_style_button,
    mut img: *const nk_image,
) -> () {
    nk_draw_button(out, bounds, state, style);
    nk_draw_image(out, *content, img, nk_white);
}
#[no_mangle]
pub unsafe fn nk_button_symbol_label(
    mut ctx: *mut nk_context,
    mut symbol: nk_symbol_type,
    mut label: *const libc::c_char,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_button_symbol_text(ctx, symbol, label, nk_strlen(label), align);
}
#[no_mangle]
pub unsafe fn nk_button_symbol_text(
    mut ctx: *mut nk_context,
    mut symbol: nk_symbol_type,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
) -> libc::c_int {
    if ctx.is_null() {
        return 0i32;
    } else {
        return nk_button_symbol_text_styled(
            ctx,
            &mut (*ctx).style.button,
            symbol,
            text,
            len,
            align,
        );
    };
}
#[no_mangle]
pub unsafe fn nk_button_symbol_text_styled(
    mut ctx: *mut nk_context,
    mut style: *const nk_style_button,
    mut symbol: nk_symbol_type,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            return nk_do_button_text_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                symbol,
                text,
                len,
                align,
                (*ctx).button_behavior,
                style,
                (*ctx).style.font,
                in_0,
            );
        }
    };
}
unsafe fn nk_do_button_text_symbol(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut symbol: nk_symbol_type,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut behavior: nk_button_behavior,
    mut style: *const nk_style_button,
    mut font: *const nk_user_font,
    mut in_0: *const nk_input,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut tri: nk_rect = nk_rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    let mut content: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() || font.is_null() {
        return nk_false as libc::c_int;
    } else {
        ret = nk_do_button(state, out, bounds, style, in_0, behavior, &mut content);
        tri.y =
            content.y + content.h / 2i32 as f32 - (*font).height / 2i32 as f32;
        tri.w = (*font).height;
        tri.h = (*font).height;
        if 0 != align & NK_TEXT_ALIGN_LEFT as libc::c_int as libc::c_uint {
            tri.x = content.x + content.w - (2i32 as f32 * (*style).padding.x + tri.w);
            tri.x = if tri.x < 0i32 as f32 {
                0i32 as f32
            } else {
                tri.x
            }
        } else {
            tri.x = content.x + 2i32 as f32 * (*style).padding.x
        }
        /* draw button */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_button_text_symbol(
            out,
            &mut bounds,
            &mut content,
            &mut tri,
            *state,
            style,
            str,
            len,
            symbol,
            font,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return ret;
    };
}
unsafe fn nk_draw_button_text_symbol(
    mut out: *mut nk_command_buffer,
    mut bounds: *const nk_rect,
    mut label: *const nk_rect,
    mut symbol: *const nk_rect,
    mut state: nk_flags,
    mut style: *const nk_style_button,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut type_0: nk_symbol_type,
    mut font: *const nk_user_font,
) -> () {
    let mut sym: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    /* select correct background colors/images */
    background = nk_draw_button(out, bounds, state, style);
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint {
        text.background = (*background).data.color
    } else {
        text.background = (*style).text_background
    }
    /* select correct text colors */
    if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        sym = (*style).text_hover;
        text.text = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        sym = (*style).text_active;
        text.text = (*style).text_active
    } else {
        sym = (*style).text_normal;
        text.text = (*style).text_normal
    }
    text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
    nk_draw_symbol(
        out,
        type_0,
        *symbol,
        (*style).text_background,
        sym,
        0i32 as f32,
        font,
    );
    nk_widget_text(
        out,
        *label,
        str,
        len,
        &mut text,
        NK_TEXT_CENTERED as libc::c_int as nk_flags,
        font,
    );
}
#[no_mangle]
pub unsafe fn nk_button_image_label(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut label: *const libc::c_char,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_button_image_text(ctx, img, label, nk_strlen(label), align);
}
#[no_mangle]
pub unsafe fn nk_button_image_text(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_button_image_text_styled(ctx, &mut (*ctx).style.button, img, text, len, align);
}
#[no_mangle]
pub unsafe fn nk_button_image_text_styled(
    mut ctx: *mut nk_context,
    mut style: *const nk_style_button,
    mut img: nk_image,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            return nk_do_button_text_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                img,
                text,
                len,
                align,
                (*ctx).button_behavior,
                style,
                (*ctx).style.font,
                in_0,
            );
        }
    };
}
unsafe fn nk_do_button_text_image(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut img: nk_image,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut behavior: nk_button_behavior,
    mut style: *const nk_style_button,
    mut font: *const nk_user_font,
    mut in_0: *const nk_input,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut icon: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut content: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || font.is_null() || style.is_null() || str.is_null() {
        return nk_false as libc::c_int;
    } else {
        ret = nk_do_button(state, out, bounds, style, in_0, behavior, &mut content);
        icon.y = bounds.y + (*style).padding.y;
        icon.h = bounds.h - 2i32 as f32 * (*style).padding.y;
        icon.w = icon.h;
        if 0 != align & NK_TEXT_ALIGN_LEFT as libc::c_int as libc::c_uint {
            icon.x = bounds.x + bounds.w - (2i32 as f32 * (*style).padding.x + icon.w);
            icon.x = if icon.x < 0i32 as f32 {
                0i32 as f32
            } else {
                icon.x
            }
        } else {
            icon.x = bounds.x + 2i32 as f32 * (*style).padding.x
        }
        icon.x += (*style).image_padding.x;
        icon.y += (*style).image_padding.y;
        icon.w -= 2i32 as f32 * (*style).image_padding.x;
        icon.h -= 2i32 as f32 * (*style).image_padding.y;
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_button_text_image(
            out,
            &mut bounds,
            &mut content,
            &mut icon,
            *state,
            style,
            str,
            len,
            font,
            &mut img,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return ret;
    };
}
unsafe fn nk_draw_button_text_image(
    mut out: *mut nk_command_buffer,
    mut bounds: *const nk_rect,
    mut label: *const nk_rect,
    mut image: *const nk_rect,
    mut state: nk_flags,
    mut style: *const nk_style_button,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut font: *const nk_user_font,
    mut img: *const nk_image,
) -> () {
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    background = nk_draw_button(out, bounds, state, style);
    /* select correct colors */
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint {
        text.background = (*background).data.color
    } else {
        text.background = (*style).text_background
    }
    if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        text.text = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        text.text = (*style).text_active
    } else {
        text.text = (*style).text_normal
    }
    text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
    nk_widget_text(
        out,
        *label,
        str,
        len,
        &mut text,
        NK_TEXT_CENTERED as libc::c_int as nk_flags,
        font,
    );
    nk_draw_image(out, *image, img, nk_white);
}
#[no_mangle]
pub unsafe fn nk_button_label_styled(
    mut ctx: *mut nk_context,
    mut style: *const nk_style_button,
    mut title: *const libc::c_char,
) -> libc::c_int {
    return nk_button_text_styled(ctx, style, title, nk_strlen(title));
}
#[no_mangle]
pub unsafe fn nk_button_symbol_label_styled(
    mut ctx: *mut nk_context,
    mut style: *const nk_style_button,
    mut symbol: nk_symbol_type,
    mut title: *const libc::c_char,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_button_symbol_text_styled(ctx, style, symbol, title, nk_strlen(title), align);
}
#[no_mangle]
pub unsafe fn nk_button_image_label_styled(
    mut ctx: *mut nk_context,
    mut style: *const nk_style_button,
    mut img: nk_image,
    mut label: *const libc::c_char,
    mut text_alignment: nk_flags,
) -> libc::c_int {
    return nk_button_image_text_styled(ctx, style, img, label, nk_strlen(label), text_alignment);
}
#[no_mangle]
pub unsafe fn nk_button_set_behavior(
    mut ctx: *mut nk_context,
    mut behavior: nk_button_behavior,
) -> () {
    if ctx.is_null() {
        return;
    } else {
        (*ctx).button_behavior = behavior;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_button_push_behavior(
    mut ctx: *mut nk_context,
    mut behavior: nk_button_behavior,
) -> libc::c_int {
    let mut button_stack: *mut nk_config_stack_button_behavior =
        0 as *mut nk_config_stack_button_behavior;
    let mut element: *mut nk_config_stack_button_behavior_element =
        0 as *mut nk_config_stack_button_behavior_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        button_stack = &mut (*ctx).stacks.button_behaviors as *mut nk_config_stack_button_behavior;
        if (*button_stack).head
            >= (::std::mem::size_of::<[nk_config_stack_button_behavior_element; 8]>()
                as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<nk_config_stack_button_behavior_element>()
                        as libc::c_ulong,
                ) as libc::c_int
        {
            return 0i32;
        } else {
            let fresh19 = (*button_stack).head;
            (*button_stack).head = (*button_stack).head + 1;
            element = &mut (*button_stack).elements[fresh19 as usize]
                as *mut nk_config_stack_button_behavior_element;
            (*element).address = &mut (*ctx).button_behavior as *mut nk_button_behavior;
            (*element).old_value = (*ctx).button_behavior;
            (*ctx).button_behavior = behavior;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_button_pop_behavior(mut ctx: *mut nk_context) -> libc::c_int {
    let mut button_stack: *mut nk_config_stack_button_behavior =
        0 as *mut nk_config_stack_button_behavior;
    let mut element: *mut nk_config_stack_button_behavior_element =
        0 as *mut nk_config_stack_button_behavior_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        button_stack = &mut (*ctx).stacks.button_behaviors as *mut nk_config_stack_button_behavior;
        if (*button_stack).head < 1i32 {
            return 0i32;
        } else {
            (*button_stack).head -= 1;
            element = &mut (*button_stack).elements[(*button_stack).head as usize]
                as *mut nk_config_stack_button_behavior_element;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_check_label(
    mut ctx: *mut nk_context,
    mut label: *const libc::c_char,
    mut active: libc::c_int,
) -> libc::c_int {
    return nk_check_text(ctx, label, nk_strlen(label), active);
}
#[no_mangle]
pub unsafe fn nk_check_text(
    mut ctx: *mut nk_context,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut active: libc::c_int,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return active;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return active;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            nk_do_toggle(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                &mut active,
                text,
                len,
                NK_TOGGLE_CHECK,
                &(*style).checkbox,
                in_0,
                (*style).font,
            );
            return active;
        }
    };
}
unsafe fn nk_do_toggle(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut r: nk_rect,
    mut active: *mut libc::c_int,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut type_0: nk_toggle_type,
    mut style: *const nk_style_toggle,
    mut in_0: *const nk_input,
    mut font: *const nk_user_font,
) -> libc::c_int {
    let mut was_active: libc::c_int = 0;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut select: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut cursor: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut label: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() || font.is_null() || active.is_null() {
        return 0i32;
    } else {
        r.w = if r.w < (*font).height + 2i32 as f32 * (*style).padding.x {
            (*font).height + 2i32 as f32 * (*style).padding.x
        } else {
            r.w
        };
        r.h = if r.h < (*font).height + 2i32 as f32 * (*style).padding.y {
            (*font).height + 2i32 as f32 * (*style).padding.y
        } else {
            r.h
        };
        /* add additional touch padding for touch screen devices */
        bounds.x = r.x - (*style).touch_padding.x;
        bounds.y = r.y - (*style).touch_padding.y;
        bounds.w = r.w + 2i32 as f32 * (*style).touch_padding.x;
        bounds.h = r.h + 2i32 as f32 * (*style).touch_padding.y;
        /* calculate the selector space */
        select.w = (*font).height;
        select.h = select.w;
        select.y = r.y + r.h / 2.0f32 - select.h / 2.0f32;
        select.x = r.x;
        /* calculate the bounds of the cursor inside the selector */
        cursor.x = select.x + (*style).padding.x + (*style).border;
        cursor.y = select.y + (*style).padding.y + (*style).border;
        cursor.w = select.w
            - (2i32 as f32 * (*style).padding.x
                + 2i32 as f32 * (*style).border);
        cursor.h = select.h
            - (2i32 as f32 * (*style).padding.y
                + 2i32 as f32 * (*style).border);
        /* label behind the selector */
        label.x = select.x + select.w + (*style).spacing;
        label.y = select.y;
        label.w = if r.x + r.w < label.x {
            label.x
        } else {
            r.x + r.w
        } - label.x;
        label.h = select.w;
        /* update selector */
        was_active = *active;
        *active = nk_toggle_behavior(in_0, bounds, state, *active);
        /* draw selector */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        if type_0 as libc::c_uint == NK_TOGGLE_CHECK as libc::c_int as libc::c_uint {
            nk_draw_checkbox(
                out,
                *state,
                style,
                *active,
                &mut label,
                &mut select,
                &mut cursor,
                str,
                len,
                font,
            );
        } else {
            nk_draw_option(
                out,
                *state,
                style,
                *active,
                &mut label,
                &mut select,
                &mut cursor,
                str,
                len,
                font,
            );
        }
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return (was_active != *active) as libc::c_int;
    };
}
unsafe fn nk_draw_option(
    mut out: *mut nk_command_buffer,
    mut state: nk_flags,
    mut style: *const nk_style_toggle,
    mut active: libc::c_int,
    mut label: *const nk_rect,
    mut selector: *const nk_rect,
    mut cursors: *const nk_rect,
    mut string: *const libc::c_char,
    mut len: libc::c_int,
    mut font: *const nk_user_font,
) -> () {
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    let mut cursor: *const nk_style_item = 0 as *const nk_style_item;
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    /* select correct colors/images */
    if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        background = &(*style).hover as *const nk_style_item;
        cursor = &(*style).cursor_hover as *const nk_style_item;
        text.text = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        background = &(*style).hover as *const nk_style_item;
        cursor = &(*style).cursor_hover as *const nk_style_item;
        text.text = (*style).text_active
    } else {
        background = &(*style).normal as *const nk_style_item;
        cursor = &(*style).cursor_normal as *const nk_style_item;
        text.text = (*style).text_normal
    }
    /* draw background and cursor */
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint {
        nk_fill_circle(out, *selector, (*style).border_color);
        nk_fill_circle(
            out,
            nk_shrink_rect(*selector, (*style).border),
            (*background).data.color,
        );
    } else {
        nk_draw_image(out, *selector, &(*background).data.image, nk_white);
    }
    if 0 != active {
        if (*cursor).type_0 as libc::c_uint == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint {
            nk_draw_image(out, *cursors, &(*cursor).data.image, nk_white);
        } else {
            nk_fill_circle(out, *cursors, (*cursor).data.color);
        }
    }
    text.padding.x = 0i32 as f32;
    text.padding.y = 0i32 as f32;
    text.background = (*style).text_background;
    nk_widget_text(
        out,
        *label,
        string,
        len,
        &mut text,
        NK_TEXT_LEFT as libc::c_int as nk_flags,
        font,
    );
}
unsafe fn nk_draw_checkbox(
    mut out: *mut nk_command_buffer,
    mut state: nk_flags,
    mut style: *const nk_style_toggle,
    mut active: libc::c_int,
    mut label: *const nk_rect,
    mut selector: *const nk_rect,
    mut cursors: *const nk_rect,
    mut string: *const libc::c_char,
    mut len: libc::c_int,
    mut font: *const nk_user_font,
) -> () {
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    let mut cursor: *const nk_style_item = 0 as *const nk_style_item;
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    /* select correct colors/images */
    if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        background = &(*style).hover as *const nk_style_item;
        cursor = &(*style).cursor_hover as *const nk_style_item;
        text.text = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        background = &(*style).hover as *const nk_style_item;
        cursor = &(*style).cursor_hover as *const nk_style_item;
        text.text = (*style).text_active
    } else {
        background = &(*style).normal as *const nk_style_item;
        cursor = &(*style).cursor_normal as *const nk_style_item;
        text.text = (*style).text_normal
    }
    /* draw background and cursor */
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint {
        nk_fill_rect(out, *selector, 0i32 as f32, (*style).border_color);
        nk_fill_rect(
            out,
            nk_shrink_rect(*selector, (*style).border),
            0i32 as f32,
            (*background).data.color,
        );
    } else {
        nk_draw_image(out, *selector, &(*background).data.image, nk_white);
    }
    if 0 != active {
        if (*cursor).type_0 as libc::c_uint == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint {
            nk_draw_image(out, *cursors, &(*cursor).data.image, nk_white);
        } else {
            nk_fill_rect(out, *cursors, 0i32 as f32, (*cursor).data.color);
        }
    }
    text.padding.x = 0i32 as f32;
    text.padding.y = 0i32 as f32;
    text.background = (*style).text_background;
    nk_widget_text(
        out,
        *label,
        string,
        len,
        &mut text,
        NK_TEXT_LEFT as libc::c_int as nk_flags,
        font,
    );
}
unsafe fn nk_toggle_behavior(
    mut in_0: *const nk_input,
    mut select: nk_rect,
    mut state: *mut nk_flags,
    mut active: libc::c_int,
) -> libc::c_int {
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as libc::c_int as libc::c_uint {
        *state = (NK_WIDGET_STATE_INACTIVE as libc::c_int | NK_WIDGET_STATE_MODIFIED as libc::c_int)
            as nk_flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as libc::c_int as nk_flags
    }
    if 0 != nk_button_behavior(state, select, in_0, NK_BUTTON_DEFAULT) {
        *state = NK_WIDGET_STATE_ACTIVE as libc::c_int as nk_flags;
        active = (0 == active) as libc::c_int
    }
    if 0 != *state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
        && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, select)
    {
        *state |= NK_WIDGET_STATE_ENTERED as libc::c_int as libc::c_uint
    } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, select) {
        *state |= NK_WIDGET_STATE_LEFT as libc::c_int as libc::c_uint
    }
    return active;
}
#[no_mangle]
pub unsafe fn nk_check_flags_label(
    mut ctx: *mut nk_context,
    mut label: *const libc::c_char,
    mut flags: libc::c_uint,
    mut value: libc::c_uint,
) -> libc::c_uint {
    return nk_check_flags_text(ctx, label, nk_strlen(label), flags, value);
}
#[no_mangle]
pub unsafe fn nk_check_flags_text(
    mut ctx: *mut nk_context,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut flags: libc::c_uint,
    mut value: libc::c_uint,
) -> libc::c_uint {
    let mut old_active: libc::c_int = 0;
    if ctx.is_null() || text.is_null() {
        return flags;
    } else {
        old_active = (flags & value & value) as libc::c_int;
        if 0 != nk_check_text(ctx, text, len, old_active) {
            flags |= value
        } else {
            flags &= !value
        }
        return flags;
    };
}
#[no_mangle]
pub unsafe fn nk_checkbox_label(
    mut ctx: *mut nk_context,
    mut label: *const libc::c_char,
    mut active: *mut libc::c_int,
) -> libc::c_int {
    return nk_checkbox_text(ctx, label, nk_strlen(label), active);
}
#[no_mangle]
pub unsafe fn nk_checkbox_text(
    mut ctx: *mut nk_context,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut active: *mut libc::c_int,
) -> libc::c_int {
    let mut old_val: libc::c_int = 0;
    if ctx.is_null() || text.is_null() || active.is_null() {
        return 0i32;
    } else {
        old_val = *active;
        *active = nk_check_text(ctx, text, len, *active);
        return (old_val != *active) as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_checkbox_flags_label(
    mut ctx: *mut nk_context,
    mut label: *const libc::c_char,
    mut flags: *mut libc::c_uint,
    mut value: libc::c_uint,
) -> libc::c_int {
    return nk_checkbox_flags_text(ctx, label, nk_strlen(label), flags, value);
}
#[no_mangle]
pub unsafe fn nk_checkbox_flags_text(
    mut ctx: *mut nk_context,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut flags: *mut libc::c_uint,
    mut value: libc::c_uint,
) -> libc::c_int {
    let mut active: libc::c_int = 0;
    if ctx.is_null() || text.is_null() || flags.is_null() {
        return 0i32;
    } else {
        active = (*flags & value & value) as libc::c_int;
        if 0 != nk_checkbox_text(ctx, text, len, &mut active) {
            if 0 != active {
                *flags |= value
            } else {
                *flags &= !value
            }
            return 1i32;
        } else {
            return 0i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_radio_label(
    mut ctx: *mut nk_context,
    mut label: *const libc::c_char,
    mut active: *mut libc::c_int,
) -> libc::c_int {
    return nk_radio_text(ctx, label, nk_strlen(label), active);
}
#[no_mangle]
pub unsafe fn nk_radio_text(
    mut ctx: *mut nk_context,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut active: *mut libc::c_int,
) -> libc::c_int {
    let mut old_value: libc::c_int = 0;
    if ctx.is_null() || text.is_null() || active.is_null() {
        return 0i32;
    } else {
        old_value = *active;
        *active = nk_option_text(ctx, text, len, old_value);
        return (old_value != *active) as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_option_text(
    mut ctx: *mut nk_context,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut is_active: libc::c_int,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return is_active;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return state as libc::c_int;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            nk_do_toggle(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                &mut is_active,
                text,
                len,
                NK_TOGGLE_OPTION,
                &(*style).option,
                in_0,
                (*style).font,
            );
            return is_active;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_option_label(
    mut ctx: *mut nk_context,
    mut label: *const libc::c_char,
    mut active: libc::c_int,
) -> libc::c_int {
    return nk_option_text(ctx, label, nk_strlen(label), active);
}
#[no_mangle]
pub unsafe fn nk_selectable_label(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut align: nk_flags,
    mut value: *mut libc::c_int,
) -> libc::c_int {
    return nk_selectable_text(ctx, str, nk_strlen(str), align, value);
}
#[no_mangle]
pub unsafe fn nk_selectable_text(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut value: *mut libc::c_int,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || value.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        style = &mut (*ctx).style as *mut nk_style;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            return nk_do_selectable(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                str,
                len,
                align,
                value,
                &(*style).selectable,
                in_0,
                (*style).font,
            );
        }
    };
}
#[no_mangle]
pub unsafe fn nk_selectable_image_label(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut str: *const libc::c_char,
    mut align: nk_flags,
    mut value: *mut libc::c_int,
) -> libc::c_int {
    return nk_selectable_image_text(ctx, img, str, nk_strlen(str), align, value);
}
#[no_mangle]
pub unsafe fn nk_selectable_image_text(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut value: *mut libc::c_int,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || value.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        style = &mut (*ctx).style as *mut nk_style;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            return nk_do_selectable_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                str,
                len,
                align,
                value,
                &mut img,
                &(*style).selectable,
                in_0,
                (*style).font,
            );
        }
    };
}
#[no_mangle]
pub unsafe fn nk_selectable_symbol_label(
    mut ctx: *mut nk_context,
    mut sym: nk_symbol_type,
    mut title: *const libc::c_char,
    mut align: nk_flags,
    mut value: *mut libc::c_int,
) -> libc::c_int {
    return nk_selectable_symbol_text(ctx, sym, title, nk_strlen(title), align, value);
}
#[no_mangle]
pub unsafe fn nk_selectable_symbol_text(
    mut ctx: *mut nk_context,
    mut sym: nk_symbol_type,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut value: *mut libc::c_int,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || value.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        style = &mut (*ctx).style as *mut nk_style;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            return nk_do_selectable_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                str,
                len,
                align,
                value,
                sym,
                &(*style).selectable,
                in_0,
                (*style).font,
            );
        }
    };
}
unsafe fn nk_do_selectable_symbol(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut value: *mut libc::c_int,
    mut sym: nk_symbol_type,
    mut style: *const nk_style_selectable,
    mut in_0: *const nk_input,
    mut font: *const nk_user_font,
) -> libc::c_int {
    let mut old_value: libc::c_int = 0;
    let mut touch: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut icon: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if state.is_null()
        || out.is_null()
        || str.is_null()
        || 0 == len
        || value.is_null()
        || style.is_null()
        || font.is_null()
    {
        return 0i32;
    } else {
        old_value = *value;
        /* toggle behavior */
        touch.x = bounds.x - (*style).touch_padding.x;
        touch.y = bounds.y - (*style).touch_padding.y;
        touch.w = bounds.w + (*style).touch_padding.x * 2i32 as f32;
        touch.h = bounds.h + (*style).touch_padding.y * 2i32 as f32;
        if 0 != nk_button_behavior(state, touch, in_0, NK_BUTTON_DEFAULT) {
            *value = (0 == *value) as libc::c_int
        }
        icon.y = bounds.y + (*style).padding.y;
        icon.h = bounds.h - 2i32 as f32 * (*style).padding.y;
        icon.w = icon.h;
        if 0 != align & NK_TEXT_ALIGN_LEFT as libc::c_int as libc::c_uint {
            icon.x = bounds.x + bounds.w - (2i32 as f32 * (*style).padding.x + icon.w);
            icon.x = if icon.x < 0i32 as f32 {
                0i32 as f32
            } else {
                icon.x
            }
        } else {
            icon.x = bounds.x + 2i32 as f32 * (*style).padding.x
        }
        icon.x += (*style).image_padding.x;
        icon.y += (*style).image_padding.y;
        icon.w -= 2i32 as f32 * (*style).image_padding.x;
        icon.h -= 2i32 as f32 * (*style).image_padding.y;
        /* draw selectable */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_selectable(
            out,
            *state,
            style,
            *value,
            &mut bounds,
            &mut icon,
            0 as *const nk_image,
            sym,
            str,
            len,
            align,
            font,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return (old_value != *value) as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_select_label(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut align: nk_flags,
    mut value: libc::c_int,
) -> libc::c_int {
    nk_selectable_text(ctx, str, nk_strlen(str), align, &mut value);
    return value;
}
#[no_mangle]
pub unsafe fn nk_select_text(
    mut ctx: *mut nk_context,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut value: libc::c_int,
) -> libc::c_int {
    nk_selectable_text(ctx, str, len, align, &mut value);
    return value;
}
#[no_mangle]
pub unsafe fn nk_select_image_label(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut str: *const libc::c_char,
    mut align: nk_flags,
    mut value: libc::c_int,
) -> libc::c_int {
    nk_selectable_image_text(ctx, img, str, nk_strlen(str), align, &mut value);
    return value;
}
#[no_mangle]
pub unsafe fn nk_select_image_text(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut value: libc::c_int,
) -> libc::c_int {
    nk_selectable_image_text(ctx, img, str, len, align, &mut value);
    return value;
}
#[no_mangle]
pub unsafe fn nk_select_symbol_label(
    mut ctx: *mut nk_context,
    mut sym: nk_symbol_type,
    mut title: *const libc::c_char,
    mut align: nk_flags,
    mut value: libc::c_int,
) -> libc::c_int {
    return nk_select_symbol_text(ctx, sym, title, nk_strlen(title), align, value);
}
#[no_mangle]
pub unsafe fn nk_select_symbol_text(
    mut ctx: *mut nk_context,
    mut sym: nk_symbol_type,
    mut title: *const libc::c_char,
    mut title_len: libc::c_int,
    mut align: nk_flags,
    mut value: libc::c_int,
) -> libc::c_int {
    nk_selectable_symbol_text(ctx, sym, title, title_len, align, &mut value);
    return value;
}
#[no_mangle]
pub unsafe fn nk_slide_float(
    mut ctx: *mut nk_context,
    mut min: f32,
    mut val: f32,
    mut max: f32,
    mut step: f32,
) -> f32 {
    nk_slider_float(ctx, min, &mut val, max, step);
    return val;
}
#[no_mangle]
pub unsafe fn nk_slider_float(
    mut ctx: *mut nk_context,
    mut min_value: f32,
    mut value: *mut f32,
    mut max_value: f32,
    mut value_step: f32,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut ret: libc::c_int = 0i32;
    let mut old_value: f32 = 0.;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || value.is_null()
    {
        return ret;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return ret;
        } else {
            /*state == NK_WIDGET_ROM || */
            in_0 = if 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            old_value = *value;
            *value = nk_do_slider(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                min_value,
                old_value,
                max_value,
                value_step,
                &(*style).slider,
                in_0,
                (*style).font,
            );
            return (old_value > *value || old_value < *value) as libc::c_int;
        }
    };
}
unsafe fn nk_do_slider(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut min: f32,
    mut val: f32,
    mut max: f32,
    mut step: f32,
    mut style: *const nk_style_slider,
    mut in_0: *mut nk_input,
    mut font: *const nk_user_font,
) -> f32 {
    let mut slider_range: f32 = 0.;
    let mut slider_min: f32 = 0.;
    let mut slider_max: f32 = 0.;
    let mut slider_value: f32 = 0.;
    let mut slider_steps: f32 = 0.;
    let mut cursor_offset: f32 = 0.;
    let mut visual_cursor: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut logical_cursor: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() {
        return 0i32 as f32;
    } else {
        /* remove padding from slider bounds */
        bounds.x = bounds.x + (*style).padding.x;
        bounds.y = bounds.y + (*style).padding.y;
        bounds.h = if bounds.h < 2i32 as f32 * (*style).padding.y {
            2i32 as f32 * (*style).padding.y
        } else {
            bounds.h
        };
        bounds.w = if bounds.w < 2i32 as f32 * (*style).padding.x + (*style).cursor_size.x
        {
            2i32 as f32 * (*style).padding.x + (*style).cursor_size.x
        } else {
            bounds.w
        };
        bounds.w -= 2i32 as f32 * (*style).padding.x;
        bounds.h -= 2i32 as f32 * (*style).padding.y;
        /* optional buttons */
        if 0 != (*style).show_buttons {
            let mut ws: nk_flags = 0;
            let mut button: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            button.y = bounds.y;
            button.w = bounds.h;
            button.h = bounds.h;
            /* decrement button */
            button.x = bounds.x;
            if 0 != nk_do_button_symbol(
                &mut ws,
                out,
                button,
                (*style).dec_symbol,
                NK_BUTTON_DEFAULT,
                &(*style).dec_button,
                in_0,
                font,
            ) {
                val -= step
            }
            /* increment button */
            button.x = bounds.x + bounds.w - button.w;
            if 0 != nk_do_button_symbol(
                &mut ws,
                out,
                button,
                (*style).inc_symbol,
                NK_BUTTON_DEFAULT,
                &(*style).inc_button,
                in_0,
                font,
            ) {
                val += step
            }
            bounds.x = bounds.x + button.w + (*style).spacing.x;
            bounds.w = bounds.w
                - (2i32 as f32 * button.w + 2i32 as f32 * (*style).spacing.x)
        }
        /* remove one cursor size to support visual cursor */
        bounds.x += (*style).cursor_size.x * 0.5f32;
        bounds.w -= (*style).cursor_size.x;
        /* make sure the provided values are correct */
        slider_max = if min < max { max } else { min };
        slider_min = if min < max { min } else { max };
        slider_value = if if val < slider_max { val } else { slider_max } < slider_min {
            slider_min
        } else if val < slider_max {
            val
        } else {
            slider_max
        };
        slider_range = slider_max - slider_min;
        slider_steps = slider_range / step;
        cursor_offset = (slider_value - slider_min) / step;
        /* calculate cursor
    Basically you have two cursors. One for visual representation and interaction
    and one for updating the actual cursor value. */
        logical_cursor.h = bounds.h;
        logical_cursor.w = bounds.w / slider_steps;
        logical_cursor.x = bounds.x + logical_cursor.w * cursor_offset;
        logical_cursor.y = bounds.y;
        visual_cursor.h = (*style).cursor_size.y;
        visual_cursor.w = (*style).cursor_size.x;
        visual_cursor.y = bounds.y + bounds.h * 0.5f32 - visual_cursor.h * 0.5f32;
        visual_cursor.x = logical_cursor.x - visual_cursor.w * 0.5f32;
        slider_value = nk_slider_behavior(
            state,
            &mut logical_cursor,
            &mut visual_cursor,
            in_0,
            bounds,
            slider_min,
            slider_max,
            slider_value,
            step,
            slider_steps,
        );
        visual_cursor.x = logical_cursor.x - visual_cursor.w * 0.5f32;
        /* draw slider */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_slider(
            out,
            *state,
            style,
            &mut bounds,
            &mut visual_cursor,
            slider_min,
            slider_value,
            slider_max,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return slider_value;
    };
}
unsafe fn nk_draw_slider(
    mut out: *mut nk_command_buffer,
    mut state: nk_flags,
    mut style: *const nk_style_slider,
    mut bounds: *const nk_rect,
    mut visual_cursor: *const nk_rect,
    mut min: f32,
    mut value: f32,
    mut max: f32,
) -> () {
    let mut fill: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut bar: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    /* select correct slider images/colors */
    let mut bar_color: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut cursor: *const nk_style_item = 0 as *const nk_style_item;
    if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        background = &(*style).active as *const nk_style_item;
        bar_color = (*style).bar_active;
        cursor = &(*style).cursor_active as *const nk_style_item
    } else if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        background = &(*style).hover as *const nk_style_item;
        bar_color = (*style).bar_hover;
        cursor = &(*style).cursor_hover as *const nk_style_item
    } else {
        background = &(*style).normal as *const nk_style_item;
        bar_color = (*style).bar_normal;
        cursor = &(*style).cursor_normal as *const nk_style_item
    }
    /* calculate slider background bar */
    bar.x = (*bounds).x;
    bar.y = (*visual_cursor).y + (*visual_cursor).h / 2i32 as f32
        - (*bounds).h / 12i32 as f32;
    bar.w = (*bounds).w;
    bar.h = (*bounds).h / 6i32 as f32;
    /* filled background bar style */
    fill.w = (*visual_cursor).x + (*visual_cursor).w / 2.0f32 - bar.x;
    fill.x = bar.x;
    fill.y = bar.y;
    fill.h = bar.h;
    /* draw background */
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
    } else {
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        nk_stroke_rect(
            out,
            *bounds,
            (*style).rounding,
            (*style).border,
            (*style).border_color,
        );
    }
    /* draw slider bar */
    nk_fill_rect(out, bar, (*style).rounding, bar_color);
    nk_fill_rect(out, fill, (*style).rounding, (*style).bar_filled);
    /* draw cursor */
    if (*cursor).type_0 as libc::c_uint == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint {
        nk_draw_image(out, *visual_cursor, &(*cursor).data.image, nk_white);
    } else {
        nk_fill_circle(out, *visual_cursor, (*cursor).data.color);
    };
}
unsafe fn nk_slider_behavior(
    mut state: *mut nk_flags,
    mut logical_cursor: *mut nk_rect,
    mut visual_cursor: *mut nk_rect,
    mut in_0: *mut nk_input,
    mut bounds: nk_rect,
    mut slider_min: f32,
    mut slider_max: f32,
    mut slider_value: f32,
    mut slider_step: f32,
    mut slider_steps: f32,
) -> f32 {
    let mut left_mouse_down: libc::c_int = 0;
    let mut left_mouse_click_in_cursor: libc::c_int = 0;
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as libc::c_int as libc::c_uint {
        *state = (NK_WIDGET_STATE_INACTIVE as libc::c_int | NK_WIDGET_STATE_MODIFIED as libc::c_int)
            as nk_flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as libc::c_int as nk_flags
    }
    /* check if visual cursor is being dragged */
    left_mouse_down = (!in_0.is_null()
        && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down)
        as libc::c_int;
    left_mouse_click_in_cursor = (!in_0.is_null()
        && 0 != nk_input_has_mouse_click_down_in_rect(
            in_0,
            NK_BUTTON_LEFT,
            *visual_cursor,
            nk_true as libc::c_int,
        )) as libc::c_int;
    if 0 != left_mouse_down && 0 != left_mouse_click_in_cursor {
        let mut ratio: f32 = 0i32 as f32;
        let d: f32 =
            (*in_0).mouse.pos.x - ((*visual_cursor).x + (*visual_cursor).w * 0.5f32);
        let pxstep: f32 = bounds.w / slider_steps;
        /* only update value if the next slider step is reached */
        *state = NK_WIDGET_STATE_ACTIVE as libc::c_int as nk_flags;
        if if d < 0i32 as f32 { -d } else { d } >= pxstep {
            let steps: f32 = (if d < 0i32 as f32 { -d } else { d } / pxstep)
                as libc::c_int as f32;
            slider_value += if d > 0i32 as f32 {
                slider_step * steps
            } else {
                -(slider_step * steps)
            };
            slider_value = if if slider_value < slider_max {
                slider_value
            } else {
                slider_max
            } < slider_min
            {
                slider_min
            } else if slider_value < slider_max {
                slider_value
            } else {
                slider_max
            };
            ratio = (slider_value - slider_min) / slider_step;
            (*logical_cursor).x = bounds.x + (*logical_cursor).w * ratio;
            (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize]
                .clicked_pos
                .x = (*logical_cursor).x
        }
    }
    /* slider widget state */
    if 0 != nk_input_is_mouse_hovering_rect(in_0, bounds) {
        *state = NK_WIDGET_STATE_HOVERED as libc::c_int as nk_flags
    }
    if 0 != *state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
        && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, bounds)
    {
        *state |= NK_WIDGET_STATE_ENTERED as libc::c_int as libc::c_uint
    } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, bounds) {
        *state |= NK_WIDGET_STATE_LEFT as libc::c_int as libc::c_uint
    }
    return slider_value;
}
#[no_mangle]
pub unsafe fn nk_slide_int(
    mut ctx: *mut nk_context,
    mut min: libc::c_int,
    mut val: libc::c_int,
    mut max: libc::c_int,
    mut step: libc::c_int,
) -> libc::c_int {
    let mut value: f32 = val as f32;
    nk_slider_float(
        ctx,
        min as f32,
        &mut value,
        max as f32,
        step as f32,
    );
    return value as libc::c_int;
}
#[no_mangle]
pub unsafe fn nk_slider_int(
    mut ctx: *mut nk_context,
    mut min: libc::c_int,
    mut val: *mut libc::c_int,
    mut max: libc::c_int,
    mut step: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut value: f32 = *val as f32;
    ret = nk_slider_float(
        ctx,
        min as f32,
        &mut value,
        max as f32,
        step as f32,
    );
    *val = value as libc::c_int;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_progress(
    mut ctx: *mut nk_context,
    mut cur: *mut nk_size,
    mut max: nk_size,
    mut is_modifyable: libc::c_int,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut old_value: nk_size = 0;
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || cur.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            old_value = *cur;
            *cur = nk_do_progress(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                *cur,
                max,
                is_modifyable,
                &(*style).progress,
                in_0,
            );
            return (*cur != old_value) as libc::c_int;
        }
    };
}
unsafe fn nk_do_progress(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut value: nk_size,
    mut max: nk_size,
    mut modifiable: libc::c_int,
    mut style: *const nk_style_progress,
    mut in_0: *mut nk_input,
) -> nk_size {
    let mut prog_scale: f32 = 0.;
    let mut prog_value: nk_size = 0;
    let mut cursor: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() {
        return 0i32 as nk_size;
    } else {
        /* calculate progressbar cursor */
        cursor.w = if bounds.w
            < 2i32 as f32 * (*style).padding.x + 2i32 as f32 * (*style).border
        {
            2i32 as f32 * (*style).padding.x + 2i32 as f32 * (*style).border
        } else {
            bounds.w
        };
        cursor.h = if bounds.h
            < 2i32 as f32 * (*style).padding.y + 2i32 as f32 * (*style).border
        {
            2i32 as f32 * (*style).padding.y + 2i32 as f32 * (*style).border
        } else {
            bounds.h
        };
        cursor = nk_pad_rect(
            bounds,
            nk_vec2(
                (*style).padding.x + (*style).border,
                (*style).padding.y + (*style).border,
            ),
        );
        prog_scale = value as f32 / max as f32;
        /* update progressbar */
        prog_value = if value < max { value } else { max };
        prog_value = nk_progress_behavior(state, in_0, bounds, cursor, max, prog_value, modifiable);
        cursor.w = cursor.w * prog_scale;
        /* draw progressbar */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_progress(out, *state, style, &mut bounds, &mut cursor, value, max);
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return prog_value;
    };
}
unsafe fn nk_draw_progress(
    mut out: *mut nk_command_buffer,
    mut state: nk_flags,
    mut style: *const nk_style_progress,
    mut bounds: *const nk_rect,
    mut scursor: *const nk_rect,
    mut value: nk_size,
    mut max: nk_size,
) -> () {
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    let mut cursor: *const nk_style_item = 0 as *const nk_style_item;
    /* select correct colors/images to draw */
    if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        background = &(*style).active as *const nk_style_item;
        cursor = &(*style).cursor_active as *const nk_style_item
    } else if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        background = &(*style).hover as *const nk_style_item;
        cursor = &(*style).cursor_hover as *const nk_style_item
    } else {
        background = &(*style).normal as *const nk_style_item;
        cursor = &(*style).cursor_normal as *const nk_style_item
    }
    /* draw background */
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint {
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        nk_stroke_rect(
            out,
            *bounds,
            (*style).rounding,
            (*style).border,
            (*style).border_color,
        );
    } else {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
    }
    /* draw cursor */
    if (*cursor).type_0 as libc::c_uint == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint {
        nk_fill_rect(out, *scursor, (*style).rounding, (*cursor).data.color);
        nk_stroke_rect(
            out,
            *scursor,
            (*style).rounding,
            (*style).border,
            (*style).border_color,
        );
    } else {
        nk_draw_image(out, *scursor, &(*cursor).data.image, nk_white);
    };
}
unsafe fn nk_progress_behavior(
    mut state: *mut nk_flags,
    mut in_0: *mut nk_input,
    mut r: nk_rect,
    mut cursor: nk_rect,
    mut max: nk_size,
    mut value: nk_size,
    mut modifiable: libc::c_int,
) -> nk_size {
    let mut left_mouse_down: libc::c_int = 0i32;
    let mut left_mouse_click_in_cursor: libc::c_int = 0i32;
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as libc::c_int as libc::c_uint {
        *state = (NK_WIDGET_STATE_INACTIVE as libc::c_int | NK_WIDGET_STATE_MODIFIED as libc::c_int)
            as nk_flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as libc::c_int as nk_flags
    }
    if in_0.is_null() || 0 == modifiable {
        return value;
    } else {
        left_mouse_down = (!in_0.is_null()
            && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down)
            as libc::c_int;
        left_mouse_click_in_cursor = (!in_0.is_null()
            && 0 != nk_input_has_mouse_click_down_in_rect(
                in_0,
                NK_BUTTON_LEFT,
                cursor,
                nk_true as libc::c_int,
            )) as libc::c_int;
        if 0 != nk_input_is_mouse_hovering_rect(in_0, r) {
            *state = NK_WIDGET_STATE_HOVERED as libc::c_int as nk_flags
        }
        if !in_0.is_null() && 0 != left_mouse_down && 0 != left_mouse_click_in_cursor {
            if 0 != left_mouse_down && 0 != left_mouse_click_in_cursor {
                let mut ratio: f32 =
                    if (0i32 as f32) < (*in_0).mouse.pos.x - cursor.x {
                        (*in_0).mouse.pos.x - cursor.x
                    } else {
                        0i32 as f32
                    } / cursor.w;
                value = (if if max as f32 * ratio < max as f32 {
                    max as f32 * ratio
                } else {
                    max as f32
                } < 0i32 as f32
                {
                    0i32 as f32
                } else if max as f32 * ratio < max as f32 {
                    max as f32 * ratio
                } else {
                    max as f32
                }) as nk_size;
                (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize]
                    .clicked_pos
                    .x = cursor.x + cursor.w / 2.0f32;
                *state |= NK_WIDGET_STATE_ACTIVE as libc::c_int as libc::c_uint
            }
        }
        /* set progressbar widget state */
        if 0 != *state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, r)
        {
            *state |= NK_WIDGET_STATE_ENTERED as libc::c_int as libc::c_uint
        } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, r) {
            *state |= NK_WIDGET_STATE_LEFT as libc::c_int as libc::c_uint
        }
        return value;
    };
}
unsafe fn nk_pad_rect(mut r: nk_rect, mut pad: nk_vec2) -> nk_rect {
    r.w = if r.w < 2i32 as f32 * pad.x {
        2i32 as f32 * pad.x
    } else {
        r.w
    };
    r.h = if r.h < 2i32 as f32 * pad.y {
        2i32 as f32 * pad.y
    } else {
        r.h
    };
    r.x += pad.x;
    r.y += pad.y;
    r.w -= 2i32 as f32 * pad.x;
    r.h -= 2i32 as f32 * pad.y;
    return r;
}
#[no_mangle]
pub unsafe fn nk_prog(
    mut ctx: *mut nk_context,
    mut cur: nk_size,
    mut max: nk_size,
    mut modifyable: libc::c_int,
) -> nk_size {
    nk_progress(ctx, &mut cur, max, modifyable);
    return cur;
}
#[no_mangle]
pub unsafe fn nk_color_picker(
    mut ctx: *mut nk_context,
    mut color: nk_colorf,
    mut fmt: nk_color_format,
) -> nk_colorf {
    nk_color_pick(ctx, &mut color, fmt);
    return color;
}
#[no_mangle]
pub unsafe fn nk_color_pick(
    mut ctx: *mut nk_context,
    mut color: *mut nk_colorf,
    mut fmt: nk_color_format,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut config: *const nk_style = 0 as *const nk_style;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || color.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        config = &mut (*ctx).style as *mut nk_style;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            return nk_do_color_picker(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                color,
                fmt,
                bounds,
                nk_vec2(0i32 as f32, 0i32 as f32),
                in_0,
                (*config).font,
            );
        }
    };
}
unsafe fn nk_do_color_picker(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut col: *mut nk_colorf,
    mut fmt: nk_color_format,
    mut bounds: nk_rect,
    mut padding: nk_vec2,
    mut in_0: *const nk_input,
    mut font: *const nk_user_font,
) -> libc::c_int {
    let mut ret: libc::c_int = 0i32;
    let mut matrix: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut hue_bar: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut alpha_bar: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut bar_w: f32 = 0.;
    if out.is_null() || col.is_null() || state.is_null() || font.is_null() {
        return ret;
    } else {
        bar_w = (*font).height;
        bounds.x += padding.x;
        bounds.y += padding.x;
        bounds.w -= 2i32 as f32 * padding.x;
        bounds.h -= 2i32 as f32 * padding.y;
        matrix.x = bounds.x;
        matrix.y = bounds.y;
        matrix.h = bounds.h;
        matrix.w = bounds.w - (3i32 as f32 * padding.x + 2i32 as f32 * bar_w);
        hue_bar.w = bar_w;
        hue_bar.y = bounds.y;
        hue_bar.h = matrix.h;
        hue_bar.x = matrix.x + matrix.w + padding.x;
        alpha_bar.x = hue_bar.x + hue_bar.w + padding.x;
        alpha_bar.y = bounds.y;
        alpha_bar.w = bar_w;
        alpha_bar.h = matrix.h;
        ret = nk_color_picker_behavior(
            state,
            &mut bounds,
            &mut matrix,
            &mut hue_bar,
            if fmt as libc::c_uint == NK_RGBA as libc::c_int as libc::c_uint {
                &mut alpha_bar
            } else {
                0 as *mut nk_rect
            },
            col,
            in_0,
        );
        nk_draw_color_picker(
            out,
            &mut matrix,
            &mut hue_bar,
            if fmt as libc::c_uint == NK_RGBA as libc::c_int as libc::c_uint {
                &mut alpha_bar
            } else {
                0 as *mut nk_rect
            },
            *col,
        );
        return ret;
    };
}
unsafe fn nk_draw_color_picker(
    mut o: *mut nk_command_buffer,
    mut matrix: *const nk_rect,
    mut hue_bar: *const nk_rect,
    mut alpha_bar: *const nk_rect,
    mut col: nk_colorf,
) -> () {
    let mut alpha: f32 = 0.;
    static mut black: nk_color = unsafe {
        nk_color {
            r: 0i32 as nk_byte,
            g: 0i32 as nk_byte,
            b: 0i32 as nk_byte,
            a: 255i32 as nk_byte,
        }
    };
    static mut white: nk_color = unsafe {
        nk_color {
            r: 255i32 as nk_byte,
            g: 255i32 as nk_byte,
            b: 255i32 as nk_byte,
            a: 255i32 as nk_byte,
        }
    };
    static mut black_trans: nk_color = unsafe {
        nk_color {
            r: 0i32 as nk_byte,
            g: 0i32 as nk_byte,
            b: 0i32 as nk_byte,
            a: 0i32 as nk_byte,
        }
    };
    let crosshair_size: f32 = 7.0f32;
    let mut temp: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut hsva: [f32; 4] = [0.; 4];
    let mut line_y: f32 = 0.;
    let mut i: libc::c_int = 0;
    /* draw hue bar */
    nk_colorf_hsva_fv(hsva.as_mut_ptr(), col);
    i = 0i32;
    while i < 6i32 {
        static mut hue_colors: [nk_color; 7] = unsafe {
            [
                nk_color {
                    r: 255i32 as nk_byte,
                    g: 0i32 as nk_byte,
                    b: 0i32 as nk_byte,
                    a: 255i32 as nk_byte,
                },
                nk_color {
                    r: 255i32 as nk_byte,
                    g: 255i32 as nk_byte,
                    b: 0i32 as nk_byte,
                    a: 255i32 as nk_byte,
                },
                nk_color {
                    r: 0i32 as nk_byte,
                    g: 255i32 as nk_byte,
                    b: 0i32 as nk_byte,
                    a: 255i32 as nk_byte,
                },
                nk_color {
                    r: 0i32 as nk_byte,
                    g: 255i32 as nk_byte,
                    b: 255i32 as nk_byte,
                    a: 255i32 as nk_byte,
                },
                nk_color {
                    r: 0i32 as nk_byte,
                    g: 0i32 as nk_byte,
                    b: 255i32 as nk_byte,
                    a: 255i32 as nk_byte,
                },
                nk_color {
                    r: 255i32 as nk_byte,
                    g: 0i32 as nk_byte,
                    b: 255i32 as nk_byte,
                    a: 255i32 as nk_byte,
                },
                nk_color {
                    r: 255i32 as nk_byte,
                    g: 0i32 as nk_byte,
                    b: 0i32 as nk_byte,
                    a: 255i32 as nk_byte,
                },
            ]
        };
        nk_fill_rect_multi_color(
            o,
            nk_rect(
                (*hue_bar).x,
                (*hue_bar).y + i as f32 * ((*hue_bar).h / 6.0f32) + 0.5f32,
                (*hue_bar).w,
                (*hue_bar).h / 6.0f32 + 0.5f32,
            ),
            hue_colors[i as usize],
            hue_colors[i as usize],
            hue_colors[(i + 1i32) as usize],
            hue_colors[(i + 1i32) as usize],
        );
        i += 1
    }
    line_y = ((*hue_bar).y + hsva[0usize] * (*matrix).h + 0.5f32) as libc::c_int as f32;
    nk_stroke_line(
        o,
        (*hue_bar).x - 1i32 as f32,
        line_y,
        (*hue_bar).x + (*hue_bar).w + 2i32 as f32,
        line_y,
        1i32 as f32,
        nk_rgb(255i32, 255i32, 255i32),
    );
    /* draw alpha bar */
    if !alpha_bar.is_null() {
        alpha = if (0i32 as f32) < if 1.0f32 < col.a {
            1.0f32
        } else {
            col.a
        } {
            if 1.0f32 < col.a {
                1.0f32
            } else {
                col.a
            }
        } else {
            0i32 as f32
        };
        line_y = ((*alpha_bar).y + (1.0f32 - alpha) * (*matrix).h + 0.5f32) as libc::c_int
            as f32;
        nk_fill_rect_multi_color(o, *alpha_bar, white, white, black, black);
        nk_stroke_line(
            o,
            (*alpha_bar).x - 1i32 as f32,
            line_y,
            (*alpha_bar).x + (*alpha_bar).w + 2i32 as f32,
            line_y,
            1i32 as f32,
            nk_rgb(255i32, 255i32, 255i32),
        );
    }
    /* draw color matrix */
    temp = nk_hsv_f(hsva[0usize], 1.0f32, 1.0f32);
    nk_fill_rect_multi_color(o, *matrix, white, temp, temp, white);
    nk_fill_rect_multi_color(o, *matrix, black_trans, black_trans, black, black);
    /* draw cross-hair */
    let mut p: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut S: f32 = hsva[1usize];
    let mut V: f32 = hsva[2usize];
    p.x = ((*matrix).x + S * (*matrix).w) as libc::c_int as f32;
    p.y = ((*matrix).y + (1.0f32 - V) * (*matrix).h) as libc::c_int as f32;
    nk_stroke_line(
        o,
        p.x - crosshair_size,
        p.y,
        p.x - 2i32 as f32,
        p.y,
        1.0f32,
        white,
    );
    nk_stroke_line(
        o,
        p.x + crosshair_size + 1i32 as f32,
        p.y,
        p.x + 3i32 as f32,
        p.y,
        1.0f32,
        white,
    );
    nk_stroke_line(
        o,
        p.x,
        p.y + crosshair_size + 1i32 as f32,
        p.x,
        p.y + 3i32 as f32,
        1.0f32,
        white,
    );
    nk_stroke_line(
        o,
        p.x,
        p.y - crosshair_size,
        p.x,
        p.y - 2i32 as f32,
        1.0f32,
        white,
    );
}
#[no_mangle]
pub unsafe fn nk_stroke_line(
    mut b: *mut nk_command_buffer,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
    mut line_thickness: f32,
    mut c: nk_color,
) -> () {
    let mut cmd: *mut nk_command_line = 0 as *mut nk_command_line;
    if b.is_null() || line_thickness <= 0i32 as f32 {
        return;
    } else {
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_LINE,
            ::std::mem::size_of::<nk_command_line>() as libc::c_ulong,
        ) as *mut nk_command_line;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).line_thickness = line_thickness as libc::c_ushort;
            (*cmd).begin.x = x0 as libc::c_short;
            (*cmd).begin.y = y0 as libc::c_short;
            (*cmd).end.x = x1 as libc::c_short;
            (*cmd).end.y = y1 as libc::c_short;
            (*cmd).color = c;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_fill_rect_multi_color(
    mut b: *mut nk_command_buffer,
    mut rect: nk_rect,
    mut left: nk_color,
    mut top: nk_color,
    mut right: nk_color,
    mut bottom: nk_color,
) -> () {
    let mut cmd: *mut nk_command_rect_multi_color = 0 as *mut nk_command_rect_multi_color;
    if b.is_null() || rect.w == 0i32 as f32 || rect.h == 0i32 as f32 {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const nk_rect = &mut (*b).clip as *mut nk_rect;
            if (*clip).x > rect.x + rect.w
                || (*clip).x + (*clip).w < rect.x
                || (*clip).y > rect.y + rect.h
                || (*clip).y + (*clip).h < rect.y
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_RECT_MULTI_COLOR,
            ::std::mem::size_of::<nk_command_rect_multi_color>() as libc::c_ulong,
        ) as *mut nk_command_rect_multi_color;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).x = rect.x as libc::c_short;
            (*cmd).y = rect.y as libc::c_short;
            (*cmd).w = (if (0i32 as f32) < rect.w {
                rect.w
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).h = (if (0i32 as f32) < rect.h {
                rect.h
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).left = left;
            (*cmd).top = top;
            (*cmd).right = right;
            (*cmd).bottom = bottom;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_hsv_f(
    mut h: f32,
    mut s: f32,
    mut v: f32,
) -> nk_color {
    return nk_hsva_f(h, s, v, 1.0f32);
}
#[no_mangle]
pub unsafe fn nk_hsva_f(
    mut h: f32,
    mut s: f32,
    mut v: f32,
    mut a: f32,
) -> nk_color {
    let mut c: nk_colorf = nk_hsva_colorf(h, s, v, a);
    return nk_rgba_f(c.r, c.g, c.b, c.a);
}
#[no_mangle]
pub unsafe fn nk_hsva_colorf(
    mut h: f32,
    mut s: f32,
    mut v: f32,
    mut a: f32,
) -> nk_colorf {
    let mut i: libc::c_int = 0;
    let mut p: f32 = 0.;
    let mut q: f32 = 0.;
    let mut t: f32 = 0.;
    let mut f: f32 = 0.;
    let mut out: nk_colorf = nk_colorf {
        r: 0i32 as f32,
        g: 0i32 as f32,
        b: 0i32 as f32,
        a: 0i32 as f32,
    };
    if s <= 0.0f32 {
        out.r = v;
        out.g = v;
        out.b = v;
        out.a = a;
        return out;
    } else {
        h = h / (60.0f32 / 360.0f32);
        i = h as libc::c_int;
        f = h - i as f32;
        p = v * (1.0f32 - s);
        q = v * (1.0f32 - s * f);
        t = v * (1.0f32 - s * (1.0f32 - f));
        match i {
            1 => {
                out.r = q;
                out.g = v;
                out.b = p
            }
            2 => {
                out.r = p;
                out.g = v;
                out.b = t
            }
            3 => {
                out.r = p;
                out.g = q;
                out.b = v
            }
            4 => {
                out.r = t;
                out.g = p;
                out.b = v
            }
            5 => {
                out.r = v;
                out.g = p;
                out.b = q
            }
            0 | _ => {
                out.r = v;
                out.g = t;
                out.b = p
            }
        }
        out.a = a;
        return out;
    };
}
#[no_mangle]
pub unsafe fn nk_colorf_hsva_fv(mut hsva: *mut f32, mut in_0: nk_colorf) -> () {
    nk_colorf_hsva_f(
        &mut *hsva.offset(0isize),
        &mut *hsva.offset(1isize),
        &mut *hsva.offset(2isize),
        &mut *hsva.offset(3isize),
        in_0,
    );
}
#[no_mangle]
pub unsafe fn nk_colorf_hsva_f(
    mut out_h: *mut f32,
    mut out_s: *mut f32,
    mut out_v: *mut f32,
    mut out_a: *mut f32,
    mut in_0: nk_colorf,
) -> () {
    let mut t_0: f32 = 0.;
    let mut t: f32 = 0.;
    let mut chroma: f32 = 0.;
    let mut K: f32 = 0.0f32;
    if in_0.g < in_0.b {
        t = in_0.g;
        in_0.g = in_0.b;
        in_0.b = t;
        K = -1.0f32
    }
    if in_0.r < in_0.g {
        t_0 = in_0.r;
        in_0.r = in_0.g;
        in_0.g = t_0;
        K = -2.0f32 / 6.0f32 - K
    }
    chroma = in_0.r - if in_0.g < in_0.b {
        in_0.g
    } else {
        in_0.b
    };
    *out_h = if K + (in_0.g - in_0.b) / (6.0f32 * chroma + 9.999999682655225e-21f32)
        < 0i32 as f32
    {
        -(K + (in_0.g - in_0.b) / (6.0f32 * chroma + 9.999999682655225e-21f32))
    } else {
        K + (in_0.g - in_0.b) / (6.0f32 * chroma + 9.999999682655225e-21f32)
    };
    *out_s = chroma / (in_0.r + 9.999999682655225e-21f32);
    *out_v = in_0.r;
    *out_a = in_0.a;
}
unsafe fn nk_color_picker_behavior(
    mut state: *mut nk_flags,
    mut bounds: *const nk_rect,
    mut matrix: *const nk_rect,
    mut hue_bar: *const nk_rect,
    mut alpha_bar: *const nk_rect,
    mut color: *mut nk_colorf,
    mut in_0: *const nk_input,
) -> libc::c_int {
    let mut hsva: [f32; 4] = [0.; 4];
    let mut value_changed: libc::c_int = 0i32;
    let mut hsv_changed: libc::c_int = 0i32;
    /* color matrix */
    nk_colorf_hsva_fv(hsva.as_mut_ptr(), *color);
    if 0 != nk_button_behavior(state, *matrix, in_0, NK_BUTTON_REPEATER) {
        hsva[1usize] = if (0i32 as f32)
            < if 1.0f32
                < ((*in_0).mouse.pos.x - (*matrix).x) / ((*matrix).w - 1i32 as f32)
            {
                1.0f32
            } else {
                ((*in_0).mouse.pos.x - (*matrix).x) / ((*matrix).w - 1i32 as f32)
            } {
            if 1.0f32 < ((*in_0).mouse.pos.x - (*matrix).x) / ((*matrix).w - 1i32 as f32)
            {
                1.0f32
            } else {
                ((*in_0).mouse.pos.x - (*matrix).x) / ((*matrix).w - 1i32 as f32)
            }
        } else {
            0i32 as f32
        };
        hsva[2usize] = 1.0f32
            - if (0i32 as f32)
                < if 1.0f32
                    < ((*in_0).mouse.pos.y - (*matrix).y) / ((*matrix).h - 1i32 as f32)
                {
                    1.0f32
                } else {
                    ((*in_0).mouse.pos.y - (*matrix).y) / ((*matrix).h - 1i32 as f32)
                } {
                if 1.0f32
                    < ((*in_0).mouse.pos.y - (*matrix).y) / ((*matrix).h - 1i32 as f32)
                {
                    1.0f32
                } else {
                    ((*in_0).mouse.pos.y - (*matrix).y) / ((*matrix).h - 1i32 as f32)
                }
            } else {
                0i32 as f32
            };
        hsv_changed = 1i32;
        value_changed = hsv_changed
    }
    /* hue bar */
    if 0 != nk_button_behavior(state, *hue_bar, in_0, NK_BUTTON_REPEATER) {
        hsva[0usize] = if (0i32 as f32)
            < if 1.0f32
                < ((*in_0).mouse.pos.y - (*hue_bar).y) / ((*hue_bar).h - 1i32 as f32)
            {
                1.0f32
            } else {
                ((*in_0).mouse.pos.y - (*hue_bar).y) / ((*hue_bar).h - 1i32 as f32)
            } {
            if 1.0f32
                < ((*in_0).mouse.pos.y - (*hue_bar).y) / ((*hue_bar).h - 1i32 as f32)
            {
                1.0f32
            } else {
                ((*in_0).mouse.pos.y - (*hue_bar).y) / ((*hue_bar).h - 1i32 as f32)
            }
        } else {
            0i32 as f32
        };
        hsv_changed = 1i32;
        value_changed = hsv_changed
    }
    /* alpha bar */
    if !alpha_bar.is_null() {
        if 0 != nk_button_behavior(state, *alpha_bar, in_0, NK_BUTTON_REPEATER) {
            hsva[3usize] = 1.0f32
                - if (0i32 as f32)
                    < if 1.0f32
                        < ((*in_0).mouse.pos.y - (*alpha_bar).y)
                            / ((*alpha_bar).h - 1i32 as f32)
                    {
                        1.0f32
                    } else {
                        ((*in_0).mouse.pos.y - (*alpha_bar).y)
                            / ((*alpha_bar).h - 1i32 as f32)
                    } {
                    if 1.0f32
                        < ((*in_0).mouse.pos.y - (*alpha_bar).y)
                            / ((*alpha_bar).h - 1i32 as f32)
                    {
                        1.0f32
                    } else {
                        ((*in_0).mouse.pos.y - (*alpha_bar).y)
                            / ((*alpha_bar).h - 1i32 as f32)
                    }
                } else {
                    0i32 as f32
                };
            value_changed = 1i32
        }
    }
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as libc::c_int as libc::c_uint {
        *state = (NK_WIDGET_STATE_INACTIVE as libc::c_int | NK_WIDGET_STATE_MODIFIED as libc::c_int)
            as nk_flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as libc::c_int as nk_flags
    }
    if 0 != hsv_changed {
        *color = nk_hsva_colorfv(hsva.as_mut_ptr());
        *state = NK_WIDGET_STATE_ACTIVE as libc::c_int as nk_flags
    }
    if 0 != value_changed {
        (*color).a = hsva[3usize];
        *state = NK_WIDGET_STATE_ACTIVE as libc::c_int as nk_flags
    }
    /* set color picker widget state */
    if 0 != nk_input_is_mouse_hovering_rect(in_0, *bounds) {
        *state = NK_WIDGET_STATE_HOVERED as libc::c_int as nk_flags
    }
    if 0 != *state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
        && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, *bounds)
    {
        *state |= NK_WIDGET_STATE_ENTERED as libc::c_int as libc::c_uint
    } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, *bounds) {
        *state |= NK_WIDGET_STATE_LEFT as libc::c_int as libc::c_uint
    }
    return value_changed;
}
#[no_mangle]
pub unsafe fn nk_hsva_colorfv(mut c: *mut f32) -> nk_colorf {
    return nk_hsva_colorf(
        *c.offset(0isize),
        *c.offset(1isize),
        *c.offset(2isize),
        *c.offset(3isize),
    );
}
#[no_mangle]
pub unsafe fn nk_property_int(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut min: libc::c_int,
    mut val: *mut libc::c_int,
    mut max: libc::c_int,
    mut step: libc::c_int,
    mut inc_per_pixel: f32,
) -> () {
    let mut variant: nk_property_variant = nk_property_variant {
        kind: NK_PROPERTY_INT,
        value: nk_property { i: 0 },
        min_value: nk_property { i: 0 },
        max_value: nk_property { i: 0 },
        step: nk_property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() || val.is_null() {
        return;
    } else {
        variant = nk_property_variant_int(*val, min, max, step);
        nk_property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_INT);
        *val = variant.value.i;
        return;
    };
}
unsafe fn nk_property(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut variant: *mut nk_property_variant,
    mut inc_per_pixel: f32,
    filter: nk_property_filter,
) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut s: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut state: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut hash: nk_hash = 0i32 as nk_hash;
    let mut buffer: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut cursor: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut select_begin: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut select_end: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut old_state: libc::c_int = 0;
    let mut dummy_buffer: [libc::c_char; 64] = [0; 64];
    let mut dummy_state: libc::c_int = NK_PROPERTY_DEFAULT as libc::c_int;
    let mut dummy_length: libc::c_int = 0i32;
    let mut dummy_cursor: libc::c_int = 0i32;
    let mut dummy_select_begin: libc::c_int = 0i32;
    let mut dummy_select_end: libc::c_int = 0i32;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        style = &mut (*ctx).style as *mut nk_style;
        s = nk_widget(&mut bounds, ctx);
        if 0 == s as u64 {
            return;
        } else {
            /* calculate hash from name */
            if *name.offset(0isize) as libc::c_int == '#' as i32 {
                let fresh20 = (*win).property.seq;
                (*win).property.seq = (*win).property.seq.wrapping_add(1);
                hash = nk_murmur_hash(name as *const libc::c_void, nk_strlen(name), fresh20);
                /* special number hash */
                name = name.offset(1isize)
            } else {
                hash = nk_murmur_hash(
                    name as *const libc::c_void,
                    nk_strlen(name),
                    42i32 as nk_hash,
                )
            }
            /* check if property is currently hot item */
            if 0 != (*win).property.active && hash == (*win).property.name {
                buffer = (*win).property.buffer.as_mut_ptr();
                len = &mut (*win).property.length as *mut libc::c_int;
                cursor = &mut (*win).property.cursor as *mut libc::c_int;
                state = &mut (*win).property.state as *mut libc::c_int;
                select_begin = &mut (*win).property.select_start as *mut libc::c_int;
                select_end = &mut (*win).property.select_end as *mut libc::c_int
            } else {
                buffer = dummy_buffer.as_mut_ptr();
                len = &mut dummy_length;
                cursor = &mut dummy_cursor;
                state = &mut dummy_state;
                select_begin = &mut dummy_select_begin;
                select_end = &mut dummy_select_end
            }
            /* execute property widget */
            old_state = *state;
            (*ctx).text_edit.clip = (*ctx).clip;
            in_0 = if s as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                && 0 == (*win).property.active
                || 0 != (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            nk_do_property(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                name,
                variant,
                inc_per_pixel,
                buffer,
                len,
                state,
                cursor,
                select_begin,
                select_end,
                &(*style).property,
                filter,
                in_0,
                (*style).font,
                &mut (*ctx).text_edit,
                (*ctx).button_behavior,
            );
            if !in_0.is_null()
                && *state != NK_PROPERTY_DEFAULT as libc::c_int
                && 0 == (*win).property.active
            {
                /* current property is now hot */
                (*win).property.active = 1i32;
                nk_memcopy(
                    (*win).property.buffer.as_mut_ptr() as *mut libc::c_void,
                    buffer as *const libc::c_void,
                    *len as nk_size,
                );
                (*win).property.length = *len;
                (*win).property.cursor = *cursor;
                (*win).property.state = *state;
                (*win).property.name = hash;
                (*win).property.select_start = *select_begin;
                (*win).property.select_end = *select_end;
                if *state == NK_PROPERTY_DRAG as libc::c_int {
                    (*ctx).input.mouse.grab = nk_true as libc::c_int as libc::c_uchar;
                    (*ctx).input.mouse.grabbed = nk_true as libc::c_int as libc::c_uchar
                }
            }
            /* check if previously active property is now inactive */
            if *state == NK_PROPERTY_DEFAULT as libc::c_int
                && old_state != NK_PROPERTY_DEFAULT as libc::c_int
            {
                if old_state == NK_PROPERTY_DRAG as libc::c_int {
                    (*ctx).input.mouse.grab = nk_false as libc::c_int as libc::c_uchar;
                    (*ctx).input.mouse.grabbed = nk_false as libc::c_int as libc::c_uchar;
                    (*ctx).input.mouse.ungrab = nk_true as libc::c_int as libc::c_uchar
                }
                (*win).property.select_start = 0i32;
                (*win).property.select_end = 0i32;
                (*win).property.active = 0i32
            }
            return;
        }
    };
}
unsafe fn nk_do_property(
    mut ws: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut property: nk_rect,
    mut name: *const libc::c_char,
    mut variant: *mut nk_property_variant,
    mut inc_per_pixel: f32,
    mut buffer: *mut libc::c_char,
    mut len: *mut libc::c_int,
    mut state: *mut libc::c_int,
    mut cursor: *mut libc::c_int,
    mut select_begin: *mut libc::c_int,
    mut select_end: *mut libc::c_int,
    mut style: *const nk_style_property,
    mut filter: nk_property_filter,
    mut in_0: *mut nk_input,
    mut font: *const nk_user_font,
    mut text_edit: *mut nk_text_edit,
    mut behavior: nk_button_behavior,
) -> () {
    let mut current_block: u64;
    let filters: [nk_plugin_filter; 2] = [Some(nk_filter_decimal), Some(nk_filter_float)];
    let mut active: libc::c_int = 0;
    let mut old: libc::c_int = 0;
    let mut num_len: libc::c_int = 0;
    let mut name_len: libc::c_int = 0;
    let mut string: [libc::c_char; 64] = [0; 64];
    let mut size: f32 = 0.;
    let mut dst: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut length: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut left: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut right: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut label: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut edit: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut empty: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    /* left decrement button */
    left.h = (*font).height / 2i32 as f32;
    left.w = left.h;
    left.x = property.x + (*style).border + (*style).padding.x;
    left.y = property.y + (*style).border + property.h / 2.0f32 - left.h / 2i32 as f32;
    /* text label */
    name_len = nk_strlen(name);
    size = (*font).width.expect("non-null function pointer")(
        (*font).userdata,
        (*font).height,
        name,
        name_len,
    );
    label.x = left.x + left.w + (*style).padding.x;
    label.w = size + 2i32 as f32 * (*style).padding.x;
    label.y = property.y + (*style).border + (*style).padding.y;
    label.h = property.h
        - (2i32 as f32 * (*style).border + 2i32 as f32 * (*style).padding.y);
    /* right increment button */
    right.y = left.y;
    right.w = left.w;
    right.h = left.h;
    right.x = property.x + property.w - (right.w + (*style).padding.x);
    /* edit */
    if *state == NK_PROPERTY_EDIT as libc::c_int {
        size = (*font).width.expect("non-null function pointer")(
            (*font).userdata,
            (*font).height,
            buffer,
            *len,
        );
        size += (*style).edit.cursor_size;
        length = len;
        dst = buffer
    } else {
        match (*variant).kind as libc::c_uint {
            0 => {
                nk_itoa(string.as_mut_ptr(), (*variant).value.i as libc::c_long);
                num_len = nk_strlen(string.as_mut_ptr())
            }
            1 => {
                nk_dtoa(string.as_mut_ptr(), (*variant).value.f as libc::c_double);
                num_len = nk_string_float_limit(string.as_mut_ptr(), 2i32)
            }
            2 => {
                nk_dtoa(string.as_mut_ptr(), (*variant).value.d);
                num_len = nk_string_float_limit(string.as_mut_ptr(), 2i32)
            }
            _ => {}
        }
        size = (*font).width.expect("non-null function pointer")(
            (*font).userdata,
            (*font).height,
            string.as_mut_ptr(),
            num_len,
        );
        dst = string.as_mut_ptr();
        length = &mut num_len
    }
    edit.w = size + 2i32 as f32 * (*style).padding.x;
    edit.w = if edit.w < right.x - (label.x + label.w) {
        edit.w
    } else {
        right.x - (label.x + label.w)
    };
    edit.x = right.x - (edit.w + (*style).padding.x);
    edit.y = property.y + (*style).border;
    edit.h = property.h - 2i32 as f32 * (*style).border;
    /* empty left space activator */
    empty.w = edit.x - (label.x + label.w);
    empty.x = label.x + label.w;
    empty.y = property.y;
    empty.h = property.h;
    /* update property */
    old = (*state == NK_PROPERTY_EDIT as libc::c_int) as libc::c_int;
    nk_property_behavior(
        ws,
        in_0,
        property,
        label,
        edit,
        empty,
        state,
        variant,
        inc_per_pixel,
    );
    /* draw property */
    if (*style).draw_begin.is_some() {
        (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
    }
    nk_draw_property(
        out,
        style,
        &mut property,
        &mut label,
        *ws,
        name,
        name_len,
        font,
    );
    if (*style).draw_end.is_some() {
        (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
    }
    /* execute right button  */
    if 0 != nk_do_button_symbol(
        ws,
        out,
        left,
        (*style).sym_left,
        behavior,
        &(*style).dec_button,
        in_0,
        font,
    ) {
        match (*variant).kind as libc::c_uint {
            0 => {
                current_block = 17608344827992466330;
                match current_block {
                    9289946841932024176 => {
                        (*variant).value.f = if if (*variant).value.f - (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f - (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    17608344827992466330 => {
                        (*variant).value.i = if if (*variant).value.i - (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i - (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    _ => {
                        (*variant).value.d = if if (*variant).value.d - (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d - (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                }
            }
            1 => {
                current_block = 9289946841932024176;
                match current_block {
                    9289946841932024176 => {
                        (*variant).value.f = if if (*variant).value.f - (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f - (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    17608344827992466330 => {
                        (*variant).value.i = if if (*variant).value.i - (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i - (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    _ => {
                        (*variant).value.d = if if (*variant).value.d - (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d - (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                }
            }
            2 => {
                current_block = 16190589082301463196;
                match current_block {
                    9289946841932024176 => {
                        (*variant).value.f = if if (*variant).value.f - (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f - (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    17608344827992466330 => {
                        (*variant).value.i = if if (*variant).value.i - (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i - (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    _ => {
                        (*variant).value.d = if if (*variant).value.d - (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d - (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                }
            }
            _ => {}
        }
    }
    /* execute left button  */
    if 0 != nk_do_button_symbol(
        ws,
        out,
        right,
        (*style).sym_right,
        behavior,
        &(*style).inc_button,
        in_0,
        font,
    ) {
        match (*variant).kind as libc::c_uint {
            0 => {
                current_block = 2124387292137129013;
                match current_block {
                    2124387292137129013 => {
                        (*variant).value.i = if if (*variant).value.i + (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i + (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    5316822834505342835 => {
                        (*variant).value.d = if if (*variant).value.d + (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d + (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    _ => {
                        (*variant).value.f = if if (*variant).value.f + (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f + (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                }
            }
            1 => {
                current_block = 16006929488343096132;
                match current_block {
                    2124387292137129013 => {
                        (*variant).value.i = if if (*variant).value.i + (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i + (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    5316822834505342835 => {
                        (*variant).value.d = if if (*variant).value.d + (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d + (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    _ => {
                        (*variant).value.f = if if (*variant).value.f + (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f + (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                }
            }
            2 => {
                current_block = 5316822834505342835;
                match current_block {
                    2124387292137129013 => {
                        (*variant).value.i = if if (*variant).value.i + (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i + (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    5316822834505342835 => {
                        (*variant).value.d = if if (*variant).value.d + (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d + (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    _ => {
                        (*variant).value.f = if if (*variant).value.f + (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f + (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                }
            }
            _ => {}
        }
    }
    if old != NK_PROPERTY_EDIT as libc::c_int && *state == NK_PROPERTY_EDIT as libc::c_int {
        nk_memcopy(
            buffer as *mut libc::c_void,
            dst as *const libc::c_void,
            *length as nk_size,
        );
        /* property has been activated so setup buffer */
        *cursor = nk_utf_len(buffer, *length);
        *len = *length;
        length = len;
        dst = buffer;
        active = 0i32
    } else {
        active = (*state == NK_PROPERTY_EDIT as libc::c_int) as libc::c_int
    }
    /* execute and run text edit field */
    nk_textedit_clear_state(
        text_edit,
        NK_TEXT_EDIT_SINGLE_LINE,
        filters[filter as usize],
    );
    (*text_edit).active = active as libc::c_uchar;
    (*text_edit).string.len = *length;
    (*text_edit).cursor = if if *cursor < *length { *cursor } else { *length } < 0i32 {
        0i32
    } else if *cursor < *length {
        *cursor
    } else {
        *length
    };
    (*text_edit).select_start = if if *select_begin < *length {
        *select_begin
    } else {
        *length
    } < 0i32
    {
        0i32
    } else if *select_begin < *length {
        *select_begin
    } else {
        *length
    };
    (*text_edit).select_end = if if *select_end < *length {
        *select_end
    } else {
        *length
    } < 0i32
    {
        0i32
    } else if *select_end < *length {
        *select_end
    } else {
        *length
    };
    (*text_edit).string.buffer.allocated = *length as nk_size;
    (*text_edit).string.buffer.memory.size = 64i32 as nk_size;
    (*text_edit).string.buffer.memory.ptr = dst as *mut libc::c_void;
    (*text_edit).string.buffer.size = 64i32 as nk_size;
    (*text_edit).mode = NK_TEXT_EDIT_MODE_INSERT as libc::c_int as libc::c_uchar;
    nk_do_edit(
        ws,
        out,
        edit,
        (NK_EDIT_FIELD as libc::c_int | NK_EDIT_AUTO_SELECT as libc::c_int) as nk_flags,
        filters[filter as usize],
        text_edit,
        &(*style).edit,
        if *state == NK_PROPERTY_EDIT as libc::c_int {
            in_0
        } else {
            0 as *mut nk_input
        },
        font,
    );
    *length = (*text_edit).string.len;
    *cursor = (*text_edit).cursor;
    *select_begin = (*text_edit).select_start;
    *select_end = (*text_edit).select_end;
    if 0 != (*text_edit).active as libc::c_int && 0 != nk_input_is_key_pressed(in_0, NK_KEY_ENTER) {
        (*text_edit).active = nk_false as libc::c_int as libc::c_uchar
    }
    if 0 != active && 0 == (*text_edit).active {
        /* property is now not active so convert edit text to value*/
        *state = NK_PROPERTY_DEFAULT as libc::c_int;
        *buffer.offset(*len as isize) = '\u{0}' as i32 as libc::c_char;
        match (*variant).kind as libc::c_uint {
            0 => {
                current_block = 14176438224543909724;
                match current_block {
                    9505175611044265049 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.d = nk_strtod(buffer, 0 as *mut *const libc::c_char);
                        (*variant).value.d = if if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    11008709377727432485 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.f = nk_strtof(buffer, 0 as *mut *const libc::c_char);
                        (*variant).value.f = if if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    _ => {
                        (*variant).value.i = nk_strtoi(buffer, 0 as *mut *const libc::c_char);
                        (*variant).value.i = if if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                }
            }
            1 => {
                current_block = 11008709377727432485;
                match current_block {
                    9505175611044265049 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.d = nk_strtod(buffer, 0 as *mut *const libc::c_char);
                        (*variant).value.d = if if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    11008709377727432485 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.f = nk_strtof(buffer, 0 as *mut *const libc::c_char);
                        (*variant).value.f = if if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    _ => {
                        (*variant).value.i = nk_strtoi(buffer, 0 as *mut *const libc::c_char);
                        (*variant).value.i = if if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                }
            }
            2 => {
                current_block = 9505175611044265049;
                match current_block {
                    9505175611044265049 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.d = nk_strtod(buffer, 0 as *mut *const libc::c_char);
                        (*variant).value.d = if if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    11008709377727432485 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.f = nk_strtof(buffer, 0 as *mut *const libc::c_char);
                        (*variant).value.f = if if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    _ => {
                        (*variant).value.i = nk_strtoi(buffer, 0 as *mut *const libc::c_char);
                        (*variant).value.i = if if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                }
            }
            _ => {}
        }
    };
}
#[no_mangle]
pub unsafe fn nk_strtod(
    mut str: *const libc::c_char,
    mut endptr: *mut *const libc::c_char,
) -> libc::c_double {
    let mut m: libc::c_double = 0.;
    let mut neg: libc::c_double = 1.0f64;
    let mut p: *const libc::c_char = str;
    let mut value: libc::c_double = 0i32 as libc::c_double;
    let mut number: libc::c_double = 0i32 as libc::c_double;
    if str.is_null() {
        return 0i32 as libc::c_double;
    } else {
        /* skip whitespace */
        while *p as libc::c_int == ' ' as i32 {
            p = p.offset(1isize)
        }
        if *p as libc::c_int == '-' as i32 {
            neg = -1.0f64;
            p = p.offset(1isize)
        }
        while 0 != *p as libc::c_int
            && *p as libc::c_int != '.' as i32
            && *p as libc::c_int != 'e' as i32
        {
            value = value * 10.0f64 + (*p as libc::c_int - '0' as i32) as libc::c_double;
            p = p.offset(1isize)
        }
        if *p as libc::c_int == '.' as i32 {
            p = p.offset(1isize);
            m = 0.1f64;
            while 0 != *p as libc::c_int && *p as libc::c_int != 'e' as i32 {
                value = value + (*p as libc::c_int - '0' as i32) as libc::c_double * m;
                m *= 0.1f64;
                p = p.offset(1isize)
            }
        }
        if *p as libc::c_int == 'e' as i32 {
            let mut i: libc::c_int = 0;
            let mut pow: libc::c_int = 0;
            let mut div: libc::c_int = 0;
            p = p.offset(1isize);
            if *p as libc::c_int == '-' as i32 {
                div = nk_true as libc::c_int;
                p = p.offset(1isize)
            } else if *p as libc::c_int == '+' as i32 {
                div = nk_false as libc::c_int;
                p = p.offset(1isize)
            } else {
                div = nk_false as libc::c_int
            }
            pow = 0i32;
            while 0 != *p {
                pow = pow * 10i32 + (*p as libc::c_int - '0' as i32);
                p = p.offset(1isize)
            }
            m = 1.0f64;
            i = 0i32;
            while i < pow {
                m *= 10.0f64;
                i += 1
            }
            if 0 != div {
                value /= m
            } else {
                value *= m
            }
        }
        number = value * neg;
        if !endptr.is_null() {
            *endptr = p
        }
        return number;
    };
}
unsafe fn nk_string_float_limit(
    mut string: *mut libc::c_char,
    mut prec: libc::c_int,
) -> libc::c_int {
    let mut dot: libc::c_int = 0i32;
    let mut c: *mut libc::c_char = string;
    while 0 != *c {
        if *c as libc::c_int == '.' as i32 {
            dot = 1i32;
            c = c.offset(1isize)
        } else if dot == prec + 1i32 {
            *c = 0i32 as libc::c_char;
            break;
        } else {
            if dot > 0i32 {
                dot += 1
            }
            c = c.offset(1isize)
        }
    }
    return string.ptr_offset_to(c).expect("bad offset_to") as libc::c_long as libc::c_int;
}
#[no_mangle]
pub unsafe fn nk_strtof(
    mut str: *const libc::c_char,
    mut endptr: *mut *const libc::c_char,
) -> f32 {
    let mut float_value: f32 = 0.;
    let mut double_value: libc::c_double = 0.;
    double_value = nk_strtod(str, endptr);
    float_value = double_value as f32;
    return float_value;
}
#[no_mangle]
pub unsafe fn nk_strtoi(
    mut str: *const libc::c_char,
    mut endptr: *mut *const libc::c_char,
) -> libc::c_int {
    let mut neg: libc::c_int = 1i32;
    let mut p: *const libc::c_char = str;
    let mut value: libc::c_int = 0i32;
    if str.is_null() {
        return 0i32;
    } else {
        /* skip whitespace */
        while *p as libc::c_int == ' ' as i32 {
            p = p.offset(1isize)
        }
        if *p as libc::c_int == '-' as i32 {
            neg = -1i32;
            p = p.offset(1isize)
        }
        while 0 != *p as libc::c_int
            && *p as libc::c_int >= '0' as i32
            && *p as libc::c_int <= '9' as i32
        {
            value = value * 10i32 + (*p as libc::c_int - '0' as i32);
            p = p.offset(1isize)
        }
        if !endptr.is_null() {
            *endptr = p
        }
        return neg * value;
    };
}
#[no_mangle]
pub unsafe fn nk_filter_float(mut box_0: *const nk_text_edit, mut unicode: nk_rune) -> libc::c_int {
    if (unicode < '0' as i32 as libc::c_uint || unicode > '9' as i32 as libc::c_uint)
        && unicode != '.' as i32 as libc::c_uint
        && unicode != '-' as i32 as libc::c_uint
    {
        return nk_false as libc::c_int;
    } else {
        return nk_true as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_filter_decimal(
    mut box_0: *const nk_text_edit,
    mut unicode: nk_rune,
) -> libc::c_int {
    if (unicode < '0' as i32 as libc::c_uint || unicode > '9' as i32 as libc::c_uint)
        && unicode != '-' as i32 as libc::c_uint
    {
        return nk_false as libc::c_int;
    } else {
        return nk_true as libc::c_int;
    };
}
unsafe fn nk_do_edit(
    mut state: *mut nk_flags,
    mut out: *mut nk_command_buffer,
    mut bounds: nk_rect,
    mut flags: nk_flags,
    mut filter: nk_plugin_filter,
    mut edit: *mut nk_text_edit,
    mut style: *const nk_style_edit,
    mut in_0: *mut nk_input,
    mut font: *const nk_user_font,
) -> nk_flags {
    let mut l: libc::c_int = 0;
    let mut remaining: *const libc::c_char = 0 as *const libc::c_char;
    let mut cursor: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut out_offset_1: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut glyph_offset_1: libc::c_int = 0;
    let mut glyph_offset: libc::c_int = 0;
    let mut row_size_0: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut remaining_0: *const libc::c_char = 0 as *const libc::c_char;
    let mut remaining_1: *const libc::c_char = 0 as *const libc::c_char;
    let mut begin_0: *const libc::c_char = 0 as *const libc::c_char;
    let mut out_offset: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut row_size: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut begin_2: *const libc::c_char = 0 as *const libc::c_char;
    let mut row_size_1: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut begin_1: *const libc::c_char = 0 as *const libc::c_char;
    let mut glyph_offset_0: libc::c_int = 0;
    let mut out_offset_0: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut area: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut ret: nk_flags = 0i32 as nk_flags;
    let mut row_height: f32 = 0.;
    let mut prev_state: libc::c_char = 0i32 as libc::c_char;
    let mut is_hovered: libc::c_char = 0i32 as libc::c_char;
    let mut select_all: libc::c_char = 0i32 as libc::c_char;
    let mut cursor_follow: libc::c_char = 0i32 as libc::c_char;
    let mut old_clip: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut clip: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if state.is_null() || out.is_null() || style.is_null() {
        return ret;
    } else {
        /* visible text area calculation */
        area.x = bounds.x + (*style).padding.x + (*style).border;
        area.y = bounds.y + (*style).padding.y + (*style).border;
        area.w = bounds.w - (2.0f32 * (*style).padding.x + 2i32 as f32 * (*style).border);
        area.h = bounds.h - (2.0f32 * (*style).padding.y + 2i32 as f32 * (*style).border);
        if 0 != flags & NK_EDIT_MULTILINE as libc::c_int as libc::c_uint {
            area.w = if (0i32 as f32) < area.w - (*style).scrollbar_size.x {
                area.w - (*style).scrollbar_size.x
            } else {
                0i32 as f32
            }
        }
        row_height = if 0 != flags & NK_EDIT_MULTILINE as libc::c_int as libc::c_uint {
            (*font).height + (*style).row_padding
        } else {
            area.h
        };
        /* calculate clipping rectangle */
        old_clip = (*out).clip;
        nk_unify(
            &mut clip,
            &mut old_clip,
            area.x,
            area.y,
            area.x + area.w,
            area.y + area.h,
        );
        /* update edit state */
        prev_state = (*edit).active as libc::c_char;
        is_hovered = nk_input_is_mouse_hovering_rect(in_0, bounds) as libc::c_char;
        if !in_0.is_null()
            && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].clicked
            && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down
        {
            (*edit).active = (bounds.x <= (*in_0).mouse.pos.x
                && (*in_0).mouse.pos.x < bounds.x + bounds.w
                && (bounds.y <= (*in_0).mouse.pos.y && (*in_0).mouse.pos.y < bounds.y + bounds.h))
                as libc::c_int as libc::c_uchar
        }
        /* (de)activate text editor */
        if 0 == prev_state && 0 != (*edit).active as libc::c_int {
            let type_0: nk_text_edit_type =
                (if 0 != flags & NK_EDIT_MULTILINE as libc::c_int as libc::c_uint {
                    NK_TEXT_EDIT_MULTI_LINE as libc::c_int
                } else {
                    NK_TEXT_EDIT_SINGLE_LINE as libc::c_int
                }) as nk_text_edit_type;
            nk_textedit_clear_state(edit, type_0, filter);
            if 0 != flags & NK_EDIT_AUTO_SELECT as libc::c_int as libc::c_uint {
                select_all = nk_true as libc::c_int as libc::c_char
            }
            if 0 != flags & NK_EDIT_GOTO_END_ON_ACTIVATE as libc::c_int as libc::c_uint {
                (*edit).cursor = (*edit).string.len;
                in_0 = 0 as *mut nk_input
            }
        } else if 0 == (*edit).active {
            (*edit).mode = NK_TEXT_EDIT_MODE_VIEW as libc::c_int as libc::c_uchar
        }
        if 0 != flags & NK_EDIT_READ_ONLY as libc::c_int as libc::c_uint {
            (*edit).mode = NK_TEXT_EDIT_MODE_VIEW as libc::c_int as libc::c_uchar
        } else if 0 != flags & NK_EDIT_ALWAYS_INSERT_MODE as libc::c_int as libc::c_uint {
            (*edit).mode = NK_TEXT_EDIT_MODE_INSERT as libc::c_int as libc::c_uchar
        }
        ret = (if 0 != (*edit).active as libc::c_int {
            NK_EDIT_ACTIVE as libc::c_int
        } else {
            NK_EDIT_INACTIVE as libc::c_int
        }) as nk_flags;
        if prev_state as libc::c_int != (*edit).active as libc::c_int {
            ret |= (if 0 != (*edit).active as libc::c_int {
                NK_EDIT_ACTIVATED as libc::c_int
            } else {
                NK_EDIT_DEACTIVATED as libc::c_int
            }) as libc::c_uint
        }
        /* handle user input */
        if 0 != (*edit).active as libc::c_int && !in_0.is_null() {
            let mut shift_mod: libc::c_int =
                (*in_0).keyboard.keys[NK_KEY_SHIFT as libc::c_int as usize].down;
            let mouse_x: f32 = (*in_0).mouse.pos.x - area.x + (*edit).scrollbar.x;
            let mouse_y: f32 = (*in_0).mouse.pos.y - area.y + (*edit).scrollbar.y;
            /* mouse click handler */
            is_hovered = nk_input_is_mouse_hovering_rect(in_0, area) as libc::c_char;
            if 0 != select_all {
                nk_textedit_select_all(edit);
            } else if 0 != is_hovered as libc::c_int
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].clicked
            {
                nk_textedit_click(edit, mouse_x, mouse_y, font, row_height);
            } else if 0 != is_hovered as libc::c_int
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down
                && ((*in_0).mouse.delta.x != 0.0f32 || (*in_0).mouse.delta.y != 0.0f32)
            {
                nk_textedit_drag(edit, mouse_x, mouse_y, font, row_height);
                cursor_follow = nk_true as libc::c_int as libc::c_char
            } else if 0 != is_hovered as libc::c_int
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_RIGHT as libc::c_int as usize].clicked
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_RIGHT as libc::c_int as usize].down
            {
                nk_textedit_key(
                    edit,
                    NK_KEY_TEXT_WORD_LEFT,
                    nk_false as libc::c_int,
                    font,
                    row_height,
                );
                nk_textedit_key(
                    edit,
                    NK_KEY_TEXT_WORD_RIGHT,
                    nk_true as libc::c_int,
                    font,
                    row_height,
                );
                cursor_follow = nk_true as libc::c_int as libc::c_char
            }
            /* keyboard input */
            let mut i: libc::c_int = 0;
            let mut old_mode: libc::c_int = (*edit).mode as libc::c_int;
            i = 0i32;
            while i < NK_KEY_MAX as libc::c_int {
                if !(i == NK_KEY_ENTER as libc::c_int || i == NK_KEY_TAB as libc::c_int) {
                    /* special case */
                    if 0 != nk_input_is_key_pressed(in_0, i as nk_keys) {
                        nk_textedit_key(edit, i as nk_keys, shift_mod, font, row_height);
                        cursor_follow = nk_true as libc::c_int as libc::c_char
                    }
                }
                i += 1
            }
            if old_mode != (*edit).mode as libc::c_int {
                (*in_0).keyboard.text_len = 0i32
            }
            /* text input */
            (*edit).filter = filter;
            if 0 != (*in_0).keyboard.text_len {
                nk_textedit_text(
                    edit,
                    (*in_0).keyboard.text.as_mut_ptr(),
                    (*in_0).keyboard.text_len,
                );
                cursor_follow = nk_true as libc::c_int as libc::c_char;
                (*in_0).keyboard.text_len = 0i32
            }
            /* enter key handler */
            if 0 != nk_input_is_key_pressed(in_0, NK_KEY_ENTER) {
                cursor_follow = nk_true as libc::c_int as libc::c_char;
                if 0 != flags & NK_EDIT_CTRL_ENTER_NEWLINE as libc::c_int as libc::c_uint
                    && 0 != shift_mod
                {
                    nk_textedit_text(edit, b"\n\x00" as *const u8 as *const libc::c_char, 1i32);
                } else if 0 != flags & NK_EDIT_SIG_ENTER as libc::c_int as libc::c_uint {
                    ret |= NK_EDIT_COMMITED as libc::c_int as libc::c_uint
                } else {
                    nk_textedit_text(edit, b"\n\x00" as *const u8 as *const libc::c_char, 1i32);
                }
            }
            /* cut & copy handler */
            let mut copy: libc::c_int = nk_input_is_key_pressed(in_0, NK_KEY_COPY);
            let mut cut: libc::c_int = nk_input_is_key_pressed(in_0, NK_KEY_CUT);
            if (0 != copy || 0 != cut)
                && 0 != flags & NK_EDIT_CLIPBOARD as libc::c_int as libc::c_uint
            {
                let mut glyph_len: libc::c_int = 0;
                let mut unicode: nk_rune = 0;
                let mut text: *const libc::c_char = 0 as *const libc::c_char;
                let mut b: libc::c_int = (*edit).select_start;
                let mut e: libc::c_int = (*edit).select_end;
                let mut begin: libc::c_int = if b < e { b } else { e };
                let mut end: libc::c_int = if b < e { e } else { b };
                text = nk_str_at_const(&mut (*edit).string, begin, &mut unicode, &mut glyph_len);
                if (*edit).clip.copy.is_some() {
                    (*edit).clip.copy.expect("non-null function pointer")(
                        (*edit).clip.userdata,
                        text,
                        end - begin,
                    );
                }
                if 0 != cut && 0 == flags & NK_EDIT_READ_ONLY as libc::c_int as libc::c_uint {
                    nk_textedit_cut(edit);
                    cursor_follow = nk_true as libc::c_int as libc::c_char
                }
            }
            /* paste handler */
            let mut paste: libc::c_int = nk_input_is_key_pressed(in_0, NK_KEY_PASTE);
            if 0 != paste
                && 0 != flags & NK_EDIT_CLIPBOARD as libc::c_int as libc::c_uint
                && (*edit).clip.paste.is_some()
            {
                (*edit).clip.paste.expect("non-null function pointer")((*edit).clip.userdata, edit);
                cursor_follow = nk_true as libc::c_int as libc::c_char
            }
            /* tab handler */
            let mut tab: libc::c_int = nk_input_is_key_pressed(in_0, NK_KEY_TAB);
            if 0 != tab && 0 != flags & NK_EDIT_ALLOW_TAB as libc::c_int as libc::c_uint {
                nk_textedit_text(edit, b"    \x00" as *const u8 as *const libc::c_char, 4i32);
                cursor_follow = nk_true as libc::c_int as libc::c_char
            }
        }
        /* set widget state */
        if 0 != (*edit).active {
            *state = NK_WIDGET_STATE_ACTIVE as libc::c_int as nk_flags
        } else if 0 != *state & NK_WIDGET_STATE_MODIFIED as libc::c_int as libc::c_uint {
            *state = (NK_WIDGET_STATE_INACTIVE as libc::c_int
                | NK_WIDGET_STATE_MODIFIED as libc::c_int) as nk_flags
        } else {
            *state = NK_WIDGET_STATE_INACTIVE as libc::c_int as nk_flags
        }
        if 0 != is_hovered {
            *state |= NK_WIDGET_STATE_HOVERED as libc::c_int as libc::c_uint
        }
        /* DRAW EDIT */
        let mut text_0: *const libc::c_char = nk_str_get_const(&mut (*edit).string);
        let mut len: libc::c_int = nk_str_len_char(&mut (*edit).string);
        /* select background colors/images  */
        let mut background: *const nk_style_item = 0 as *const nk_style_item;
        if 0 != *state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
            background = &(*style).active as *const nk_style_item
        } else if 0 != *state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
            background = &(*style).hover as *const nk_style_item
        } else {
            background = &(*style).normal as *const nk_style_item
        }
        /* draw background frame */
        if (*background).type_0 as libc::c_uint
            == NK_STYLE_ITEM_COLOR as libc::c_int as libc::c_uint
        {
            nk_stroke_rect(
                out,
                bounds,
                (*style).rounding,
                (*style).border,
                (*style).border_color,
            );
            nk_fill_rect(out, bounds, (*style).rounding, (*background).data.color);
        } else {
            nk_draw_image(out, bounds, &(*background).data.image, nk_white);
        }
        area.w = if (0i32 as f32) < area.w - (*style).cursor_size {
            area.w - (*style).cursor_size
        } else {
            0i32 as f32
        };
        if 0 != (*edit).active {
            let mut total_lines: libc::c_int = 1i32;
            let mut text_size: nk_vec2 = nk_vec2(0i32 as f32, 0i32 as f32);
            /* text pointer positions */
            let mut cursor_ptr: *const libc::c_char = 0 as *const libc::c_char;
            let mut select_begin_ptr: *const libc::c_char = 0 as *const libc::c_char;
            let mut select_end_ptr: *const libc::c_char = 0 as *const libc::c_char;
            /* 2D pixel positions */
            let mut cursor_pos: nk_vec2 = nk_vec2(0i32 as f32, 0i32 as f32);
            let mut selection_offset_start: nk_vec2 =
                nk_vec2(0i32 as f32, 0i32 as f32);
            let mut selection_offset_end: nk_vec2 =
                nk_vec2(0i32 as f32, 0i32 as f32);
            let mut selection_begin: libc::c_int = if (*edit).select_start < (*edit).select_end {
                (*edit).select_start
            } else {
                (*edit).select_end
            };
            let mut selection_end: libc::c_int = if (*edit).select_start < (*edit).select_end {
                (*edit).select_end
            } else {
                (*edit).select_start
            };
            /* calculate total line count + total space + cursor/selection position */
            let mut line_width: f32 = 0.0f32;
            if !text_0.is_null() && 0 != len {
                /* utf8 encoding */
                let mut glyph_width: f32 = 0.;
                let mut glyph_len_0: libc::c_int = 0i32;
                let mut unicode_0: nk_rune = 0i32 as nk_rune;
                let mut text_len: libc::c_int = 0i32;
                let mut glyphs: libc::c_int = 0i32;
                let mut row_begin: libc::c_int = 0i32;
                glyph_len_0 = nk_utf_decode(text_0, &mut unicode_0, len);
                glyph_width = (*font).width.expect("non-null function pointer")(
                    (*font).userdata,
                    (*font).height,
                    text_0,
                    glyph_len_0,
                );
                line_width = 0i32 as f32;
                /* iterate all lines */
                while text_len < len && 0 != glyph_len_0 {
                    /* set cursor 2D position and line */
                    if cursor_ptr.is_null() && glyphs == (*edit).cursor {
                        glyph_offset = 0;
                        out_offset = nk_vec2 { x: 0., y: 0. };
                        row_size = nk_vec2 { x: 0., y: 0. };
                        remaining = 0 as *const libc::c_char;
                        /* calculate 2d position */
                        cursor_pos.y = (total_lines - 1i32) as f32 * row_height;
                        row_size = nk_text_calculate_text_bounds(
                            font,
                            text_0.offset(row_begin as isize),
                            text_len - row_begin,
                            row_height,
                            &mut remaining,
                            &mut out_offset,
                            &mut glyph_offset,
                            NK_STOP_ON_NEW_LINE as libc::c_int,
                        );
                        cursor_pos.x = row_size.x;
                        cursor_ptr = text_0.offset(text_len as isize)
                    }
                    /* set start selection 2D position and line */
                    if select_begin_ptr.is_null()
                        && (*edit).select_start != (*edit).select_end
                        && glyphs == selection_begin
                    {
                        glyph_offset_0 = 0;
                        out_offset_0 = nk_vec2 { x: 0., y: 0. };
                        row_size_0 = nk_vec2 { x: 0., y: 0. };
                        remaining_0 = 0 as *const libc::c_char;
                        /* calculate 2d position */
                        selection_offset_start.y = (if total_lines - 1i32 < 0i32 {
                            0i32
                        } else {
                            total_lines - 1i32
                        }) as f32
                            * row_height;
                        row_size_0 = nk_text_calculate_text_bounds(
                            font,
                            text_0.offset(row_begin as isize),
                            text_len - row_begin,
                            row_height,
                            &mut remaining_0,
                            &mut out_offset_0,
                            &mut glyph_offset_0,
                            NK_STOP_ON_NEW_LINE as libc::c_int,
                        );
                        selection_offset_start.x = row_size_0.x;
                        select_begin_ptr = text_0.offset(text_len as isize)
                    }
                    /* set end selection 2D position and line */
                    if select_end_ptr.is_null()
                        && (*edit).select_start != (*edit).select_end
                        && glyphs == selection_end
                    {
                        glyph_offset_1 = 0;
                        out_offset_1 = nk_vec2 { x: 0., y: 0. };
                        row_size_1 = nk_vec2 { x: 0., y: 0. };
                        remaining_1 = 0 as *const libc::c_char;
                        /* calculate 2d position */
                        selection_offset_end.y = (total_lines - 1i32) as f32 * row_height;
                        row_size_1 = nk_text_calculate_text_bounds(
                            font,
                            text_0.offset(row_begin as isize),
                            text_len - row_begin,
                            row_height,
                            &mut remaining_1,
                            &mut out_offset_1,
                            &mut glyph_offset_1,
                            NK_STOP_ON_NEW_LINE as libc::c_int,
                        );
                        selection_offset_end.x = row_size_1.x;
                        select_end_ptr = text_0.offset(text_len as isize)
                    }
                    if unicode_0 == '\n' as i32 as libc::c_uint {
                        text_size.x = if text_size.x < line_width {
                            line_width
                        } else {
                            text_size.x
                        };
                        total_lines += 1;
                        line_width = 0i32 as f32;
                        text_len += 1;
                        glyphs += 1;
                        row_begin = text_len;
                        glyph_len_0 = nk_utf_decode(
                            text_0.offset(text_len as isize),
                            &mut unicode_0,
                            len - text_len,
                        );
                        glyph_width = (*font).width.expect("non-null function pointer")(
                            (*font).userdata,
                            (*font).height,
                            text_0.offset(text_len as isize),
                            glyph_len_0,
                        )
                    } else {
                        glyphs += 1;
                        text_len += glyph_len_0;
                        line_width += glyph_width;
                        glyph_len_0 = nk_utf_decode(
                            text_0.offset(text_len as isize),
                            &mut unicode_0,
                            len - text_len,
                        );
                        glyph_width = (*font).width.expect("non-null function pointer")(
                            (*font).userdata,
                            (*font).height,
                            text_0.offset(text_len as isize),
                            glyph_len_0,
                        )
                    }
                }
                text_size.y = total_lines as f32 * row_height;
                /* handle case when cursor is at end of text buffer */
                if cursor_ptr.is_null() && (*edit).cursor == (*edit).string.len {
                    cursor_pos.x = line_width;
                    cursor_pos.y = text_size.y - row_height
                }
            }
            /* scrollbar */
            if 0 != cursor_follow {
                /* update scrollbar to follow cursor */
                if 0 == flags & NK_EDIT_NO_HORIZONTAL_SCROLL as libc::c_int as libc::c_uint {
                    /* horizontal scroll */
                    let scroll_increment: f32 = area.w * 0.25f32;
                    if cursor_pos.x < (*edit).scrollbar.x {
                        (*edit).scrollbar.x = (if 0.0f32 < cursor_pos.x - scroll_increment {
                            cursor_pos.x - scroll_increment
                        } else {
                            0.0f32
                        }) as libc::c_int
                            as f32
                    }
                    if cursor_pos.x >= (*edit).scrollbar.x + area.w {
                        (*edit).scrollbar.x = (if 0.0f32 < (*edit).scrollbar.x + scroll_increment {
                            (*edit).scrollbar.x + scroll_increment
                        } else {
                            0.0f32
                        }) as libc::c_int
                            as f32
                    }
                } else {
                    (*edit).scrollbar.x = 0i32 as f32
                }
                if 0 != flags & NK_EDIT_MULTILINE as libc::c_int as libc::c_uint {
                    /* vertical scroll */
                    if cursor_pos.y < (*edit).scrollbar.y {
                        (*edit).scrollbar.y = if 0.0f32 < cursor_pos.y - row_height {
                            cursor_pos.y - row_height
                        } else {
                            0.0f32
                        }
                    }
                    if cursor_pos.y >= (*edit).scrollbar.y + area.h {
                        (*edit).scrollbar.y = (*edit).scrollbar.y + row_height
                    }
                } else {
                    (*edit).scrollbar.y = 0i32 as f32
                }
            }
            /* scrollbar widget */
            if 0 != flags & NK_EDIT_MULTILINE as libc::c_int as libc::c_uint {
                let mut ws: nk_flags = 0;
                let mut scroll: nk_rect = nk_rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                let mut scroll_target: f32 = 0.;
                let mut scroll_offset: f32 = 0.;
                let mut scroll_step: f32 = 0.;
                let mut scroll_inc: f32 = 0.;
                scroll = area;
                scroll.x = bounds.x + bounds.w - (*style).border - (*style).scrollbar_size.x;
                scroll.w = (*style).scrollbar_size.x;
                scroll_offset = (*edit).scrollbar.y;
                scroll_step = scroll.h * 0.10000000149011612f32;
                scroll_inc = scroll.h * 0.009999999776482582f32;
                scroll_target = text_size.y;
                (*edit).scrollbar.y = nk_do_scrollbarv(
                    &mut ws,
                    out,
                    scroll,
                    0i32,
                    scroll_offset,
                    scroll_target,
                    scroll_step,
                    scroll_inc,
                    &(*style).scrollbar,
                    in_0,
                    font,
                )
            }
            /* draw text */
            let mut background_color: nk_color = nk_color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut text_color: nk_color = nk_color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut sel_background_color: nk_color = nk_color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut sel_text_color: nk_color = nk_color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut cursor_color: nk_color = nk_color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut cursor_text_color: nk_color = nk_color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut background_0: *const nk_style_item = 0 as *const nk_style_item;
            nk_push_scissor(out, clip);
            /* select correct colors to draw */
            if 0 != *state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
                background_0 = &(*style).active as *const nk_style_item;
                text_color = (*style).text_active;
                sel_text_color = (*style).selected_text_hover;
                sel_background_color = (*style).selected_hover;
                cursor_color = (*style).cursor_hover;
                cursor_text_color = (*style).cursor_text_hover
            } else if 0 != *state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
                background_0 = &(*style).hover as *const nk_style_item;
                text_color = (*style).text_hover;
                sel_text_color = (*style).selected_text_hover;
                sel_background_color = (*style).selected_hover;
                cursor_text_color = (*style).cursor_text_hover;
                cursor_color = (*style).cursor_hover
            } else {
                background_0 = &(*style).normal as *const nk_style_item;
                text_color = (*style).text_normal;
                sel_text_color = (*style).selected_text_normal;
                sel_background_color = (*style).selected_normal;
                cursor_color = (*style).cursor_normal;
                cursor_text_color = (*style).cursor_text_normal
            }
            if (*background_0).type_0 as libc::c_uint
                == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                background_color = nk_rgba(0i32, 0i32, 0i32, 0i32)
            } else {
                background_color = (*background_0).data.color
            }
            if (*edit).select_start == (*edit).select_end {
                /* no selection so just draw the complete text */
                begin_0 = nk_str_get_const(&mut (*edit).string);
                l = nk_str_len_char(&mut (*edit).string);
                nk_edit_draw_text(
                    out,
                    style,
                    area.x - (*edit).scrollbar.x,
                    area.y - (*edit).scrollbar.y,
                    0i32 as f32,
                    begin_0,
                    l,
                    row_height,
                    font,
                    background_color,
                    text_color,
                    nk_false as libc::c_int,
                );
            } else {
                /* edit has selection so draw 1-3 text chunks */
                if (*edit).select_start != (*edit).select_end && selection_begin > 0i32 {
                    /* draw unselected text before selection */
                    begin_1 = nk_str_get_const(&mut (*edit).string);
                    nk_edit_draw_text(
                        out,
                        style,
                        area.x - (*edit).scrollbar.x,
                        area.y - (*edit).scrollbar.y,
                        0i32 as f32,
                        begin_1,
                        begin_1
                            .ptr_offset_to(select_begin_ptr)
                            .expect("bad offset_to") as libc::c_long
                            as libc::c_int,
                        row_height,
                        font,
                        background_color,
                        text_color,
                        nk_false as libc::c_int,
                    );
                }
                if (*edit).select_start != (*edit).select_end {
                    /* draw selected text */
                    if select_end_ptr.is_null() {
                        begin_2 = nk_str_get_const(&mut (*edit).string);
                        select_end_ptr =
                            begin_2.offset(nk_str_len_char(&mut (*edit).string) as isize)
                    }
                    nk_edit_draw_text(
                        out,
                        style,
                        area.x - (*edit).scrollbar.x,
                        area.y + selection_offset_start.y - (*edit).scrollbar.y,
                        selection_offset_start.x,
                        select_begin_ptr,
                        select_begin_ptr
                            .ptr_offset_to(select_end_ptr)
                            .expect("bad offset_to") as libc::c_long
                            as libc::c_int,
                        row_height,
                        font,
                        sel_background_color,
                        sel_text_color,
                        nk_true as libc::c_int,
                    );
                }
                if (*edit).select_start != (*edit).select_end && selection_end < (*edit).string.len
                {
                    /* draw unselected text after selected text */
                    let mut begin_3: *const libc::c_char = select_end_ptr;
                    let mut end_0: *const libc::c_char = nk_str_get_const(&mut (*edit).string)
                        .offset(nk_str_len_char(&mut (*edit).string) as isize);
                    nk_edit_draw_text(
                        out,
                        style,
                        area.x - (*edit).scrollbar.x,
                        area.y + selection_offset_end.y - (*edit).scrollbar.y,
                        selection_offset_end.x,
                        begin_3,
                        begin_3.ptr_offset_to(end_0).expect("bad offset_to") as libc::c_long
                            as libc::c_int,
                        row_height,
                        font,
                        background_color,
                        text_color,
                        nk_true as libc::c_int,
                    );
                }
            }
            /* cursor */
            if (*edit).select_start == (*edit).select_end {
                if (*edit).cursor >= nk_str_len(&mut (*edit).string)
                    || !cursor_ptr.is_null() && *cursor_ptr as libc::c_int == '\n' as i32
                {
                    /* draw cursor at end of line */
                    cursor = nk_rect {
                        x: 0.,
                        y: 0.,
                        w: 0.,
                        h: 0.,
                    };
                    cursor.w = (*style).cursor_size;
                    cursor.h = (*font).height;
                    cursor.x = area.x + cursor_pos.x - (*edit).scrollbar.x;
                    cursor.y = area.y + cursor_pos.y + row_height / 2.0f32 - cursor.h / 2.0f32;
                    cursor.y -= (*edit).scrollbar.y;
                    nk_fill_rect(out, cursor, 0i32 as f32, cursor_color);
                } else {
                    /* draw cursor inside text */
                    let mut glyph_len_1: libc::c_int = 0;
                    let mut label: nk_rect = nk_rect {
                        x: 0.,
                        y: 0.,
                        w: 0.,
                        h: 0.,
                    };
                    let mut txt: nk_text = nk_text {
                        padding: nk_vec2 { x: 0., y: 0. },
                        background: nk_color {
                            r: 0,
                            g: 0,
                            b: 0,
                            a: 0,
                        },
                        text: nk_color {
                            r: 0,
                            g: 0,
                            b: 0,
                            a: 0,
                        },
                    };
                    let mut unicode_1: nk_rune = 0;
                    glyph_len_1 = nk_utf_decode(cursor_ptr, &mut unicode_1, 4i32);
                    label.x = area.x + cursor_pos.x - (*edit).scrollbar.x;
                    label.y = area.y + cursor_pos.y - (*edit).scrollbar.y;
                    label.w = (*font).width.expect("non-null function pointer")(
                        (*font).userdata,
                        (*font).height,
                        cursor_ptr,
                        glyph_len_1,
                    );
                    label.h = row_height;
                    txt.padding = nk_vec2(0i32 as f32, 0i32 as f32);
                    txt.background = cursor_color;
                    txt.text = cursor_text_color;
                    nk_fill_rect(out, label, 0i32 as f32, cursor_color);
                    nk_widget_text(
                        out,
                        label,
                        cursor_ptr,
                        glyph_len_1,
                        &mut txt,
                        NK_TEXT_LEFT as libc::c_int as nk_flags,
                        font,
                    );
                }
            }
        } else {
            /* not active so just draw text */
            let mut l_0: libc::c_int = nk_str_len_char(&mut (*edit).string);
            let mut begin_4: *const libc::c_char = nk_str_get_const(&mut (*edit).string);
            let mut background_1: *const nk_style_item = 0 as *const nk_style_item;
            let mut background_color_0: nk_color = nk_color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut text_color_0: nk_color = nk_color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            nk_push_scissor(out, clip);
            if 0 != *state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
                background_1 = &(*style).active as *const nk_style_item;
                text_color_0 = (*style).text_active
            } else if 0 != *state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
                background_1 = &(*style).hover as *const nk_style_item;
                text_color_0 = (*style).text_hover
            } else {
                background_1 = &(*style).normal as *const nk_style_item;
                text_color_0 = (*style).text_normal
            }
            if (*background_1).type_0 as libc::c_uint
                == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                background_color_0 = nk_rgba(0i32, 0i32, 0i32, 0i32)
            } else {
                background_color_0 = (*background_1).data.color
            }
            nk_edit_draw_text(
                out,
                style,
                area.x - (*edit).scrollbar.x,
                area.y - (*edit).scrollbar.y,
                0i32 as f32,
                begin_4,
                l_0,
                row_height,
                font,
                background_color_0,
                text_color_0,
                nk_false as libc::c_int,
            );
        }
        nk_push_scissor(out, old_clip);
        return ret;
    };
}
#[no_mangle]
pub unsafe fn nk_str_len_char(mut s: *mut nk_str) -> libc::c_int {
    if s.is_null() || 0 == (*s).len || 0 == (*s).buffer.allocated {
        return 0i32;
    } else {
        return (*s).buffer.allocated as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_str_get_const(mut s: *const nk_str) -> *const libc::c_char {
    if s.is_null() || 0 == (*s).len || 0 == (*s).buffer.allocated {
        return 0 as *const libc::c_char;
    } else {
        return (*s).buffer.memory.ptr as *const libc::c_char;
    };
}
unsafe fn nk_edit_draw_text(
    mut out: *mut nk_command_buffer,
    mut style: *const nk_style_edit,
    mut pos_x: f32,
    mut pos_y: f32,
    mut x_offset: f32,
    mut text: *const libc::c_char,
    mut byte_len: libc::c_int,
    mut row_height: f32,
    mut font: *const nk_user_font,
    mut background: nk_color,
    mut foreground: nk_color,
    mut is_selected: libc::c_int,
) -> () {
    if text.is_null() || 0 == byte_len || out.is_null() || style.is_null() {
        return;
    } else {
        let mut glyph_len: libc::c_int = 0i32;
        let mut unicode: nk_rune = 0i32 as nk_rune;
        let mut text_len: libc::c_int = 0i32;
        let mut line_width: f32 = 0i32 as f32;
        let mut glyph_width: f32 = 0.;
        let mut line: *const libc::c_char = text;
        let mut line_offset: f32 = 0i32 as f32;
        let mut line_count: libc::c_int = 0i32;
        let mut txt: nk_text = nk_text {
            padding: nk_vec2 { x: 0., y: 0. },
            background: nk_color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            },
            text: nk_color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            },
        };
        txt.padding = nk_vec2(0i32 as f32, 0i32 as f32);
        txt.background = background;
        txt.text = foreground;
        glyph_len = nk_utf_decode(
            text.offset(text_len as isize),
            &mut unicode,
            byte_len - text_len,
        );
        if 0 == glyph_len {
            return;
        } else {
            while text_len < byte_len && 0 != glyph_len {
                if unicode == '\n' as i32 as libc::c_uint {
                    /* new line separator so draw previous line */
                    let mut label: nk_rect = nk_rect {
                        x: 0.,
                        y: 0.,
                        w: 0.,
                        h: 0.,
                    };
                    label.y = pos_y + line_offset;
                    label.h = row_height;
                    label.w = line_width;
                    label.x = pos_x;
                    if 0 == line_count {
                        label.x += x_offset
                    }
                    /* selection needs to draw different background color */
                    if 0 != is_selected {
                        nk_fill_rect(out, label, 0i32 as f32, background);
                    }
                    nk_widget_text(
                        out,
                        label,
                        line,
                        line.ptr_offset_to(text.offset(text_len as isize))
                            .expect("bad offset_to") as libc::c_long
                            as libc::c_int,
                        &mut txt,
                        NK_TEXT_CENTERED as libc::c_int as nk_flags,
                        font,
                    );
                    text_len += 1;
                    line_count += 1;
                    line_width = 0i32 as f32;
                    line = text.offset(text_len as isize);
                    line_offset += row_height;
                    glyph_len = nk_utf_decode(
                        text.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    )
                } else if unicode == '\r' as i32 as libc::c_uint {
                    text_len += 1;
                    glyph_len = nk_utf_decode(
                        text.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    )
                } else {
                    glyph_width = (*font).width.expect("non-null function pointer")(
                        (*font).userdata,
                        (*font).height,
                        text.offset(text_len as isize),
                        glyph_len,
                    );
                    line_width += glyph_width;
                    text_len += glyph_len;
                    glyph_len = nk_utf_decode(
                        text.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    )
                }
            }
            if line_width > 0i32 as f32 {
                /* draw last line */
                let mut label_0: nk_rect = nk_rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                label_0.y = pos_y + line_offset;
                label_0.h = row_height;
                label_0.w = line_width;
                label_0.x = pos_x;
                if 0 == line_count {
                    label_0.x += x_offset
                }
                if 0 != is_selected {
                    nk_fill_rect(out, label_0, 0i32 as f32, background);
                }
                nk_widget_text(
                    out,
                    label_0,
                    line,
                    line.ptr_offset_to(text.offset(text_len as isize))
                        .expect("bad offset_to") as libc::c_long as libc::c_int,
                    &mut txt,
                    NK_TEXT_LEFT as libc::c_int as nk_flags,
                    font,
                );
            }
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_str_len(mut s: *mut nk_str) -> libc::c_int {
    if s.is_null() || 0 == (*s).len || 0 == (*s).buffer.allocated {
        return 0i32;
    } else {
        return (*s).len;
    };
}
unsafe fn nk_text_calculate_text_bounds(
    mut font: *const nk_user_font,
    mut begin: *const libc::c_char,
    mut byte_len: libc::c_int,
    mut row_height: f32,
    mut remaining: *mut *const libc::c_char,
    mut out_offset: *mut nk_vec2,
    mut glyphs: *mut libc::c_int,
    mut op: libc::c_int,
) -> nk_vec2 {
    let mut line_height: f32 = row_height;
    let mut text_size: nk_vec2 = nk_vec2(0i32 as f32, 0i32 as f32);
    let mut line_width: f32 = 0.0f32;
    let mut glyph_width: f32 = 0.;
    let mut glyph_len: libc::c_int = 0i32;
    let mut unicode: nk_rune = 0i32 as nk_rune;
    let mut text_len: libc::c_int = 0i32;
    if begin.is_null() || byte_len <= 0i32 || font.is_null() {
        return nk_vec2(0i32 as f32, row_height);
    } else {
        glyph_len = nk_utf_decode(begin, &mut unicode, byte_len);
        if 0 == glyph_len {
            return text_size;
        } else {
            glyph_width = (*font).width.expect("non-null function pointer")(
                (*font).userdata,
                (*font).height,
                begin,
                glyph_len,
            );
            *glyphs = 0i32;
            while text_len < byte_len && 0 != glyph_len {
                if unicode == '\n' as i32 as libc::c_uint {
                    text_size.x = if text_size.x < line_width {
                        line_width
                    } else {
                        text_size.x
                    };
                    text_size.y += line_height;
                    line_width = 0i32 as f32;
                    *glyphs += 1i32;
                    if op == NK_STOP_ON_NEW_LINE as libc::c_int {
                        break;
                    }
                    text_len += 1;
                    glyph_len = nk_utf_decode(
                        begin.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    )
                } else if unicode == '\r' as i32 as libc::c_uint {
                    text_len += 1;
                    *glyphs += 1i32;
                    glyph_len = nk_utf_decode(
                        begin.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    )
                } else {
                    *glyphs = *glyphs + 1i32;
                    text_len += glyph_len;
                    line_width += glyph_width;
                    glyph_len = nk_utf_decode(
                        begin.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    );
                    glyph_width = (*font).width.expect("non-null function pointer")(
                        (*font).userdata,
                        (*font).height,
                        begin.offset(text_len as isize),
                        glyph_len,
                    )
                }
            }
            if text_size.x < line_width {
                text_size.x = line_width
            }
            if !out_offset.is_null() {
                *out_offset = nk_vec2(line_width, text_size.y + line_height)
            }
            if line_width > 0i32 as f32 || text_size.y == 0.0f32 {
                text_size.y += line_height
            }
            if !remaining.is_null() {
                *remaining = begin.offset(text_len as isize)
            }
            return text_size;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_textedit_text(
    mut state: *mut nk_text_edit,
    mut text: *const libc::c_char,
    mut total_len: libc::c_int,
) -> () {
    let mut unicode: nk_rune = 0;
    let mut glyph_len: libc::c_int = 0;
    let mut text_len: libc::c_int = 0i32;
    if text.is_null()
        || 0 == total_len
        || (*state).mode as libc::c_int == NK_TEXT_EDIT_MODE_VIEW as libc::c_int
    {
        return;
    } else {
        glyph_len = nk_utf_decode(text, &mut unicode, total_len);
        while text_len < total_len && 0 != glyph_len {
            /* don't insert a backward delete, just process the event */
            if !(unicode == 127i32 as libc::c_uint) {
                /* can't add newline in single-line mode */
                if !(unicode == '\n' as i32 as libc::c_uint
                    && 0 != (*state).single_line as libc::c_int)
                {
                    /* filter incoming text */
                    if !((*state).filter.is_some()
                        && 0 == (*state).filter.expect("non-null function pointer")(state, unicode))
                    {
                        if !((*state).select_start != (*state).select_end)
                            && (*state).cursor < (*state).string.len
                        {
                            if (*state).mode as libc::c_int
                                == NK_TEXT_EDIT_MODE_REPLACE as libc::c_int
                            {
                                nk_textedit_makeundo_replace(state, (*state).cursor, 1i32, 1i32);
                                nk_str_delete_runes(&mut (*state).string, (*state).cursor, 1i32);
                            }
                            if 0 != nk_str_insert_text_utf8(
                                &mut (*state).string,
                                (*state).cursor,
                                text.offset(text_len as isize),
                                1i32,
                            ) {
                                (*state).cursor += 1;
                                (*state).has_preferred_x = 0i32 as libc::c_uchar
                            }
                        } else {
                            /* implicitly clamps */
                            nk_textedit_delete_selection(state);
                            if 0 != nk_str_insert_text_utf8(
                                &mut (*state).string,
                                (*state).cursor,
                                text.offset(text_len as isize),
                                1i32,
                            ) {
                                nk_textedit_makeundo_insert(state, (*state).cursor, 1i32);
                                (*state).cursor += 1;
                                (*state).has_preferred_x = 0i32 as libc::c_uchar
                            }
                        }
                    }
                }
            }
            text_len += glyph_len;
            glyph_len = nk_utf_decode(
                text.offset(text_len as isize),
                &mut unicode,
                total_len - text_len,
            )
        }
        return;
    };
}
unsafe fn nk_textedit_makeundo_insert(
    mut state: *mut nk_text_edit,
    mut where_0: libc::c_int,
    mut length: libc::c_int,
) -> () {
    nk_textedit_createundo(&mut (*state).undo, where_0, 0i32, length);
}
unsafe fn nk_textedit_createundo(
    mut state: *mut nk_text_undo_state,
    mut pos: libc::c_int,
    mut insert_len: libc::c_int,
    mut delete_len: libc::c_int,
) -> *mut nk_rune {
    let mut r: *mut nk_text_undo_record = nk_textedit_create_undo_record(state, insert_len);
    if r.is_null() {
        return 0 as *mut nk_rune;
    } else {
        (*r).where_0 = pos;
        (*r).insert_length = insert_len as libc::c_short;
        (*r).delete_length = delete_len as libc::c_short;
        if insert_len == 0i32 {
            (*r).char_storage = -1i32 as libc::c_short;
            return 0 as *mut nk_rune;
        } else {
            (*r).char_storage = (*state).undo_char_point;
            (*state).undo_char_point =
                ((*state).undo_char_point as libc::c_int + insert_len) as libc::c_short;
            return &mut (*state).undo_char[(*r).char_storage as usize] as *mut nk_rune;
        }
    };
}
unsafe fn nk_textedit_create_undo_record(
    mut state: *mut nk_text_undo_state,
    mut numchars: libc::c_int,
) -> *mut nk_text_undo_record {
    /* any time we create a new undo record, we discard redo*/
    nk_textedit_flush_redo(state);
    /* if we have no free records, we have to make room,
     * by sliding the existing records down */
    if (*state).undo_point as libc::c_int == 99i32 {
        nk_textedit_discard_undo(state);
    }
    /* if the characters to store won't possibly fit in the buffer,
     * we can't undo */
    if numchars > 999i32 {
        (*state).undo_point = 0i32 as libc::c_short;
        (*state).undo_char_point = 0i32 as libc::c_short;
        return 0 as *mut nk_text_undo_record;
    } else {
        /* if we don't have enough free characters in the buffer,
         * we have to make room */
        while (*state).undo_char_point as libc::c_int + numchars > 999i32 {
            nk_textedit_discard_undo(state);
        }
        let fresh21 = (*state).undo_point;
        (*state).undo_point = (*state).undo_point + 1;
        return &mut (*state).undo_rec[fresh21 as usize] as *mut nk_text_undo_record;
    };
}
unsafe fn nk_textedit_discard_undo(mut state: *mut nk_text_undo_state) -> () {
    /* discard the oldest entry in the undo list */
    if (*state).undo_point as libc::c_int > 0i32 {
        /* if the 0th undo state has characters, clean those up */
        if (*state).undo_rec[0usize].char_storage as libc::c_int >= 0i32 {
            let mut n: libc::c_int = (*state).undo_rec[0usize].insert_length as libc::c_int;
            let mut i: libc::c_int = 0;
            /* delete n characters from all other records */
            (*state).undo_char_point =
                ((*state).undo_char_point as libc::c_int - n) as libc::c_short;
            nk_memcopy(
                (*state).undo_char.as_mut_ptr() as *mut libc::c_void,
                (*state).undo_char.as_mut_ptr().offset(n as isize) as *const libc::c_void,
                ((*state).undo_char_point as nk_size)
                    .wrapping_mul(::std::mem::size_of::<nk_rune>() as libc::c_ulong),
            );
            i = 0i32;
            while i < (*state).undo_point as libc::c_int {
                if (*state).undo_rec[i as usize].char_storage as libc::c_int >= 0i32 {
                    (*state).undo_rec[i as usize].char_storage =
                        ((*state).undo_rec[i as usize].char_storage as libc::c_int - n)
                            as libc::c_short
                }
                i += 1
            }
        }
        (*state).undo_point -= 1;
        nk_memcopy(
            (*state).undo_rec.as_mut_ptr() as *mut libc::c_void,
            (*state).undo_rec.as_mut_ptr().offset(1isize) as *const libc::c_void,
            ((*state).undo_point as nk_size)
                .wrapping_mul(::std::mem::size_of::<nk_text_undo_record>() as libc::c_ulong),
        );
    };
}
unsafe fn nk_textedit_flush_redo(mut state: *mut nk_text_undo_state) -> () {
    (*state).redo_point = 99i32 as libc::c_short;
    (*state).redo_char_point = 999i32 as libc::c_short;
}
#[no_mangle]
pub unsafe fn nk_str_insert_text_utf8(
    mut str: *mut nk_str,
    mut pos: libc::c_int,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0i32;
    let mut byte_len: libc::c_int = 0i32;
    let mut unicode: nk_rune = 0;
    if str.is_null() || text.is_null() || 0 == len {
        return 0i32;
    } else {
        i = 0i32;
        while i < len {
            byte_len += nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
            i += 1
        }
        nk_str_insert_at_rune(str, pos, text, byte_len);
        return len;
    };
}
#[no_mangle]
pub unsafe fn nk_str_insert_at_rune(
    mut str: *mut nk_str,
    mut pos: libc::c_int,
    mut cstr: *const libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut glyph_len: libc::c_int = 0;
    let mut unicode: nk_rune = 0;
    let mut begin: *const libc::c_char = 0 as *const libc::c_char;
    let mut buffer: *const libc::c_char = 0 as *const libc::c_char;
    if str.is_null() || cstr.is_null() || 0 == len {
        return 0i32;
    } else {
        begin = nk_str_at_rune(str, pos, &mut unicode, &mut glyph_len);
        if 0 == (*str).len {
            return nk_str_append_text_char(str, cstr, len);
        } else {
            buffer = nk_str_get_const(str);
            if begin.is_null() {
                return 0i32;
            } else {
                return nk_str_insert_at_char(
                    str,
                    buffer.ptr_offset_to(begin).expect("bad offset_to") as libc::c_long
                        as libc::c_int,
                    cstr,
                    len,
                );
            }
        }
    };
}
#[no_mangle]
pub unsafe fn nk_str_insert_at_char(
    mut s: *mut nk_str,
    mut pos: libc::c_int,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut mem: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut src: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut dst: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut copylen: libc::c_int = 0;
    if s.is_null() || str.is_null() || 0 == len || pos as nk_size > (*s).buffer.allocated {
        return 0i32;
    } else if (*s).buffer.allocated.wrapping_add(len as nk_size) >= (*s).buffer.memory.size
        && (*s).buffer.type_0 as libc::c_uint == NK_BUFFER_FIXED as libc::c_int as libc::c_uint
    {
        return 0i32;
    } else {
        copylen = (*s).buffer.allocated as libc::c_int - pos;
        if 0 == copylen {
            nk_str_append_text_char(s, str, len);
            return 1i32;
        } else {
            mem = nk_buffer_alloc(
                &mut (*s).buffer,
                NK_BUFFER_FRONT,
                (len as nk_size)
                    .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
                0i32 as nk_size,
            );
            if mem.is_null() {
                return 0i32;
            } else {
                /* memmove */
                dst = ((*s).buffer.memory.ptr as *mut nk_byte)
                    .offset((pos + len + (copylen - 1i32)) as isize)
                    as *mut libc::c_void as *mut libc::c_char;
                src = ((*s).buffer.memory.ptr as *mut nk_byte)
                    .offset((pos + (copylen - 1i32)) as isize)
                    as *mut libc::c_void as *mut libc::c_char;
                i = 0i32;
                while i < copylen {
                    let fresh23 = dst;
                    dst = dst.offset(-1);
                    let fresh22 = src;
                    src = src.offset(-1);
                    *fresh23 = *fresh22;
                    i += 1
                }
                mem = ((*s).buffer.memory.ptr as *mut nk_byte).offset(pos as isize)
                    as *mut libc::c_void;
                nk_memcopy(
                    mem,
                    str as *const libc::c_void,
                    (len as nk_size)
                        .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
                );
                (*s).len = nk_utf_len(
                    (*s).buffer.memory.ptr as *mut libc::c_char,
                    (*s).buffer.allocated as libc::c_int,
                );
                return 1i32;
            }
        }
    };
}
#[no_mangle]
pub unsafe fn nk_utf_len(mut str: *const libc::c_char, mut len: libc::c_int) -> libc::c_int {
    let mut text: *const libc::c_char = 0 as *const libc::c_char;
    let mut glyphs: libc::c_int = 0i32;
    let mut text_len: libc::c_int = 0;
    let mut glyph_len: libc::c_int = 0;
    let mut src_len: libc::c_int = 0i32;
    let mut unicode: nk_rune = 0;
    if str.is_null() || 0 == len {
        return 0i32;
    } else {
        text = str;
        text_len = len;
        glyph_len = nk_utf_decode(text, &mut unicode, text_len);
        while 0 != glyph_len && src_len < len {
            glyphs += 1;
            src_len = src_len + glyph_len;
            glyph_len = nk_utf_decode(
                text.offset(src_len as isize),
                &mut unicode,
                text_len - src_len,
            )
        }
        return glyphs;
    };
}
#[no_mangle]
pub unsafe fn nk_str_append_text_char(
    mut s: *mut nk_str,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut mem: *mut libc::c_char = 0 as *mut libc::c_char;
    if s.is_null() || str.is_null() || 0 == len {
        return 0i32;
    } else {
        mem = nk_buffer_alloc(
            &mut (*s).buffer,
            NK_BUFFER_FRONT,
            (len as nk_size).wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
            0i32 as nk_size,
        ) as *mut libc::c_char;
        if mem.is_null() {
            return 0i32;
        } else {
            nk_memcopy(
                mem as *mut libc::c_void,
                str as *const libc::c_void,
                (len as nk_size)
                    .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
            );
            (*s).len += nk_utf_len(str, len);
            return len;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_str_at_rune(
    mut str: *mut nk_str,
    mut pos: libc::c_int,
    mut unicode: *mut nk_rune,
    mut len: *mut libc::c_int,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0i32;
    let mut src_len: libc::c_int = 0i32;
    let mut glyph_len: libc::c_int = 0i32;
    let mut text: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut text_len: libc::c_int = 0;
    if str.is_null() || unicode.is_null() || len.is_null() {
        return 0 as *mut libc::c_char;
    } else if pos < 0i32 {
        *unicode = 0i32 as nk_rune;
        *len = 0i32;
        return 0 as *mut libc::c_char;
    } else {
        text = (*str).buffer.memory.ptr as *mut libc::c_char;
        text_len = (*str).buffer.allocated as libc::c_int;
        glyph_len = nk_utf_decode(text, unicode, text_len);
        while 0 != glyph_len {
            if i == pos {
                *len = glyph_len;
                break;
            } else {
                i += 1;
                src_len = src_len + glyph_len;
                glyph_len =
                    nk_utf_decode(text.offset(src_len as isize), unicode, text_len - src_len)
            }
        }
        if i != pos {
            return 0 as *mut libc::c_char;
        } else {
            return text.offset(src_len as isize);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_textedit_delete_selection(mut state: *mut nk_text_edit) -> () {
    /* delete the section */
    nk_textedit_clamp(state);
    if (*state).select_start != (*state).select_end {
        if (*state).select_start < (*state).select_end {
            nk_textedit_delete(
                state,
                (*state).select_start,
                (*state).select_end - (*state).select_start,
            );
            (*state).cursor = (*state).select_start;
            (*state).select_end = (*state).cursor
        } else {
            nk_textedit_delete(
                state,
                (*state).select_end,
                (*state).select_start - (*state).select_end,
            );
            (*state).cursor = (*state).select_end;
            (*state).select_start = (*state).cursor
        }
        (*state).has_preferred_x = 0i32 as libc::c_uchar
    };
}
#[no_mangle]
pub unsafe fn nk_textedit_delete(
    mut state: *mut nk_text_edit,
    mut where_0: libc::c_int,
    mut len: libc::c_int,
) -> () {
    /* delete characters while updating undo */
    nk_textedit_makeundo_delete(state, where_0, len);
    nk_str_delete_runes(&mut (*state).string, where_0, len);
    (*state).has_preferred_x = 0i32 as libc::c_uchar;
}
#[no_mangle]
pub unsafe fn nk_str_delete_runes(
    mut s: *mut nk_str,
    mut pos: libc::c_int,
    mut len: libc::c_int,
) -> () {
    let mut temp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut unicode: nk_rune = 0;
    let mut begin: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut end: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut unused: libc::c_int = 0;
    if (*s).len < pos + len {
        len = if if (*s).len - pos < (*s).len {
            (*s).len - pos
        } else {
            (*s).len
        } < 0i32
        {
            0i32
        } else if (*s).len - pos < (*s).len {
            (*s).len - pos
        } else {
            (*s).len
        }
    }
    if 0 == len {
        return;
    } else {
        temp = (*s).buffer.memory.ptr as *mut libc::c_char;
        begin = nk_str_at_rune(s, pos, &mut unicode, &mut unused);
        if begin.is_null() {
            return;
        } else {
            (*s).buffer.memory.ptr = begin as *mut libc::c_void;
            end = nk_str_at_rune(s, len, &mut unicode, &mut unused);
            (*s).buffer.memory.ptr = temp as *mut libc::c_void;
            if end.is_null() {
                return;
            } else {
                nk_str_delete_chars(
                    s,
                    temp.ptr_offset_to(begin).expect("bad offset_to") as libc::c_long
                        as libc::c_int,
                    begin.ptr_offset_to(end).expect("bad offset_to") as libc::c_long as libc::c_int,
                );
                return;
            }
        }
    };
}
#[no_mangle]
pub unsafe fn nk_str_delete_chars(
    mut s: *mut nk_str,
    mut pos: libc::c_int,
    mut len: libc::c_int,
) -> () {
    let mut dst: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut src: *mut libc::c_char = 0 as *mut libc::c_char;
    if s.is_null()
        || 0 == len
        || pos as nk_size > (*s).buffer.allocated
        || (pos + len) as nk_size > (*s).buffer.allocated
    {
        return;
    } else {
        if ((pos + len) as nk_size) < (*s).buffer.allocated {
            /* memmove */
            dst = ((*s).buffer.memory.ptr as *mut nk_byte).offset(pos as isize) as *mut libc::c_void
                as *mut libc::c_char;
            src = ((*s).buffer.memory.ptr as *mut nk_byte).offset((pos + len) as isize)
                as *mut libc::c_void as *mut libc::c_char;
            nk_memcopy(
                dst as *mut libc::c_void,
                src as *const libc::c_void,
                (*s).buffer.allocated.wrapping_sub((pos + len) as nk_size),
            );
            (*s).buffer.allocated = ((*s).buffer.allocated as libc::c_ulong)
                .wrapping_sub(len as nk_size) as nk_size
                as nk_size
        } else {
            nk_str_remove_chars(s, len);
        }
        (*s).len = nk_utf_len(
            (*s).buffer.memory.ptr as *mut libc::c_char,
            (*s).buffer.allocated as libc::c_int,
        );
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_str_remove_chars(mut s: *mut nk_str, mut len: libc::c_int) -> () {
    if s.is_null() || len < 0i32 || len as nk_size > (*s).buffer.allocated {
        return;
    } else {
        (*s).buffer.allocated = ((*s).buffer.allocated as libc::c_ulong)
            .wrapping_sub(len as nk_size) as nk_size as nk_size;
        (*s).len = nk_utf_len(
            (*s).buffer.memory.ptr as *mut libc::c_char,
            (*s).buffer.allocated as libc::c_int,
        );
        return;
    };
}
unsafe fn nk_textedit_makeundo_delete(
    mut state: *mut nk_text_edit,
    mut where_0: libc::c_int,
    mut length: libc::c_int,
) -> () {
    let mut i: libc::c_int = 0;
    let mut p: *mut nk_rune = nk_textedit_createundo(&mut (*state).undo, where_0, length, 0i32);
    if !p.is_null() {
        i = 0i32;
        while i < length {
            *p.offset(i as isize) = nk_str_rune_at(&mut (*state).string, where_0 + i);
            i += 1
        }
    };
}
#[no_mangle]
pub unsafe fn nk_str_rune_at(mut str: *const nk_str, mut pos: libc::c_int) -> nk_rune {
    let mut len: libc::c_int = 0;
    let mut unicode: nk_rune = 0i32 as nk_rune;
    nk_str_at_const(str, pos, &mut unicode, &mut len);
    return unicode;
}
#[no_mangle]
pub unsafe fn nk_str_at_const(
    mut str: *const nk_str,
    mut pos: libc::c_int,
    mut unicode: *mut nk_rune,
    mut len: *mut libc::c_int,
) -> *const libc::c_char {
    let mut i: libc::c_int = 0i32;
    let mut src_len: libc::c_int = 0i32;
    let mut glyph_len: libc::c_int = 0i32;
    let mut text: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut text_len: libc::c_int = 0;
    if str.is_null() || unicode.is_null() || len.is_null() {
        return 0 as *const libc::c_char;
    } else if pos < 0i32 {
        *unicode = 0i32 as nk_rune;
        *len = 0i32;
        return 0 as *const libc::c_char;
    } else {
        text = (*str).buffer.memory.ptr as *mut libc::c_char;
        text_len = (*str).buffer.allocated as libc::c_int;
        glyph_len = nk_utf_decode(text, unicode, text_len);
        while 0 != glyph_len {
            if i == pos {
                *len = glyph_len;
                break;
            } else {
                i += 1;
                src_len = src_len + glyph_len;
                glyph_len =
                    nk_utf_decode(text.offset(src_len as isize), unicode, text_len - src_len)
            }
        }
        if i != pos {
            return 0 as *const libc::c_char;
        } else {
            return text.offset(src_len as isize);
        }
    };
}
unsafe fn nk_textedit_clamp(mut state: *mut nk_text_edit) -> () {
    /* make the selection/cursor state valid if client altered the string */
    let mut n: libc::c_int = (*state).string.len;
    if (*state).select_start != (*state).select_end {
        if (*state).select_start > n {
            (*state).select_start = n
        }
        if (*state).select_end > n {
            (*state).select_end = n
        }
        /* if clamping forced them to be equal, move the cursor to match */
        if (*state).select_start == (*state).select_end {
            (*state).cursor = (*state).select_start
        }
    }
    if (*state).cursor > n {
        (*state).cursor = n
    };
}
unsafe fn nk_textedit_makeundo_replace(
    mut state: *mut nk_text_edit,
    mut where_0: libc::c_int,
    mut old_length: libc::c_int,
    mut new_length: libc::c_int,
) -> () {
    let mut i: libc::c_int = 0;
    let mut p: *mut nk_rune =
        nk_textedit_createundo(&mut (*state).undo, where_0, old_length, new_length);
    if !p.is_null() {
        i = 0i32;
        while i < old_length {
            *p.offset(i as isize) = nk_str_rune_at(&mut (*state).string, where_0 + i);
            i += 1
        }
    };
}
#[no_mangle]
pub unsafe fn nk_textedit_cut(mut state: *mut nk_text_edit) -> libc::c_int {
    /* API cut: delete selection */
    if (*state).mode as libc::c_int == NK_TEXT_EDIT_MODE_VIEW as libc::c_int {
        return 0i32;
    } else if (*state).select_start != (*state).select_end {
        /* implicitly clamps */
        nk_textedit_delete_selection(state);
        (*state).has_preferred_x = 0i32 as libc::c_uchar;
        return 1i32;
    } else {
        return 0i32;
    };
}
unsafe fn nk_textedit_key(
    mut state: *mut nk_text_edit,
    mut key: nk_keys,
    mut shift_mod: libc::c_int,
    mut font: *const nk_user_font,
    mut row_height: f32,
) -> () {
    let mut sel: libc::c_int = 0;
    let mut find: nk_text_find = nk_text_find {
        x: 0.,
        y: 0.,
        height: 0.,
        first_char: 0,
        length: 0,
        prev_first: 0,
    };
    let mut row: nk_text_edit_row = nk_text_edit_row {
        x0: 0.,
        x1: 0.,
        baseline_y_delta: 0.,
        ymin: 0.,
        ymax: 0.,
        num_chars: 0,
    };
    let mut sel_0: libc::c_int = 0;
    let mut i_0: libc::c_int = 0;
    let mut row_0: nk_text_edit_row = nk_text_edit_row {
        x0: 0.,
        x1: 0.,
        baseline_y_delta: 0.,
        ymin: 0.,
        ymax: 0.,
        num_chars: 0,
    };
    let mut i: libc::c_int = 0;
    let mut find_0: nk_text_find = nk_text_find {
        x: 0.,
        y: 0.,
        height: 0.,
        first_char: 0,
        length: 0,
        prev_first: 0,
    };
    let mut current_block: u64;
    loop {
        match key as libc::c_uint {
            21 => {
                nk_textedit_undo(state);
                (*state).has_preferred_x = 0i32 as libc::c_uchar;
                current_block = 6281126495347172768;
                break;
            }
            22 => {
                nk_textedit_redo(state);
                (*state).has_preferred_x = 0i32 as libc::c_uchar;
                current_block = 6281126495347172768;
                break;
            }
            23 => {
                nk_textedit_select_all(state);
                (*state).has_preferred_x = 0i32 as libc::c_uchar;
                current_block = 6281126495347172768;
                break;
            }
            14 => {
                if (*state).mode as libc::c_int == NK_TEXT_EDIT_MODE_VIEW as libc::c_int {
                    current_block = 16658872821858055392;
                    break;
                } else {
                    current_block = 6281126495347172768;
                    break;
                }
            }
            15 => {
                if (*state).mode as libc::c_int == NK_TEXT_EDIT_MODE_VIEW as libc::c_int {
                    current_block = 17179679302217393232;
                    break;
                } else {
                    current_block = 6281126495347172768;
                    break;
                }
            }
            16 => {
                if (*state).mode as libc::c_int == NK_TEXT_EDIT_MODE_INSERT as libc::c_int
                    || (*state).mode as libc::c_int == NK_TEXT_EDIT_MODE_REPLACE as libc::c_int
                {
                    current_block = 820271813250567934;
                    break;
                } else {
                    current_block = 6281126495347172768;
                    break;
                }
            }
            12 => {
                if 0 != shift_mod {
                    current_block = 15619007995458559411;
                    break;
                } else {
                    current_block = 10886091980245723256;
                    break;
                }
            }
            13 => {
                if 0 != shift_mod {
                    current_block = 11650488183268122163;
                    break;
                } else {
                    current_block = 5399440093318478209;
                    break;
                }
            }
            24 => {
                if 0 != shift_mod {
                    current_block = 8236137900636309791;
                    break;
                } else {
                    current_block = 12039483399334584727;
                    break;
                }
            }
            25 => {
                if 0 != shift_mod {
                    current_block = 7175849428784450219;
                    break;
                } else {
                    current_block = 224731115979188411;
                    break;
                }
            }
            11 => {
                find = nk_text_find {
                    x: 0.,
                    y: 0.,
                    height: 0.,
                    first_char: 0,
                    length: 0,
                    prev_first: 0,
                };
                row = nk_text_edit_row {
                    x0: 0.,
                    x1: 0.,
                    baseline_y_delta: 0.,
                    ymin: 0.,
                    ymax: 0.,
                    num_chars: 0,
                };
                i = 0;
                sel = shift_mod;
                if 0 != (*state).single_line {
                    /* on windows, up&down in single-line behave like left&right */
                    key = NK_KEY_RIGHT
                } else if 0 != sel {
                    current_block = 18386322304582297246;
                    break;
                } else {
                    current_block = 6669252993407410313;
                    break;
                }
            }
            10 => {
                find_0 = nk_text_find {
                    x: 0.,
                    y: 0.,
                    height: 0.,
                    first_char: 0,
                    length: 0,
                    prev_first: 0,
                };
                row_0 = nk_text_edit_row {
                    x0: 0.,
                    x1: 0.,
                    baseline_y_delta: 0.,
                    ymin: 0.,
                    ymax: 0.,
                    num_chars: 0,
                };
                i_0 = 0;
                sel_0 = shift_mod;
                if 0 != (*state).single_line {
                    /* on windows, up&down become left&right */
                    key = NK_KEY_LEFT
                } else if 0 != sel_0 {
                    current_block = 10692455896603418738;
                    break;
                } else {
                    current_block = 1836292691772056875;
                    break;
                }
            }
            3 => {
                if (*state).mode as libc::c_int == NK_TEXT_EDIT_MODE_VIEW as libc::c_int {
                    current_block = 6281126495347172768;
                    break;
                } else {
                    current_block = 1847472278776910194;
                    break;
                }
            }
            6 => {
                if (*state).mode as libc::c_int == NK_TEXT_EDIT_MODE_VIEW as libc::c_int {
                    current_block = 6281126495347172768;
                    break;
                } else {
                    current_block = 6174974146017752131;
                    break;
                }
            }
            19 => {
                if 0 != shift_mod {
                    current_block = 7990025728955927862;
                    break;
                } else {
                    current_block = 2516253395664191498;
                    break;
                }
            }
            20 => {
                if 0 != shift_mod {
                    current_block = 7018308795614528254;
                    break;
                } else {
                    current_block = 17233182392562552756;
                    break;
                }
            }
            17 => {
                if 0 != shift_mod {
                    current_block = 2520131295878969859;
                    break;
                } else {
                    current_block = 11441799814184323368;
                    break;
                }
            }
            18 => {
                if 0 != shift_mod {
                    current_block = 9437013279121998969;
                    break;
                } else {
                    current_block = 7494008139977416618;
                    break;
                }
            }
            0 | 2 | 4 | 1 | 5 | 7 | 8 | 9 | 30 | _ => {
                current_block = 6281126495347172768;
                break;
            }
        }
    }
    match current_block {
        10886091980245723256 => {
            /* if currently there's a selection,
             * move cursor to start of selection */
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_first(state);
            } else if (*state).cursor > 0i32 {
                (*state).cursor -= 1
            }
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        10692455896603418738 => {
            nk_textedit_prep_selection_at_cursor(state);
            current_block = 2604890879466389055;
        }
        6174974146017752131 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_delete_selection(state);
            } else {
                nk_textedit_clamp(state);
                if (*state).cursor > 0i32 {
                    nk_textedit_delete(state, (*state).cursor - 1i32, 1i32);
                    (*state).cursor -= 1
                }
            }
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        7990025728955927862 => {
            nk_textedit_prep_selection_at_cursor(state);
            (*state).select_end = 0i32;
            (*state).cursor = (*state).select_end;
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        1836292691772056875 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_first(state);
                current_block = 2604890879466389055;
            } else {
                current_block = 2604890879466389055;
            }
        }
        15619007995458559411 => {
            nk_textedit_clamp(state);
            nk_textedit_prep_selection_at_cursor(state);
            /* move selection left */
            if (*state).select_end > 0i32 {
                (*state).select_end -= 1
            }
            (*state).cursor = (*state).select_end;
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        9437013279121998969 => {
            let mut find_3: nk_text_find = nk_text_find {
                x: 0.,
                y: 0.,
                height: 0.,
                first_char: 0,
                length: 0,
                prev_first: 0,
            };
            nk_textedit_clamp(state);
            nk_textedit_prep_selection_at_cursor(state);
            nk_textedit_find_charpos(
                &mut find_3,
                state,
                (*state).cursor,
                (*state).single_line as libc::c_int,
                font,
                row_height,
            );
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            (*state).cursor = find_3.first_char + find_3.length;
            if find_3.length > 0i32
                && nk_str_rune_at(&mut (*state).string, (*state).cursor - 1i32)
                    == '\n' as i32 as libc::c_uint
            {
                (*state).cursor -= 1
            }
            (*state).select_end = (*state).cursor;
            current_block = 6281126495347172768;
        }
        8236137900636309791 => {
            if !((*state).select_start != (*state).select_end) {
                nk_textedit_prep_selection_at_cursor(state);
            }
            (*state).cursor = nk_textedit_move_to_word_previous(state);
            (*state).select_end = (*state).cursor;
            nk_textedit_clamp(state);
            current_block = 6281126495347172768;
        }
        7175849428784450219 => {
            if !((*state).select_start != (*state).select_end) {
                nk_textedit_prep_selection_at_cursor(state);
            }
            (*state).cursor = nk_textedit_move_to_word_next(state);
            (*state).select_end = (*state).cursor;
            nk_textedit_clamp(state);
            current_block = 6281126495347172768;
        }
        7494008139977416618 => {
            let mut find_4: nk_text_find = nk_text_find {
                x: 0.,
                y: 0.,
                height: 0.,
                first_char: 0,
                length: 0,
                prev_first: 0,
            };
            nk_textedit_clamp(state);
            nk_textedit_move_to_first(state);
            nk_textedit_find_charpos(
                &mut find_4,
                state,
                (*state).cursor,
                (*state).single_line as libc::c_int,
                font,
                row_height,
            );
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            (*state).cursor = find_4.first_char + find_4.length;
            if find_4.length > 0i32
                && nk_str_rune_at(&mut (*state).string, (*state).cursor - 1i32)
                    == '\n' as i32 as libc::c_uint
            {
                (*state).cursor -= 1;
                current_block = 6281126495347172768;
            } else {
                current_block = 6281126495347172768;
            }
        }
        5399440093318478209 => {
            /* if currently there's a selection,
             * move cursor to end of selection */
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_last(state);
            } else {
                (*state).cursor += 1
            }
            nk_textedit_clamp(state);
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        18386322304582297246 => {
            nk_textedit_prep_selection_at_cursor(state);
            current_block = 7172762164747879670;
        }
        224731115979188411 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_last(state);
            } else {
                (*state).cursor = nk_textedit_move_to_word_next(state);
                nk_textedit_clamp(state);
            }
            current_block = 6281126495347172768;
        }
        11441799814184323368 => {
            let mut find_2: nk_text_find = nk_text_find {
                x: 0.,
                y: 0.,
                height: 0.,
                first_char: 0,
                length: 0,
                prev_first: 0,
            };
            if 0 != (*state).string.len && (*state).cursor == (*state).string.len {
                (*state).cursor -= 1
            }
            nk_textedit_clamp(state);
            nk_textedit_move_to_first(state);
            nk_textedit_find_charpos(
                &mut find_2,
                state,
                (*state).cursor,
                (*state).single_line as libc::c_int,
                font,
                row_height,
            );
            (*state).cursor = find_2.first_char;
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        7018308795614528254 => {
            nk_textedit_prep_selection_at_cursor(state);
            (*state).select_end = (*state).string.len;
            (*state).cursor = (*state).select_end;
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        1847472278776910194 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_delete_selection(state);
            } else {
                let mut n: libc::c_int = (*state).string.len;
                if (*state).cursor < n {
                    nk_textedit_delete(state, (*state).cursor, 1i32);
                }
            }
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        11650488183268122163 => {
            nk_textedit_prep_selection_at_cursor(state);
            /* move selection right */
            (*state).select_end += 1;
            nk_textedit_clamp(state);
            (*state).cursor = (*state).select_end;
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        6669252993407410313 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_last(state);
                current_block = 7172762164747879670;
            } else {
                current_block = 7172762164747879670;
            }
        }
        2520131295878969859 => {
            let mut find_1: nk_text_find = nk_text_find {
                x: 0.,
                y: 0.,
                height: 0.,
                first_char: 0,
                length: 0,
                prev_first: 0,
            };
            nk_textedit_clamp(state);
            nk_textedit_prep_selection_at_cursor(state);
            if 0 != (*state).string.len && (*state).cursor == (*state).string.len {
                (*state).cursor -= 1
            }
            nk_textedit_find_charpos(
                &mut find_1,
                state,
                (*state).cursor,
                (*state).single_line as libc::c_int,
                font,
                row_height,
            );
            (*state).select_end = find_1.first_char;
            (*state).cursor = (*state).select_end;
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        12039483399334584727 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_first(state);
            } else {
                (*state).cursor = nk_textedit_move_to_word_previous(state);
                nk_textedit_clamp(state);
            }
            current_block = 6281126495347172768;
        }
        16658872821858055392 => {
            (*state).mode = NK_TEXT_EDIT_MODE_INSERT as libc::c_int as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        820271813250567934 => {
            (*state).mode = NK_TEXT_EDIT_MODE_VIEW as libc::c_int as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        17233182392562552756 => {
            (*state).cursor = (*state).string.len;
            (*state).select_end = 0i32;
            (*state).select_start = (*state).select_end;
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        17179679302217393232 => {
            (*state).mode = NK_TEXT_EDIT_MODE_REPLACE as libc::c_int as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        2516253395664191498 => {
            (*state).select_end = 0i32;
            (*state).select_start = (*state).select_end;
            (*state).cursor = (*state).select_start;
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            current_block = 6281126495347172768;
        }
        _ => {}
    }
    match current_block {
        7172762164747879670 => {
            /* compute current position of cursor point */
            nk_textedit_clamp(state);
            nk_textedit_find_charpos(
                &mut find,
                state,
                (*state).cursor,
                (*state).single_line as libc::c_int,
                font,
                row_height,
            );
            /* now find character position down a row */
            if 0 != find.length {
                let mut x: f32 = 0.;
                let mut goal_x: f32 = if 0 != (*state).has_preferred_x as libc::c_int {
                    (*state).preferred_x
                } else {
                    find.x
                };
                let mut start: libc::c_int = find.first_char + find.length;
                (*state).cursor = start;
                nk_textedit_layout_row(&mut row, state, (*state).cursor, row_height, font);
                x = row.x0;
                i = 0i32;
                while i < row.num_chars && x < row.x1 {
                    let mut dx: f32 = nk_textedit_get_width(state, start, i, font);
                    x += dx;
                    if x > goal_x {
                        break;
                    }
                    (*state).cursor += 1;
                    i += 1
                }
                nk_textedit_clamp(state);
                (*state).has_preferred_x = 1i32 as libc::c_uchar;
                (*state).preferred_x = goal_x;
                if 0 != sel {
                    (*state).select_end = (*state).cursor
                }
            }
        }
        2604890879466389055 => {
            /* compute current position of cursor point */
            nk_textedit_clamp(state);
            nk_textedit_find_charpos(
                &mut find_0,
                state,
                (*state).cursor,
                (*state).single_line as libc::c_int,
                font,
                row_height,
            );
            /* can only go up if there's a previous row */
            if find_0.prev_first != find_0.first_char {
                /* now find character position up a row */
                let mut x_0: f32 = 0.;
                let mut goal_x_0: f32 = if 0 != (*state).has_preferred_x as libc::c_int {
                    (*state).preferred_x
                } else {
                    find_0.x
                };
                (*state).cursor = find_0.prev_first;
                nk_textedit_layout_row(&mut row_0, state, (*state).cursor, row_height, font);
                x_0 = row_0.x0;
                i_0 = 0i32;
                while i_0 < row_0.num_chars && x_0 < row_0.x1 {
                    let mut dx_0: f32 =
                        nk_textedit_get_width(state, find_0.prev_first, i_0, font);
                    x_0 += dx_0;
                    if x_0 > goal_x_0 {
                        break;
                    }
                    (*state).cursor += 1;
                    i_0 += 1
                }
                nk_textedit_clamp(state);
                (*state).has_preferred_x = 1i32 as libc::c_uchar;
                (*state).preferred_x = goal_x_0;
                if 0 != sel_0 {
                    (*state).select_end = (*state).cursor
                }
            }
        }
        _ => {}
    };
}
unsafe fn nk_textedit_find_charpos(
    mut find: *mut nk_text_find,
    mut state: *mut nk_text_edit,
    mut n: libc::c_int,
    mut single_line: libc::c_int,
    mut font: *const nk_user_font,
    mut row_height: f32,
) -> () {
    /* find the x/y location of a character, and remember info about the previous
     * row in case we get a move-up event (for page up, we'll have to rescan) */
    let mut r: nk_text_edit_row = nk_text_edit_row {
        x0: 0.,
        x1: 0.,
        baseline_y_delta: 0.,
        ymin: 0.,
        ymax: 0.,
        num_chars: 0,
    };
    let mut prev_start: libc::c_int = 0i32;
    let mut z: libc::c_int = (*state).string.len;
    let mut i: libc::c_int = 0i32;
    let mut first: libc::c_int = 0;
    nk_zero(
        &mut r as *mut nk_text_edit_row as *mut libc::c_void,
        ::std::mem::size_of::<nk_text_edit_row>() as libc::c_ulong,
    );
    if n == z {
        /* if it's at the end, then find the last line -- simpler than trying to
        explicitly handle this case in the regular code */
        nk_textedit_layout_row(&mut r, state, 0i32, row_height, font);
        if 0 != single_line {
            (*find).first_char = 0i32;
            (*find).length = z
        } else {
            while i < z {
                prev_start = i;
                i += r.num_chars;
                nk_textedit_layout_row(&mut r, state, i, row_height, font);
            }
            (*find).first_char = i;
            (*find).length = r.num_chars
        }
        (*find).x = r.x1;
        (*find).y = r.ymin;
        (*find).height = r.ymax - r.ymin;
        (*find).prev_first = prev_start;
        return;
    } else {
        /* search rows to find the one that straddles character n */
        (*find).y = 0i32 as f32;
        loop {
            nk_textedit_layout_row(&mut r, state, i, row_height, font);
            if n < i + r.num_chars {
                break;
            }
            prev_start = i;
            i += r.num_chars;
            (*find).y += r.baseline_y_delta
        }
        first = i;
        (*find).first_char = first;
        (*find).length = r.num_chars;
        (*find).height = r.ymax - r.ymin;
        (*find).prev_first = prev_start;
        /* now scan to find xpos */
        (*find).x = r.x0;
        i = 0i32;
        while first + i < n {
            (*find).x += nk_textedit_get_width(state, first, i, font);
            i += 1
        }
        return;
    };
}
unsafe fn nk_textedit_get_width(
    mut edit: *const nk_text_edit,
    mut line_start: libc::c_int,
    mut char_id: libc::c_int,
    mut font: *const nk_user_font,
) -> f32 {
    let mut len: libc::c_int = 0i32;
    let mut unicode: nk_rune = 0i32 as nk_rune;
    let mut str: *const libc::c_char = nk_str_at_const(
        &(*edit).string,
        line_start + char_id,
        &mut unicode,
        &mut len,
    );
    return (*font).width.expect("non-null function pointer")(
        (*font).userdata,
        (*font).height,
        str,
        len,
    );
}
unsafe fn nk_textedit_layout_row(
    mut r: *mut nk_text_edit_row,
    mut edit: *mut nk_text_edit,
    mut line_start_id: libc::c_int,
    mut row_height: f32,
    mut font: *const nk_user_font,
) -> () {
    let mut l: libc::c_int = 0;
    let mut glyphs: libc::c_int = 0i32;
    let mut unicode: nk_rune = 0;
    let mut remaining: *const libc::c_char = 0 as *const libc::c_char;
    let mut len: libc::c_int = nk_str_len_char(&mut (*edit).string);
    let mut end: *const libc::c_char = nk_str_get_const(&mut (*edit).string).offset(len as isize);
    let mut text: *const libc::c_char =
        nk_str_at_const(&mut (*edit).string, line_start_id, &mut unicode, &mut l);
    let size: nk_vec2 = nk_text_calculate_text_bounds(
        font,
        text,
        text.ptr_offset_to(end).expect("bad offset_to") as libc::c_long as libc::c_int,
        row_height,
        &mut remaining,
        0 as *mut nk_vec2,
        &mut glyphs,
        NK_STOP_ON_NEW_LINE as libc::c_int,
    );
    (*r).x0 = 0.0f32;
    (*r).x1 = size.x;
    (*r).baseline_y_delta = size.y;
    (*r).ymin = 0.0f32;
    (*r).ymax = size.y;
    (*r).num_chars = glyphs;
}
unsafe fn nk_textedit_move_to_first(mut state: *mut nk_text_edit) -> () {
    /* move cursor to first character of selection */
    if (*state).select_start != (*state).select_end {
        nk_textedit_sortselection(state);
        (*state).cursor = (*state).select_start;
        (*state).select_end = (*state).select_start;
        (*state).has_preferred_x = 0i32 as libc::c_uchar
    };
}
unsafe fn nk_textedit_sortselection(mut state: *mut nk_text_edit) -> () {
    /* canonicalize the selection so start <= end */
    if (*state).select_end < (*state).select_start {
        let mut temp: libc::c_int = (*state).select_end;
        (*state).select_end = (*state).select_start;
        (*state).select_start = temp
    };
}
unsafe fn nk_textedit_prep_selection_at_cursor(mut state: *mut nk_text_edit) -> () {
    /* update selection and cursor to match each other */
    if !((*state).select_start != (*state).select_end) {
        (*state).select_end = (*state).cursor;
        (*state).select_start = (*state).select_end
    } else {
        (*state).cursor = (*state).select_end
    };
}
unsafe fn nk_textedit_move_to_last(mut state: *mut nk_text_edit) -> () {
    /* move cursor to last character of selection */
    if (*state).select_start != (*state).select_end {
        nk_textedit_sortselection(state);
        nk_textedit_clamp(state);
        (*state).cursor = (*state).select_end;
        (*state).select_start = (*state).select_end;
        (*state).has_preferred_x = 0i32 as libc::c_uchar
    };
}
unsafe fn nk_textedit_move_to_word_next(mut state: *mut nk_text_edit) -> libc::c_int {
    let len: libc::c_int = (*state).string.len;
    let mut c: libc::c_int = (*state).cursor + 1i32;
    while c < len && 0 == nk_is_word_boundary(state, c) {
        c += 1
    }
    if c > len {
        c = len
    }
    return c;
}
unsafe fn nk_is_word_boundary(mut state: *mut nk_text_edit, mut idx: libc::c_int) -> libc::c_int {
    let mut len: libc::c_int = 0;
    let mut c: nk_rune = 0;
    if idx <= 0i32 {
        return 1i32;
    } else if nk_str_at_rune(&mut (*state).string, idx, &mut c, &mut len).is_null() {
        return 1i32;
    } else {
        return (c == ' ' as i32 as libc::c_uint
            || c == '\t' as i32 as libc::c_uint
            || c == 12288i32 as libc::c_uint
            || c == ',' as i32 as libc::c_uint
            || c == ';' as i32 as libc::c_uint
            || c == '(' as i32 as libc::c_uint
            || c == ')' as i32 as libc::c_uint
            || c == '{' as i32 as libc::c_uint
            || c == '}' as i32 as libc::c_uint
            || c == '[' as i32 as libc::c_uint
            || c == ']' as i32 as libc::c_uint
            || c == '|' as i32 as libc::c_uint) as libc::c_int;
    };
}
unsafe fn nk_textedit_move_to_word_previous(mut state: *mut nk_text_edit) -> libc::c_int {
    let mut c: libc::c_int = (*state).cursor - 1i32;
    while c >= 0i32 && 0 == nk_is_word_boundary(state, c) {
        c -= 1
    }
    if c < 0i32 {
        c = 0i32
    }
    return c;
}
#[no_mangle]
pub unsafe fn nk_textedit_select_all(mut state: *mut nk_text_edit) -> () {
    (*state).select_start = 0i32;
    (*state).select_end = (*state).string.len;
}
#[no_mangle]
pub unsafe fn nk_textedit_redo(mut state: *mut nk_text_edit) -> () {
    let mut s: *mut nk_text_undo_state = &mut (*state).undo as *mut nk_text_undo_state;
    let mut u: *mut nk_text_undo_record = 0 as *mut nk_text_undo_record;
    let mut r: nk_text_undo_record = nk_text_undo_record {
        where_0: 0,
        insert_length: 0,
        delete_length: 0,
        char_storage: 0,
    };
    if (*s).redo_point as libc::c_int == 99i32 {
        return;
    } else {
        /* we need to do two things: apply the redo record, and create an undo record */
        u = &mut (*s).undo_rec[(*s).undo_point as usize] as *mut nk_text_undo_record;
        r = (*s).undo_rec[(*s).redo_point as usize];
        /* we KNOW there must be room for the undo record, because the redo record
    was derived from an undo record */
        (*u).delete_length = r.insert_length;
        (*u).insert_length = r.delete_length;
        (*u).where_0 = r.where_0;
        (*u).char_storage = -1i32 as libc::c_short;
        if 0 != r.delete_length {
            /* the redo record requires us to delete characters, so the undo record
        needs to store the characters */
            if (*s).undo_char_point as libc::c_int + (*u).insert_length as libc::c_int
                > (*s).redo_char_point as libc::c_int
            {
                (*u).insert_length = 0i32 as libc::c_short;
                (*u).delete_length = 0i32 as libc::c_short
            } else {
                let mut i: libc::c_int = 0;
                (*u).char_storage = (*s).undo_char_point;
                (*s).undo_char_point = ((*s).undo_char_point as libc::c_int
                    + (*u).insert_length as libc::c_int)
                    as libc::c_short;
                /* now save the characters */
                i = 0i32;
                while i < (*u).insert_length as libc::c_int {
                    (*s).undo_char[((*u).char_storage as libc::c_int + i) as usize] =
                        nk_str_rune_at(&mut (*state).string, (*u).where_0 + i);
                    i += 1
                }
            }
            nk_str_delete_runes(
                &mut (*state).string,
                r.where_0,
                r.delete_length as libc::c_int,
            );
        }
        if 0 != r.insert_length {
            /* easy case: need to insert n characters */
            nk_str_insert_text_runes(
                &mut (*state).string,
                r.where_0,
                &mut (*s).undo_char[r.char_storage as usize],
                r.insert_length as libc::c_int,
            );
        }
        (*state).cursor = r.where_0 + r.insert_length as libc::c_int;
        (*s).undo_point += 1;
        (*s).redo_point += 1;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_str_insert_text_runes(
    mut str: *mut nk_str,
    mut pos: libc::c_int,
    mut runes: *const nk_rune,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0i32;
    let mut byte_len: libc::c_int = 0i32;
    let mut glyph: nk_glyph = [0; 4];
    if str.is_null() || runes.is_null() || 0 == len {
        return 0i32;
    } else {
        i = 0i32;
        while i < len {
            byte_len = nk_utf_encode(*runes.offset(i as isize), glyph.as_mut_ptr(), 4i32);
            if 0 == byte_len {
                break;
            }
            nk_str_insert_at_rune(str, pos + i, glyph.as_mut_ptr(), byte_len);
            i += 1
        }
        return len;
    };
}
#[no_mangle]
pub unsafe fn nk_textedit_undo(mut state: *mut nk_text_edit) -> () {
    let mut s: *mut nk_text_undo_state = &mut (*state).undo as *mut nk_text_undo_state;
    let mut u: nk_text_undo_record = nk_text_undo_record {
        where_0: 0,
        insert_length: 0,
        delete_length: 0,
        char_storage: 0,
    };
    let mut r: *mut nk_text_undo_record = 0 as *mut nk_text_undo_record;
    if (*s).undo_point as libc::c_int == 0i32 {
        return;
    } else {
        /* we need to do two things: apply the undo record, and create a redo record */
        u = (*s).undo_rec[((*s).undo_point as libc::c_int - 1i32) as usize];
        r = &mut (*s).undo_rec[((*s).redo_point as libc::c_int - 1i32) as usize]
            as *mut nk_text_undo_record;
        (*r).char_storage = -1i32 as libc::c_short;
        (*r).insert_length = u.delete_length;
        (*r).delete_length = u.insert_length;
        (*r).where_0 = u.where_0;
        if 0 != u.delete_length {
            /*   if the undo record says to delete characters, then the redo record will
            need to re-insert the characters that get deleted, so we need to store
            them.
            there are three cases:
                - there's enough room to store the characters
                - characters stored for *redoing* don't leave room for redo
                - characters stored for *undoing* don't leave room for redo
            if the last is true, we have to bail */
            if (*s).undo_char_point as libc::c_int + u.delete_length as libc::c_int >= 999i32 {
                /* the undo records take up too much character space; there's no space
                 * to store the redo characters */
                (*r).insert_length = 0i32 as libc::c_short
            } else {
                let mut i: libc::c_int = 0;
                /* there's definitely room to store the characters eventually */
                while (*s).undo_char_point as libc::c_int + u.delete_length as libc::c_int
                    > (*s).redo_char_point as libc::c_int
                {
                    /* there's currently not enough room, so discard a redo record */
                    nk_textedit_discard_redo(s);
                    /* should never happen: */
                    if !((*s).redo_point as libc::c_int == 99i32) {
                        continue;
                    }
                    return;
                }
                r = &mut (*s).undo_rec[((*s).redo_point as libc::c_int - 1i32) as usize]
                    as *mut nk_text_undo_record;
                (*r).char_storage = ((*s).redo_char_point as libc::c_int
                    - u.delete_length as libc::c_int)
                    as libc::c_short;
                (*s).redo_char_point = ((*s).redo_char_point as libc::c_int
                    - u.delete_length as libc::c_int)
                    as libc::c_short;
                /* now save the characters */
                i = 0i32;
                while i < u.delete_length as libc::c_int {
                    (*s).undo_char[((*r).char_storage as libc::c_int + i) as usize] =
                        nk_str_rune_at(&mut (*state).string, u.where_0 + i);
                    i += 1
                }
            }
            /* now we can carry out the deletion */
            nk_str_delete_runes(
                &mut (*state).string,
                u.where_0,
                u.delete_length as libc::c_int,
            );
        }
        /* check type of recorded action: */
        if 0 != u.insert_length {
            /* easy case: was a deletion, so we need to insert n characters */
            nk_str_insert_text_runes(
                &mut (*state).string,
                u.where_0,
                &mut (*s).undo_char[u.char_storage as usize],
                u.insert_length as libc::c_int,
            );
            (*s).undo_char_point = ((*s).undo_char_point as libc::c_int
                - u.insert_length as libc::c_int)
                as libc::c_short
        }
        (*state).cursor =
            (u.where_0 + u.insert_length as libc::c_int) as libc::c_short as libc::c_int;
        (*s).undo_point -= 1;
        (*s).redo_point -= 1;
        return;
    };
}
unsafe fn nk_textedit_discard_redo(mut state: *mut nk_text_undo_state) -> () {
    /*  discard the oldest entry in the redo list--it's bad if this
    ever happens, but because undo & redo have to store the actual
    characters in different cases, the redo character buffer can
    fill up even though the undo buffer didn't */
    let mut num: nk_size = 0;
    let mut k: libc::c_int = 99i32 - 1i32;
    if (*state).redo_point as libc::c_int <= k {
        /* if the k'th undo state has characters, clean those up */
        if (*state).undo_rec[k as usize].char_storage as libc::c_int >= 0i32 {
            let mut n: libc::c_int = (*state).undo_rec[k as usize].insert_length as libc::c_int;
            let mut i: libc::c_int = 0;
            /* delete n characters from all other records */
            (*state).redo_char_point =
                ((*state).redo_char_point as libc::c_int + n) as libc::c_short;
            num = (999i32 - (*state).redo_char_point as libc::c_int) as nk_size;
            nk_memcopy(
                (*state)
                    .undo_char
                    .as_mut_ptr()
                    .offset((*state).redo_char_point as libc::c_int as isize)
                    as *mut libc::c_void,
                (*state)
                    .undo_char
                    .as_mut_ptr()
                    .offset((*state).redo_char_point as libc::c_int as isize)
                    .offset(-(n as isize)) as *const libc::c_void,
                num.wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
            );
            i = (*state).redo_point as libc::c_int;
            while i < k {
                if (*state).undo_rec[i as usize].char_storage as libc::c_int >= 0i32 {
                    (*state).undo_rec[i as usize].char_storage =
                        ((*state).undo_rec[i as usize].char_storage as libc::c_int + n)
                            as libc::c_short
                }
                i += 1
            }
        }
        (*state).redo_point += 1;
        num = (99i32 - (*state).redo_point as libc::c_int) as nk_size;
        if 0 != num {
            nk_memcopy(
                (*state)
                    .undo_rec
                    .as_mut_ptr()
                    .offset((*state).redo_point as libc::c_int as isize)
                    .offset(-1isize) as *mut libc::c_void,
                (*state)
                    .undo_rec
                    .as_mut_ptr()
                    .offset((*state).redo_point as libc::c_int as isize)
                    as *const libc::c_void,
                num.wrapping_mul(::std::mem::size_of::<nk_text_undo_record>() as libc::c_ulong),
            );
        }
    };
}
unsafe fn nk_textedit_drag(
    mut state: *mut nk_text_edit,
    mut x: f32,
    mut y: f32,
    mut font: *const nk_user_font,
    mut row_height: f32,
) -> () {
    /* API drag: on mouse drag, move the cursor and selection endpoint
     * to the clicked location */
    let mut p: libc::c_int = nk_textedit_locate_coord(state, x, y, font, row_height);
    if (*state).select_start == (*state).select_end {
        (*state).select_start = (*state).cursor
    }
    (*state).select_end = p;
    (*state).cursor = (*state).select_end;
}
unsafe fn nk_textedit_locate_coord(
    mut edit: *mut nk_text_edit,
    mut x: f32,
    mut y: f32,
    mut font: *const nk_user_font,
    mut row_height: f32,
) -> libc::c_int {
    let mut r: nk_text_edit_row = nk_text_edit_row {
        x0: 0.,
        x1: 0.,
        baseline_y_delta: 0.,
        ymin: 0.,
        ymax: 0.,
        num_chars: 0,
    };
    let mut n: libc::c_int = (*edit).string.len;
    let mut base_y: f32 = 0i32 as f32;
    let mut prev_x: f32 = 0.;
    let mut i: libc::c_int = 0i32;
    let mut k: libc::c_int = 0;
    r.x1 = 0i32 as f32;
    r.x0 = r.x1;
    r.ymax = 0i32 as f32;
    r.ymin = r.ymax;
    r.num_chars = 0i32;
    /* search rows to find one that straddles 'y' */
    while i < n {
        nk_textedit_layout_row(&mut r, edit, i, row_height, font);
        if r.num_chars <= 0i32 {
            return n;
        } else if i == 0i32 && y < base_y + r.ymin {
            return 0i32;
        } else {
            if y < base_y + r.ymax {
                break;
            }
            i += r.num_chars;
            base_y += r.baseline_y_delta
        }
    }
    /* below all text, return 'after' last character */
    if i >= n {
        return n;
    } else if x < r.x0 {
        return i;
    } else {
        /* check if it's before the end of the line */
        if x < r.x1 {
            /* search characters in row for one that straddles 'x' */
            k = i;
            prev_x = r.x0;
            i = 0i32;
            while i < r.num_chars {
                let mut w: f32 = nk_textedit_get_width(edit, k, i, font);
                if x < prev_x + w {
                    if x < prev_x + w / 2i32 as f32 {
                        return k + i;
                    } else {
                        return k + i + 1i32;
                    }
                } else {
                    prev_x += w;
                    i += 1
                }
            }
        }
        /* shouldn't happen, but if it does, fall through to end-of-line case */
        /* if the last character is a newline, return that.
         * otherwise return 'after' the last character */
        if nk_str_rune_at(&mut (*edit).string, i + r.num_chars - 1i32)
            == '\n' as i32 as libc::c_uint
        {
            return i + r.num_chars - 1i32;
        } else {
            return i + r.num_chars;
        }
    };
}
unsafe fn nk_textedit_click(
    mut state: *mut nk_text_edit,
    mut x: f32,
    mut y: f32,
    mut font: *const nk_user_font,
    mut row_height: f32,
) -> () {
    /* API click: on mouse down, move the cursor to the clicked location,
     * and reset the selection */
    (*state).cursor = nk_textedit_locate_coord(state, x, y, font, row_height);
    (*state).select_start = (*state).cursor;
    (*state).select_end = (*state).cursor;
    (*state).has_preferred_x = 0i32 as libc::c_uchar;
}
unsafe fn nk_textedit_clear_state(
    mut state: *mut nk_text_edit,
    mut type_0: nk_text_edit_type,
    mut filter: nk_plugin_filter,
) -> () {
    /* reset the state to default */
    (*state).undo.undo_point = 0i32 as libc::c_short;
    (*state).undo.undo_char_point = 0i32 as libc::c_short;
    (*state).undo.redo_point = 99i32 as libc::c_short;
    (*state).undo.redo_char_point = 999i32 as libc::c_short;
    (*state).select_start = 0i32;
    (*state).select_end = (*state).select_start;
    (*state).cursor = 0i32;
    (*state).has_preferred_x = 0i32 as libc::c_uchar;
    (*state).preferred_x = 0i32 as f32;
    (*state).cursor_at_end_of_line = 0i32 as libc::c_uchar;
    (*state).initialized = 1i32 as libc::c_uchar;
    (*state).single_line = (type_0 as libc::c_uint
        == NK_TEXT_EDIT_SINGLE_LINE as libc::c_int as libc::c_uint)
        as libc::c_int as libc::c_uchar;
    (*state).mode = NK_TEXT_EDIT_MODE_VIEW as libc::c_int as libc::c_uchar;
    (*state).filter = filter;
    (*state).scrollbar = nk_vec2(0i32 as f32, 0i32 as f32);
}
unsafe fn nk_draw_property(
    mut out: *mut nk_command_buffer,
    mut style: *const nk_style_property,
    mut bounds: *const nk_rect,
    mut label: *const nk_rect,
    mut state: nk_flags,
    mut name: *const libc::c_char,
    mut len: libc::c_int,
    mut font: *const nk_user_font,
) -> () {
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    /* select correct background and text color */
    if 0 != state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
        background = &(*style).active as *const nk_style_item;
        text.text = (*style).label_active
    } else if 0 != state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint {
        background = &(*style).hover as *const nk_style_item;
        text.text = (*style).label_hover
    } else {
        background = &(*style).normal as *const nk_style_item;
        text.text = (*style).label_normal
    }
    /* draw background */
    if (*background).type_0 as libc::c_uint == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
        text.background = nk_rgba(0i32, 0i32, 0i32, 0i32)
    } else {
        text.background = (*background).data.color;
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        nk_stroke_rect(
            out,
            *bounds,
            (*style).rounding,
            (*style).border,
            (*background).data.color,
        );
    }
    /* draw label */
    text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
    nk_widget_text(
        out,
        *label,
        name,
        len,
        &mut text,
        NK_TEXT_CENTERED as libc::c_int as nk_flags,
        font,
    );
}
unsafe fn nk_property_behavior(
    mut ws: *mut nk_flags,
    mut in_0: *const nk_input,
    mut property: nk_rect,
    mut label: nk_rect,
    mut edit: nk_rect,
    mut empty: nk_rect,
    mut state: *mut libc::c_int,
    mut variant: *mut nk_property_variant,
    mut inc_per_pixel: f32,
) -> () {
    if !in_0.is_null() && *state == NK_PROPERTY_DEFAULT as libc::c_int {
        if 0 != nk_button_behavior(ws, edit, in_0, NK_BUTTON_DEFAULT) {
            *state = NK_PROPERTY_EDIT as libc::c_int
        } else if 0 != nk_input_is_mouse_click_down_in_rect(
            in_0,
            NK_BUTTON_LEFT,
            label,
            nk_true as libc::c_int,
        ) {
            *state = NK_PROPERTY_DRAG as libc::c_int
        } else if 0 != nk_input_is_mouse_click_down_in_rect(
            in_0,
            NK_BUTTON_LEFT,
            empty,
            nk_true as libc::c_int,
        ) {
            *state = NK_PROPERTY_DRAG as libc::c_int
        }
    }
    if *state == NK_PROPERTY_DRAG as libc::c_int {
        nk_drag_behavior(ws, in_0, property, variant, inc_per_pixel);
        if 0 == *ws & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint {
            *state = NK_PROPERTY_DEFAULT as libc::c_int
        }
    };
}
unsafe fn nk_drag_behavior(
    mut state: *mut nk_flags,
    mut in_0: *const nk_input,
    mut drag: nk_rect,
    mut variant: *mut nk_property_variant,
    mut inc_per_pixel: f32,
) -> () {
    let mut left_mouse_down: libc::c_int = (!in_0.is_null()
        && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down)
        as libc::c_int;
    let mut left_mouse_click_in_cursor: libc::c_int = (!in_0.is_null()
        && 0 != nk_input_has_mouse_click_down_in_rect(
            in_0,
            NK_BUTTON_LEFT,
            drag,
            nk_true as libc::c_int,
        )) as libc::c_int;
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as libc::c_int as libc::c_uint {
        *state = (NK_WIDGET_STATE_INACTIVE as libc::c_int | NK_WIDGET_STATE_MODIFIED as libc::c_int)
            as nk_flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as libc::c_int as nk_flags
    }
    if 0 != nk_input_is_mouse_hovering_rect(in_0, drag) {
        *state = NK_WIDGET_STATE_HOVERED as libc::c_int as nk_flags
    }
    if 0 != left_mouse_down && 0 != left_mouse_click_in_cursor {
        let mut delta: f32 = 0.;
        let mut pixels: f32 = 0.;
        pixels = (*in_0).mouse.delta.x;
        delta = pixels * inc_per_pixel;
        match (*variant).kind as libc::c_uint {
            0 => {
                (*variant).value.i = (*variant).value.i + delta as libc::c_int;
                (*variant).value.i = if if (*variant).value.i < (*variant).max_value.i {
                    (*variant).value.i
                } else {
                    (*variant).max_value.i
                } < (*variant).min_value.i
                {
                    (*variant).min_value.i
                } else if (*variant).value.i < (*variant).max_value.i {
                    (*variant).value.i
                } else {
                    (*variant).max_value.i
                }
            }
            1 => {
                (*variant).value.f = (*variant).value.f + delta;
                (*variant).value.f = if if (*variant).value.f < (*variant).max_value.f {
                    (*variant).value.f
                } else {
                    (*variant).max_value.f
                } < (*variant).min_value.f
                {
                    (*variant).min_value.f
                } else if (*variant).value.f < (*variant).max_value.f {
                    (*variant).value.f
                } else {
                    (*variant).max_value.f
                }
            }
            2 => {
                (*variant).value.d = (*variant).value.d + delta as libc::c_double;
                (*variant).value.d = if if (*variant).value.d < (*variant).max_value.d {
                    (*variant).value.d
                } else {
                    (*variant).max_value.d
                } < (*variant).min_value.d
                {
                    (*variant).min_value.d
                } else if (*variant).value.d < (*variant).max_value.d {
                    (*variant).value.d
                } else {
                    (*variant).max_value.d
                }
            }
            _ => {}
        }
        *state = NK_WIDGET_STATE_ACTIVE as libc::c_int as nk_flags
    }
    if 0 != *state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
        && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, drag)
    {
        *state |= NK_WIDGET_STATE_ENTERED as libc::c_int as libc::c_uint
    } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, drag) {
        *state |= NK_WIDGET_STATE_LEFT as libc::c_int as libc::c_uint
    };
}
#[no_mangle]
pub unsafe fn nk_input_is_mouse_click_down_in_rect(
    mut i: *const nk_input,
    mut id: nk_buttons,
    mut b: nk_rect,
    mut down: libc::c_int,
) -> libc::c_int {
    let mut btn: *const nk_mouse_button = 0 as *const nk_mouse_button;
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        btn = &(*i).mouse.buttons[id as usize] as *const nk_mouse_button;
        return if 0 != nk_input_has_mouse_click_down_in_rect(i, id, b, down) && 0 != (*btn).clicked
        {
            nk_true as libc::c_int
        } else {
            nk_false as libc::c_int
        };
    };
}
unsafe fn nk_dtoa(mut s: *mut libc::c_char, mut n: libc::c_double) -> *mut libc::c_char {
    let mut t: libc::c_double = 0.;
    let mut useExp: libc::c_int = 0i32;
    let mut digit: libc::c_int = 0i32;
    let mut m: libc::c_int = 0i32;
    let mut m1: libc::c_int = 0i32;
    let mut c: *mut libc::c_char = s;
    let mut neg: libc::c_int = 0i32;
    if s.is_null() {
        return 0 as *mut libc::c_char;
    } else if n == 0.0f64 {
        *s.offset(0isize) = '0' as i32 as libc::c_char;
        *s.offset(1isize) = '\u{0}' as i32 as libc::c_char;
        return s;
    } else {
        neg = (n < 0i32 as libc::c_double) as libc::c_int;
        if 0 != neg {
            n = -n
        }
        /* calculate magnitude */
        m = nk_log10(n);
        useExp = (m >= 14i32 || 0 != neg && m >= 9i32 || m <= -9i32) as libc::c_int;
        if 0 != neg {
            let fresh24 = c;
            c = c.offset(1);
            *fresh24 = '-' as i32 as libc::c_char
        }
        /* set up for scientific notation */
        if 0 != useExp {
            if m < 0i32 {
                m -= 1i32
            }
            n = n / nk_pow(10.0f64, m);
            m1 = m;
            m = 0i32
        }
        if (m as libc::c_double) < 1.0f64 {
            m = 0i32
        }
        /* convert the number */
        while n > 1e-14f64 || m >= 0i32 {
            let mut weight: libc::c_double = nk_pow(10.0f64, m);
            if weight > 0i32 as libc::c_double {
                t = n / weight;
                digit = nk_ifloord(t);
                n -= digit as libc::c_double * weight;
                let fresh25 = c;
                c = c.offset(1);
                *fresh25 = ('0' as i32 + digit as libc::c_char as libc::c_int) as libc::c_char
            }
            if m == 0i32 && n > 0i32 as libc::c_double {
                let fresh26 = c;
                c = c.offset(1);
                *fresh26 = '.' as i32 as libc::c_char
            }
            m -= 1
        }
        if 0 != useExp {
            let mut i: libc::c_int = 0;
            /* convert the exponent */
            let mut j: libc::c_int = 0;
            let fresh27 = c;
            c = c.offset(1);
            *fresh27 = 'e' as i32 as libc::c_char;
            if m1 > 0i32 {
                let fresh28 = c;
                c = c.offset(1);
                *fresh28 = '+' as i32 as libc::c_char
            } else {
                let fresh29 = c;
                c = c.offset(1);
                *fresh29 = '-' as i32 as libc::c_char;
                m1 = -m1
            }
            m = 0i32;
            while m1 > 0i32 {
                let fresh30 = c;
                c = c.offset(1);
                *fresh30 =
                    ('0' as i32 + (m1 % 10i32) as libc::c_char as libc::c_int) as libc::c_char;
                m1 /= 10i32;
                m += 1
            }
            c = c.offset(-(m as isize));
            i = 0i32;
            j = m - 1i32;
            while i < j {
                /* swap without temporary */
                let ref mut fresh31 = *c.offset(i as isize);
                *fresh31 = (*fresh31 as libc::c_int ^ *c.offset(j as isize) as libc::c_int)
                    as libc::c_char;
                let ref mut fresh32 = *c.offset(j as isize);
                *fresh32 = (*fresh32 as libc::c_int ^ *c.offset(i as isize) as libc::c_int)
                    as libc::c_char;
                let ref mut fresh33 = *c.offset(i as isize);
                *fresh33 = (*fresh33 as libc::c_int ^ *c.offset(j as isize) as libc::c_int)
                    as libc::c_char;
                i += 1;
                j -= 1
            }
            c = c.offset(m as isize)
        }
        *c = '\u{0}' as i32 as libc::c_char;
        return s;
    };
}
unsafe fn nk_pow(mut x: libc::c_double, mut n: libc::c_int) -> libc::c_double {
    /*  check the sign of n */
    let mut r: libc::c_double = 1i32 as libc::c_double;
    let mut plus: libc::c_int = (n >= 0i32) as libc::c_int;
    n = if 0 != plus { n } else { -n };
    while n > 0i32 {
        if n & 1i32 == 1i32 {
            r *= x
        }
        n /= 2i32;
        x *= x
    }
    return if 0 != plus { r } else { 1.0f64 / r };
}
unsafe fn nk_ifloord(mut x: libc::c_double) -> libc::c_int {
    x = (x as libc::c_int - if x < 0.0f64 { 1i32 } else { 0i32 }) as libc::c_double;
    return x as libc::c_int;
}
unsafe fn nk_log10(mut n: libc::c_double) -> libc::c_int {
    let mut neg: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut exp: libc::c_int = 0i32;
    neg = if n < 0i32 as libc::c_double {
        1i32
    } else {
        0i32
    };
    ret = if 0 != neg {
        -n as libc::c_int
    } else {
        n as libc::c_int
    };
    while ret / 10i32 > 0i32 {
        ret /= 10i32;
        exp += 1
    }
    if 0 != neg {
        exp = -exp
    }
    return exp;
}
unsafe fn nk_itoa(mut s: *mut libc::c_char, mut n: libc::c_long) -> *mut libc::c_char {
    let mut i: libc::c_long = 0i32 as libc::c_long;
    if n == 0i32 as libc::c_long {
        let fresh34 = i;
        i = i + 1;
        *s.offset(fresh34 as isize) = '0' as i32 as libc::c_char;
        *s.offset(i as isize) = 0i32 as libc::c_char;
        return s;
    } else {
        if n < 0i32 as libc::c_long {
            let fresh35 = i;
            i = i + 1;
            *s.offset(fresh35 as isize) = '-' as i32 as libc::c_char;
            n = -n
        }
        while n > 0i32 as libc::c_long {
            let fresh36 = i;
            i = i + 1;
            *s.offset(fresh36 as isize) =
                ('0' as i32 as libc::c_long + n % 10i32 as libc::c_long) as libc::c_char;
            n /= 10i32 as libc::c_long
        }
        *s.offset(i as isize) = 0i32 as libc::c_char;
        if *s.offset(0isize) as libc::c_int == '-' as i32 {
            s = s.offset(1isize)
        }
        nk_strrev_ascii(s);
        return s;
    };
}
unsafe fn nk_strrev_ascii(mut s: *mut libc::c_char) -> () {
    let mut len: libc::c_int = nk_strlen(s);
    let mut end: libc::c_int = len / 2i32;
    let mut i: libc::c_int = 0i32;
    let mut t: libc::c_char = 0;
    while i < end {
        t = *s.offset(i as isize);
        *s.offset(i as isize) = *s.offset((len - 1i32 - i) as isize);
        *s.offset((len - 1i32 - i) as isize) = t;
        i += 1
    }
}
unsafe fn nk_property_variant_int(
    mut value: libc::c_int,
    mut min_value: libc::c_int,
    mut max_value: libc::c_int,
    mut step: libc::c_int,
) -> nk_property_variant {
    let mut result: nk_property_variant = nk_property_variant {
        kind: NK_PROPERTY_INT,
        value: nk_property { i: 0 },
        min_value: nk_property { i: 0 },
        max_value: nk_property { i: 0 },
        step: nk_property { i: 0 },
    };
    result.kind = NK_PROPERTY_INT;
    result.value.i = value;
    result.min_value.i = min_value;
    result.max_value.i = max_value;
    result.step.i = step;
    return result;
}
#[no_mangle]
pub unsafe fn nk_property_float(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut min: f32,
    mut val: *mut f32,
    mut max: f32,
    mut step: f32,
    mut inc_per_pixel: f32,
) -> () {
    let mut variant: nk_property_variant = nk_property_variant {
        kind: NK_PROPERTY_INT,
        value: nk_property { i: 0 },
        min_value: nk_property { i: 0 },
        max_value: nk_property { i: 0 },
        step: nk_property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() || val.is_null() {
        return;
    } else {
        variant = nk_property_variant_float(*val, min, max, step);
        nk_property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_FLOAT);
        *val = variant.value.f;
        return;
    };
}
unsafe fn nk_property_variant_float(
    mut value: f32,
    mut min_value: f32,
    mut max_value: f32,
    mut step: f32,
) -> nk_property_variant {
    let mut result: nk_property_variant = nk_property_variant {
        kind: NK_PROPERTY_INT,
        value: nk_property { i: 0 },
        min_value: nk_property { i: 0 },
        max_value: nk_property { i: 0 },
        step: nk_property { i: 0 },
    };
    result.kind = NK_PROPERTY_FLOAT;
    result.value.f = value;
    result.min_value.f = min_value;
    result.max_value.f = max_value;
    result.step.f = step;
    return result;
}
#[no_mangle]
pub unsafe fn nk_property_double(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut min: libc::c_double,
    mut val: *mut libc::c_double,
    mut max: libc::c_double,
    mut step: libc::c_double,
    mut inc_per_pixel: f32,
) -> () {
    let mut variant: nk_property_variant = nk_property_variant {
        kind: NK_PROPERTY_INT,
        value: nk_property { i: 0 },
        min_value: nk_property { i: 0 },
        max_value: nk_property { i: 0 },
        step: nk_property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() || val.is_null() {
        return;
    } else {
        variant = nk_property_variant_double(*val, min, max, step);
        nk_property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_FLOAT);
        *val = variant.value.d;
        return;
    };
}
unsafe fn nk_property_variant_double(
    mut value: libc::c_double,
    mut min_value: libc::c_double,
    mut max_value: libc::c_double,
    mut step: libc::c_double,
) -> nk_property_variant {
    let mut result: nk_property_variant = nk_property_variant {
        kind: NK_PROPERTY_INT,
        value: nk_property { i: 0 },
        min_value: nk_property { i: 0 },
        max_value: nk_property { i: 0 },
        step: nk_property { i: 0 },
    };
    result.kind = NK_PROPERTY_DOUBLE;
    result.value.d = value;
    result.min_value.d = min_value;
    result.max_value.d = max_value;
    result.step.d = step;
    return result;
}
#[no_mangle]
pub unsafe fn nk_propertyi(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut min: libc::c_int,
    mut val: libc::c_int,
    mut max: libc::c_int,
    mut step: libc::c_int,
    mut inc_per_pixel: f32,
) -> libc::c_int {
    let mut variant: nk_property_variant = nk_property_variant {
        kind: NK_PROPERTY_INT,
        value: nk_property { i: 0 },
        min_value: nk_property { i: 0 },
        max_value: nk_property { i: 0 },
        step: nk_property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() {
        return val;
    } else {
        variant = nk_property_variant_int(val, min, max, step);
        nk_property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_INT);
        val = variant.value.i;
        return val;
    };
}
#[no_mangle]
pub unsafe fn nk_propertyf(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut min: f32,
    mut val: f32,
    mut max: f32,
    mut step: f32,
    mut inc_per_pixel: f32,
) -> f32 {
    let mut variant: nk_property_variant = nk_property_variant {
        kind: NK_PROPERTY_INT,
        value: nk_property { i: 0 },
        min_value: nk_property { i: 0 },
        max_value: nk_property { i: 0 },
        step: nk_property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() {
        return val;
    } else {
        variant = nk_property_variant_float(val, min, max, step);
        nk_property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_FLOAT);
        val = variant.value.f;
        return val;
    };
}
#[no_mangle]
pub unsafe fn nk_propertyd(
    mut ctx: *mut nk_context,
    mut name: *const libc::c_char,
    mut min: libc::c_double,
    mut val: libc::c_double,
    mut max: libc::c_double,
    mut step: libc::c_double,
    mut inc_per_pixel: f32,
) -> libc::c_double {
    let mut variant: nk_property_variant = nk_property_variant {
        kind: NK_PROPERTY_INT,
        value: nk_property { i: 0 },
        min_value: nk_property { i: 0 },
        max_value: nk_property { i: 0 },
        step: nk_property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() {
        return val;
    } else {
        variant = nk_property_variant_double(val, min, max, step);
        nk_property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_FLOAT);
        val = variant.value.d;
        return val;
    };
}
#[no_mangle]
pub unsafe fn nk_edit_string(
    mut ctx: *mut nk_context,
    mut flags: nk_flags,
    mut memory: *mut libc::c_char,
    mut len: *mut libc::c_int,
    mut max: libc::c_int,
    mut filter: nk_plugin_filter,
) -> nk_flags {
    let mut hash: nk_hash = 0;
    let mut state: nk_flags = 0;
    let mut edit: *mut nk_text_edit = 0 as *mut nk_text_edit;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() || memory.is_null() || len.is_null() {
        return 0i32 as nk_flags;
    } else {
        filter = if filter.is_none() {
            Some(nk_filter_default)
        } else {
            filter
        };
        win = (*ctx).current;
        hash = (*win).edit.seq;
        edit = &mut (*ctx).text_edit as *mut nk_text_edit;
        nk_textedit_clear_state(
            &mut (*ctx).text_edit,
            (if 0 != flags & NK_EDIT_MULTILINE as libc::c_int as libc::c_uint {
                NK_TEXT_EDIT_MULTI_LINE as libc::c_int
            } else {
                NK_TEXT_EDIT_SINGLE_LINE as libc::c_int
            }) as nk_text_edit_type,
            filter,
        );
        if 0 != (*win).edit.active && hash == (*win).edit.name {
            if 0 != flags & NK_EDIT_NO_CURSOR as libc::c_int as libc::c_uint {
                (*edit).cursor = nk_utf_len(memory, *len)
            } else {
                (*edit).cursor = (*win).edit.cursor
            }
            if 0 == flags & NK_EDIT_SELECTABLE as libc::c_int as libc::c_uint {
                (*edit).select_start = (*win).edit.cursor;
                (*edit).select_end = (*win).edit.cursor
            } else {
                (*edit).select_start = (*win).edit.sel_start;
                (*edit).select_end = (*win).edit.sel_end
            }
            (*edit).mode = (*win).edit.mode;
            (*edit).scrollbar.x = (*win).edit.scrollbar.x as f32;
            (*edit).scrollbar.y = (*win).edit.scrollbar.y as f32;
            (*edit).active = nk_true as libc::c_int as libc::c_uchar
        } else {
            (*edit).active = nk_false as libc::c_int as libc::c_uchar
        }
        max = if 1i32 < max { max } else { 1i32 };
        *len = if *len < max - 1i32 { *len } else { max - 1i32 };
        nk_str_init_fixed(
            &mut (*edit).string,
            memory as *mut libc::c_void,
            max as nk_size,
        );
        (*edit).string.buffer.allocated = *len as nk_size;
        (*edit).string.len = nk_utf_len(memory, *len);
        state = nk_edit_buffer(ctx, flags, edit, filter);
        *len = (*edit).string.buffer.allocated as libc::c_int;
        if 0 != (*edit).active {
            (*win).edit.cursor = (*edit).cursor;
            (*win).edit.sel_start = (*edit).select_start;
            (*win).edit.sel_end = (*edit).select_end;
            (*win).edit.mode = (*edit).mode;
            (*win).edit.scrollbar.x = (*edit).scrollbar.x as nk_uint;
            (*win).edit.scrollbar.y = (*edit).scrollbar.y as nk_uint
        }
        return state;
    };
}
#[no_mangle]
pub unsafe fn nk_edit_buffer(
    mut ctx: *mut nk_context,
    mut flags: nk_flags,
    mut edit: *mut nk_text_edit,
    mut filter: nk_plugin_filter,
) -> nk_flags {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut style: *mut nk_style = 0 as *mut nk_style;
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut ret_flags: nk_flags = 0i32 as nk_flags;
    let mut prev_state: libc::c_uchar = 0;
    let mut hash: nk_hash = 0;
    /* make sure correct values */
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32 as nk_flags;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return state as nk_flags;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            /* check if edit is currently hot item */
            let fresh37 = (*win).edit.seq;
            (*win).edit.seq = (*win).edit.seq.wrapping_add(1);
            hash = fresh37;
            if 0 != (*win).edit.active && hash == (*win).edit.name {
                if 0 != flags & NK_EDIT_NO_CURSOR as libc::c_int as libc::c_uint {
                    (*edit).cursor = (*edit).string.len
                }
                if 0 == flags & NK_EDIT_SELECTABLE as libc::c_int as libc::c_uint {
                    (*edit).select_start = (*edit).cursor;
                    (*edit).select_end = (*edit).cursor
                }
                if 0 != flags & NK_EDIT_CLIPBOARD as libc::c_int as libc::c_uint {
                    (*edit).clip = (*ctx).clip
                }
                (*edit).active = (*win).edit.active as libc::c_uchar
            } else {
                (*edit).active = nk_false as libc::c_int as libc::c_uchar
            }
            (*edit).mode = (*win).edit.mode;
            filter = if filter.is_none() {
                Some(nk_filter_default)
            } else {
                filter
            };
            prev_state = (*edit).active;
            in_0 = if 0 != flags & NK_EDIT_READ_ONLY as libc::c_int as libc::c_uint {
                0 as *mut nk_input
            } else {
                in_0
            };
            ret_flags = nk_do_edit(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                flags,
                filter,
                edit,
                &mut (*style).edit,
                in_0,
                (*style).font,
            );
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                (*ctx).style.cursor_active =
                    (*ctx).style.cursors[NK_CURSOR_TEXT as libc::c_int as usize]
            }
            if 0 != (*edit).active as libc::c_int
                && prev_state as libc::c_int != (*edit).active as libc::c_int
            {
                /* current edit is now hot */
                (*win).edit.active = nk_true as libc::c_int;
                (*win).edit.name = hash
            } else if 0 != prev_state as libc::c_int && 0 == (*edit).active {
                /* current edit is now cold */
                (*win).edit.active = nk_false as libc::c_int
            }
            return ret_flags;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_filter_default(
    mut box_0: *const nk_text_edit,
    mut unicode: nk_rune,
) -> libc::c_int {
    return nk_true as libc::c_int;
}
#[no_mangle]
pub unsafe fn nk_str_init_fixed(
    mut str: *mut nk_str,
    mut memory: *mut libc::c_void,
    mut size: nk_size,
) -> () {
    nk_buffer_init_fixed(&mut (*str).buffer, memory, size);
    (*str).len = 0i32;
}
#[no_mangle]
pub unsafe fn nk_edit_string_zero_terminated(
    mut ctx: *mut nk_context,
    mut flags: nk_flags,
    mut buffer: *mut libc::c_char,
    mut max: libc::c_int,
    mut filter: nk_plugin_filter,
) -> nk_flags {
    let mut result: nk_flags = 0;
    let mut len: libc::c_int = nk_strlen(buffer);
    result = nk_edit_string(ctx, flags, buffer, &mut len, max, filter);
    *buffer.offset(
        (if if max - 1i32 < 0i32 { 0i32 } else { max - 1i32 } < len {
            if max - 1i32 < 0i32 {
                0i32
            } else {
                max - 1i32
            }
        } else {
            len
        }) as isize,
    ) = '\u{0}' as i32 as libc::c_char;
    return result;
}
#[no_mangle]
pub unsafe fn nk_edit_focus(mut ctx: *mut nk_context, mut flags: nk_flags) -> () {
    let mut hash: nk_hash = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        win = (*ctx).current;
        hash = (*win).edit.seq;
        (*win).edit.active = nk_true as libc::c_int;
        (*win).edit.name = hash;
        if 0 != flags & NK_EDIT_ALWAYS_INSERT_MODE as libc::c_int as libc::c_uint {
            (*win).edit.mode = NK_TEXT_EDIT_MODE_INSERT as libc::c_int as libc::c_uchar
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_edit_unfocus(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        win = (*ctx).current;
        (*win).edit.active = nk_false as libc::c_int;
        (*win).edit.name = 0i32 as nk_hash;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_chart_begin(
    mut ctx: *mut nk_context,
    type_0: nk_chart_type,
    mut count: libc::c_int,
    mut min_value: f32,
    mut max_value: f32,
) -> libc::c_int {
    return nk_chart_begin_colored(
        ctx,
        type_0,
        (*ctx).style.chart.color,
        (*ctx).style.chart.selected_color,
        count,
        min_value,
        max_value,
    );
}
#[no_mangle]
pub unsafe fn nk_chart_begin_colored(
    mut ctx: *mut nk_context,
    mut type_0: nk_chart_type,
    mut color: nk_color,
    mut highlight: nk_color,
    mut count: libc::c_int,
    mut min_value: f32,
    mut max_value: f32,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut chart: *mut nk_chart = 0 as *mut nk_chart;
    let mut config: *const nk_style = 0 as *const nk_style;
    let mut style: *const nk_style_chart = 0 as *const nk_style_chart;
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    let mut bounds: nk_rect = nk_rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else if 0 == nk_widget(&mut bounds, ctx) as u64 {
        chart = &mut (*(*(*ctx).current).layout).chart as *mut nk_chart;
        nk_zero(
            chart as *mut libc::c_void,
            ::std::mem::size_of::<nk_chart>() as libc::c_ulong,
        );
        return 0i32;
    } else {
        win = (*ctx).current;
        config = &mut (*ctx).style as *mut nk_style;
        chart = &mut (*(*win).layout).chart as *mut nk_chart;
        style = &(*config).chart as *const nk_style_chart;
        /* setup basic generic chart  */
        nk_zero(
            chart as *mut libc::c_void,
            ::std::mem::size_of::<nk_chart>() as libc::c_ulong,
        );
        (*chart).x = bounds.x + (*style).padding.x;
        (*chart).y = bounds.y + (*style).padding.y;
        (*chart).w = bounds.w - 2i32 as f32 * (*style).padding.x;
        (*chart).h = bounds.h - 2i32 as f32 * (*style).padding.y;
        (*chart).w = if (*chart).w < 2i32 as f32 * (*style).padding.x {
            2i32 as f32 * (*style).padding.x
        } else {
            (*chart).w
        };
        (*chart).h = if (*chart).h < 2i32 as f32 * (*style).padding.y {
            2i32 as f32 * (*style).padding.y
        } else {
            (*chart).h
        };
        /* add first slot into chart */
        let fresh38 = (*chart).slot;
        (*chart).slot = (*chart).slot + 1;
        let mut slot: *mut nk_chart_slot =
            &mut (*chart).slots[fresh38 as usize] as *mut nk_chart_slot;
        (*slot).type_0 = type_0;
        (*slot).count = count;
        (*slot).color = color;
        (*slot).highlight = highlight;
        (*slot).min = if min_value < max_value {
            min_value
        } else {
            max_value
        };
        (*slot).max = if min_value < max_value {
            max_value
        } else {
            min_value
        };
        (*slot).range = (*slot).max - (*slot).min;
        /* draw chart background */
        background = &(*style).background as *const nk_style_item;
        if (*background).type_0 as libc::c_uint
            == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
        {
            nk_draw_image(
                &mut (*win).buffer,
                bounds,
                &(*background).data.image,
                nk_white,
            );
        } else {
            nk_fill_rect(
                &mut (*win).buffer,
                bounds,
                (*style).rounding,
                (*style).border_color,
            );
            nk_fill_rect(
                &mut (*win).buffer,
                nk_shrink_rect(bounds, (*style).border),
                (*style).rounding,
                (*style).background.data.color,
            );
        }
        return 1i32;
    };
}
#[no_mangle]
pub unsafe fn nk_chart_add_slot(
    mut ctx: *mut nk_context,
    type_0: nk_chart_type,
    mut count: libc::c_int,
    mut min_value: f32,
    mut max_value: f32,
) -> () {
    nk_chart_add_slot_colored(
        ctx,
        type_0,
        (*ctx).style.chart.color,
        (*ctx).style.chart.selected_color,
        count,
        min_value,
        max_value,
    );
}
#[no_mangle]
pub unsafe fn nk_chart_add_slot_colored(
    mut ctx: *mut nk_context,
    type_0: nk_chart_type,
    mut color: nk_color,
    mut highlight: nk_color,
    mut count: libc::c_int,
    mut min_value: f32,
    mut max_value: f32,
) -> () {
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else if (*(*(*ctx).current).layout).chart.slot >= 4i32 {
        return;
    } else {
        /* add another slot into the graph */
        let mut chart: *mut nk_chart = &mut (*(*(*ctx).current).layout).chart as *mut nk_chart;
        let fresh39 = (*chart).slot;
        (*chart).slot = (*chart).slot + 1;
        let mut slot: *mut nk_chart_slot =
            &mut (*chart).slots[fresh39 as usize] as *mut nk_chart_slot;
        (*slot).type_0 = type_0;
        (*slot).count = count;
        (*slot).color = color;
        (*slot).highlight = highlight;
        (*slot).min = if min_value < max_value {
            min_value
        } else {
            max_value
        };
        (*slot).max = if min_value < max_value {
            max_value
        } else {
            min_value
        };
        (*slot).range = (*slot).max - (*slot).min;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_chart_push(mut ctx: *mut nk_context, mut value: f32) -> nk_flags {
    return nk_chart_push_slot(ctx, value, 0i32);
}
#[no_mangle]
pub unsafe fn nk_chart_push_slot(
    mut ctx: *mut nk_context,
    mut value: f32,
    mut slot: libc::c_int,
) -> nk_flags {
    let mut flags: nk_flags = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() || (*ctx).current.is_null() || slot >= 4i32 {
        return nk_false as libc::c_int as nk_flags;
    } else if slot >= (*(*(*ctx).current).layout).chart.slot {
        return nk_false as libc::c_int as nk_flags;
    } else {
        win = (*ctx).current;
        if (*(*win).layout).chart.slot < slot {
            return nk_false as libc::c_int as nk_flags;
        } else {
            match (*(*win).layout).chart.slots[slot as usize].type_0 as libc::c_uint {
                0 => flags = nk_chart_push_line(ctx, win, &mut (*(*win).layout).chart, value, slot),
                1 => {
                    flags = nk_chart_push_column(ctx, win, &mut (*(*win).layout).chart, value, slot)
                }
                2 | _ => flags = 0i32 as nk_flags,
            }
            return flags;
        }
    };
}
unsafe fn nk_chart_push_column(
    mut ctx: *const nk_context,
    mut win: *mut nk_window,
    mut chart: *mut nk_chart,
    mut value: f32,
    mut slot: libc::c_int,
) -> nk_flags {
    let mut padding: f32 = 0.;
    let mut out: *mut nk_command_buffer = &mut (*win).buffer as *mut nk_command_buffer;
    let mut in_0: *const nk_input = &(*ctx).input as *const nk_input;
    let mut layout: *mut nk_panel = (*win).layout;
    let mut ratio: f32 = 0.;
    let mut ret: nk_flags = 0i32 as nk_flags;
    let mut color: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut item: nk_rect = nk_rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    if (*chart).slots[slot as usize].index >= (*chart).slots[slot as usize].count {
        return nk_false as libc::c_int as nk_flags;
    } else {
        if 0 != (*chart).slots[slot as usize].count {
            padding = ((*chart).slots[slot as usize].count - 1i32) as f32;
            item.w = ((*chart).w - padding) / (*chart).slots[slot as usize].count as f32
        }
        /* calculate bounds of current bar chart entry */
        color = (*chart).slots[slot as usize].color;
        item.h = (*chart).h
            * if value / (*chart).slots[slot as usize].range < 0i32 as f32 {
                -(value / (*chart).slots[slot as usize].range)
            } else {
                value / (*chart).slots[slot as usize].range
            };
        if value >= 0i32 as f32 {
            ratio = (value + if (*chart).slots[slot as usize].min < 0i32 as f32 {
                -(*chart).slots[slot as usize].min
            } else {
                (*chart).slots[slot as usize].min
            })
                / if (*chart).slots[slot as usize].range < 0i32 as f32 {
                    -(*chart).slots[slot as usize].range
                } else {
                    (*chart).slots[slot as usize].range
                };
            item.y = (*chart).y + (*chart).h - (*chart).h * ratio
        } else {
            ratio =
                (value - (*chart).slots[slot as usize].max) / (*chart).slots[slot as usize].range;
            item.y = (*chart).y + (*chart).h * if ratio < 0i32 as f32 {
                -ratio
            } else {
                ratio
            } - item.h
        }
        item.x = (*chart).x + (*chart).slots[slot as usize].index as f32 * item.w;
        item.x = item.x + (*chart).slots[slot as usize].index as f32;
        /* user chart bar selection */
        if 0 == (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            && (item.x <= (*in_0).mouse.pos.x
                && (*in_0).mouse.pos.x < item.x + item.w
                && (item.y <= (*in_0).mouse.pos.y && (*in_0).mouse.pos.y < item.y + item.h))
        {
            ret = NK_CHART_HOVERING as libc::c_int as nk_flags;
            ret |= (if 0 == (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].clicked
            {
                NK_CHART_CLICKED as libc::c_int
            } else {
                0i32
            }) as libc::c_uint;
            color = (*chart).slots[slot as usize].highlight
        }
        nk_fill_rect(out, item, 0i32 as f32, color);
        (*chart).slots[slot as usize].index += 1i32;
        return ret;
    };
}
unsafe fn nk_chart_push_line(
    mut ctx: *mut nk_context,
    mut win: *mut nk_window,
    mut g: *mut nk_chart,
    mut value: f32,
    mut slot: libc::c_int,
) -> nk_flags {
    let mut layout: *mut nk_panel = (*win).layout;
    let mut i: *const nk_input = &mut (*ctx).input as *mut nk_input;
    let mut out: *mut nk_command_buffer = &mut (*win).buffer as *mut nk_command_buffer;
    let mut ret: nk_flags = 0i32 as nk_flags;
    let mut cur: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut color: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut step: f32 = 0.;
    let mut range: f32 = 0.;
    let mut ratio: f32 = 0.;
    step = (*g).w / (*g).slots[slot as usize].count as f32;
    range = (*g).slots[slot as usize].max - (*g).slots[slot as usize].min;
    ratio = (value - (*g).slots[slot as usize].min) / range;
    if (*g).slots[slot as usize].index == 0i32 {
        /* first data point does not have a connection */
        (*g).slots[slot as usize].last.x = (*g).x;
        (*g).slots[slot as usize].last.y = (*g).y + (*g).h - ratio * (*g).h;
        bounds.x = (*g).slots[slot as usize].last.x - 2i32 as f32;
        bounds.y = (*g).slots[slot as usize].last.y - 2i32 as f32;
        bounds.h = 4i32 as f32;
        bounds.w = bounds.h;
        color = (*g).slots[slot as usize].color;
        if 0 == (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            && ((*g).slots[slot as usize].last.x - 3i32 as f32 <= (*i).mouse.pos.x
                && (*i).mouse.pos.x
                    < (*g).slots[slot as usize].last.x - 3i32 as f32
                        + 6i32 as f32
                && ((*g).slots[slot as usize].last.y - 3i32 as f32 <= (*i).mouse.pos.y
                    && (*i).mouse.pos.y
                        < (*g).slots[slot as usize].last.y - 3i32 as f32
                            + 6i32 as f32))
        {
            ret = (if 0 != nk_input_is_mouse_hovering_rect(i, bounds) {
                NK_CHART_HOVERING as libc::c_int
            } else {
                0i32
            }) as nk_flags;
            ret |= (if 0 != (*i).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down
                && 0 != (*i).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].clicked
            {
                NK_CHART_CLICKED as libc::c_int
            } else {
                0i32
            }) as libc::c_uint;
            color = (*g).slots[slot as usize].highlight
        }
        nk_fill_rect(out, bounds, 0i32 as f32, color);
        (*g).slots[slot as usize].index += 1i32;
        return ret;
    } else {
        /* draw a line between the last data point and the new one */
        color = (*g).slots[slot as usize].color;
        cur.x = (*g).x + step * (*g).slots[slot as usize].index as f32;
        cur.y = (*g).y + (*g).h - ratio * (*g).h;
        nk_stroke_line(
            out,
            (*g).slots[slot as usize].last.x,
            (*g).slots[slot as usize].last.y,
            cur.x,
            cur.y,
            1.0f32,
            color,
        );
        bounds.x = cur.x - 3i32 as f32;
        bounds.y = cur.y - 3i32 as f32;
        bounds.h = 6i32 as f32;
        bounds.w = bounds.h;
        /* user selection of current data point */
        if 0 == (*layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint {
            if 0 != nk_input_is_mouse_hovering_rect(i, bounds) {
                ret = NK_CHART_HOVERING as libc::c_int as nk_flags;
                ret |= (if 0 == (*i).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].down
                    && 0 != (*i).mouse.buttons[NK_BUTTON_LEFT as libc::c_int as usize].clicked
                {
                    NK_CHART_CLICKED as libc::c_int
                } else {
                    0i32
                }) as libc::c_uint;
                color = (*g).slots[slot as usize].highlight
            }
        }
        nk_fill_rect(
            out,
            nk_rect(
                cur.x - 2i32 as f32,
                cur.y - 2i32 as f32,
                4i32 as f32,
                4i32 as f32,
            ),
            0i32 as f32,
            color,
        );
        /* save current data point position */
        (*g).slots[slot as usize].last.x = cur.x;
        (*g).slots[slot as usize].last.y = cur.y;
        (*g).slots[slot as usize].index += 1i32;
        return ret;
    };
}
#[no_mangle]
pub unsafe fn nk_chart_end(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut chart: *mut nk_chart = 0 as *mut nk_chart;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        win = (*ctx).current;
        chart = &mut (*(*win).layout).chart as *mut nk_chart;
        nk_memset(
            chart as *mut libc::c_void,
            0i32,
            ::std::mem::size_of::<nk_chart>() as libc::c_ulong,
        );
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_plot(
    mut ctx: *mut nk_context,
    mut type_0: nk_chart_type,
    mut values: *const f32,
    mut count: libc::c_int,
    mut offset: libc::c_int,
) -> () {
    let mut i: libc::c_int = 0i32;
    let mut min_value: f32 = 0.;
    let mut max_value: f32 = 0.;
    if ctx.is_null() || values.is_null() || 0 == count {
        return;
    } else {
        min_value = *values.offset(offset as isize);
        max_value = *values.offset(offset as isize);
        i = 0i32;
        while i < count {
            min_value = if *values.offset((i + offset) as isize) < min_value {
                *values.offset((i + offset) as isize)
            } else {
                min_value
            };
            max_value = if *values.offset((i + offset) as isize) < max_value {
                max_value
            } else {
                *values.offset((i + offset) as isize)
            };
            i += 1
        }
        if 0 != nk_chart_begin(ctx, type_0, count, min_value, max_value) {
            i = 0i32;
            while i < count {
                nk_chart_push(ctx, *values.offset((i + offset) as isize));
                i += 1
            }
            nk_chart_end(ctx);
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_plot_function(
    mut ctx: *mut nk_context,
    mut type_0: nk_chart_type,
    mut userdata: *mut libc::c_void,
    mut value_getter: Option<unsafe fn(_: *mut libc::c_void, _: libc::c_int) -> f32>,
    mut count: libc::c_int,
    mut offset: libc::c_int,
) -> () {
    let mut i: libc::c_int = 0i32;
    let mut min_value: f32 = 0.;
    let mut max_value: f32 = 0.;
    if ctx.is_null() || value_getter.is_none() || 0 == count {
        return;
    } else {
        min_value = value_getter.expect("non-null function pointer")(userdata, offset);
        max_value = min_value;
        i = 0i32;
        while i < count {
            let mut value: f32 =
                value_getter.expect("non-null function pointer")(userdata, i + offset);
            min_value = if value < min_value { value } else { min_value };
            max_value = if value < max_value { max_value } else { value };
            i += 1
        }
        if 0 != nk_chart_begin(ctx, type_0, count, min_value, max_value) {
            i = 0i32;
            while i < count {
                nk_chart_push(
                    ctx,
                    value_getter.expect("non-null function pointer")(userdata, i + offset),
                );
                i += 1
            }
            nk_chart_end(ctx);
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_popup_begin(
    mut ctx: *mut nk_context,
    mut type_0: nk_popup_type,
    mut title: *const libc::c_char,
    mut flags: nk_flags,
    mut rect: nk_rect,
) -> libc::c_int {
    let mut popup: *mut nk_window = 0 as *mut nk_window;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut panel: *mut nk_panel = 0 as *mut nk_panel;
    let mut title_len: libc::c_int = 0;
    let mut title_hash: nk_hash = 0;
    let mut allocated: nk_size = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        panel = (*win).layout;
        title_len = nk_strlen(title);
        title_hash = nk_murmur_hash(
            title as *const libc::c_void,
            title_len,
            NK_PANEL_POPUP as libc::c_int as nk_hash,
        );
        popup = (*win).popup.win;
        if popup.is_null() {
            popup = nk_create_window(ctx) as *mut nk_window;
            (*popup).parent = win;
            (*win).popup.win = popup;
            (*win).popup.active = 0i32;
            (*win).popup.type_0 = NK_PANEL_POPUP
        }
        /* make sure we have correct popup */
        if (*win).popup.name != title_hash {
            if 0 == (*win).popup.active {
                nk_zero(
                    popup as *mut libc::c_void,
                    ::std::mem::size_of::<nk_window>() as libc::c_ulong,
                );
                (*win).popup.name = title_hash;
                (*win).popup.active = 1i32;
                (*win).popup.type_0 = NK_PANEL_POPUP
            } else {
                return 0i32;
            }
        }
        /* popup position is local to window */
        (*ctx).current = popup;
        rect.x += (*(*win).layout).clip.x;
        rect.y += (*(*win).layout).clip.y;
        /* setup popup data */
        (*popup).parent = win;
        (*popup).bounds = rect;
        (*popup).seq = (*ctx).seq;
        (*popup).layout = nk_create_panel(ctx) as *mut nk_panel;
        (*popup).flags = flags;
        (*popup).flags |= NK_WINDOW_BORDER as libc::c_int as libc::c_uint;
        if type_0 as libc::c_uint == NK_POPUP_DYNAMIC as libc::c_int as libc::c_uint {
            (*popup).flags |= NK_WINDOW_DYNAMIC as libc::c_int as libc::c_uint
        }
        (*popup).buffer = (*win).buffer;
        nk_start_popup(ctx, win);
        allocated = (*ctx).memory.allocated;
        nk_push_scissor(&mut (*popup).buffer, nk_null_rect);
        if 0 != nk_panel_begin(ctx, title, NK_PANEL_POPUP) {
            /* popup is running therefore invalidate parent panels */
            let mut root: *mut nk_panel = 0 as *mut nk_panel;
            root = (*win).layout;
            while !root.is_null() {
                (*root).flags |= NK_WINDOW_ROM as libc::c_int as libc::c_uint;
                (*root).flags &= !(NK_WINDOW_REMOVE_ROM as libc::c_int as nk_flags);
                root = (*root).parent
            }
            (*win).popup.active = 1i32;
            (*(*popup).layout).offset_x = &mut (*popup).scrollbar.x as *mut nk_uint;
            (*(*popup).layout).offset_y = &mut (*popup).scrollbar.y as *mut nk_uint;
            (*(*popup).layout).parent = (*win).layout;
            return 1i32;
        } else {
            /* popup was closed/is invalid so cleanup */
            let mut root_0: *mut nk_panel = 0 as *mut nk_panel;
            root_0 = (*win).layout;
            while !root_0.is_null() {
                (*root_0).flags |= NK_WINDOW_REMOVE_ROM as libc::c_int as libc::c_uint;
                root_0 = (*root_0).parent
            }
            (*win).popup.buf.active = 0i32;
            (*win).popup.active = 0i32;
            (*ctx).memory.allocated = allocated;
            (*ctx).current = win;
            nk_free_panel(ctx, (*popup).layout);
            (*popup).layout = 0 as *mut nk_panel;
            return 0i32;
        }
    };
}
unsafe fn nk_start_popup(mut ctx: *mut nk_context, mut win: *mut nk_window) -> () {
    let mut buf: *mut nk_popup_buffer = 0 as *mut nk_popup_buffer;
    if ctx.is_null() || win.is_null() {
        return;
    } else {
        /* save buffer fill state for popup */
        buf = &mut (*win).popup.buf as *mut nk_popup_buffer;
        (*buf).begin = (*win).buffer.end;
        (*buf).end = (*win).buffer.end;
        (*buf).parent = (*win).buffer.last;
        (*buf).last = (*buf).begin;
        (*buf).active = nk_true as libc::c_int;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_popup_close(mut ctx: *mut nk_context) -> () {
    let mut popup: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        popup = (*ctx).current;
        (*popup).flags |= NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_popup_end(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut popup: *mut nk_window = 0 as *mut nk_window;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        popup = (*ctx).current;
        if (*popup).parent.is_null() {
            return;
        } else {
            win = (*popup).parent;
            if 0 != (*popup).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint {
                let mut root: *mut nk_panel = 0 as *mut nk_panel;
                root = (*win).layout;
                while !root.is_null() {
                    (*root).flags |= NK_WINDOW_REMOVE_ROM as libc::c_int as libc::c_uint;
                    root = (*root).parent
                }
                (*win).popup.active = 0i32
            }
            nk_push_scissor(&mut (*popup).buffer, nk_null_rect);
            nk_end(ctx);
            (*win).buffer = (*popup).buffer;
            nk_finish_popup(ctx, win);
            (*ctx).current = win;
            nk_push_scissor(&mut (*win).buffer, (*(*win).layout).clip);
            return;
        }
    };
}
unsafe fn nk_finish_popup(mut ctx: *mut nk_context, mut win: *mut nk_window) -> () {
    let mut buf: *mut nk_popup_buffer = 0 as *mut nk_popup_buffer;
    if ctx.is_null() || win.is_null() {
        return;
    } else {
        buf = &mut (*win).popup.buf as *mut nk_popup_buffer;
        (*buf).last = (*win).buffer.last;
        (*buf).end = (*win).buffer.end;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_combo(
    mut ctx: *mut nk_context,
    mut items: *mut *const libc::c_char,
    mut count: libc::c_int,
    mut selected: libc::c_int,
    mut item_height: libc::c_int,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut i: libc::c_int = 0i32;
    let mut max_height: libc::c_int = 0;
    let mut item_spacing: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut window_padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    if ctx.is_null() || items.is_null() || 0 == count {
        return selected;
    } else {
        item_spacing = (*ctx).style.window.spacing;
        window_padding =
            nk_panel_get_padding(&mut (*ctx).style, (*(*(*ctx).current).layout).type_0);
        max_height = count * item_height + count * item_spacing.y as libc::c_int;
        max_height += item_spacing.y as libc::c_int * 2i32 + window_padding.y as libc::c_int * 2i32;
        size.y = if size.y < max_height as f32 {
            size.y
        } else {
            max_height as f32
        };
        if 0 != nk_combo_begin_label(ctx, *items.offset(selected as isize), size) {
            nk_layout_row_dynamic(ctx, item_height as f32, 1i32);
            i = 0i32;
            while i < count {
                if 0 != nk_combo_item_label(
                    ctx,
                    *items.offset(i as isize),
                    NK_TEXT_LEFT as libc::c_int as nk_flags,
                ) {
                    selected = i
                }
                i += 1
            }
            nk_combo_end(ctx);
        }
        return selected;
    };
}
#[no_mangle]
pub unsafe fn nk_combo_end(mut ctx: *mut nk_context) -> () {
    nk_contextual_end(ctx);
}
#[no_mangle]
pub unsafe fn nk_contextual_end(mut ctx: *mut nk_context) -> () {
    let mut padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut popup: *mut nk_window = 0 as *mut nk_window;
    let mut panel: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        popup = (*ctx).current;
        panel = (*popup).layout;
        if 0 != (*panel).flags & NK_WINDOW_DYNAMIC as libc::c_int as libc::c_uint {
            /* Close behavior
        This is a bit of a hack solution since we do not know before we end our popup
        how big it will be. We therefore do not directly know when a
        click outside the non-blocking popup must close it at that direct frame.
        Instead it will be closed in the next frame.*/
            let mut body: nk_rect = nk_rect {
                x: 0i32 as f32,
                y: 0i32 as f32,
                w: 0i32 as f32,
                h: 0i32 as f32,
            };
            if (*panel).at_y < (*panel).bounds.y + (*panel).bounds.h {
                padding = nk_panel_get_padding(&mut (*ctx).style, (*panel).type_0);
                body = (*panel).bounds;
                body.y = (*panel).at_y
                    + (*panel).footer_height
                    + (*panel).border
                    + padding.y
                    + (*panel).row.height;
                body.h = (*panel).bounds.y + (*panel).bounds.h - body.y
            }
            let mut pressed: libc::c_int =
                nk_input_is_mouse_pressed(&mut (*ctx).input, NK_BUTTON_LEFT);
            let mut in_body: libc::c_int = nk_input_is_mouse_hovering_rect(&mut (*ctx).input, body);
            if 0 != pressed && 0 != in_body {
                (*popup).flags |= NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
            }
        }
        if 0 != (*popup).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint {
            (*popup).seq = 0i32 as libc::c_uint
        }
        nk_popup_end(ctx);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_combo_item_label(
    mut ctx: *mut nk_context,
    mut label: *const libc::c_char,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_label(ctx, label, align);
}
#[no_mangle]
pub unsafe fn nk_contextual_item_label(
    mut ctx: *mut nk_context,
    mut label: *const libc::c_char,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_text(ctx, label, nk_strlen(label), align);
}
#[no_mangle]
pub unsafe fn nk_contextual_item_text(
    mut ctx: *mut nk_context,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut alignment: nk_flags,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        state = nk_widget_fitting(&mut bounds, ctx, (*style).contextual_button.padding);
        if 0 == state as u64 {
            return nk_false as libc::c_int;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_do_button_text(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                text,
                len,
                alignment,
                NK_BUTTON_DEFAULT,
                &(*style).contextual_button,
                in_0,
                (*style).font,
            ) {
                nk_contextual_close(ctx);
                return nk_true as libc::c_int;
            } else {
                return nk_false as libc::c_int;
            }
        }
    };
}
#[no_mangle]
pub unsafe fn nk_contextual_close(mut ctx: *mut nk_context) -> () {
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        nk_popup_close(ctx);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_combo_begin_label(
    mut ctx: *mut nk_context,
    mut selected: *const libc::c_char,
    mut size: nk_vec2,
) -> libc::c_int {
    return nk_combo_begin_text(ctx, selected, nk_strlen(selected), size);
}
#[no_mangle]
pub unsafe fn nk_combo_begin_text(
    mut ctx: *mut nk_context,
    mut selected: *const libc::c_char,
    mut len: libc::c_int,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut style: *mut nk_style = 0 as *mut nk_style;
    let mut s: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || selected.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        s = nk_widget(&mut header, ctx);
        if s as libc::c_uint == NK_WIDGET_INVALID as libc::c_int as libc::c_uint {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
                || s as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_button_behavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            /* draw combo box header background and border */
            if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.active as *mut nk_style_item;
                text.text = (*style).combo.label_active
            } else if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.hover as *mut nk_style_item;
                text.text = (*style).combo.label_hover
            } else {
                background = &mut (*style).combo.normal as *mut nk_style_item;
                text.text = (*style).combo.label_normal
            }
            if (*background).type_0 as libc::c_uint
                == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                text.background = nk_rgba(0i32, 0i32, 0i32, 0i32);
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                text.background = (*background).data.color;
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            /* print currently selected text item */
            let mut label: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut content: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: nk_symbol_type = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.x;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            /* draw selected label */
            text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
            label.x = header.x + (*style).combo.content_padding.x;
            label.y = header.y + (*style).combo.content_padding.y;
            label.w =
                button.x - ((*style).combo.content_padding.x + (*style).combo.spacing.x) - label.x;
            label.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            nk_widget_text(
                &mut (*win).buffer,
                label,
                selected,
                len,
                &mut text,
                NK_TEXT_LEFT as libc::c_int as nk_flags,
                (*ctx).style.font,
            );
            /* draw open/close button */
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut button,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}
unsafe fn nk_combo_begin(
    mut ctx: *mut nk_context,
    mut win: *mut nk_window,
    mut size: nk_vec2,
    mut is_clicked: libc::c_int,
    mut header: nk_rect,
) -> libc::c_int {
    let mut popup: *mut nk_window = 0 as *mut nk_window;
    let mut is_open: libc::c_int = 0i32;
    let mut is_active: libc::c_int = 0i32;
    let mut body: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut hash: nk_hash = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        popup = (*win).popup.win;
        body.x = header.x;
        body.w = size.x;
        body.y = header.y + header.h - (*ctx).style.window.combo_border;
        body.h = size.y;
        let fresh40 = (*win).popup.combo_count;
        (*win).popup.combo_count = (*win).popup.combo_count.wrapping_add(1);
        hash = fresh40;
        is_open = if !popup.is_null() {
            nk_true as libc::c_int
        } else {
            nk_false as libc::c_int
        };
        is_active = (!popup.is_null()
            && (*win).popup.name == hash
            && (*win).popup.type_0 as libc::c_uint == NK_PANEL_COMBO as libc::c_int as libc::c_uint)
            as libc::c_int;
        if 0 != is_clicked && 0 != is_open && 0 == is_active
            || 0 != is_open && 0 == is_active
            || 0 == is_open && 0 == is_active && 0 == is_clicked
        {
            return 0i32;
        } else if 0 == nk_nonblock_begin(
            ctx,
            0i32 as nk_flags,
            body,
            if 0 != is_clicked && 0 != is_open {
                nk_rect(
                    0i32 as f32,
                    0i32 as f32,
                    0i32 as f32,
                    0i32 as f32,
                )
            } else {
                header
            },
            NK_PANEL_COMBO,
        ) {
            return 0i32;
        } else {
            (*win).popup.type_0 = NK_PANEL_COMBO;
            (*win).popup.name = hash;
            return 1i32;
        }
    };
}
unsafe fn nk_nonblock_begin(
    mut ctx: *mut nk_context,
    mut flags: nk_flags,
    mut body: nk_rect,
    mut header: nk_rect,
    mut panel_type: nk_panel_type,
) -> libc::c_int {
    let mut popup: *mut nk_window = 0 as *mut nk_window;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut panel: *mut nk_panel = 0 as *mut nk_panel;
    let mut is_active: libc::c_int = nk_true as libc::c_int;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        /* popups cannot have popups */
        win = (*ctx).current;
        panel = (*win).layout;
        popup = (*win).popup.win;
        if popup.is_null() {
            /* create window for nonblocking popup */
            popup = nk_create_window(ctx) as *mut nk_window;
            (*popup).parent = win;
            (*win).popup.win = popup;
            (*win).popup.type_0 = panel_type;
            nk_command_buffer_init(&mut (*popup).buffer, &mut (*ctx).memory, NK_CLIPPING_ON);
        } else {
            let mut pressed: libc::c_int = 0;
            let mut in_body: libc::c_int = 0;
            /* close the popup if user pressed outside or in the header */
            let mut in_header: libc::c_int = 0;
            pressed = nk_input_is_mouse_pressed(&mut (*ctx).input, NK_BUTTON_LEFT);
            in_body = nk_input_is_mouse_hovering_rect(&mut (*ctx).input, body);
            in_header = nk_input_is_mouse_hovering_rect(&mut (*ctx).input, header);
            if 0 != pressed && (0 == in_body || 0 != in_header) {
                is_active = nk_false as libc::c_int
            }
        }
        (*win).popup.header = header;
        if 0 == is_active {
            /* remove read only mode from all parent panels */
            let mut root: *mut nk_panel = (*win).layout;
            while !root.is_null() {
                (*root).flags |= NK_WINDOW_REMOVE_ROM as libc::c_int as libc::c_uint;
                root = (*root).parent
            }
            return is_active;
        } else {
            (*popup).bounds = body;
            (*popup).parent = win;
            (*popup).layout = nk_create_panel(ctx) as *mut nk_panel;
            (*popup).flags = flags;
            (*popup).flags |= NK_WINDOW_BORDER as libc::c_int as libc::c_uint;
            (*popup).flags |= NK_WINDOW_DYNAMIC as libc::c_int as libc::c_uint;
            (*popup).seq = (*ctx).seq;
            (*win).popup.active = 1i32;
            nk_start_popup(ctx, win);
            (*popup).buffer = (*win).buffer;
            nk_push_scissor(&mut (*popup).buffer, nk_null_rect);
            (*ctx).current = popup;
            nk_panel_begin(ctx, 0 as *const libc::c_char, panel_type);
            (*win).buffer = (*popup).buffer;
            (*(*popup).layout).parent = (*win).layout;
            (*(*popup).layout).offset_x = &mut (*popup).scrollbar.x as *mut nk_uint;
            (*(*popup).layout).offset_y = &mut (*popup).scrollbar.y as *mut nk_uint;
            /* set read only mode to all parent panels */
            let mut root_0: *mut nk_panel = 0 as *mut nk_panel;
            root_0 = (*win).layout;
            while !root_0.is_null() {
                (*root_0).flags |= NK_WINDOW_ROM as libc::c_int as libc::c_uint;
                root_0 = (*root_0).parent
            }
            return is_active;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_combo_separator(
    mut ctx: *mut nk_context,
    mut items_separated_by_separator: *const libc::c_char,
    mut separator: libc::c_int,
    mut selected: libc::c_int,
    mut count: libc::c_int,
    mut item_height: libc::c_int,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut max_height: libc::c_int = 0;
    let mut item_spacing: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut window_padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut current_item: *const libc::c_char = 0 as *const libc::c_char;
    let mut iter: *const libc::c_char = 0 as *const libc::c_char;
    let mut length: libc::c_int = 0i32;
    if ctx.is_null() || items_separated_by_separator.is_null() {
        return selected;
    } else {
        /* calculate popup window */
        item_spacing = (*ctx).style.window.spacing;
        window_padding =
            nk_panel_get_padding(&mut (*ctx).style, (*(*(*ctx).current).layout).type_0);
        max_height = count * item_height + count * item_spacing.y as libc::c_int;
        max_height += item_spacing.y as libc::c_int * 2i32 + window_padding.y as libc::c_int * 2i32;
        size.y = if size.y < max_height as f32 {
            size.y
        } else {
            max_height as f32
        };
        /* find selected item */
        current_item = items_separated_by_separator;
        i = 0i32;
        while i < count {
            iter = current_item;
            while 0 != *iter as libc::c_int && *iter as libc::c_int != separator {
                iter = iter.offset(1isize)
            }
            length = current_item.ptr_offset_to(iter).expect("bad offset_to") as libc::c_long
                as libc::c_int;
            if i == selected {
                break;
            }
            current_item = iter.offset(1isize);
            i += 1
        }
        if 0 != nk_combo_begin_text(ctx, current_item, length, size) {
            current_item = items_separated_by_separator;
            nk_layout_row_dynamic(ctx, item_height as f32, 1i32);
            i = 0i32;
            while i < count {
                iter = current_item;
                while 0 != *iter as libc::c_int && *iter as libc::c_int != separator {
                    iter = iter.offset(1isize)
                }
                length = current_item.ptr_offset_to(iter).expect("bad offset_to") as libc::c_long
                    as libc::c_int;
                if 0 != nk_combo_item_text(
                    ctx,
                    current_item,
                    length,
                    NK_TEXT_LEFT as libc::c_int as nk_flags,
                ) {
                    selected = i
                }
                current_item = current_item.offset(length as isize).offset(1isize);
                i += 1
            }
            nk_combo_end(ctx);
        }
        return selected;
    };
}
#[no_mangle]
pub unsafe fn nk_combo_item_text(
    mut ctx: *mut nk_context,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_text(ctx, text, len, align);
}
#[no_mangle]
pub unsafe fn nk_combo_string(
    mut ctx: *mut nk_context,
    mut items_separated_by_zeros: *const libc::c_char,
    mut selected: libc::c_int,
    mut count: libc::c_int,
    mut item_height: libc::c_int,
    mut size: nk_vec2,
) -> libc::c_int {
    return nk_combo_separator(
        ctx,
        items_separated_by_zeros,
        '\u{0}' as i32,
        selected,
        count,
        item_height,
        size,
    );
}
#[no_mangle]
pub unsafe fn nk_combo_callback(
    mut ctx: *mut nk_context,
    mut item_getter: Option<
        unsafe fn(_: *mut libc::c_void, _: libc::c_int, _: *mut *const libc::c_char) -> (),
    >,
    mut userdata: *mut libc::c_void,
    mut selected: libc::c_int,
    mut count: libc::c_int,
    mut item_height: libc::c_int,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut max_height: libc::c_int = 0;
    let mut item_spacing: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut window_padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut item: *const libc::c_char = 0 as *const libc::c_char;
    if ctx.is_null() || item_getter.is_none() {
        return selected;
    } else {
        /* calculate popup window */
        item_spacing = (*ctx).style.window.spacing;
        window_padding =
            nk_panel_get_padding(&mut (*ctx).style, (*(*(*ctx).current).layout).type_0);
        max_height = count * item_height + count * item_spacing.y as libc::c_int;
        max_height += item_spacing.y as libc::c_int * 2i32 + window_padding.y as libc::c_int * 2i32;
        size.y = if size.y < max_height as f32 {
            size.y
        } else {
            max_height as f32
        };
        item_getter.expect("non-null function pointer")(userdata, selected, &mut item);
        if 0 != nk_combo_begin_label(ctx, item, size) {
            nk_layout_row_dynamic(ctx, item_height as f32, 1i32);
            i = 0i32;
            while i < count {
                item_getter.expect("non-null function pointer")(userdata, i, &mut item);
                if 0 != nk_combo_item_label(ctx, item, NK_TEXT_LEFT as libc::c_int as nk_flags) {
                    selected = i
                }
                i += 1
            }
            nk_combo_end(ctx);
        }
        return selected;
    };
}
#[no_mangle]
pub unsafe fn nk_combobox(
    mut ctx: *mut nk_context,
    mut items: *mut *const libc::c_char,
    mut count: libc::c_int,
    mut selected: *mut libc::c_int,
    mut item_height: libc::c_int,
    mut size: nk_vec2,
) -> () {
    *selected = nk_combo(ctx, items, count, *selected, item_height, size);
}
#[no_mangle]
pub unsafe fn nk_combobox_string(
    mut ctx: *mut nk_context,
    mut items_separated_by_zeros: *const libc::c_char,
    mut selected: *mut libc::c_int,
    mut count: libc::c_int,
    mut item_height: libc::c_int,
    mut size: nk_vec2,
) -> () {
    *selected = nk_combo_string(
        ctx,
        items_separated_by_zeros,
        *selected,
        count,
        item_height,
        size,
    );
}
#[no_mangle]
pub unsafe fn nk_combobox_separator(
    mut ctx: *mut nk_context,
    mut items_separated_by_separator: *const libc::c_char,
    mut separator: libc::c_int,
    mut selected: *mut libc::c_int,
    mut count: libc::c_int,
    mut item_height: libc::c_int,
    mut size: nk_vec2,
) -> () {
    *selected = nk_combo_separator(
        ctx,
        items_separated_by_separator,
        separator,
        *selected,
        count,
        item_height,
        size,
    );
}
#[no_mangle]
pub unsafe fn nk_combobox_callback(
    mut ctx: *mut nk_context,
    mut item_getter: Option<
        unsafe fn(_: *mut libc::c_void, _: libc::c_int, _: *mut *const libc::c_char) -> (),
    >,
    mut userdata: *mut libc::c_void,
    mut selected: *mut libc::c_int,
    mut count: libc::c_int,
    mut item_height: libc::c_int,
    mut size: nk_vec2,
) -> () {
    *selected = nk_combo_callback(
        ctx,
        item_getter,
        userdata,
        *selected,
        count,
        item_height,
        size,
    );
}
#[no_mangle]
pub unsafe fn nk_combo_begin_color(
    mut ctx: *mut nk_context,
    mut color: nk_color,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut style: *mut nk_style = 0 as *mut nk_style;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut s: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        s = nk_widget(&mut header, ctx);
        if s as libc::c_uint == NK_WIDGET_INVALID as libc::c_int as libc::c_uint {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
                || s as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_button_behavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            /* draw combo box header background and border */
            if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.active as *mut nk_style_item
            } else if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.hover as *mut nk_style_item
            } else {
                background = &mut (*style).combo.normal as *mut nk_style_item
            }
            if (*background).type_0 as libc::c_uint
                == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            let mut content: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut bounds: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: nk_symbol_type = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.x;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            /* draw color */
            bounds.h = header.h - 4i32 as f32 * (*style).combo.content_padding.y;
            bounds.y = header.y + 2i32 as f32 * (*style).combo.content_padding.y;
            bounds.x = header.x + 2i32 as f32 * (*style).combo.content_padding.x;
            bounds.w =
                button.x - ((*style).combo.content_padding.x + (*style).combo.spacing.x) - bounds.x;
            nk_fill_rect(&mut (*win).buffer, bounds, 0i32 as f32, color);
            /* draw open/close button */
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut button,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_combo_begin_symbol(
    mut ctx: *mut nk_context,
    mut symbol: nk_symbol_type,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut style: *mut nk_style = 0 as *mut nk_style;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut s: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    let mut sym_background: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut symbol_color: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        s = nk_widget(&mut header, ctx);
        if s as libc::c_uint == NK_WIDGET_INVALID as libc::c_int as libc::c_uint {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
                || s as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_button_behavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            /* draw combo box header background and border */
            if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.active as *mut nk_style_item;
                symbol_color = (*style).combo.symbol_active
            } else if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.hover as *mut nk_style_item;
                symbol_color = (*style).combo.symbol_hover
            } else {
                background = &mut (*style).combo.normal as *mut nk_style_item;
                symbol_color = (*style).combo.symbol_hover
            }
            if (*background).type_0 as libc::c_uint
                == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                sym_background = nk_rgba(0i32, 0i32, 0i32, 0i32);
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                sym_background = (*background).data.color;
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            let mut bounds: nk_rect = nk_rect {
                x: 0i32 as f32,
                y: 0i32 as f32,
                w: 0i32 as f32,
                h: 0i32 as f32,
            };
            let mut content: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: nk_symbol_type = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.y;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            /* draw symbol */
            bounds.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            bounds.y = header.y + (*style).combo.content_padding.y;
            bounds.x = header.x + (*style).combo.content_padding.x;
            bounds.w = button.x - (*style).combo.content_padding.y - bounds.x;
            nk_draw_symbol(
                &mut (*win).buffer,
                symbol,
                bounds,
                sym_background,
                symbol_color,
                1.0f32,
                (*style).font,
            );
            /* draw open/close button */
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut bounds,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_combo_begin_symbol_label(
    mut ctx: *mut nk_context,
    mut selected: *const libc::c_char,
    mut type_0: nk_symbol_type,
    mut size: nk_vec2,
) -> libc::c_int {
    return nk_combo_begin_symbol_text(ctx, selected, nk_strlen(selected), type_0, size);
}
#[no_mangle]
pub unsafe fn nk_combo_begin_symbol_text(
    mut ctx: *mut nk_context,
    mut selected: *const libc::c_char,
    mut len: libc::c_int,
    mut symbol: nk_symbol_type,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut style: *mut nk_style = 0 as *mut nk_style;
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut s: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    let mut symbol_color: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        s = nk_widget(&mut header, ctx);
        if 0 == s as u64 {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
                || s as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_button_behavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            /* draw combo box header background and border */
            if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.active as *mut nk_style_item;
                symbol_color = (*style).combo.symbol_active;
                text.text = (*style).combo.label_active
            } else if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.hover as *mut nk_style_item;
                symbol_color = (*style).combo.symbol_hover;
                text.text = (*style).combo.label_hover
            } else {
                background = &mut (*style).combo.normal as *mut nk_style_item;
                symbol_color = (*style).combo.symbol_normal;
                text.text = (*style).combo.label_normal
            }
            if (*background).type_0 as libc::c_uint
                == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                text.background = nk_rgba(0i32, 0i32, 0i32, 0i32);
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                text.background = (*background).data.color;
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            let mut content: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut label: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut image: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: nk_symbol_type = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.x;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut button,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            /* draw symbol */
            image.x = header.x + (*style).combo.content_padding.x;
            image.y = header.y + (*style).combo.content_padding.y;
            image.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            image.w = image.h;
            nk_draw_symbol(
                &mut (*win).buffer,
                symbol,
                image,
                text.background,
                symbol_color,
                1.0f32,
                (*style).font,
            );
            /* draw label */
            text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
            label.x =
                image.x + image.w + (*style).combo.spacing.x + (*style).combo.content_padding.x;
            label.y = header.y + (*style).combo.content_padding.y;
            label.w = button.x - (*style).combo.content_padding.x - label.x;
            label.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            nk_widget_text(
                &mut (*win).buffer,
                label,
                selected,
                len,
                &mut text,
                NK_TEXT_LEFT as libc::c_int as nk_flags,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_combo_begin_image(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut style: *mut nk_style = 0 as *mut nk_style;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut s: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        s = nk_widget(&mut header, ctx);
        if s as libc::c_uint == NK_WIDGET_INVALID as libc::c_int as libc::c_uint {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
                || s as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_button_behavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            /* draw combo box header background and border */
            if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.active as *mut nk_style_item
            } else if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.hover as *mut nk_style_item
            } else {
                background = &mut (*style).combo.normal as *mut nk_style_item
            }
            if (*background).type_0 as libc::c_uint
                == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            let mut bounds: nk_rect = nk_rect {
                x: 0i32 as f32,
                y: 0i32 as f32,
                w: 0i32 as f32,
                h: 0i32 as f32,
            };
            let mut content: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: nk_symbol_type = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.y;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            /* draw image */
            bounds.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            bounds.y = header.y + (*style).combo.content_padding.y;
            bounds.x = header.x + (*style).combo.content_padding.x;
            bounds.w = button.x - (*style).combo.content_padding.y - bounds.x;
            nk_draw_image(&mut (*win).buffer, bounds, &mut img, nk_white);
            /* draw open/close button */
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut bounds,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_combo_begin_image_label(
    mut ctx: *mut nk_context,
    mut selected: *const libc::c_char,
    mut img: nk_image,
    mut size: nk_vec2,
) -> libc::c_int {
    return nk_combo_begin_image_text(ctx, selected, nk_strlen(selected), img, size);
}
#[no_mangle]
pub unsafe fn nk_combo_begin_image_text(
    mut ctx: *mut nk_context,
    mut selected: *const libc::c_char,
    mut len: libc::c_int,
    mut img: nk_image,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut style: *mut nk_style = 0 as *mut nk_style;
    let mut in_0: *mut nk_input = 0 as *mut nk_input;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut s: nk_widget_layout_states = NK_WIDGET_INVALID;
    let mut background: *const nk_style_item = 0 as *const nk_style_item;
    let mut text: nk_text = nk_text {
        padding: nk_vec2 { x: 0., y: 0. },
        background: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: nk_color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        s = nk_widget(&mut header, ctx);
        if 0 == s as u64 {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
                || s as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_button_behavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            /* draw combo box header background and border */
            if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.active as *mut nk_style_item;
                text.text = (*style).combo.label_active
            } else if 0
                != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                background = &mut (*style).combo.hover as *mut nk_style_item;
                text.text = (*style).combo.label_hover
            } else {
                background = &mut (*style).combo.normal as *mut nk_style_item;
                text.text = (*style).combo.label_normal
            }
            if (*background).type_0 as libc::c_uint
                == NK_STYLE_ITEM_IMAGE as libc::c_int as libc::c_uint
            {
                text.background = nk_rgba(0i32, 0i32, 0i32, 0i32);
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                text.background = (*background).data.color;
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            let mut content: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut label: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut image: nk_rect = nk_rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: nk_symbol_type = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as libc::c_int as libc::c_uint
            {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.x;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut button,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            /* draw image */
            image.x = header.x + (*style).combo.content_padding.x;
            image.y = header.y + (*style).combo.content_padding.y;
            image.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            image.w = image.h;
            nk_draw_image(&mut (*win).buffer, image, &mut img, nk_white);
            /* draw label */
            text.padding = nk_vec2(0i32 as f32, 0i32 as f32);
            label.x =
                image.x + image.w + (*style).combo.spacing.x + (*style).combo.content_padding.x;
            label.y = header.y + (*style).combo.content_padding.y;
            label.w = button.x - (*style).combo.content_padding.x - label.x;
            label.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            nk_widget_text(
                &mut (*win).buffer,
                label,
                selected,
                len,
                &mut text,
                NK_TEXT_LEFT as libc::c_int as nk_flags,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_combo_item_image_label(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut text: *const libc::c_char,
    mut alignment: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_image_label(ctx, img, text, alignment);
}
#[no_mangle]
pub unsafe fn nk_contextual_item_image_label(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut label: *const libc::c_char,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_image_text(ctx, img, label, nk_strlen(label), align);
}
#[no_mangle]
pub unsafe fn nk_contextual_item_image_text(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        state = nk_widget_fitting(&mut bounds, ctx, (*style).contextual_button.padding);
        if 0 == state as u64 {
            return nk_false as libc::c_int;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_do_button_text_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                img,
                text,
                len,
                align,
                NK_BUTTON_DEFAULT,
                &(*style).contextual_button,
                (*style).font,
                in_0,
            ) {
                nk_contextual_close(ctx);
                return nk_true as libc::c_int;
            } else {
                return nk_false as libc::c_int;
            }
        }
    };
}
#[no_mangle]
pub unsafe fn nk_combo_item_image_text(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut alignment: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_image_text(ctx, img, text, len, alignment);
}
#[no_mangle]
pub unsafe fn nk_combo_item_symbol_label(
    mut ctx: *mut nk_context,
    mut sym: nk_symbol_type,
    mut label: *const libc::c_char,
    mut alignment: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_symbol_label(ctx, sym, label, alignment);
}
#[no_mangle]
pub unsafe fn nk_contextual_item_symbol_label(
    mut ctx: *mut nk_context,
    mut symbol: nk_symbol_type,
    mut text: *const libc::c_char,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_symbol_text(ctx, symbol, text, nk_strlen(text), align);
}
#[no_mangle]
pub unsafe fn nk_contextual_item_symbol_text(
    mut ctx: *mut nk_context,
    mut symbol: nk_symbol_type,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: nk_widget_layout_states = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut nk_style;
        state = nk_widget_fitting(&mut bounds, ctx, (*style).contextual_button.padding);
        if 0 == state as u64 {
            return nk_false as libc::c_int;
        } else {
            in_0 = if state as libc::c_uint == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_do_button_text_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                symbol,
                text,
                len,
                align,
                NK_BUTTON_DEFAULT,
                &(*style).contextual_button,
                (*style).font,
                in_0,
            ) {
                nk_contextual_close(ctx);
                return nk_true as libc::c_int;
            } else {
                return nk_false as libc::c_int;
            }
        }
    };
}
#[no_mangle]
pub unsafe fn nk_combo_item_symbol_text(
    mut ctx: *mut nk_context,
    mut sym: nk_symbol_type,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut alignment: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_symbol_text(ctx, sym, text, len, alignment);
}
#[no_mangle]
pub unsafe fn nk_combo_close(mut ctx: *mut nk_context) -> () {
    nk_contextual_close(ctx);
}
#[no_mangle]
pub unsafe fn nk_contextual_begin(
    mut ctx: *mut nk_context,
    mut flags: nk_flags,
    mut size: nk_vec2,
    mut trigger_bounds: nk_rect,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut popup: *mut nk_window = 0 as *mut nk_window;
    let mut body: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    static mut null_rect: nk_rect = unsafe {
        nk_rect {
            x: -1i32 as f32,
            y: -1i32 as f32,
            w: 0i32 as f32,
            h: 0i32 as f32,
        }
    };
    let mut is_clicked: libc::c_int = 0i32;
    let mut is_open: libc::c_int = 0i32;
    let mut ret: libc::c_int = 0i32;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        (*win).popup.con_count = (*win).popup.con_count.wrapping_add(1);
        if (*ctx).current != (*ctx).active {
            return 0i32;
        } else {
            /* check if currently active contextual is active */
            popup = (*win).popup.win;
            is_open = (!popup.is_null()
                && (*win).popup.type_0 as libc::c_uint
                    == NK_PANEL_CONTEXTUAL as libc::c_int as libc::c_uint)
                as libc::c_int;
            is_clicked = nk_input_mouse_clicked(&mut (*ctx).input, NK_BUTTON_RIGHT, trigger_bounds);
            if 0 != (*win).popup.active_con && (*win).popup.con_count != (*win).popup.active_con {
                return 0i32;
            } else {
                if 0 == is_open && 0 != (*win).popup.active_con {
                    (*win).popup.active_con = 0i32 as libc::c_uint
                }
                if 0 == is_open && 0 == is_clicked {
                    return 0i32;
                } else {
                    /* calculate contextual position on click */
                    (*win).popup.active_con = (*win).popup.con_count;
                    if 0 != is_clicked {
                        body.x = (*ctx).input.mouse.pos.x;
                        body.y = (*ctx).input.mouse.pos.y
                    } else {
                        body.x = (*popup).bounds.x;
                        body.y = (*popup).bounds.y
                    }
                    body.w = size.x;
                    body.h = size.y;
                    /* start nonblocking contextual popup */
                    ret = nk_nonblock_begin(
                        ctx,
                        flags | NK_WINDOW_NO_SCROLLBAR as libc::c_int as libc::c_uint,
                        body,
                        null_rect,
                        NK_PANEL_CONTEXTUAL,
                    );
                    if 0 != ret {
                        (*win).popup.type_0 = NK_PANEL_CONTEXTUAL
                    } else {
                        (*win).popup.active_con = 0i32 as libc::c_uint;
                        (*win).popup.type_0 = NK_PANEL_NONE;
                        if !(*win).popup.win.is_null() {
                            (*(*win).popup.win).flags = 0i32 as nk_flags
                        }
                    }
                    return ret;
                }
            }
        }
    };
}
#[no_mangle]
pub unsafe fn nk_tooltip(mut ctx: *mut nk_context, mut text: *const libc::c_char) -> () {
    let mut style: *const nk_style = 0 as *const nk_style;
    let mut padding: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    let mut text_len: libc::c_int = 0;
    let mut text_width: f32 = 0.;
    let mut text_height: f32 = 0.;
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || text.is_null()
    {
        return;
    } else {
        /* fetch configuration data */
        style = &mut (*ctx).style as *mut nk_style;
        padding = (*style).window.padding;
        /* calculate size of the text and tooltip */
        text_len = nk_strlen(text);
        text_width = (*(*style).font).width.expect("non-null function pointer")(
            (*(*style).font).userdata,
            (*(*style).font).height,
            text,
            text_len,
        );
        text_width += 4i32 as f32 * padding.x;
        text_height = (*(*style).font).height + 2i32 as f32 * padding.y;
        /* execute tooltip and fill with text */
        if 0 != nk_tooltip_begin(ctx, text_width) {
            nk_layout_row_dynamic(ctx, text_height, 1i32);
            nk_text(ctx, text, text_len, NK_TEXT_LEFT as libc::c_int as nk_flags);
            nk_tooltip_end(ctx);
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_tooltip_end(mut ctx: *mut nk_context) -> () {
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        (*(*ctx).current).seq = (*(*ctx).current).seq.wrapping_sub(1);
        nk_popup_close(ctx);
        nk_popup_end(ctx);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_tooltip_begin(mut ctx: *mut nk_context, mut width: f32) -> libc::c_int {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut w: libc::c_int = 0;
    let mut h: libc::c_int = 0;
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut bounds: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut ret: libc::c_int = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        /* make sure that no nonblocking popup is currently active */
        win = (*ctx).current;
        in_0 = &mut (*ctx).input as *mut nk_input;
        if !(*win).popup.win.is_null()
            && 0 != (*win).popup.type_0 as libc::c_uint
                & NK_PANEL_SET_NONBLOCK as libc::c_int as libc::c_uint
        {
            return 0i32;
        } else {
            w = nk_iceilf(width);
            h = nk_iceilf(nk_null_rect.h);
            x = nk_ifloorf((*in_0).mouse.pos.x + 1i32 as f32)
                - (*(*win).layout).clip.x as libc::c_int;
            y = nk_ifloorf((*in_0).mouse.pos.y + 1i32 as f32)
                - (*(*win).layout).clip.y as libc::c_int;
            bounds.x = x as f32;
            bounds.y = y as f32;
            bounds.w = w as f32;
            bounds.h = h as f32;
            ret = nk_popup_begin(
                ctx,
                NK_POPUP_DYNAMIC,
                b"__##Tooltip##__\x00" as *const u8 as *const libc::c_char,
                (NK_WINDOW_NO_SCROLLBAR as libc::c_int | NK_WINDOW_BORDER as libc::c_int)
                    as nk_flags,
                bounds,
            );
            if 0 != ret {
                (*(*win).layout).flags &= !(NK_WINDOW_ROM as libc::c_int as nk_flags)
            }
            (*win).popup.type_0 = NK_PANEL_TOOLTIP;
            (*(*(*ctx).current).layout).type_0 = NK_PANEL_TOOLTIP;
            return ret;
        }
    };
}
unsafe fn nk_ifloorf(mut x: f32) -> libc::c_int {
    x = (x as libc::c_int - if x < 0.0f32 { 1i32 } else { 0i32 }) as f32;
    return x as libc::c_int;
}
#[no_mangle]
pub unsafe fn nk_menubar_begin(mut ctx: *mut nk_context) -> () {
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        layout = (*(*ctx).current).layout;
        /* if this assert triggers you allocated space between nk_begin and nk_menubar_begin.
    If you want a menubar the first nuklear function after `nk_begin` has to be a
    `nk_menubar_begin` call. Inside the menubar you then have to allocate space for
    widgets (also supports multiple rows).
    Example:
        if (nk_begin(...)) {
            nk_menubar_begin(...);
                nk_layout_xxxx(...);
                nk_button(...);
                nk_layout_xxxx(...);
                nk_button(...);
            nk_menubar_end(...);
        }
        nk_end(...);
    */
        if 0 != (*layout).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
            || 0 != (*layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
        {
            return;
        } else {
            (*layout).menu.x = (*layout).at_x;
            (*layout).menu.y = (*layout).at_y + (*layout).row.height;
            (*layout).menu.w = (*layout).bounds.w;
            (*layout).menu.offset.x = *(*layout).offset_x;
            (*layout).menu.offset.y = *(*layout).offset_y;
            *(*layout).offset_y = 0i32 as nk_uint;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_menubar_end(mut ctx: *mut nk_context) -> () {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut layout: *mut nk_panel = 0 as *mut nk_panel;
    let mut out: *mut nk_command_buffer = 0 as *mut nk_command_buffer;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        out = &mut (*win).buffer as *mut nk_command_buffer;
        layout = (*win).layout;
        if 0 != (*layout).flags & NK_WINDOW_HIDDEN as libc::c_int as libc::c_uint
            || 0 != (*layout).flags & NK_WINDOW_MINIMIZED as libc::c_int as libc::c_uint
        {
            return;
        } else {
            (*layout).menu.h = (*layout).at_y - (*layout).menu.y;
            (*layout).bounds.y +=
                (*layout).menu.h + (*ctx).style.window.spacing.y + (*layout).row.height;
            (*layout).bounds.h -=
                (*layout).menu.h + (*ctx).style.window.spacing.y + (*layout).row.height;
            *(*layout).offset_x = (*layout).menu.offset.x;
            *(*layout).offset_y = (*layout).menu.offset.y;
            (*layout).at_y = (*layout).bounds.y - (*layout).row.height;
            (*layout).clip.y = (*layout).bounds.y;
            (*layout).clip.h = (*layout).bounds.h;
            nk_push_scissor(out, (*layout).clip);
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_menu_begin_text(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut state: nk_flags = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        state = nk_widget(&mut header, ctx) as nk_flags;
        if 0 == state {
            return 0i32;
        } else {
            in_0 = if state == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*win).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_do_button_text(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                header,
                title,
                len,
                align,
                NK_BUTTON_DEFAULT,
                &mut (*ctx).style.menu_button,
                in_0,
                (*ctx).style.font,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            return nk_menu_begin(ctx, win, title, is_clicked, header, size);
        }
    };
}
unsafe fn nk_menu_begin(
    mut ctx: *mut nk_context,
    mut win: *mut nk_window,
    mut id: *const libc::c_char,
    mut is_clicked: libc::c_int,
    mut header: nk_rect,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut is_open: libc::c_int = 0i32;
    let mut is_active: libc::c_int = 0i32;
    let mut body: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut popup: *mut nk_window = 0 as *mut nk_window;
    let mut hash: nk_hash = nk_murmur_hash(
        id as *const libc::c_void,
        nk_strlen(id),
        NK_PANEL_MENU as libc::c_int as nk_hash,
    );
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        body.x = header.x;
        body.w = size.x;
        body.y = header.y + header.h;
        body.h = size.y;
        popup = (*win).popup.win;
        is_open = if !popup.is_null() {
            nk_true as libc::c_int
        } else {
            nk_false as libc::c_int
        };
        is_active = (!popup.is_null()
            && (*win).popup.name == hash
            && (*win).popup.type_0 as libc::c_uint == NK_PANEL_MENU as libc::c_int as libc::c_uint)
            as libc::c_int;
        if 0 != is_clicked && 0 != is_open && 0 == is_active
            || 0 != is_open && 0 == is_active
            || 0 == is_open && 0 == is_active && 0 == is_clicked
        {
            return 0i32;
        } else if 0 == nk_nonblock_begin(
            ctx,
            NK_WINDOW_NO_SCROLLBAR as libc::c_int as nk_flags,
            body,
            header,
            NK_PANEL_MENU,
        ) {
            return 0i32;
        } else {
            (*win).popup.type_0 = NK_PANEL_MENU;
            (*win).popup.name = hash;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_menu_begin_label(
    mut ctx: *mut nk_context,
    mut text: *const libc::c_char,
    mut align: nk_flags,
    mut size: nk_vec2,
) -> libc::c_int {
    return nk_menu_begin_text(ctx, text, nk_strlen(text), align, size);
}
#[no_mangle]
pub unsafe fn nk_menu_begin_image(
    mut ctx: *mut nk_context,
    mut id: *const libc::c_char,
    mut img: nk_image,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut state: nk_flags = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        state = nk_widget(&mut header, ctx) as nk_flags;
        if 0 == state {
            return 0i32;
        } else {
            in_0 = if state == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_do_button_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                header,
                img,
                NK_BUTTON_DEFAULT,
                &mut (*ctx).style.menu_button,
                in_0,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            return nk_menu_begin(ctx, win, id, is_clicked, header, size);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_menu_begin_image_text(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut img: nk_image,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut state: nk_flags = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        state = nk_widget(&mut header, ctx) as nk_flags;
        if 0 == state {
            return 0i32;
        } else {
            in_0 = if state == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_do_button_text_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                header,
                img,
                title,
                len,
                align,
                NK_BUTTON_DEFAULT,
                &mut (*ctx).style.menu_button,
                (*ctx).style.font,
                in_0,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            return nk_menu_begin(ctx, win, title, is_clicked, header, size);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_menu_begin_image_label(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
    mut align: nk_flags,
    mut img: nk_image,
    mut size: nk_vec2,
) -> libc::c_int {
    return nk_menu_begin_image_text(ctx, title, nk_strlen(title), align, img, size);
}
#[no_mangle]
pub unsafe fn nk_menu_begin_symbol(
    mut ctx: *mut nk_context,
    mut id: *const libc::c_char,
    mut sym: nk_symbol_type,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut state: nk_flags = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        state = nk_widget(&mut header, ctx) as nk_flags;
        if 0 == state {
            return 0i32;
        } else {
            in_0 = if state == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_do_button_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                header,
                sym,
                NK_BUTTON_DEFAULT,
                &mut (*ctx).style.menu_button,
                in_0,
                (*ctx).style.font,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            return nk_menu_begin(ctx, win, id, is_clicked, header, size);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_menu_begin_symbol_text(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
    mut sym: nk_symbol_type,
    mut size: nk_vec2,
) -> libc::c_int {
    let mut win: *mut nk_window = 0 as *mut nk_window;
    let mut header: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut in_0: *const nk_input = 0 as *const nk_input;
    let mut is_clicked: libc::c_int = nk_false as libc::c_int;
    let mut state: nk_flags = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        state = nk_widget(&mut header, ctx) as nk_flags;
        if 0 == state {
            return 0i32;
        } else {
            in_0 = if state == NK_WIDGET_ROM as libc::c_int as libc::c_uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as libc::c_int as libc::c_uint
            {
                0 as *mut nk_input
            } else {
                &mut (*ctx).input as *mut nk_input
            };
            if 0 != nk_do_button_text_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                header,
                sym,
                title,
                len,
                align,
                NK_BUTTON_DEFAULT,
                &mut (*ctx).style.menu_button,
                (*ctx).style.font,
                in_0,
            ) {
                is_clicked = nk_true as libc::c_int
            }
            return nk_menu_begin(ctx, win, title, is_clicked, header, size);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_menu_begin_symbol_label(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
    mut align: nk_flags,
    mut sym: nk_symbol_type,
    mut size: nk_vec2,
) -> libc::c_int {
    return nk_menu_begin_symbol_text(ctx, title, nk_strlen(title), align, sym, size);
}
#[no_mangle]
pub unsafe fn nk_menu_item_text(
    mut ctx: *mut nk_context,
    mut title: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_text(ctx, title, len, align);
}
#[no_mangle]
pub unsafe fn nk_menu_item_label(
    mut ctx: *mut nk_context,
    mut label: *const libc::c_char,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_label(ctx, label, align);
}
#[no_mangle]
pub unsafe fn nk_menu_item_image_label(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut label: *const libc::c_char,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_image_label(ctx, img, label, align);
}
#[no_mangle]
pub unsafe fn nk_menu_item_image_text(
    mut ctx: *mut nk_context,
    mut img: nk_image,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_image_text(ctx, img, text, len, align);
}
#[no_mangle]
pub unsafe fn nk_menu_item_symbol_text(
    mut ctx: *mut nk_context,
    mut sym: nk_symbol_type,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_symbol_text(ctx, sym, text, len, align);
}
#[no_mangle]
pub unsafe fn nk_menu_item_symbol_label(
    mut ctx: *mut nk_context,
    mut sym: nk_symbol_type,
    mut label: *const libc::c_char,
    mut align: nk_flags,
) -> libc::c_int {
    return nk_contextual_item_symbol_label(ctx, sym, label, align);
}
#[no_mangle]
pub unsafe fn nk_menu_close(mut ctx: *mut nk_context) -> () {
    nk_contextual_close(ctx);
}
#[no_mangle]
pub unsafe fn nk_menu_end(mut ctx: *mut nk_context) -> () {
    nk_contextual_end(ctx);
}
#[no_mangle]
pub unsafe fn nk_style_load_cursor(
    mut ctx: *mut nk_context,
    mut cursor: nk_style_cursor,
    mut c: *const nk_cursor,
) -> () {
    let mut style: *mut nk_style = 0 as *mut nk_style;
    if ctx.is_null() {
        return;
    } else {
        style = &mut (*ctx).style as *mut nk_style;
        (*style).cursors[cursor as usize] = c;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_style_load_all_cursors(
    mut ctx: *mut nk_context,
    mut cursors: *mut nk_cursor,
) -> () {
    let mut i: libc::c_int = 0i32;
    let mut style: *mut nk_style = 0 as *mut nk_style;
    if ctx.is_null() {
        return;
    } else {
        style = &mut (*ctx).style as *mut nk_style;
        i = 0i32;
        while i < NK_CURSOR_COUNT as libc::c_int {
            (*style).cursors[i as usize] = &mut *cursors.offset(i as isize) as *mut nk_cursor;
            i += 1
        }
        (*style).cursor_visible = nk_true as libc::c_int;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_style_get_color_by_name(mut c: nk_style_colors) -> *const libc::c_char {
    return nk_color_names[c as usize];
}
static mut nk_color_names: [*const libc::c_char; 28] = unsafe {
    [
        b"NK_COLOR_TEXT\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_WINDOW\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_HEADER\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_BORDER\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_BUTTON\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_BUTTON_HOVER\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_BUTTON_ACTIVE\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_TOGGLE\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_TOGGLE_HOVER\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_TOGGLE_CURSOR\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_SELECT\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_SELECT_ACTIVE\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_SLIDER\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_SLIDER_CURSOR\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_SLIDER_CURSOR_HOVER\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_SLIDER_CURSOR_ACTIVE\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_PROPERTY\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_EDIT\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_EDIT_CURSOR\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_COMBO\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_CHART\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_CHART_COLOR\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_CHART_COLOR_HIGHLIGHT\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_SCROLLBAR\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_SCROLLBAR_CURSOR\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_SCROLLBAR_CURSOR_HOVER\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_SCROLLBAR_CURSOR_ACTIVE\x00" as *const u8 as *const libc::c_char,
        b"NK_COLOR_TAB_HEADER\x00" as *const u8 as *const libc::c_char,
    ]
};
#[no_mangle]
pub unsafe fn nk_style_set_font(mut ctx: *mut nk_context, mut font: *const nk_user_font) -> () {
    let mut style: *mut nk_style = 0 as *mut nk_style;
    if ctx.is_null() {
        return;
    } else {
        style = &mut (*ctx).style as *mut nk_style;
        (*style).font = font;
        (*ctx).stacks.fonts.head = 0i32;
        if !(*ctx).current.is_null() {
            nk_layout_reset_min_row_height(ctx);
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_style_set_cursor(mut ctx: *mut nk_context, mut c: nk_style_cursor) -> libc::c_int {
    let mut style: *mut nk_style = 0 as *mut nk_style;
    if ctx.is_null() {
        return 0i32;
    } else {
        style = &mut (*ctx).style as *mut nk_style;
        if !(*style).cursors[c as usize].is_null() {
            (*style).cursor_active = (*style).cursors[c as usize];
            return 1i32;
        } else {
            return 0i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_show_cursor(mut ctx: *mut nk_context) -> () {
    (*ctx).style.cursor_visible = nk_true as libc::c_int;
}
#[no_mangle]
pub unsafe fn nk_style_hide_cursor(mut ctx: *mut nk_context) -> () {
    (*ctx).style.cursor_visible = nk_false as libc::c_int;
}
#[no_mangle]
pub unsafe fn nk_style_push_font(
    mut ctx: *mut nk_context,
    mut font: *const nk_user_font,
) -> libc::c_int {
    let mut font_stack: *mut nk_config_stack_user_font = 0 as *mut nk_config_stack_user_font;
    let mut element: *mut nk_config_stack_user_font_element =
        0 as *mut nk_config_stack_user_font_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        font_stack = &mut (*ctx).stacks.fonts as *mut nk_config_stack_user_font;
        if (*font_stack).head
            >= (::std::mem::size_of::<[nk_config_stack_user_font_element; 8]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<nk_config_stack_user_font_element>() as libc::c_ulong
                ) as libc::c_int
        {
            return 0i32;
        } else {
            let fresh41 = (*font_stack).head;
            (*font_stack).head = (*font_stack).head + 1;
            element = &mut (*font_stack).elements[fresh41 as usize]
                as *mut nk_config_stack_user_font_element;
            (*element).address = &mut (*ctx).style.font as *mut *const nk_user_font;
            (*element).old_value = (*ctx).style.font;
            (*ctx).style.font = font;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_push_float(
    mut ctx: *mut nk_context,
    mut address: *mut f32,
    mut value: f32,
) -> libc::c_int {
    let mut type_stack: *mut nk_config_stack_float = 0 as *mut nk_config_stack_float;
    let mut element: *mut nk_config_stack_float_element = 0 as *mut nk_config_stack_float_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.floats as *mut nk_config_stack_float;
        if (*type_stack).head
            >= (::std::mem::size_of::<[nk_config_stack_float_element; 32]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<nk_config_stack_float_element>() as libc::c_ulong
                ) as libc::c_int
        {
            return 0i32;
        } else {
            let fresh42 = (*type_stack).head;
            (*type_stack).head = (*type_stack).head + 1;
            element =
                &mut (*type_stack).elements[fresh42 as usize] as *mut nk_config_stack_float_element;
            (*element).address = address;
            (*element).old_value = *address;
            *address = value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_push_vec2(
    mut ctx: *mut nk_context,
    mut address: *mut nk_vec2,
    mut value: nk_vec2,
) -> libc::c_int {
    let mut type_stack: *mut nk_config_stack_vec2 = 0 as *mut nk_config_stack_vec2;
    let mut element: *mut nk_config_stack_vec2_element = 0 as *mut nk_config_stack_vec2_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.vectors as *mut nk_config_stack_vec2;
        if (*type_stack).head
            >= (::std::mem::size_of::<[nk_config_stack_vec2_element; 16]>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<nk_config_stack_vec2_element>() as libc::c_ulong)
                as libc::c_int
        {
            return 0i32;
        } else {
            let fresh43 = (*type_stack).head;
            (*type_stack).head = (*type_stack).head + 1;
            element =
                &mut (*type_stack).elements[fresh43 as usize] as *mut nk_config_stack_vec2_element;
            (*element).address = address;
            (*element).old_value = *address;
            *address = value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_push_style_item(
    mut ctx: *mut nk_context,
    mut address: *mut nk_style_item,
    mut value: nk_style_item,
) -> libc::c_int {
    let mut type_stack: *mut nk_config_stack_style_item = 0 as *mut nk_config_stack_style_item;
    let mut element: *mut nk_config_stack_style_item_element =
        0 as *mut nk_config_stack_style_item_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.style_items as *mut nk_config_stack_style_item;
        if (*type_stack).head
            >= (::std::mem::size_of::<[nk_config_stack_style_item_element; 16]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<nk_config_stack_style_item_element>() as libc::c_ulong
                ) as libc::c_int
        {
            return 0i32;
        } else {
            let fresh44 = (*type_stack).head;
            (*type_stack).head = (*type_stack).head + 1;
            element = &mut (*type_stack).elements[fresh44 as usize]
                as *mut nk_config_stack_style_item_element;
            (*element).address = address;
            (*element).old_value = *address;
            *address = value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_push_flags(
    mut ctx: *mut nk_context,
    mut address: *mut nk_flags,
    mut value: nk_flags,
) -> libc::c_int {
    let mut type_stack: *mut nk_config_stack_flags = 0 as *mut nk_config_stack_flags;
    let mut element: *mut nk_config_stack_flags_element = 0 as *mut nk_config_stack_flags_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.flags as *mut nk_config_stack_flags;
        if (*type_stack).head
            >= (::std::mem::size_of::<[nk_config_stack_flags_element; 32]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<nk_config_stack_flags_element>() as libc::c_ulong
                ) as libc::c_int
        {
            return 0i32;
        } else {
            let fresh45 = (*type_stack).head;
            (*type_stack).head = (*type_stack).head + 1;
            element =
                &mut (*type_stack).elements[fresh45 as usize] as *mut nk_config_stack_flags_element;
            (*element).address = address;
            (*element).old_value = *address;
            *address = value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_push_color(
    mut ctx: *mut nk_context,
    mut address: *mut nk_color,
    mut value: nk_color,
) -> libc::c_int {
    let mut type_stack: *mut nk_config_stack_color = 0 as *mut nk_config_stack_color;
    let mut element: *mut nk_config_stack_color_element = 0 as *mut nk_config_stack_color_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.colors as *mut nk_config_stack_color;
        if (*type_stack).head
            >= (::std::mem::size_of::<[nk_config_stack_color_element; 32]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<nk_config_stack_color_element>() as libc::c_ulong
                ) as libc::c_int
        {
            return 0i32;
        } else {
            let fresh46 = (*type_stack).head;
            (*type_stack).head = (*type_stack).head + 1;
            element =
                &mut (*type_stack).elements[fresh46 as usize] as *mut nk_config_stack_color_element;
            (*element).address = address;
            (*element).old_value = *address;
            *address = value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_pop_font(mut ctx: *mut nk_context) -> libc::c_int {
    let mut font_stack: *mut nk_config_stack_user_font = 0 as *mut nk_config_stack_user_font;
    let mut element: *mut nk_config_stack_user_font_element =
        0 as *mut nk_config_stack_user_font_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        font_stack = &mut (*ctx).stacks.fonts as *mut nk_config_stack_user_font;
        if (*font_stack).head < 1i32 {
            return 0i32;
        } else {
            (*font_stack).head -= 1;
            element = &mut (*font_stack).elements[(*font_stack).head as usize]
                as *mut nk_config_stack_user_font_element;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_pop_float(mut ctx: *mut nk_context) -> libc::c_int {
    let mut type_stack: *mut nk_config_stack_float = 0 as *mut nk_config_stack_float;
    let mut element: *mut nk_config_stack_float_element = 0 as *mut nk_config_stack_float_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.floats as *mut nk_config_stack_float;
        if (*type_stack).head < 1i32 {
            return 0i32;
        } else {
            (*type_stack).head -= 1;
            element = &mut (*type_stack).elements[(*type_stack).head as usize]
                as *mut nk_config_stack_float_element;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_pop_vec2(mut ctx: *mut nk_context) -> libc::c_int {
    let mut type_stack: *mut nk_config_stack_vec2 = 0 as *mut nk_config_stack_vec2;
    let mut element: *mut nk_config_stack_vec2_element = 0 as *mut nk_config_stack_vec2_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.vectors as *mut nk_config_stack_vec2;
        if (*type_stack).head < 1i32 {
            return 0i32;
        } else {
            (*type_stack).head -= 1;
            element = &mut (*type_stack).elements[(*type_stack).head as usize]
                as *mut nk_config_stack_vec2_element;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_pop_style_item(mut ctx: *mut nk_context) -> libc::c_int {
    let mut type_stack: *mut nk_config_stack_style_item = 0 as *mut nk_config_stack_style_item;
    let mut element: *mut nk_config_stack_style_item_element =
        0 as *mut nk_config_stack_style_item_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.style_items as *mut nk_config_stack_style_item;
        if (*type_stack).head < 1i32 {
            return 0i32;
        } else {
            (*type_stack).head -= 1;
            element = &mut (*type_stack).elements[(*type_stack).head as usize]
                as *mut nk_config_stack_style_item_element;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_pop_flags(mut ctx: *mut nk_context) -> libc::c_int {
    let mut type_stack: *mut nk_config_stack_flags = 0 as *mut nk_config_stack_flags;
    let mut element: *mut nk_config_stack_flags_element = 0 as *mut nk_config_stack_flags_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.flags as *mut nk_config_stack_flags;
        if (*type_stack).head < 1i32 {
            return 0i32;
        } else {
            (*type_stack).head -= 1;
            element = &mut (*type_stack).elements[(*type_stack).head as usize]
                as *mut nk_config_stack_flags_element;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_pop_color(mut ctx: *mut nk_context) -> libc::c_int {
    let mut type_stack: *mut nk_config_stack_color = 0 as *mut nk_config_stack_color;
    let mut element: *mut nk_config_stack_color_element = 0 as *mut nk_config_stack_color_element;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.colors as *mut nk_config_stack_color;
        if (*type_stack).head < 1i32 {
            return 0i32;
        } else {
            (*type_stack).head -= 1;
            element = &mut (*type_stack).elements[(*type_stack).head as usize]
                as *mut nk_config_stack_color_element;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_rgb_iv(mut c: *const libc::c_int) -> nk_color {
    return nk_rgb(*c.offset(0isize), *c.offset(1isize), *c.offset(2isize));
}
#[no_mangle]
pub unsafe fn nk_rgb_bv(mut c: *const nk_byte) -> nk_color {
    return nk_rgb(
        *c.offset(0isize) as libc::c_int,
        *c.offset(1isize) as libc::c_int,
        *c.offset(2isize) as libc::c_int,
    );
}
#[no_mangle]
pub unsafe fn nk_rgb_f(
    mut r: f32,
    mut g: f32,
    mut b: f32,
) -> nk_color {
    let mut ret: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    ret.r = (if (0i32 as f32) < if 1.0f32 < r { 1.0f32 } else { r } {
        if 1.0f32 < r {
            1.0f32
        } else {
            r
        }
    } else {
        0i32 as f32
    } * 255.0f32) as nk_byte;
    ret.g = (if (0i32 as f32) < if 1.0f32 < g { 1.0f32 } else { g } {
        if 1.0f32 < g {
            1.0f32
        } else {
            g
        }
    } else {
        0i32 as f32
    } * 255.0f32) as nk_byte;
    ret.b = (if (0i32 as f32) < if 1.0f32 < b { 1.0f32 } else { b } {
        if 1.0f32 < b {
            1.0f32
        } else {
            b
        }
    } else {
        0i32 as f32
    } * 255.0f32) as nk_byte;
    ret.a = 255i32 as nk_byte;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_rgb_fv(mut c: *const f32) -> nk_color {
    return nk_rgb_f(*c.offset(0isize), *c.offset(1isize), *c.offset(2isize));
}
#[no_mangle]
pub unsafe fn nk_rgb_cf(mut c: nk_colorf) -> nk_color {
    return nk_rgb_f(c.r, c.g, c.b);
}
#[no_mangle]
pub unsafe fn nk_rgb_hex(mut rgb: *const libc::c_char) -> nk_color {
    let mut col: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut c: *const libc::c_char = rgb;
    if *c as libc::c_int == '#' as i32 {
        c = c.offset(1isize)
    }
    col.r = nk_parse_hex(c, 2i32) as nk_byte;
    col.g = nk_parse_hex(c.offset(2isize), 2i32) as nk_byte;
    col.b = nk_parse_hex(c.offset(4isize), 2i32) as nk_byte;
    col.a = 255i32 as nk_byte;
    return col;
}
unsafe fn nk_parse_hex(mut p: *const libc::c_char, mut length: libc::c_int) -> libc::c_int {
    let mut i: libc::c_int = 0i32;
    let mut len: libc::c_int = 0i32;
    while len < length {
        i <<= 4i32;
        if *p.offset(len as isize) as libc::c_int >= 'a' as i32
            && *p.offset(len as isize) as libc::c_int <= 'f' as i32
        {
            i += *p.offset(len as isize) as libc::c_int - 'a' as i32 + 10i32
        } else if *p.offset(len as isize) as libc::c_int >= 'A' as i32
            && *p.offset(len as isize) as libc::c_int <= 'F' as i32
        {
            i += *p.offset(len as isize) as libc::c_int - 'A' as i32 + 10i32
        } else {
            i += *p.offset(len as isize) as libc::c_int - '0' as i32
        }
        len += 1
    }
    return i;
}
#[no_mangle]
pub unsafe fn nk_rgba_u32(mut in_0: nk_uint) -> nk_color {
    let mut ret: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    ret.r = (in_0 & 255i32 as libc::c_uint) as nk_byte;
    ret.g = (in_0 >> 8i32 & 255i32 as libc::c_uint) as nk_byte;
    ret.b = (in_0 >> 16i32 & 255i32 as libc::c_uint) as nk_byte;
    ret.a = (in_0 >> 24i32 & 255i32 as libc::c_uint) as nk_byte;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_rgba_iv(mut c: *const libc::c_int) -> nk_color {
    return nk_rgba(
        *c.offset(0isize),
        *c.offset(1isize),
        *c.offset(2isize),
        *c.offset(3isize),
    );
}
#[no_mangle]
pub unsafe fn nk_rgba_bv(mut c: *const nk_byte) -> nk_color {
    return nk_rgba(
        *c.offset(0isize) as libc::c_int,
        *c.offset(1isize) as libc::c_int,
        *c.offset(2isize) as libc::c_int,
        *c.offset(3isize) as libc::c_int,
    );
}
#[no_mangle]
pub unsafe fn nk_rgba_cf(mut c: nk_colorf) -> nk_color {
    return nk_rgba_f(c.r, c.g, c.b, c.a);
}
#[no_mangle]
pub unsafe fn nk_rgba_hex(mut rgb: *const libc::c_char) -> nk_color {
    let mut col: nk_color = nk_color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut c: *const libc::c_char = rgb;
    if *c as libc::c_int == '#' as i32 {
        c = c.offset(1isize)
    }
    col.r = nk_parse_hex(c, 2i32) as nk_byte;
    col.g = nk_parse_hex(c.offset(2isize), 2i32) as nk_byte;
    col.b = nk_parse_hex(c.offset(4isize), 2i32) as nk_byte;
    col.a = nk_parse_hex(c.offset(6isize), 2i32) as nk_byte;
    return col;
}
#[no_mangle]
pub unsafe fn nk_hsv(mut h: libc::c_int, mut s: libc::c_int, mut v: libc::c_int) -> nk_color {
    return nk_hsva(h, s, v, 255i32);
}
#[no_mangle]
pub unsafe fn nk_hsva(
    mut h: libc::c_int,
    mut s: libc::c_int,
    mut v: libc::c_int,
    mut a: libc::c_int,
) -> nk_color {
    let mut hf: f32 = (if if h < 255i32 { h } else { 255i32 } < 0i32 {
        0i32
    } else if h < 255i32 {
        h
    } else {
        255i32
    }) as f32 / 255.0f32;
    let mut sf: f32 = (if if s < 255i32 { s } else { 255i32 } < 0i32 {
        0i32
    } else if s < 255i32 {
        s
    } else {
        255i32
    }) as f32 / 255.0f32;
    let mut vf: f32 = (if if v < 255i32 { v } else { 255i32 } < 0i32 {
        0i32
    } else if v < 255i32 {
        v
    } else {
        255i32
    }) as f32 / 255.0f32;
    let mut af: f32 = (if if a < 255i32 { a } else { 255i32 } < 0i32 {
        0i32
    } else if a < 255i32 {
        a
    } else {
        255i32
    }) as f32 / 255.0f32;
    return nk_hsva_f(hf, sf, vf, af);
}
#[no_mangle]
pub unsafe fn nk_hsv_iv(mut c: *const libc::c_int) -> nk_color {
    return nk_hsv(*c.offset(0isize), *c.offset(1isize), *c.offset(2isize));
}
#[no_mangle]
pub unsafe fn nk_hsv_bv(mut c: *const nk_byte) -> nk_color {
    return nk_hsv(
        *c.offset(0isize) as libc::c_int,
        *c.offset(1isize) as libc::c_int,
        *c.offset(2isize) as libc::c_int,
    );
}
#[no_mangle]
pub unsafe fn nk_hsv_fv(mut c: *const f32) -> nk_color {
    return nk_hsv_f(*c.offset(0isize), *c.offset(1isize), *c.offset(2isize));
}
#[no_mangle]
pub unsafe fn nk_hsva_iv(mut c: *const libc::c_int) -> nk_color {
    return nk_hsva(
        *c.offset(0isize),
        *c.offset(1isize),
        *c.offset(2isize),
        *c.offset(3isize),
    );
}
#[no_mangle]
pub unsafe fn nk_hsva_bv(mut c: *const nk_byte) -> nk_color {
    return nk_hsva(
        *c.offset(0isize) as libc::c_int,
        *c.offset(1isize) as libc::c_int,
        *c.offset(2isize) as libc::c_int,
        *c.offset(3isize) as libc::c_int,
    );
}
#[no_mangle]
pub unsafe fn nk_hsva_fv(mut c: *const f32) -> nk_color {
    return nk_hsva_f(
        *c.offset(0isize),
        *c.offset(1isize),
        *c.offset(2isize),
        *c.offset(3isize),
    );
}
#[no_mangle]
pub unsafe fn nk_color_cf(mut in_0: nk_color) -> nk_colorf {
    let mut o: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    nk_color_f(&mut o.r, &mut o.g, &mut o.b, &mut o.a, in_0);
    return o;
}
#[no_mangle]
pub unsafe fn nk_color_d(
    mut r: *mut libc::c_double,
    mut g: *mut libc::c_double,
    mut b: *mut libc::c_double,
    mut a: *mut libc::c_double,
    mut in_0: nk_color,
) -> () {
    static mut s: libc::c_double = unsafe { 1.0f64 / 255.0f64 };
    *r = in_0.r as libc::c_double * s;
    *g = in_0.g as libc::c_double * s;
    *b = in_0.b as libc::c_double * s;
    *a = in_0.a as libc::c_double * s;
}
#[no_mangle]
pub unsafe fn nk_color_dv(mut c: *mut libc::c_double, mut in_0: nk_color) -> () {
    nk_color_d(
        &mut *c.offset(0isize),
        &mut *c.offset(1isize),
        &mut *c.offset(2isize),
        &mut *c.offset(3isize),
        in_0,
    );
}
#[no_mangle]
pub unsafe fn nk_color_hex_rgba(mut output: *mut libc::c_char, mut col: nk_color) -> () {
    *output.offset(0isize) = (if (col.r as libc::c_int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.r as libc::c_int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.r as libc::c_int & 240i32) >> 4i32)
    }) as libc::c_char;
    *output.offset(1isize) = (if col.r as libc::c_int & 15i32 <= 9i32 {
        '0' as i32 + (col.r as libc::c_int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.r as libc::c_int & 15i32)
    }) as libc::c_char;
    *output.offset(2isize) = (if (col.g as libc::c_int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.g as libc::c_int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.g as libc::c_int & 240i32) >> 4i32)
    }) as libc::c_char;
    *output.offset(3isize) = (if col.g as libc::c_int & 15i32 <= 9i32 {
        '0' as i32 + (col.g as libc::c_int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.g as libc::c_int & 15i32)
    }) as libc::c_char;
    *output.offset(4isize) = (if (col.b as libc::c_int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.b as libc::c_int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.b as libc::c_int & 240i32) >> 4i32)
    }) as libc::c_char;
    *output.offset(5isize) = (if col.b as libc::c_int & 15i32 <= 9i32 {
        '0' as i32 + (col.b as libc::c_int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.b as libc::c_int & 15i32)
    }) as libc::c_char;
    *output.offset(6isize) = (if (col.a as libc::c_int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.a as libc::c_int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.a as libc::c_int & 240i32) >> 4i32)
    }) as libc::c_char;
    *output.offset(7isize) = (if col.a as libc::c_int & 15i32 <= 9i32 {
        '0' as i32 + (col.a as libc::c_int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.a as libc::c_int & 15i32)
    }) as libc::c_char;
    *output.offset(8isize) = '\u{0}' as i32 as libc::c_char;
}
#[no_mangle]
pub unsafe fn nk_color_hex_rgb(mut output: *mut libc::c_char, mut col: nk_color) -> () {
    *output.offset(0isize) = (if (col.r as libc::c_int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.r as libc::c_int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.r as libc::c_int & 240i32) >> 4i32)
    }) as libc::c_char;
    *output.offset(1isize) = (if col.r as libc::c_int & 15i32 <= 9i32 {
        '0' as i32 + (col.r as libc::c_int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.r as libc::c_int & 15i32)
    }) as libc::c_char;
    *output.offset(2isize) = (if (col.g as libc::c_int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.g as libc::c_int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.g as libc::c_int & 240i32) >> 4i32)
    }) as libc::c_char;
    *output.offset(3isize) = (if col.g as libc::c_int & 15i32 <= 9i32 {
        '0' as i32 + (col.g as libc::c_int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.g as libc::c_int & 15i32)
    }) as libc::c_char;
    *output.offset(4isize) = (if (col.b as libc::c_int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.b as libc::c_int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.b as libc::c_int & 240i32) >> 4i32)
    }) as libc::c_char;
    *output.offset(5isize) = (if col.b as libc::c_int & 15i32 <= 9i32 {
        '0' as i32 + (col.b as libc::c_int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.b as libc::c_int & 15i32)
    }) as libc::c_char;
    *output.offset(6isize) = '\u{0}' as i32 as libc::c_char;
}
#[no_mangle]
pub unsafe fn nk_color_hsv_i(
    mut out_h: *mut libc::c_int,
    mut out_s: *mut libc::c_int,
    mut out_v: *mut libc::c_int,
    mut in_0: nk_color,
) -> () {
    let mut a: libc::c_int = 0;
    nk_color_hsva_i(out_h, out_s, out_v, &mut a, in_0);
}
#[no_mangle]
pub unsafe fn nk_color_hsva_i(
    mut out_h: *mut libc::c_int,
    mut out_s: *mut libc::c_int,
    mut out_v: *mut libc::c_int,
    mut out_a: *mut libc::c_int,
    mut in_0: nk_color,
) -> () {
    let mut h: f32 = 0.;
    let mut s: f32 = 0.;
    let mut v: f32 = 0.;
    let mut a: f32 = 0.;
    nk_color_hsva_f(&mut h, &mut s, &mut v, &mut a, in_0);
    *out_h = (h * 255.0f32) as nk_byte as libc::c_int;
    *out_s = (s * 255.0f32) as nk_byte as libc::c_int;
    *out_v = (v * 255.0f32) as nk_byte as libc::c_int;
    *out_a = (a * 255.0f32) as nk_byte as libc::c_int;
}
#[no_mangle]
pub unsafe fn nk_color_hsva_f(
    mut out_h: *mut f32,
    mut out_s: *mut f32,
    mut out_v: *mut f32,
    mut out_a: *mut f32,
    mut in_0: nk_color,
) -> () {
    let mut col: nk_colorf = nk_colorf {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    nk_color_f(&mut col.r, &mut col.g, &mut col.b, &mut col.a, in_0);
    nk_colorf_hsva_f(out_h, out_s, out_v, out_a, col);
}
#[no_mangle]
pub unsafe fn nk_color_hsv_b(
    mut out_h: *mut nk_byte,
    mut out_s: *mut nk_byte,
    mut out_v: *mut nk_byte,
    mut in_0: nk_color,
) -> () {
    let mut tmp: [libc::c_int; 4] = [0; 4];
    nk_color_hsva_i(
        &mut tmp[0usize],
        &mut tmp[1usize],
        &mut tmp[2usize],
        &mut tmp[3usize],
        in_0,
    );
    *out_h = tmp[0usize] as nk_byte;
    *out_s = tmp[1usize] as nk_byte;
    *out_v = tmp[2usize] as nk_byte;
}
#[no_mangle]
pub unsafe fn nk_color_hsv_iv(mut out: *mut libc::c_int, mut in_0: nk_color) -> () {
    nk_color_hsv_i(
        &mut *out.offset(0isize),
        &mut *out.offset(1isize),
        &mut *out.offset(2isize),
        in_0,
    );
}
#[no_mangle]
pub unsafe fn nk_color_hsv_bv(mut out: *mut nk_byte, mut in_0: nk_color) -> () {
    let mut tmp: [libc::c_int; 4] = [0; 4];
    nk_color_hsv_i(&mut tmp[0usize], &mut tmp[1usize], &mut tmp[2usize], in_0);
    *out.offset(0isize) = tmp[0usize] as nk_byte;
    *out.offset(1isize) = tmp[1usize] as nk_byte;
    *out.offset(2isize) = tmp[2usize] as nk_byte;
}
#[no_mangle]
pub unsafe fn nk_color_hsv_f(
    mut out_h: *mut f32,
    mut out_s: *mut f32,
    mut out_v: *mut f32,
    mut in_0: nk_color,
) -> () {
    let mut a: f32 = 0.;
    nk_color_hsva_f(out_h, out_s, out_v, &mut a, in_0);
}
#[no_mangle]
pub unsafe fn nk_color_hsv_fv(mut out: *mut f32, mut in_0: nk_color) -> () {
    let mut a: f32 = 0.;
    nk_color_hsva_f(
        &mut *out.offset(0isize),
        &mut *out.offset(1isize),
        &mut *out.offset(2isize),
        &mut a,
        in_0,
    );
}
#[no_mangle]
pub unsafe fn nk_color_hsva_b(
    mut h: *mut nk_byte,
    mut s: *mut nk_byte,
    mut v: *mut nk_byte,
    mut a: *mut nk_byte,
    mut in_0: nk_color,
) -> () {
    let mut tmp: [libc::c_int; 4] = [0; 4];
    nk_color_hsva_i(
        &mut tmp[0usize],
        &mut tmp[1usize],
        &mut tmp[2usize],
        &mut tmp[3usize],
        in_0,
    );
    *h = tmp[0usize] as nk_byte;
    *s = tmp[1usize] as nk_byte;
    *v = tmp[2usize] as nk_byte;
    *a = tmp[3usize] as nk_byte;
}
#[no_mangle]
pub unsafe fn nk_color_hsva_iv(mut out: *mut libc::c_int, mut in_0: nk_color) -> () {
    nk_color_hsva_i(
        &mut *out.offset(0isize),
        &mut *out.offset(1isize),
        &mut *out.offset(2isize),
        &mut *out.offset(3isize),
        in_0,
    );
}
#[no_mangle]
pub unsafe fn nk_color_hsva_bv(mut out: *mut nk_byte, mut in_0: nk_color) -> () {
    let mut tmp: [libc::c_int; 4] = [0; 4];
    nk_color_hsva_i(
        &mut tmp[0usize],
        &mut tmp[1usize],
        &mut tmp[2usize],
        &mut tmp[3usize],
        in_0,
    );
    *out.offset(0isize) = tmp[0usize] as nk_byte;
    *out.offset(1isize) = tmp[1usize] as nk_byte;
    *out.offset(2isize) = tmp[2usize] as nk_byte;
    *out.offset(3isize) = tmp[3usize] as nk_byte;
}
#[no_mangle]
pub unsafe fn nk_color_hsva_fv(mut out: *mut f32, mut in_0: nk_color) -> () {
    nk_color_hsva_f(
        &mut *out.offset(0isize),
        &mut *out.offset(1isize),
        &mut *out.offset(2isize),
        &mut *out.offset(3isize),
        in_0,
    );
}
#[no_mangle]
pub unsafe fn nk_handle_id(mut id: libc::c_int) -> nk_handle {
    let mut handle: nk_handle = nk_handle {
        ptr: 0 as *mut libc::c_void,
    };
    nk_zero(
        &mut handle as *mut nk_handle as *mut libc::c_void,
        ::std::mem::size_of::<nk_handle>() as libc::c_ulong,
    );
    handle.id = id;
    return handle;
}
#[no_mangle]
pub unsafe fn nk_image_handle(mut handle: nk_handle) -> nk_image {
    let mut s: nk_image = nk_image {
        handle: nk_handle {
            ptr: 0 as *mut libc::c_void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut nk_image as *mut libc::c_void,
        ::std::mem::size_of::<nk_image>() as libc::c_ulong,
    );
    s.handle = handle;
    s.w = 0i32 as libc::c_ushort;
    s.h = 0i32 as libc::c_ushort;
    s.region[0usize] = 0i32 as libc::c_ushort;
    s.region[1usize] = 0i32 as libc::c_ushort;
    s.region[2usize] = 0i32 as libc::c_ushort;
    s.region[3usize] = 0i32 as libc::c_ushort;
    return s;
}
#[no_mangle]
pub unsafe fn nk_image_ptr(mut ptr: *mut libc::c_void) -> nk_image {
    let mut s: nk_image = nk_image {
        handle: nk_handle {
            ptr: 0 as *mut libc::c_void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut nk_image as *mut libc::c_void,
        ::std::mem::size_of::<nk_image>() as libc::c_ulong,
    );
    s.handle.ptr = ptr;
    s.w = 0i32 as libc::c_ushort;
    s.h = 0i32 as libc::c_ushort;
    s.region[0usize] = 0i32 as libc::c_ushort;
    s.region[1usize] = 0i32 as libc::c_ushort;
    s.region[2usize] = 0i32 as libc::c_ushort;
    s.region[3usize] = 0i32 as libc::c_ushort;
    return s;
}
#[no_mangle]
pub unsafe fn nk_image_id(mut id: libc::c_int) -> nk_image {
    let mut s: nk_image = nk_image {
        handle: nk_handle {
            ptr: 0 as *mut libc::c_void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut nk_image as *mut libc::c_void,
        ::std::mem::size_of::<nk_image>() as libc::c_ulong,
    );
    s.handle.id = id;
    s.w = 0i32 as libc::c_ushort;
    s.h = 0i32 as libc::c_ushort;
    s.region[0usize] = 0i32 as libc::c_ushort;
    s.region[1usize] = 0i32 as libc::c_ushort;
    s.region[2usize] = 0i32 as libc::c_ushort;
    s.region[3usize] = 0i32 as libc::c_ushort;
    return s;
}
#[no_mangle]
pub unsafe fn nk_subimage_ptr(
    mut ptr: *mut libc::c_void,
    mut w: libc::c_ushort,
    mut h: libc::c_ushort,
    mut r: nk_rect,
) -> nk_image {
    let mut s: nk_image = nk_image {
        handle: nk_handle {
            ptr: 0 as *mut libc::c_void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut nk_image as *mut libc::c_void,
        ::std::mem::size_of::<nk_image>() as libc::c_ulong,
    );
    s.handle.ptr = ptr;
    s.w = w;
    s.h = h;
    s.region[0usize] = r.x as libc::c_ushort;
    s.region[1usize] = r.y as libc::c_ushort;
    s.region[2usize] = r.w as libc::c_ushort;
    s.region[3usize] = r.h as libc::c_ushort;
    return s;
}
#[no_mangle]
pub unsafe fn nk_subimage_id(
    mut id: libc::c_int,
    mut w: libc::c_ushort,
    mut h: libc::c_ushort,
    mut r: nk_rect,
) -> nk_image {
    let mut s: nk_image = nk_image {
        handle: nk_handle {
            ptr: 0 as *mut libc::c_void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut nk_image as *mut libc::c_void,
        ::std::mem::size_of::<nk_image>() as libc::c_ulong,
    );
    s.handle.id = id;
    s.w = w;
    s.h = h;
    s.region[0usize] = r.x as libc::c_ushort;
    s.region[1usize] = r.y as libc::c_ushort;
    s.region[2usize] = r.w as libc::c_ushort;
    s.region[3usize] = r.h as libc::c_ushort;
    return s;
}
#[no_mangle]
pub unsafe fn nk_subimage_handle(
    mut handle: nk_handle,
    mut w: libc::c_ushort,
    mut h: libc::c_ushort,
    mut r: nk_rect,
) -> nk_image {
    let mut s: nk_image = nk_image {
        handle: nk_handle {
            ptr: 0 as *mut libc::c_void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut nk_image as *mut libc::c_void,
        ::std::mem::size_of::<nk_image>() as libc::c_ulong,
    );
    s.handle = handle;
    s.w = w;
    s.h = h;
    s.region[0usize] = r.x as libc::c_ushort;
    s.region[1usize] = r.y as libc::c_ushort;
    s.region[2usize] = r.w as libc::c_ushort;
    s.region[3usize] = r.h as libc::c_ushort;
    return s;
}
#[no_mangle]
pub unsafe fn nk_vec2i(mut x: libc::c_int, mut y: libc::c_int) -> nk_vec2 {
    let mut ret: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    ret.x = x as f32;
    ret.y = y as f32;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_vec2v(mut v: *const f32) -> nk_vec2 {
    return nk_vec2(*v.offset(0isize), *v.offset(1isize));
}
#[no_mangle]
pub unsafe fn nk_vec2iv(mut v: *const libc::c_int) -> nk_vec2 {
    return nk_vec2i(*v.offset(0isize), *v.offset(1isize));
}
#[no_mangle]
pub unsafe fn nk_get_null_rect() -> nk_rect {
    return nk_null_rect;
}
#[no_mangle]
pub unsafe fn nk_recti(
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut w: libc::c_int,
    mut h: libc::c_int,
) -> nk_rect {
    let mut r: nk_rect = nk_rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    r.x = x as f32;
    r.y = y as f32;
    r.w = w as f32;
    r.h = h as f32;
    return r;
}
#[no_mangle]
pub unsafe fn nk_recta(mut pos: nk_vec2, mut size: nk_vec2) -> nk_rect {
    return nk_rect(pos.x, pos.y, size.x, size.y);
}
#[no_mangle]
pub unsafe fn nk_rectv(mut r: *const f32) -> nk_rect {
    return nk_rect(
        *r.offset(0isize),
        *r.offset(1isize),
        *r.offset(2isize),
        *r.offset(3isize),
    );
}
#[no_mangle]
pub unsafe fn nk_rectiv(mut r: *const libc::c_int) -> nk_rect {
    return nk_recti(
        *r.offset(0isize),
        *r.offset(1isize),
        *r.offset(2isize),
        *r.offset(3isize),
    );
}
#[no_mangle]
pub unsafe fn nk_rect_pos(mut r: nk_rect) -> nk_vec2 {
    let mut ret: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    ret.x = r.x;
    ret.y = r.y;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_rect_size(mut r: nk_rect) -> nk_vec2 {
    let mut ret: nk_vec2 = nk_vec2 { x: 0., y: 0. };
    ret.x = r.w;
    ret.y = r.h;
    return ret;
}
#[no_mangle]
pub unsafe fn nk_stricmp(mut s1: *const libc::c_char, mut s2: *const libc::c_char) -> libc::c_int {
    let mut current_block: u64;
    let mut c1: nk_int = 0;
    let mut c2: nk_int = 0;
    let mut d: nk_int = 0;
    loop {
        let fresh47 = s1;
        s1 = s1.offset(1);
        c1 = *fresh47 as nk_int;
        let fresh48 = s2;
        s2 = s2.offset(1);
        c2 = *fresh48 as nk_int;
        d = c1 - c2;
        if 0 != d {
            if c1 <= 'Z' as i32 && c1 >= 'A' as i32 {
                d += 'a' as i32 - 'A' as i32;
                if 0 == d {
                    current_block = 9386390421034826751;
                } else {
                    current_block = 12675440807659640239;
                }
            } else {
                current_block = 12675440807659640239;
            }
            match current_block {
                9386390421034826751 => {}
                _ => {
                    if c2 <= 'Z' as i32 && c2 >= 'A' as i32 {
                        d -= 'a' as i32 - 'A' as i32;
                        if 0 == d {
                            current_block = 9386390421034826751;
                        } else {
                            current_block = 820271813250567934;
                        }
                    } else {
                        current_block = 820271813250567934;
                    }
                    match current_block {
                        9386390421034826751 => {}
                        _ => return (((d >= 0i32) as libc::c_int) << 1i32) - 1i32,
                    }
                }
            }
        }
        if !(0 != c1) {
            break;
        }
    }
    return 0i32;
}
#[no_mangle]
pub unsafe fn nk_strfilter(
    mut text: *const libc::c_char,
    mut regexp: *const libc::c_char,
) -> libc::c_int {
    /*
    c    matches any literal character c
    .    matches any single character
    ^    matches the beginning of the input string
    $    matches the end of the input string
    *    matches zero or more occurrences of the previous character*/
    if *regexp.offset(0isize) as libc::c_int == '^' as i32 {
        return nk_str_match_here(regexp.offset(1isize), text);
    } else {
        loop {
            /* must look even if string is empty */
            if 0 != nk_str_match_here(regexp, text) {
                return 1i32;
            } else {
                let fresh49 = text;
                text = text.offset(1);
                if !(*fresh49 as libc::c_int != '\u{0}' as i32) {
                    break;
                }
            }
        }
        return 0i32;
    };
}
unsafe fn nk_str_match_here(
    mut regexp: *const libc::c_char,
    mut text: *const libc::c_char,
) -> libc::c_int {
    if *regexp.offset(0isize) as libc::c_int == '\u{0}' as i32 {
        return 1i32;
    } else if *regexp.offset(1isize) as libc::c_int == '*' as i32 {
        return nk_str_match_star(
            *regexp.offset(0isize) as libc::c_int,
            regexp.offset(2isize),
            text,
        );
    } else if *regexp.offset(0isize) as libc::c_int == '$' as i32
        && *regexp.offset(1isize) as libc::c_int == '\u{0}' as i32
    {
        return (*text as libc::c_int == '\u{0}' as i32) as libc::c_int;
    } else if *text as libc::c_int != '\u{0}' as i32
        && (*regexp.offset(0isize) as libc::c_int == '.' as i32
            || *regexp.offset(0isize) as libc::c_int == *text as libc::c_int)
    {
        return nk_str_match_here(regexp.offset(1isize), text.offset(1isize));
    } else {
        return 0i32;
    };
}
unsafe fn nk_str_match_star(
    mut c: libc::c_int,
    mut regexp: *const libc::c_char,
    mut text: *const libc::c_char,
) -> libc::c_int {
    loop {
        /* a '* matches zero or more instances */
        if 0 != nk_str_match_here(regexp, text) {
            return 1i32;
        } else if !(*text as libc::c_int != '\u{0}' as i32 && {
            let fresh50 = text;
            text = text.offset(1);
            *fresh50 as libc::c_int == c || c == '.' as i32
        }) {
            break;
        }
    }
    return 0i32;
}
#[no_mangle]
pub unsafe fn nk_strmatch_fuzzy_string(
    mut str: *const libc::c_char,
    mut pattern: *const libc::c_char,
    mut out_score: *mut libc::c_int,
) -> libc::c_int {
    return nk_strmatch_fuzzy_text(str, nk_strlen(str), pattern, out_score);
}
#[no_mangle]
pub unsafe fn nk_strmatch_fuzzy_text(
    mut str: *const libc::c_char,
    mut str_len: libc::c_int,
    mut pattern: *const libc::c_char,
    mut out_score: *mut libc::c_int,
) -> libc::c_int {
    /* Returns true if each character in pattern is found sequentially within str
     * if found then out_score is also set. Score value has no intrinsic meaning.
     * Range varies with pattern. Can only compare scores with same search pattern. */
    /* bonus for adjacent matches */
    /* bonus if match occurs after a separator */
    /* bonus if match is uppercase and prev is lower */
    /* penalty applied for every letter in str before the first match */
    /* maximum penalty for leading letters */
    /* penalty for every letter that doesn't matter */
    /* loop variables */
    let mut score: libc::c_int = 0i32;
    let mut pattern_iter: *const libc::c_char = pattern;
    let mut str_iter: libc::c_int = 0i32;
    let mut prev_matched: libc::c_int = nk_false as libc::c_int;
    let mut prev_lower: libc::c_int = nk_false as libc::c_int;
    /* true so if first letter match gets separator bonus*/
    let mut prev_separator: libc::c_int = nk_true as libc::c_int;
    /* use "best" matched letter if multiple string letters match the pattern */
    let mut best_letter: *const libc::c_char = 0 as *const libc::c_char;
    let mut best_letter_score: libc::c_int = 0i32;
    /* loop over strings */
    if str.is_null() || 0 == str_len || pattern.is_null() {
        return 0i32;
    } else {
        while str_iter < str_len {
            let pattern_letter: libc::c_char = *pattern_iter;
            let str_letter: libc::c_char = *str.offset(str_iter as isize);
            let mut next_match: libc::c_int = (*pattern_iter as libc::c_int != '\u{0}' as i32
                && nk_to_lower(pattern_letter as libc::c_int)
                    == nk_to_lower(str_letter as libc::c_int))
                as libc::c_int;
            let mut rematch: libc::c_int = (!best_letter.is_null()
                && nk_to_upper(*best_letter as libc::c_int)
                    == nk_to_upper(str_letter as libc::c_int))
                as libc::c_int;
            let mut advanced: libc::c_int =
                (0 != next_match && !best_letter.is_null()) as libc::c_int;
            let mut pattern_repeat: libc::c_int = (!best_letter.is_null()
                && *pattern_iter as libc::c_int != '\u{0}' as i32)
                as libc::c_int;
            pattern_repeat = (0 != pattern_repeat
                && nk_to_lower(*best_letter as libc::c_int)
                    == nk_to_lower(pattern_letter as libc::c_int))
                as libc::c_int;
            if 0 != advanced || 0 != pattern_repeat {
                score += best_letter_score;
                best_letter = 0 as *const libc::c_char;
                best_letter_score = 0i32
            }
            if 0 != next_match || 0 != rematch {
                let mut new_score: libc::c_int = 0i32;
                /* Apply penalty for each letter before the first pattern match */
                if pattern_iter == pattern {
                    let mut count: libc::c_int =
                        str.ptr_offset_to(&*str.offset(str_iter as isize) as *const libc::c_char)
                            .expect("bad offset_to") as libc::c_long
                            as libc::c_int;
                    let mut penalty: libc::c_int = -3i32 * count;
                    if penalty < -9i32 {
                        penalty = -9i32
                    }
                    score += penalty
                }
                /* apply bonus for consecutive bonuses */
                if 0 != prev_matched {
                    new_score += 5i32
                }
                /* apply bonus for matches after a separator */
                if 0 != prev_separator {
                    new_score += 10i32
                }
                /* apply bonus across camel case boundaries */
                if 0 != prev_lower && 0 != nk_is_upper(str_letter as libc::c_int) {
                    new_score += 10i32
                }
                /* update pattern iter IFF the next pattern letter was matched */
                if 0 != next_match {
                    pattern_iter = pattern_iter.offset(1isize)
                }
                /* update best letter in str which may be for a "next" letter or a rematch */
                if new_score >= best_letter_score {
                    /* apply penalty for now skipped letter */
                    if !best_letter.is_null() {
                        score += -1i32
                    }
                    best_letter = &*str.offset(str_iter as isize) as *const libc::c_char;
                    best_letter_score = new_score
                }
                prev_matched = nk_true as libc::c_int
            } else {
                score += -1i32;
                prev_matched = nk_false as libc::c_int
            }
            /* separators should be more easily defined */
            prev_lower = (nk_is_lower(str_letter as libc::c_int) != 0i32) as libc::c_int;
            prev_separator = (str_letter as libc::c_int == '_' as i32
                || str_letter as libc::c_int == ' ' as i32)
                as libc::c_int;
            str_iter += 1
        }
        /* apply score for last match */
        if !best_letter.is_null() {
            score += best_letter_score
        }
        /* did not match full pattern */
        if *pattern_iter as libc::c_int != '\u{0}' as i32 {
            return nk_false as libc::c_int;
        } else {
            if !out_score.is_null() {
                *out_score = score
            }
            return nk_true as libc::c_int;
        }
    };
}
unsafe fn nk_is_lower(mut c: libc::c_int) -> libc::c_int {
    return (c >= 'a' as i32 && c <= 'z' as i32 || c >= 224i32 && c <= 255i32) as libc::c_int;
}
unsafe fn nk_to_lower(mut c: libc::c_int) -> libc::c_int {
    return if c >= 'A' as i32 && c <= 'Z' as i32 {
        c - ('a' as i32 + 'A' as i32)
    } else {
        c
    };
}
unsafe fn nk_is_upper(mut c: libc::c_int) -> libc::c_int {
    return (c >= 'A' as i32 && c <= 'Z' as i32 || c >= 192i32 && c <= 223i32) as libc::c_int;
}
unsafe fn nk_to_upper(mut c: libc::c_int) -> libc::c_int {
    return if c >= 'a' as i32 && c <= 'z' as i32 {
        c - ('a' as i32 - 'A' as i32)
    } else {
        c
    };
}
#[no_mangle]
pub unsafe fn nk_utf_at(
    mut buffer: *const libc::c_char,
    mut length: libc::c_int,
    mut index: libc::c_int,
    mut unicode: *mut nk_rune,
    mut len: *mut libc::c_int,
) -> *const libc::c_char {
    let mut i: libc::c_int = 0i32;
    let mut src_len: libc::c_int = 0i32;
    let mut glyph_len: libc::c_int = 0i32;
    let mut text: *const libc::c_char = 0 as *const libc::c_char;
    let mut text_len: libc::c_int = 0;
    if buffer.is_null() || unicode.is_null() || len.is_null() {
        return 0 as *const libc::c_char;
    } else if index < 0i32 {
        *unicode = 65533i32 as nk_rune;
        *len = 0i32;
        return 0 as *const libc::c_char;
    } else {
        text = buffer;
        text_len = length;
        glyph_len = nk_utf_decode(text, unicode, text_len);
        while 0 != glyph_len {
            if i == index {
                *len = glyph_len;
                break;
            } else {
                i += 1;
                src_len = src_len + glyph_len;
                glyph_len =
                    nk_utf_decode(text.offset(src_len as isize), unicode, text_len - src_len)
            }
        }
        if i != index {
            return 0 as *const libc::c_char;
        } else {
            return buffer.offset(src_len as isize);
        }
    };
}
#[no_mangle]
pub unsafe fn nk_font_default_glyph_ranges() -> *const nk_rune {
    static mut ranges: [nk_rune; 3] =
        unsafe { [32i32 as nk_rune, 255i32 as nk_rune, 0i32 as nk_rune] };
    return ranges.as_ptr();
}
#[no_mangle]
pub unsafe fn nk_font_chinese_glyph_ranges() -> *const nk_rune {
    static mut ranges: [nk_rune; 11] = unsafe {
        [
            32i32 as nk_rune,
            255i32 as nk_rune,
            12288i32 as nk_rune,
            12543i32 as nk_rune,
            12784i32 as nk_rune,
            12799i32 as nk_rune,
            65280i32 as nk_rune,
            65519i32 as nk_rune,
            19968i32 as nk_rune,
            40879i32 as nk_rune,
            0i32 as nk_rune,
        ]
    };
    return ranges.as_ptr();
}
#[no_mangle]
pub unsafe fn nk_font_cyrillic_glyph_ranges() -> *const nk_rune {
    static mut ranges: [nk_rune; 9] = unsafe {
        [
            32i32 as nk_rune,
            255i32 as nk_rune,
            1024i32 as nk_rune,
            1327i32 as nk_rune,
            11744i32 as nk_rune,
            11775i32 as nk_rune,
            42560i32 as nk_rune,
            42655i32 as nk_rune,
            0i32 as nk_rune,
        ]
    };
    return ranges.as_ptr();
}
#[no_mangle]
pub unsafe fn nk_font_korean_glyph_ranges() -> *const nk_rune {
    static mut ranges: [nk_rune; 7] = unsafe {
        [
            32i32 as nk_rune,
            255i32 as nk_rune,
            12593i32 as nk_rune,
            12643i32 as nk_rune,
            44032i32 as nk_rune,
            55197i32 as nk_rune,
            0i32 as nk_rune,
        ]
    };
    return ranges.as_ptr();
}
#[no_mangle]
pub unsafe fn nk_font_atlas_init_default(mut atlas: *mut nk_font_atlas) -> () {
    if atlas.is_null() {
        return;
    } else {
        nk_zero(
            atlas as *mut libc::c_void,
            ::std::mem::size_of::<nk_font_atlas>() as libc::c_ulong,
        );
        (*atlas).temporary.userdata.ptr = 0 as *mut libc::c_void;
        (*atlas).temporary.alloc = Some(nk_malloc);
        (*atlas).temporary.free = Some(nk_mfree);
        (*atlas).permanent.userdata.ptr = 0 as *mut libc::c_void;
        (*atlas).permanent.alloc = Some(nk_malloc);
        (*atlas).permanent.free = Some(nk_mfree);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_font_atlas_init(
    mut atlas: *mut nk_font_atlas,
    mut alloc: *mut nk_allocator,
) -> () {
    if atlas.is_null() || alloc.is_null() {
        return;
    } else {
        nk_zero(
            atlas as *mut libc::c_void,
            ::std::mem::size_of::<nk_font_atlas>() as libc::c_ulong,
        );
        (*atlas).permanent = *alloc;
        (*atlas).temporary = *alloc;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_font_atlas_init_custom(
    mut atlas: *mut nk_font_atlas,
    mut permanent: *mut nk_allocator,
    mut temporary: *mut nk_allocator,
) -> () {
    if atlas.is_null() || permanent.is_null() || temporary.is_null() {
        return;
    } else {
        nk_zero(
            atlas as *mut libc::c_void,
            ::std::mem::size_of::<nk_font_atlas>() as libc::c_ulong,
        );
        (*atlas).permanent = *permanent;
        (*atlas).temporary = *temporary;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_font_atlas_begin(mut atlas: *mut nk_font_atlas) -> () {
    if atlas.is_null()
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
    {
        return;
    } else {
        if !(*atlas).glyphs.is_null() {
            (*atlas).permanent.free.expect("non-null function pointer")(
                (*atlas).permanent.userdata,
                (*atlas).glyphs as *mut libc::c_void,
            );
            (*atlas).glyphs = 0 as *mut nk_font_glyph
        }
        if !(*atlas).pixel.is_null() {
            (*atlas).permanent.free.expect("non-null function pointer")(
                (*atlas).permanent.userdata,
                (*atlas).pixel,
            );
            (*atlas).pixel = 0 as *mut libc::c_void
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_font_config(mut pixel_height: f32) -> nk_font_config {
    let mut cfg: nk_font_config = nk_font_config {
        next: 0 as *mut nk_font_config,
        ttf_blob: 0 as *mut libc::c_void,
        ttf_size: 0,
        ttf_data_owned_by_atlas: 0,
        merge_mode: 0,
        pixel_snap: 0,
        oversample_v: 0,
        oversample_h: 0,
        padding: [0; 3],
        size: 0.,
        coord_type: NK_COORD_UV,
        spacing: nk_vec2 { x: 0., y: 0. },
        range: 0 as *const nk_rune,
        font: 0 as *mut nk_baked_font,
        fallback_glyph: 0,
        n: 0 as *mut nk_font_config,
        p: 0 as *mut nk_font_config,
    };
    nk_zero(
        &mut cfg as *mut nk_font_config as *mut libc::c_void,
        ::std::mem::size_of::<nk_font_config>() as libc::c_ulong,
    );
    cfg.ttf_blob = 0 as *mut libc::c_void;
    cfg.ttf_size = 0i32 as nk_size;
    cfg.ttf_data_owned_by_atlas = 0i32 as libc::c_uchar;
    cfg.size = pixel_height;
    cfg.oversample_h = 3i32 as libc::c_uchar;
    cfg.oversample_v = 1i32 as libc::c_uchar;
    cfg.pixel_snap = 0i32 as libc::c_uchar;
    cfg.coord_type = NK_COORD_UV;
    cfg.spacing = nk_vec2(0i32 as f32, 0i32 as f32);
    cfg.range = nk_font_default_glyph_ranges();
    cfg.merge_mode = 0i32 as libc::c_uchar;
    cfg.fallback_glyph = '?' as i32 as nk_rune;
    cfg.font = 0 as *mut nk_baked_font;
    cfg.n = 0 as *mut nk_font_config;
    return cfg;
}
#[no_mangle]
pub unsafe fn nk_font_atlas_add(
    mut atlas: *mut nk_font_atlas,
    mut config: *const nk_font_config,
) -> *mut nk_font {
    let mut c: *mut nk_font_config = 0 as *mut nk_font_config;
    let mut f: *mut nk_font = 0 as *mut nk_font;
    let mut font: *mut nk_font = 0 as *mut nk_font;
    let mut cfg: *mut nk_font_config = 0 as *mut nk_font_config;
    if atlas.is_null()
        || config.is_null()
        || (*config).ttf_blob.is_null()
        || 0 == (*config).ttf_size
        || (*config).size <= 0.0f32
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
    {
        return 0 as *mut nk_font;
    } else {
        /* allocate font config  */
        cfg = (*atlas).permanent.alloc.expect("non-null function pointer")(
            (*atlas).permanent.userdata,
            0 as *mut libc::c_void,
            ::std::mem::size_of::<nk_font_config>() as libc::c_ulong,
        ) as *mut nk_font_config;
        nk_memcopy(
            cfg as *mut libc::c_void,
            config as *const libc::c_void,
            ::std::mem::size_of::<nk_font_config>() as libc::c_ulong,
        );
        (*cfg).n = cfg;
        (*cfg).p = cfg;
        if 0 == (*config).merge_mode {
            /* insert font config into list */
            if (*atlas).config.is_null() {
                (*atlas).config = cfg;
                (*cfg).next = 0 as *mut nk_font_config
            } else {
                let mut i: *mut nk_font_config = (*atlas).config;
                while !(*i).next.is_null() {
                    i = (*i).next
                }
                (*i).next = cfg;
                (*cfg).next = 0 as *mut nk_font_config
            }
            /* allocate new font */
            font = (*atlas).permanent.alloc.expect("non-null function pointer")(
                (*atlas).permanent.userdata,
                0 as *mut libc::c_void,
                ::std::mem::size_of::<nk_font>() as libc::c_ulong,
            ) as *mut nk_font;
            nk_zero(
                font as *mut libc::c_void,
                ::std::mem::size_of::<nk_font>() as libc::c_ulong,
            );
            if font.is_null() {
                return 0 as *mut nk_font;
            } else {
                (*font).config = cfg;
                /* insert font into list */
                if (*atlas).fonts.is_null() {
                    (*atlas).fonts = font;
                    (*font).next = 0 as *mut nk_font
                } else {
                    let mut i_0: *mut nk_font = (*atlas).fonts;
                    while !(*i_0).next.is_null() {
                        i_0 = (*i_0).next
                    }
                    (*i_0).next = font;
                    (*font).next = 0 as *mut nk_font
                }
                (*cfg).font = &mut (*font).info as *mut nk_baked_font
            }
        } else {
            /* extend previously added font */
            f = 0 as *mut nk_font;
            c = 0 as *mut nk_font_config;
            f = (*atlas).fonts;
            c = (*f).config;
            (*cfg).font = &mut (*f).info as *mut nk_baked_font;
            (*cfg).n = c;
            (*cfg).p = (*c).p;
            (*(*c).p).n = cfg;
            (*c).p = cfg
        }
        /* create own copy of .TTF font blob */
        if 0 == (*config).ttf_data_owned_by_atlas {
            (*cfg).ttf_blob = (*atlas).permanent.alloc.expect("non-null function pointer")(
                (*atlas).permanent.userdata,
                0 as *mut libc::c_void,
                (*cfg).ttf_size,
            );
            if (*cfg).ttf_blob.is_null() {
                (*atlas).font_num += 1;
                return 0 as *mut nk_font;
            } else {
                nk_memcopy((*cfg).ttf_blob, (*config).ttf_blob, (*cfg).ttf_size);
                (*cfg).ttf_data_owned_by_atlas = 1i32 as libc::c_uchar
            }
        }
        (*atlas).font_num += 1;
        return font;
    };
}
#[no_mangle]
pub unsafe fn nk_font_atlas_add_default(
    mut atlas: *mut nk_font_atlas,
    mut pixel_height: f32,
    mut config: *const nk_font_config,
) -> *mut nk_font {
    return nk_font_atlas_add_compressed_base85(
        atlas,
        nk_proggy_clean_ttf_compressed_data_base85.as_ptr(),
        pixel_height,
        config,
    );
}
static mut nk_proggy_clean_ttf_compressed_data_base85: [libc::c_char; 11981] = unsafe {
    [
        55, 93, 41, 35, 35, 35, 35, 35, 35, 35, 104, 86, 48, 113, 115, 39, 47, 35, 35, 35, 91, 41,
        44, 35, 35, 47, 108, 58, 36, 35, 81, 54, 62, 35, 35, 53, 91, 110, 52, 50, 62, 99, 45, 84,
        72, 96, 45, 62, 62, 35, 47, 101, 62, 49, 49, 78, 78, 86, 61, 66, 118, 40, 42, 58, 46, 70,
        63, 117, 117, 35, 40, 103, 82, 85, 46, 111, 48, 88, 71, 72, 96, 36, 118, 104, 76, 71, 49,
        104, 120, 116, 57, 63, 87, 96, 35, 44, 53, 76, 115, 67, 112, 35, 45, 105, 62, 46, 114, 36,
        60, 36, 54, 112, 68, 62, 76, 98, 39, 59, 57, 67, 114, 99, 54, 116, 103, 88, 109, 75, 86,
        101, 85, 50, 99, 68, 52, 69, 111, 51, 82, 47, 50, 42, 62, 93, 98, 40, 77, 67, 59, 36, 106,
        80, 102, 89, 46, 59, 104, 94, 96, 73, 87, 77, 57, 60, 76, 104, 50, 84, 108, 83, 43, 102,
        45, 115, 36, 111, 54, 81, 60, 66, 87, 72, 96, 89, 105, 85, 46, 120, 102, 76, 113, 36, 78,
        59, 36, 48, 105, 82, 47, 71, 88, 58, 85, 40, 106, 99, 87, 50, 112, 47, 87, 42, 113, 63, 45,
        113, 109, 110, 85, 67, 73, 59, 106, 72, 83, 65, 105, 70, 87, 77, 46, 82, 42, 107, 85, 64,
        67, 61, 71, 72, 63, 97, 57, 119, 112, 56, 102, 36, 101, 46, 45, 52, 94, 81, 103, 49, 41,
        81, 45, 71, 76, 40, 108, 102, 40, 114, 47, 55, 71, 114, 82, 103, 119, 86, 37, 77, 83, 61,
        67, 35, 96, 56, 78, 68, 62, 81, 111, 35, 116, 39, 88, 35, 40, 118, 35, 89, 57, 119, 48, 35,
        49, 68, 36, 67, 73, 102, 59, 87, 39, 35, 112, 87, 85, 80, 88, 79, 117, 120, 88, 117, 85,
        40, 72, 57, 77, 40, 49, 60, 113, 45, 85, 69, 51, 49, 35, 94, 45, 86, 39, 56, 73, 82, 85,
        111, 55, 81, 102, 46, 47, 76, 62, 61, 75, 101, 36, 36, 39, 53, 70, 37, 41, 93, 48, 94, 35,
        48, 88, 64, 85, 46, 97, 60, 114, 58, 81, 76, 116, 70, 115, 76, 99, 76, 54, 35, 35, 108, 79,
        106, 41, 35, 46, 89, 53, 60, 45, 82, 38, 75, 103, 76, 119, 113, 74, 102, 76, 103, 78, 38,
        59, 81, 63, 103, 73, 94, 35, 68, 89, 50, 117, 76, 105, 64, 94, 114, 77, 108, 57, 116, 61,
        99, 87, 113, 54, 35, 35, 119, 101, 103, 62, 36, 70, 66, 106, 86, 81, 84, 83, 68, 103, 69,
        75, 110, 73, 83, 55, 69, 77, 57, 62, 90, 89, 57, 119, 48, 35, 76, 59, 62, 62, 35, 77, 120,
        38, 52, 77, 118, 116, 47, 47, 76, 91, 77, 107, 65, 35, 87, 64, 108, 75, 46, 78, 39, 91, 48,
        35, 55, 82, 76, 95, 38, 35, 119, 43, 70, 37, 72, 116, 71, 57, 77, 35, 88, 76, 96, 78, 38,
        46, 44, 71, 77, 52, 80, 103, 59, 45, 60, 110, 76, 69, 78, 104, 118, 120, 62, 45, 86, 115,
        77, 46, 77, 48, 114, 74, 102, 76, 72, 50, 101, 84, 77, 96, 42, 111, 74, 77, 72, 82, 67, 96,
        78, 107, 102, 105, 109, 77, 50, 74, 44, 87, 45, 106, 88, 83, 58, 41, 114, 48, 119, 75, 35,
        64, 70, 103, 101, 36, 85, 62, 96, 119, 39, 78, 55, 71, 35, 36, 35, 102, 66, 35, 36, 69, 94,
        36, 35, 58, 57, 58, 104, 107, 43, 101, 79, 101, 45, 45, 54, 120, 41, 70, 55, 42, 69, 37,
        63, 55, 54, 37, 94, 71, 77, 72, 101, 80, 87, 45, 90, 53, 108, 39, 38, 71, 105, 70, 35, 36,
        57, 53, 54, 58, 114, 83, 63, 100, 65, 35, 102, 105, 75, 58, 41, 89, 114, 43, 96, 38, 35,
        48, 106, 64, 39, 68, 98, 71, 38, 35, 94, 36, 80, 71, 46, 76, 108, 43, 68, 78, 97, 60, 88,
        67, 77, 75, 69, 86, 42, 78, 41, 76, 78, 47, 78, 42, 98, 61, 37, 81, 54, 112, 105, 97, 45,
        88, 103, 56, 73, 36, 60, 77, 82, 38, 44, 86, 100, 74, 101, 36, 60, 40, 55, 71, 59, 67, 107,
        108, 39, 38, 104, 70, 59, 59, 36, 60, 95, 61, 88, 40, 98, 46, 82, 83, 37, 37, 41, 35, 35,
        35, 77, 80, 66, 117, 117, 69, 49, 86, 58, 118, 38, 99, 88, 38, 35, 50, 109, 35, 40, 38, 99,
        86, 93, 96, 107, 57, 79, 104, 76, 77, 98, 110, 37, 115, 36, 71, 50, 44, 66, 36, 66, 102,
        68, 51, 88, 42, 115, 112, 53, 35, 108, 44, 36, 82, 35, 93, 120, 95, 88, 49, 120, 75, 88,
        37, 98, 53, 85, 42, 91, 114, 53, 105, 77, 102, 85, 111, 57, 85, 96, 78, 57, 57, 104, 71,
        41, 116, 109, 43, 47, 85, 115, 57, 112, 71, 41, 88, 80, 117, 96, 60, 48, 115, 45, 41, 87,
        84, 116, 40, 103, 67, 82, 120, 73, 103, 40, 37, 54, 115, 102, 104, 61, 107, 116, 77, 75,
        110, 51, 106, 41, 60, 54, 60, 98, 53, 83, 107, 95, 47, 48, 40, 94, 93, 65, 97, 78, 35, 40,
        112, 47, 76, 62, 38, 86, 90, 62, 49, 105, 37, 104, 49, 83, 57, 117, 53, 111, 64, 89, 97,
        97, 87, 36, 101, 43, 98, 60, 84, 87, 70, 110, 47, 90, 58, 79, 104, 40, 67, 120, 50, 36,
        108, 78, 69, 111, 78, 94, 101, 41, 35, 67, 70, 89, 64, 64, 73, 59, 66, 79, 81, 42, 115, 82,
        119, 90, 116, 90, 120, 82, 99, 85, 55, 117, 87, 54, 67, 88, 111, 119, 48, 105, 40, 63, 36,
        81, 91, 99, 106, 79, 100, 91, 80, 52, 100, 41, 93, 62, 82, 79, 80, 79, 112, 120, 84, 79,
        55, 83, 116, 119, 105, 49, 58, 58, 105, 66, 49, 113, 41, 67, 95, 61, 100, 86, 50, 54, 74,
        59, 50, 44, 93, 55, 111, 112, 36, 93, 117, 81, 114, 64, 95, 86, 55, 36, 113, 94, 37, 108,
        81, 119, 116, 117, 72, 89, 93, 61, 68, 88, 44, 110, 51, 76, 35, 48, 80, 72, 68, 79, 52,
        102, 57, 62, 100, 67, 64, 79, 62, 72, 66, 117, 75, 80, 112, 80, 42, 69, 44, 78, 43, 98, 51,
        76, 35, 108, 112, 82, 47, 77, 114, 84, 69, 72, 46, 73, 65, 81, 107, 46, 97, 62, 68, 91, 46,
        101, 59, 109, 99, 46, 120, 93, 73, 112, 46, 80, 72, 94, 39, 47, 97, 113, 85, 79, 47, 36,
        49, 87, 120, 76, 111, 87, 48, 91, 105, 76, 65, 60, 81, 84, 59, 53, 72, 75, 68, 43, 64, 113,
        81, 39, 78, 81, 40, 51, 95, 80, 76, 104, 69, 52, 56, 82, 46, 113, 65, 80, 83, 119, 81, 48,
        47, 87, 75, 63, 90, 44, 91, 120, 63, 45, 74, 59, 106, 81, 84, 87, 65, 48, 88, 64, 75, 74,
        40, 95, 89, 56, 78, 45, 58, 47, 77, 55, 52, 58, 47, 45, 90, 112, 75, 114, 85, 115, 115, 63,
        100, 35, 100, 90, 113, 93, 68, 65, 98, 107, 85, 42, 74, 113, 107, 76, 43, 110, 119, 88, 64,
        64, 52, 55, 96, 53, 62, 119, 61, 52, 104, 40, 57, 46, 96, 71, 67, 82, 85, 120, 72, 80, 101,
        82, 96, 53, 77, 106, 111, 108, 40, 100, 85, 87, 120, 90, 97, 40, 62, 83, 84, 114, 80, 107,
        114, 74, 105, 87, 120, 96, 53, 85, 55, 70, 35, 46, 103, 42, 106, 114, 111, 104, 71, 103,
        96, 99, 103, 58, 108, 83, 84, 118, 69, 89, 47, 69, 86, 95, 55, 72, 52, 81, 57, 91, 90, 37,
        99, 110, 118, 59, 74, 81, 89, 90, 53, 113, 46, 108, 55, 90, 101, 97, 115, 58, 72, 79, 73,
        90, 79, 66, 63, 71, 60, 78, 97, 108, 100, 36, 113, 115, 93, 64, 93, 76, 60, 74, 55, 98, 82,
        42, 62, 103, 118, 58, 91, 55, 77, 73, 50, 107, 41, 46, 39, 50, 40, 36, 53, 70, 78, 80, 38,
        69, 81, 40, 44, 41, 85, 93, 87, 93, 43, 102, 104, 49, 56, 46, 118, 115, 97, 105, 48, 48,
        41, 59, 68, 51, 64, 52, 107, 117, 53, 80, 63, 68, 80, 56, 97, 74, 116, 43, 59, 113, 85, 77,
        93, 61, 43, 98, 39, 56, 64, 59, 109, 86, 105, 66, 75, 120, 48, 68, 69, 91, 45, 97, 117, 71,
        108, 56, 58, 80, 74, 38, 68, 106, 43, 77, 54, 79, 67, 93, 79, 94, 40, 40, 35, 35, 93, 96,
        48, 105, 41, 100, 114, 84, 59, 45, 55, 88, 96, 61, 45, 72, 51, 91, 105, 103, 85, 110, 80,
        71, 45, 78, 90, 108, 111, 46, 35, 107, 64, 104, 35, 61, 79, 114, 107, 36, 109, 62, 97, 62,
        36, 45, 63, 84, 109, 36, 85, 86, 40, 63, 35, 80, 54, 89, 89, 35, 39, 47, 35, 35, 35, 120,
        101, 55, 113, 46, 55, 51, 114, 73, 51, 42, 112, 80, 47, 36, 49, 62, 115, 57, 41, 87, 44,
        74, 114, 77, 55, 83, 78, 93, 39, 47, 52, 67, 35, 118, 36, 85, 96, 48, 35, 86, 46, 91, 48,
        62, 120, 81, 115, 72, 36, 102, 69, 109, 80, 77, 103, 89, 50, 117, 55, 75, 104, 40, 71, 37,
        115, 105, 73, 102, 76, 83, 111, 83, 43, 77, 75, 50, 101, 84, 77, 36, 61, 53, 44, 77, 56,
        112, 96, 65, 46, 59, 95, 82, 37, 35, 117, 91, 75, 35, 36, 120, 52, 65, 71, 56, 46, 107, 75,
        47, 72, 83, 66, 61, 61, 45, 39, 73, 101, 47, 81, 84, 116, 71, 63, 45, 46, 42, 94, 78, 45,
        52, 66, 47, 90, 77, 95, 51, 89, 108, 81, 67, 55, 40, 112, 55, 113, 41, 38, 93, 40, 96, 54,
        95, 99, 41, 36, 47, 42, 74, 76, 40, 76, 45, 94, 40, 93, 36, 119, 73, 77, 96, 100, 80, 116,
        79, 100, 71, 65, 44, 85, 51, 58, 119, 50, 77, 45, 48, 60, 113, 45, 93, 76, 95, 63, 94, 41,
        49, 118, 119, 39, 46, 44, 77, 82, 115, 113, 86, 114, 46, 76, 59, 97, 78, 38, 35, 47, 69,
        103, 74, 41, 80, 66, 99, 91, 45, 102, 62, 43, 87, 111, 109, 88, 50, 117, 55, 108, 113, 77,
        50, 105, 69, 117, 109, 77, 84, 99, 115, 70, 63, 45, 97, 84, 61, 90, 45, 57, 55, 85, 69,
        110, 88, 103, 108, 69, 110, 49, 75, 45, 98, 110, 69, 79, 96, 103, 117, 70, 116, 40, 99, 37,
        61, 59, 65, 109, 95, 81, 115, 64, 106, 76, 111, 111, 73, 38, 78, 88, 59, 93, 48, 35, 106,
        52, 35, 70, 49, 52, 59, 103, 108, 56, 45, 71, 81, 112, 103, 119, 104, 114, 113, 56, 39, 61,
        108, 95, 102, 45, 98, 52, 57, 39, 85, 79, 113, 107, 76, 117, 55, 45, 35, 35, 111, 68, 89,
        50, 76, 40, 116, 101, 43, 77, 99, 104, 38, 103, 76, 89, 116, 74, 44, 77, 69, 116, 74, 102,
        76, 104, 39, 120, 39, 77, 61, 36, 67, 83, 45, 90, 90, 37, 80, 93, 56, 98, 90, 62, 35, 83,
        63, 89, 89, 35, 37, 81, 38, 113, 39, 51, 94, 70, 119, 38, 63, 68, 41, 85, 68, 78, 114, 111,
        99, 77, 51, 65, 55, 54, 47, 47, 111, 76, 63, 35, 104, 55, 103, 108, 56, 53, 91, 113, 87,
        47, 78, 68, 79, 107, 37, 49, 54, 105, 106, 59, 43, 58, 49, 97, 39, 105, 78, 73, 100, 98,
        45, 111, 117, 56, 46, 80, 42, 119, 44, 118, 53, 35, 69, 73, 36, 84, 87, 83, 62, 80, 111,
        116, 45, 82, 42, 72, 39, 45, 83, 69, 112, 65, 58, 103, 41, 102, 43, 79, 36, 37, 37, 96,
        107, 65, 35, 71, 61, 56, 82, 77, 109, 71, 49, 38, 79, 96, 62, 116, 111, 56, 98, 67, 93, 84,
        38, 36, 44, 110, 46, 76, 111, 79, 62, 50, 57, 115, 112, 51, 100, 116, 45, 53, 50, 85, 37,
        86, 77, 35, 113, 55, 39, 68, 72, 112, 103, 43, 35, 90, 57, 37, 72, 91, 75, 60, 76, 37, 97,
        50, 69, 45, 103, 114, 87, 86, 77, 51, 64, 50, 61, 45, 107, 50, 50, 116, 76, 93, 52, 36, 35,
        35, 54, 87, 101, 39, 56, 85, 74, 67, 75, 69, 91, 100, 95, 61, 37, 119, 73, 59, 39, 54, 88,
        45, 71, 115, 76, 88, 52, 106, 94, 83, 103, 74, 36, 35, 35, 82, 42, 119, 44, 118, 80, 51,
        119, 75, 35, 105, 105, 87, 38, 35, 42, 104, 94, 68, 38, 82, 63, 106, 112, 55, 43, 47, 117,
        38, 35, 40, 65, 80, 35, 35, 88, 85, 56, 99, 36, 102, 83, 89, 87, 45, 74, 57, 53, 95, 45,
        68, 112, 91, 103, 57, 119, 99, 79, 38, 35, 77, 45, 104, 49, 79, 99, 74, 108, 99, 45, 42,
        118, 112, 119, 48, 120, 85, 88, 38, 35, 79, 81, 70, 75, 78, 88, 64, 81, 73, 39, 73, 111,
        80, 112, 55, 110, 98, 44, 81, 85, 47, 47, 77, 81, 38, 90, 68, 107, 75, 80, 41, 88, 60, 87,
        83, 86, 76, 40, 54, 56, 117, 86, 108, 38, 35, 99, 39, 91, 48, 35, 40, 115, 49, 88, 38, 120,
        109, 36, 89, 37, 66, 55, 42, 75, 58, 101, 68, 65, 51, 50, 51, 106, 57, 57, 56, 71, 88, 98,
        65, 35, 112, 119, 77, 115, 45, 106, 103, 68, 36, 57, 81, 73, 83, 66, 45, 65, 95, 40, 97,
        78, 52, 120, 111, 70, 77, 94, 64, 67, 53, 56, 68, 48, 43, 81, 43, 113, 51, 110, 48, 35, 51,
        85, 49, 73, 110, 68, 106, 70, 54, 56, 50, 45, 83, 106, 77, 88, 74, 75, 41, 40, 104, 36,
        104, 120, 117, 97, 95, 75, 93, 117, 108, 57, 50, 37, 39, 66, 79, 85, 38, 35, 66, 82, 82,
        104, 45, 115, 108, 103, 56, 75, 68, 108, 114, 58, 37, 76, 55, 49, 75, 97, 58, 46, 65, 59,
        37, 89, 85, 76, 106, 68, 80, 109, 76, 60, 76, 89, 115, 56, 105, 35, 88, 119, 74, 79, 89,
        97, 75, 80, 75, 99, 49, 104, 58, 39, 57, 75, 101, 44, 103, 41, 98, 41, 44, 55, 56, 61, 73,
        51, 57, 66, 59, 120, 105, 89, 36, 98, 103, 71, 119, 45, 38, 46, 90, 105, 57, 73, 110, 88,
        68, 117, 89, 97, 37, 71, 42, 102, 50, 66, 113, 55, 109, 110, 57, 94, 35, 112, 49, 118, 118,
        37, 35, 40, 87, 105, 45, 59, 47, 90, 53, 104, 111, 59, 35, 50, 58, 59, 37, 100, 38, 35,
        120, 57, 118, 54, 56, 67, 53, 103, 63, 110, 116, 88, 48, 88, 41, 112, 84, 96, 59, 37, 112,
        66, 51, 113, 55, 109, 103, 71, 78, 41, 51, 37, 40, 80, 56, 110, 84, 100, 53, 76, 55, 71,
        101, 65, 45, 71, 76, 64, 43, 37, 74, 51, 117, 50, 58, 40, 89, 102, 62, 101, 116, 96, 101,
        59, 41, 102, 35, 75, 109, 56, 38, 43, 68, 67, 36, 73, 52, 54, 62, 35, 75, 114, 93, 93, 117,
        45, 91, 61, 57, 57, 116, 116, 115, 49, 46, 113, 98, 35, 113, 55, 50, 103, 49, 87, 74, 79,
        56, 49, 113, 43, 101, 78, 39, 48, 51, 39, 101, 77, 62, 38, 49, 88, 120, 89, 45, 99, 97, 69,
        110, 79, 106, 37, 50, 110, 56, 41, 41, 44, 63, 73, 76, 82, 53, 94, 46, 73, 98, 110, 60, 45,
        88, 45, 77, 113, 55, 91, 97, 56, 50, 76, 113, 58, 70, 38, 35, 99, 101, 43, 83, 57, 119,
        115, 67, 75, 42, 120, 96, 53, 54, 57, 69, 56, 101, 119, 39, 72, 101, 93, 104, 58, 115, 73,
        91, 50, 76, 77, 36, 91, 103, 117, 107, 97, 51, 90, 82, 100, 54, 58, 116, 37, 73, 71, 58,
        59, 36, 37, 89, 105, 74, 58, 78, 113, 61, 63, 101, 65, 119, 59, 47, 58, 110, 110, 68, 113,
        48, 40, 67, 89, 99, 77, 112, 71, 41, 113, 76, 78, 52, 36, 35, 35, 38, 74, 60, 106, 36, 85,
        112, 75, 60, 81, 52, 97, 49, 93, 77, 117, 112, 87, 94, 45, 115, 106, 95, 36, 37, 91, 72,
        75, 37, 39, 70, 35, 35, 35, 35, 81, 82, 90, 74, 58, 58, 89, 51, 69, 71, 108, 52, 39, 64,
        37, 70, 107, 105, 65, 79, 103, 35, 112, 91, 35, 35, 79, 96, 103, 117, 107, 84, 102, 66, 72,
        97, 103, 76, 60, 76, 72, 119, 37, 113, 38, 79, 86, 48, 35, 35, 70, 61, 54, 47, 58, 99, 104,
        73, 109, 48, 64, 101, 67, 80, 56, 88, 93, 58, 107, 70, 73, 37, 104, 108, 56, 104, 103, 79,
        64, 82, 99, 66, 104, 83, 45, 64, 81, 98, 36, 37, 43, 109, 61, 104, 80, 68, 76, 103, 42, 37,
        75, 56, 108, 110, 40, 119, 99, 102, 51, 47, 39, 68, 87, 45, 36, 46, 108, 82, 63, 110, 91,
        110, 67, 72, 45, 101, 88, 79, 79, 78, 84, 74, 108, 104, 58, 46, 82, 89, 70, 37, 51, 39,
        112, 54, 115, 113, 58, 85, 73, 77, 65, 57, 52, 53, 38, 94, 72, 70, 83, 56, 55, 64, 36, 69,
        80, 50, 105, 71, 60, 45, 108, 67, 79, 36, 37, 99, 96, 117, 75, 71, 68, 51, 114, 67, 36,
        120, 48, 66, 76, 56, 97, 70, 110, 45, 45, 96, 107, 101, 37, 35, 72, 77, 80, 39, 118, 104,
        49, 47, 82, 38, 79, 95, 74, 57, 39, 117, 109, 44, 46, 60, 116, 120, 91, 64, 37, 119, 115,
        74, 107, 38, 98, 85, 84, 50, 96, 48, 117, 77, 118, 55, 103, 103, 35, 113, 112, 47, 105,
        106, 46, 76, 53, 54, 39, 104, 108, 59, 46, 115, 53, 67, 85, 114, 120, 106, 79, 77, 55, 45,
        35, 35, 46, 108, 43, 65, 117, 39, 65, 38, 79, 58, 45, 84, 55, 50, 76, 93, 80, 96, 38, 61,
        59, 99, 116, 112, 39, 88, 83, 99, 88, 42, 114, 85, 46, 62, 45, 88, 84, 116, 44, 37, 79, 86,
        85, 52, 41, 83, 49, 43, 82, 45, 35, 100, 103, 48, 47, 78, 110, 63, 75, 117, 49, 94, 48,
        102, 36, 66, 42, 80, 58, 82, 111, 119, 119, 109, 45, 96, 48, 80, 75, 106, 89, 68, 68, 77,
        39, 51, 93, 100, 51, 57, 86, 90, 72, 69, 108, 52, 44, 46, 106, 39, 93, 80, 107, 45, 77, 46,
        104, 94, 38, 58, 48, 70, 65, 67, 109, 36, 109, 97, 113, 45, 38, 115, 103, 119, 48, 116, 55,
        47, 54, 40, 94, 120, 116, 107, 37, 76, 117, 72, 56, 56, 70, 106, 45, 101, 107, 109, 62, 71,
        65, 35, 95, 62, 53, 54, 56, 120, 54, 40, 79, 70, 82, 108, 45, 73, 90, 112, 96, 38, 98, 44,
        95, 80, 39, 36, 77, 60, 74, 110, 113, 55, 57, 86, 115, 74, 87, 47, 109, 87, 83, 42, 80, 85,
        105, 113, 55, 54, 59, 93, 47, 78, 77, 95, 62, 104, 76, 98, 120, 102, 99, 36, 109, 106, 96,
        44, 79, 59, 38, 37, 87, 50, 109, 96, 90, 104, 58, 47, 41, 85, 101, 116, 119, 58, 97, 74,
        37, 93, 75, 57, 104, 58, 84, 99, 70, 93, 117, 95, 45, 83, 106, 57, 44, 86, 75, 51, 77, 46,
        42, 39, 38, 48, 68, 91, 67, 97, 93, 74, 57, 103, 112, 56, 44, 107, 65, 87, 93, 37, 40, 63,
        65, 37, 82, 36, 102, 60, 45, 62, 90, 116, 115, 39, 94, 107, 110, 61, 45, 94, 64, 99, 52,
        37, 45, 112, 89, 54, 113, 73, 37, 74, 37, 49, 73, 71, 120, 102, 76, 85, 57, 67, 80, 56, 99,
        98, 80, 108, 88, 118, 41, 59, 67, 61, 98, 41, 44, 60, 50, 109, 79, 118, 80, 56, 117, 112,
        44, 85, 86, 102, 51, 56, 51, 57, 97, 99, 65, 87, 65, 87, 45, 87, 63, 35, 97, 111, 47, 94,
        35, 37, 75, 89, 111, 56, 102, 82, 85, 76, 78, 100, 50, 46, 62, 37, 109, 93, 85, 75, 58,
        110, 37, 114, 36, 39, 115, 119, 93, 74, 59, 53, 112, 65, 111, 79, 95, 35, 50, 109, 79, 51,
        110, 44, 39, 61, 72, 53, 40, 101, 116, 72, 103, 42, 96, 43, 82, 76, 103, 118, 62, 61, 52,
        85, 56, 103, 117, 68, 36, 73, 37, 68, 58, 87, 62, 45, 114, 53, 86, 42, 37, 106, 42, 87, 58,
        75, 118, 101, 106, 46, 76, 112, 36, 60, 77, 45, 83, 71, 90, 39, 58, 43, 81, 95, 107, 43,
        117, 118, 79, 83, 76, 105, 69, 111, 40, 60, 97, 68, 47, 75, 60, 67, 67, 99, 96, 39, 76,
        120, 62, 39, 63, 59, 43, 43, 79, 39, 62, 40, 41, 106, 76, 82, 45, 94, 117, 54, 56, 80, 72,
        109, 56, 90, 70, 87, 101, 43, 101, 106, 56, 104, 58, 57, 114, 54, 76, 42, 48, 47, 47, 99,
        38, 105, 72, 38, 82, 56, 112, 82, 98, 65, 35, 75, 106, 109, 37, 117, 112, 86, 49, 103, 58,
        97, 95, 35, 85, 114, 55, 70, 117, 65, 35, 40, 116, 82, 104, 35, 46, 89, 53, 75, 43, 64, 63,
        51, 60, 45, 56, 109, 48, 36, 80, 69, 110, 59, 74, 58, 114, 104, 54, 63, 73, 54, 117, 71,
        60, 45, 96, 119, 77, 85, 39, 105, 114, 99, 112, 48, 76, 97, 69, 95, 79, 116, 108, 77, 98,
        38, 49, 35, 54, 84, 46, 35, 70, 68, 75, 117, 35, 49, 76, 119, 37, 117, 37, 43, 71, 77, 43,
        88, 39, 101, 63, 89, 76, 102, 106, 77, 91, 86, 79, 48, 77, 98, 117, 70, 112, 55, 59, 62,
        81, 38, 35, 87, 73, 111, 41, 48, 64, 70, 37, 113, 55, 99, 35, 52, 88, 65, 88, 78, 45, 85,
        38, 86, 66, 60, 72, 70, 70, 42, 113, 76, 40, 36, 47, 86, 44, 59, 40, 107, 88, 90, 101, 106,
        87, 79, 96, 60, 91, 53, 63, 63, 101, 119, 89, 40, 42, 57, 61, 37, 119, 68, 99, 59, 44, 117,
        60, 39, 57, 116, 51, 87, 45, 40, 72, 49, 116, 104, 51, 43, 71, 93, 117, 99, 81, 93, 107,
        76, 115, 55, 100, 102, 40, 36, 47, 42, 74, 76, 93, 64, 42, 116, 55, 66, 117, 95, 71, 51,
        95, 55, 109, 112, 55, 60, 105, 97, 81, 106, 79, 64, 46, 107, 76, 103, 59, 120, 51, 66, 48,
        108, 113, 112, 55, 72, 102, 44, 94, 90, 101, 55, 45, 35, 35, 64, 47, 99, 53, 56, 77, 111,
        40, 51, 59, 107, 110, 112, 48, 37, 41, 65, 55, 63, 45, 87, 43, 101, 73, 39, 111, 56, 41,
        98, 60, 110, 75, 110, 119, 39, 72, 111, 56, 67, 61, 89, 62, 112, 113, 66, 62, 48, 105, 101,
        38, 106, 104, 90, 91, 63, 105, 76, 82, 64, 64, 95, 65, 118, 65, 45, 105, 81, 67, 40, 61,
        107, 115, 82, 90, 82, 86, 112, 55, 96, 46, 61, 43, 78, 112, 66, 67, 37, 114, 104, 38, 51,
        93, 82, 58, 56, 88, 68, 109, 69, 53, 94, 86, 56, 79, 40, 120, 60, 60, 97, 71, 47, 49, 78,
        36, 35, 70, 88, 36, 48, 86, 53, 89, 54, 120, 39, 97, 69, 114, 73, 51, 73, 36, 55, 120, 37,
        69, 96, 118, 60, 45, 66, 89, 44, 41, 37, 45, 63, 80, 115, 102, 42, 108, 63, 37, 67, 51, 46,
        109, 77, 40, 61, 47, 77, 48, 58, 74, 120, 71, 39, 63, 55, 87, 104, 72, 37, 111, 39, 97, 60,
        45, 56, 48, 103, 48, 78, 66, 120, 111, 79, 40, 71, 72, 60, 100, 77, 93, 110, 46, 43, 37,
        113, 64, 106, 72, 63, 102, 46, 85, 115, 74, 50, 71, 103, 115, 38, 52, 60, 45, 101, 52, 55,
        38, 75, 108, 43, 102, 47, 47, 57, 64, 96, 98, 43, 63, 46, 84, 101, 78, 95, 38, 66, 56, 83,
        115, 63, 118, 59, 94, 84, 114, 107, 59, 102, 35, 89, 118, 74, 107, 108, 38, 119, 36, 93,
        62, 45, 43, 107, 63, 39, 40, 60, 83, 58, 54, 56, 116, 113, 42, 87, 111, 68, 102, 90, 117,
        39, 59, 109, 77, 63, 56, 88, 91, 109, 97, 56, 87, 37, 42, 96, 45, 61, 59, 68, 46, 40, 110,
        99, 55, 47, 59, 41, 103, 58, 84, 49, 61, 94, 74, 36, 38, 66, 82, 86, 40, 45, 108, 84, 109,
        78, 66, 54, 120, 113, 66, 91, 64, 48, 42, 111, 46, 101, 114, 77, 42, 60, 83, 87, 70, 93,
        117, 50, 61, 115, 116, 45, 42, 40, 54, 118, 62, 94, 93, 40, 72, 46, 97, 82, 69, 90, 83,
        105, 44, 35, 49, 58, 91, 73, 88, 97, 90, 70, 79, 109, 60, 45, 117, 105, 35, 113, 85, 113,
        50, 36, 35, 35, 82, 105, 59, 117, 55, 53, 79, 75, 35, 40, 82, 116, 97, 87, 45, 75, 45, 70,
        96, 83, 43, 99, 70, 93, 117, 78, 96, 45, 75, 77, 81, 37, 114, 80, 47, 88, 114, 105, 46, 76,
        82, 99, 66, 35, 35, 61, 89, 76, 51, 66, 103, 77, 47, 51, 77, 68, 63, 64, 102, 38, 49, 39,
        66, 87, 45, 41, 74, 117, 60, 76, 50, 53, 103, 108, 56, 117, 104, 86, 109, 49, 104, 76, 36,
        35, 35, 42, 56, 35, 35, 35, 39, 65, 51, 47, 76, 107, 75, 87, 43, 40, 94, 114, 87, 88, 63,
        53, 87, 95, 56, 103, 41, 97, 40, 109, 38, 75, 56, 80, 62, 35, 98, 109, 109, 87, 67, 77,
        107, 107, 38, 35, 84, 82, 96, 67, 44, 53, 100, 62, 103, 41, 70, 59, 116, 44, 52, 58, 64,
        95, 108, 56, 71, 47, 53, 104, 52, 118, 85, 100, 37, 38, 37, 57, 53, 48, 58, 86, 88, 68, 39,
        81, 100, 87, 111, 89, 45, 70, 36, 66, 116, 85, 119, 109, 102, 101, 36, 89, 113, 76, 39, 56,
        40, 80, 87, 88, 40, 80, 63, 94, 64, 80, 111, 51, 36, 35, 35, 96, 77, 83, 115, 63, 68, 87,
        66, 90, 47, 83, 62, 43, 52, 37, 62, 102, 88, 44, 86, 87, 118, 47, 119, 39, 75, 68, 96, 76,
        80, 53, 73, 98, 72, 59, 114, 84, 86, 62, 110, 51, 99, 69, 75, 56, 85, 35, 98, 88, 93, 108,
        45, 47, 86, 43, 94, 108, 106, 51, 59, 118, 108, 77, 98, 38, 91, 53, 89, 81, 56, 35, 112,
        101, 107, 88, 57, 74, 80, 51, 88, 85, 67, 55, 50, 76, 44, 44, 63, 43, 78, 105, 38, 99, 111,
        55, 65, 112, 110, 79, 42, 53, 78, 75, 44, 40, 40, 87, 45, 105, 58, 36, 44, 107, 112, 39,
        85, 68, 65, 79, 40, 71, 48, 83, 113, 55, 77, 86, 106, 74, 115, 98, 73, 117, 41, 39, 90, 44,
        42, 91, 62, 98, 114, 53, 102, 88, 94, 58, 70, 80, 65, 87, 114, 45, 109, 50, 75, 103, 76,
        60, 76, 85, 78, 48, 57, 56, 107, 84, 70, 38, 35, 108, 118, 111, 53, 56, 61, 47, 118, 106,
        68, 111, 59, 46, 59, 41, 75, 97, 42, 104, 76, 82, 35, 47, 107, 61, 114, 75, 98, 120, 117,
        86, 96, 62, 81, 95, 110, 78, 54, 39, 56, 117, 84, 71, 38, 35, 49, 84, 53, 103, 41, 117, 76,
        118, 58, 56, 55, 51, 85, 112, 84, 76, 103, 72, 43, 35, 70, 103, 112, 72, 39, 95, 111, 49,
        55, 56, 48, 80, 104, 56, 75, 109, 120, 81, 74, 56, 35, 72, 55, 50, 76, 52, 64, 55, 54, 56,
        64, 84, 109, 38, 81, 104, 52, 67, 66, 47, 53, 79, 118, 109, 65, 38, 44, 81, 38, 81, 98, 85,
        111, 105, 36, 97, 95, 37, 51, 77, 48, 49, 72, 41, 52, 120, 55, 73, 94, 38, 75, 81, 86, 103,
        116, 70, 110, 86, 43, 59, 91, 80, 99, 62, 91, 109, 52, 107, 47, 47, 44, 93, 49, 63, 35, 96,
        86, 89, 91, 74, 114, 42, 51, 38, 38, 115, 108, 82, 102, 76, 105, 86, 90, 74, 58, 93, 63,
        61, 75, 51, 83, 119, 61, 91, 36, 61, 117, 82, 66, 63, 51, 120, 107, 52, 56, 64, 97, 101,
        103, 60, 90, 39, 60, 36, 35, 52, 72, 41, 54, 44, 62, 101, 48, 106, 84, 54, 39, 78, 35, 40,
        113, 37, 46, 79, 61, 63, 50, 83, 93, 117, 42, 40, 109, 60, 45, 86, 56, 74, 39, 40, 49, 41,
        71, 93, 91, 54, 56, 104, 87, 36, 53, 39, 113, 91, 71, 67, 38, 53, 106, 96, 84, 69, 63, 109,
        39, 101, 115, 70, 71, 78, 82, 77, 41, 106, 44, 102, 102, 90, 63, 45, 113, 120, 56, 59, 45,
        62, 103, 52, 116, 42, 58, 67, 73, 80, 47, 91, 81, 97, 112, 55, 47, 57, 39, 35, 40, 49, 115,
        97, 111, 55, 119, 45, 46, 113, 78, 85, 100, 107, 74, 41, 116, 67, 70, 38, 35, 66, 94, 59,
        120, 71, 118, 110, 50, 114, 57, 70, 69, 80, 70, 70, 70, 99, 76, 64, 46, 105, 70, 78, 107,
        84, 118, 101, 36, 109, 37, 35, 81, 118, 81, 83, 56, 85, 64, 41, 50, 90, 43, 51, 75, 58, 65,
        75, 77, 53, 105, 115, 90, 56, 56, 43, 100, 75, 81, 41, 87, 54, 62, 74, 37, 67, 76, 60, 75,
        69, 62, 96, 46, 100, 42, 40, 66, 96, 45, 110, 56, 68, 57, 111, 75, 60, 85, 112, 93, 99, 36,
        88, 36, 40, 44, 41, 77, 56, 90, 116, 55, 47, 91, 114, 100, 107, 113, 84, 103, 108, 45, 48,
        99, 117, 71, 77, 118, 39, 63, 62, 45, 88, 86, 49, 113, 91, 39, 45, 53, 107, 39, 99, 65, 90,
        54, 57, 101, 59, 68, 95, 63, 36, 90, 80, 80, 38, 115, 94, 43, 55, 93, 41, 36, 42, 36, 35,
        64, 81, 89, 105, 57, 44, 53, 80, 38, 35, 57, 114, 43, 36, 37, 67, 69, 61, 54, 56, 62, 75,
        56, 114, 48, 61, 100, 83, 67, 37, 37, 40, 64, 112, 55, 46, 109, 55, 106, 105, 108, 81, 48,
        50, 39, 48, 45, 86, 87, 65, 103, 60, 97, 47, 39, 39, 51, 117, 46, 61, 52, 76, 36, 89, 41,
        54, 107, 47, 75, 58, 95, 91, 51, 61, 38, 106, 118, 76, 60, 76, 48, 67, 47, 50, 39, 118, 58,
        94, 59, 45, 68, 73, 66, 87, 44, 66, 52, 69, 54, 56, 58, 107, 90, 59, 37, 63, 56, 40, 81,
        56, 66, 72, 61, 107, 79, 54, 53, 66, 87, 63, 120, 83, 71, 38, 35, 64, 117, 85, 44, 68, 83,
        42, 44, 63, 46, 43, 40, 111, 40, 35, 49, 118, 67, 83, 56, 35, 67, 72, 70, 62, 84, 108, 71,
        87, 39, 98, 41, 84, 113, 55, 86, 84, 57, 113, 94, 42, 94, 36, 36, 46, 58, 38, 78, 64, 64,
        36, 38, 41, 87, 72, 116, 80, 109, 42, 53, 95, 114, 79, 48, 38, 101, 37, 75, 38, 35, 45, 51,
        48, 106, 40, 69, 52, 35, 39, 90, 98, 46, 111, 47, 40, 84, 112, 109, 36, 62, 75, 39, 102,
        64, 91, 80, 118, 70, 108, 44, 104, 102, 73, 78, 84, 78, 85, 54, 117, 39, 48, 112, 97, 111,
        55, 37, 88, 85, 112, 57, 93, 53, 46, 62, 37, 104, 96, 56, 95, 61, 86, 89, 98, 120, 117,
        101, 108, 46, 78, 84, 83, 115, 74, 102, 76, 97, 99, 70, 117, 51, 66, 39, 108, 81, 83, 117,
        47, 109, 54, 45, 79, 113, 101, 109, 56, 84, 43, 111, 69, 45, 45, 36, 48, 97, 47, 107, 93,
        117, 106, 57, 69, 119, 115, 71, 62, 37, 118, 101, 82, 42, 104, 118, 94, 66, 70, 112, 81,
        106, 58, 75, 39, 35, 83, 74, 44, 115, 66, 45, 39, 35, 93, 40, 106, 46, 76, 103, 57, 50,
        114, 84, 119, 45, 42, 110, 37, 64, 47, 59, 51, 57, 114, 114, 74, 70, 44, 108, 35, 113, 86,
        37, 79, 114, 116, 66, 101, 67, 54, 47, 44, 59, 113, 66, 51, 101, 98, 78, 87, 91, 63, 44,
        72, 113, 106, 50, 76, 46, 49, 78, 80, 38, 71, 106, 85, 82, 61, 49, 68, 56, 81, 97, 83, 51,
        85, 112, 38, 64, 42, 57, 119, 80, 63, 43, 108, 111, 55, 98, 63, 64, 37, 39, 107, 52, 96,
        112, 48, 90, 36, 50, 50, 37, 75, 51, 43, 105, 67, 90, 106, 63, 88, 74, 78, 52, 78, 109, 38,
        43, 89, 70, 93, 117, 64, 45, 87, 36, 85, 37, 86, 69, 81, 47, 44, 44, 62, 62, 35, 41, 68,
        60, 104, 35, 96, 41, 104, 48, 58, 60, 81, 54, 57, 48, 57, 117, 97, 43, 38, 86, 85, 37, 110,
        50, 58, 99, 71, 51, 70, 74, 45, 37, 64, 66, 106, 45, 68, 103, 76, 114, 96, 72, 119, 38, 72,
        65, 75, 106, 75, 106, 115, 101, 75, 60, 47, 120, 75, 84, 42, 41, 66, 44, 78, 57, 88, 51,
        93, 107, 114, 99, 49, 50, 116, 39, 112, 103, 84, 86, 40, 76, 118, 45, 116, 76, 91, 120,
        103, 95, 37, 61, 77, 95, 113, 55, 97, 94, 120, 63, 55, 85, 98, 100, 62, 35, 37, 56, 99, 89,
        35, 89, 90, 63, 61, 44, 96, 87, 100, 120, 117, 47, 97, 101, 38, 35, 119, 54, 41, 82, 56,
        57, 116, 73, 35, 54, 64, 115, 39, 40, 54, 66, 102, 55, 97, 38, 63, 83, 61, 94, 90, 73, 95,
        107, 83, 38, 97, 105, 96, 38, 61, 116, 69, 55, 50, 76, 95, 68, 44, 59, 94, 82, 41, 55, 91,
        36, 115, 60, 69, 104, 35, 99, 38, 41, 113, 46, 77, 88, 73, 37, 35, 118, 57, 82, 79, 97, 53,
        70, 90, 79, 37, 115, 70, 55, 113, 55, 78, 119, 98, 38, 35, 112, 116, 85, 74, 58, 97, 113,
        74, 101, 36, 83, 108, 54, 56, 37, 46, 68, 35, 35, 35, 69, 67, 62, 60, 63, 45, 97, 70, 38,
        35, 82, 78, 81, 118, 62, 111, 56, 108, 75, 78, 37, 53, 47, 36, 40, 118, 100, 102, 113, 55,
        43, 101, 98, 65, 35, 117, 49, 112, 93, 111, 118, 85, 75, 87, 38, 89, 37, 113, 93, 39, 62,
        36, 49, 64, 45, 91, 120, 102, 110, 36, 55, 90, 84, 112, 55, 109, 77, 44, 71, 44, 75, 111,
        55, 97, 38, 71, 117, 37, 71, 91, 82, 77, 120, 74, 115, 91, 48, 77, 77, 37, 119, 99, 105,
        46, 76, 70, 68, 75, 41, 40, 60, 99, 96, 81, 56, 78, 41, 106, 69, 73, 70, 42, 43, 63, 80,
        50, 97, 56, 103, 37, 41, 36, 113, 93, 111, 50, 97, 72, 56, 67, 38, 60, 83, 105, 98, 67, 47,
        113, 44, 40, 101, 58, 118, 59, 45, 98, 35, 54, 91, 36, 78, 116, 68, 90, 56, 52, 74, 101,
        50, 75, 78, 118, 66, 35, 36, 80, 53, 63, 116, 81, 51, 110, 116, 40, 48, 100, 61, 106, 46,
        76, 81, 102, 46, 47, 76, 108, 51, 51, 43, 40, 59, 113, 51, 76, 45, 119, 61, 56, 100, 88,
        36, 35, 87, 70, 38, 117, 73, 74, 64, 45, 98, 102, 73, 62, 37, 58, 95, 105, 50, 66, 53, 67,
        115, 82, 56, 38, 57, 90, 38, 35, 61, 109, 80, 69, 110, 109, 48, 102, 96, 60, 38, 99, 41,
        81, 76, 53, 117, 74, 35, 37, 117, 37, 108, 74, 106, 43, 68, 45, 114, 59, 66, 111, 70, 38,
        35, 52, 68, 111, 83, 57, 55, 104, 53, 103, 41, 69, 35, 111, 58, 38, 83, 52, 119, 101, 68,
        70, 44, 57, 94, 72, 111, 101, 96, 104, 42, 76, 43, 95, 97, 42, 78, 114, 76, 87, 45, 49,
        112, 71, 95, 38, 50, 85, 100, 66, 56, 54, 101, 37, 66, 47, 58, 61, 62, 41, 78, 52, 120,
        101, 87, 46, 42, 119, 102, 116, 45, 59, 36, 39, 53, 56, 45, 69, 83, 113, 114, 60, 98, 63,
        85, 73, 40, 95, 37, 64, 91, 80, 52, 54, 62, 35, 85, 96, 39, 54, 65, 81, 93, 109, 38, 54,
        47, 96, 90, 62, 35, 83, 63, 89, 89, 35, 86, 99, 59, 114, 55, 85, 50, 38, 51, 50, 54, 100,
        61, 119, 38, 72, 35, 35, 35, 35, 63, 84, 90, 96, 42, 52, 63, 38, 46, 77, 75, 63, 76, 80,
        56, 86, 120, 103, 62, 36, 91, 81, 88, 99, 37, 81, 74, 118, 57, 50, 46, 40, 68, 98, 42, 66,
        41, 103, 98, 42, 66, 77, 57, 100, 77, 42, 104, 74, 77, 65, 111, 42, 99, 38, 35, 98, 48,
        118, 61, 80, 106, 101, 114, 93, 36, 103, 71, 38, 74, 88, 68, 102, 45, 62, 39, 83, 116, 118,
        85, 55, 53, 48, 53, 108, 57, 36, 65, 70, 118, 103, 89, 82, 73, 94, 38, 60, 94, 98, 54, 56,
        63, 106, 35, 113, 57, 81, 88, 52, 83, 77, 39, 82, 79, 35, 38, 115, 76, 49, 73, 77, 46, 114,
        74, 102, 76, 85, 65, 106, 50, 50, 49, 93, 100, 35, 35, 68, 87, 61, 109, 56, 51, 117, 53,
        59, 39, 98, 89, 120, 44, 42, 83, 108, 48, 104, 76, 40, 87, 59, 59, 36, 100, 111, 66, 38,
        79, 47, 84, 81, 58, 40, 90, 94, 120, 66, 100, 76, 106, 76, 60, 76, 110, 105, 59, 39, 39,
        88, 46, 96, 36, 35, 56, 43, 49, 71, 68, 58, 107, 36, 89, 85, 87, 115, 98, 110, 56, 111,
        103, 104, 54, 114, 120, 90, 50, 90, 57, 93, 37, 110, 100, 43, 62, 86, 35, 42, 56, 85, 95,
        55, 50, 76, 104, 43, 50, 81, 56, 67, 106, 48, 105, 58, 54, 104, 112, 38, 36, 67, 47, 58,
        112, 40, 72, 75, 62, 84, 56, 89, 91, 103, 72, 81, 52, 96, 52, 41, 39, 36, 65, 98, 40, 78,
        111, 102, 37, 86, 39, 56, 104, 76, 38, 35, 60, 78, 69, 100, 116, 103, 40, 110, 39, 61, 83,
        49, 65, 40, 81, 49, 47, 73, 38, 52, 40, 91, 37, 100, 77, 96, 44, 73, 117, 39, 49, 58, 95,
        104, 76, 62, 83, 102, 68, 48, 55, 38, 54, 68, 60, 102, 112, 56, 100, 72, 77, 55, 47, 103,
        43, 116, 108, 80, 78, 57, 74, 42, 114, 75, 97, 80, 99, 116, 38, 63, 39, 117, 66, 67, 101,
        109, 94, 106, 110, 37, 57, 95, 75, 41, 60, 44, 67, 53, 75, 51, 115, 61, 53, 103, 38, 71,
        109, 74, 98, 42, 91, 83, 89, 113, 55, 75, 59, 84, 82, 76, 71, 67, 115, 77, 45, 36, 36, 59,
        83, 37, 58, 89, 64, 114, 55, 65, 75, 48, 112, 112, 114, 112, 76, 60, 76, 114, 104, 44, 113,
        55, 101, 47, 37, 75, 87, 75, 58, 53, 48, 73, 94, 43, 109, 39, 118, 105, 96, 51, 63, 37, 90,
        112, 43, 60, 45, 100, 43, 36, 76, 45, 83, 118, 58, 64, 46, 111, 49, 57, 110, 36, 115, 48,
        38, 51, 57, 59, 107, 110, 59, 83, 37, 66, 83, 113, 42, 36, 51, 87, 111, 74, 83, 67, 76,
        119, 101, 86, 91, 97, 90, 39, 77, 81, 73, 106, 79, 60, 55, 59, 88, 45, 88, 59, 38, 43, 100,
        77, 76, 118, 117, 35, 94, 85, 115, 71, 69, 67, 57, 87, 69, 99, 91, 88, 40, 119, 73, 55, 35,
        50, 46, 40, 70, 48, 106, 86, 42, 101, 90, 102, 60, 45, 81, 118, 51, 74, 45, 99, 43, 74, 53,
        65, 108, 114, 66, 35, 36, 112, 40, 72, 54, 56, 76, 118, 69, 65, 39, 113, 51, 110, 48, 35,
        109, 44, 91, 96, 42, 56, 70, 116, 41, 70, 99, 89, 103, 69, 117, 100, 93, 67, 87, 102, 109,
        54, 56, 44, 40, 97, 76, 65, 36, 64, 69, 70, 84, 103, 76, 88, 111, 66, 113, 47, 85, 80, 108,
        112, 55, 58, 100, 91, 47, 59, 114, 95, 105, 120, 61, 58, 84, 70, 96, 83, 53, 72, 45, 98,
        60, 76, 73, 38, 72, 89, 40, 75, 61, 104, 35, 41, 93, 76, 107, 36, 75, 49, 52, 108, 86, 102,
        109, 58, 120, 36, 72, 60, 51, 94, 81, 108, 60, 77, 96, 36, 79, 104, 97, 112, 66, 110, 107,
        117, 112, 39, 68, 35, 76, 36, 80, 98, 95, 96, 78, 42, 103, 93, 50, 101, 59, 88, 47, 68,
        116, 103, 44, 98, 115, 106, 38, 75, 35, 50, 91, 45, 58, 105, 89, 114, 39, 95, 119, 103, 72,
        41, 78, 85, 73, 82, 56, 97, 49, 110, 35, 83, 63, 89, 101, 106, 39, 104, 56, 94, 53, 56, 85,
        98, 90, 100, 43, 94, 70, 75, 68, 42, 84, 64, 59, 54, 65, 55, 97, 81, 67, 91, 75, 56, 100,
        45, 40, 118, 54, 71, 73, 36, 120, 58, 84, 60, 38, 39, 71, 112, 53, 85, 102, 62, 64, 77, 46,
        42, 74, 58, 59, 36, 45, 114, 118, 50, 57, 39, 77, 93, 56, 113, 77, 118, 45, 116, 76, 112,
        44, 39, 56, 56, 54, 105, 97, 67, 61, 72, 98, 42, 89, 74, 111, 75, 74, 44, 40, 106, 37, 75,
        61, 72, 96, 75, 46, 118, 57, 72, 103, 103, 113, 66, 73, 105, 90, 117, 39, 81, 118, 66, 84,
        46, 35, 61, 41, 48, 117, 107, 114, 117, 86, 38, 46, 41, 51, 61, 40, 94, 49, 96, 111, 42,
        80, 106, 52, 60, 45, 60, 97, 78, 40, 40, 94, 55, 40, 39, 35, 90, 48, 119, 75, 35, 53, 71,
        88, 64, 55, 117, 93, 91, 96, 42, 83, 94, 52, 51, 57, 51, 51, 65, 52, 114, 108, 93, 91, 96,
        42, 79, 52, 67, 103, 76, 69, 108, 93, 118, 36, 49, 81, 51, 65, 101, 70, 51, 55, 100, 98,
        88, 107, 44, 46, 41, 118, 106, 35, 120, 39, 100, 96, 59, 113, 103, 98, 81, 82, 37, 70, 87,
        44, 50, 40, 63, 76, 79, 61, 115, 37, 83, 99, 54, 56, 37, 78, 80, 39, 35, 35, 65, 111, 116,
        108, 56, 120, 61, 66, 69, 35, 106, 49, 85, 68, 40, 91, 51, 36, 77, 40, 93, 85, 73, 50, 76,
        88, 51, 82, 112, 75, 78, 64, 59, 47, 35, 102, 39, 102, 47, 38, 95, 109, 116, 38, 70, 41,
        88, 100, 70, 60, 57, 116, 52, 41, 81, 97, 46, 42, 107, 84, 76, 119, 81, 39, 40, 84, 84, 66,
        57, 46, 120, 72, 39, 62, 35, 77, 74, 43, 103, 76, 113, 57, 45, 35, 35, 64, 72, 117, 90, 80,
        78, 48, 93, 117, 58, 104, 55, 46, 84, 46, 46, 71, 58, 59, 36, 47, 85, 115, 106, 40, 84, 55,
        96, 81, 56, 116, 84, 55, 50, 76, 110, 89, 108, 60, 45, 113, 120, 56, 59, 45, 72, 86, 55,
        81, 45, 38, 88, 100, 120, 37, 49, 97, 44, 104, 67, 61, 48, 117, 43, 72, 108, 115, 86, 62,
        110, 117, 73, 81, 76, 45, 53, 60, 78, 63, 41, 78, 66, 83, 41, 81, 78, 42, 95, 73, 44, 63,
        38, 41, 50, 39, 73, 77, 37, 76, 51, 73, 41, 88, 40, 40, 101, 47, 100, 108, 50, 38, 56, 39,
        60, 77, 58, 94, 35, 77, 42, 81, 43, 91, 84, 46, 88, 114, 105, 46, 76, 89, 83, 51, 118, 37,
        102, 70, 96, 54, 56, 104, 59, 98, 45, 88, 91, 47, 69, 110, 39, 67, 82, 46, 113, 55, 69, 41,
        112, 39, 47, 107, 108, 101, 50, 72, 77, 44, 117, 59, 94, 37, 79, 75, 67, 45, 78, 43, 76,
        108, 37, 70, 57, 67, 70, 60, 78, 102, 39, 94, 35, 116, 50, 76, 44, 59, 50, 55, 87, 58, 48,
        79, 64, 54, 35, 35, 85, 54, 87, 55, 58, 36, 114, 74, 102, 76, 87, 72, 106, 36, 35, 41, 119,
        111, 113, 66, 101, 102, 73, 90, 46, 80, 75, 60, 98, 42, 116, 55, 101, 100, 59, 112, 42, 95,
        109, 59, 52, 69, 120, 75, 35, 104, 64, 38, 93, 62, 95, 62, 64, 107, 88, 81, 116, 77, 97,
        99, 102, 68, 46, 109, 45, 86, 65, 98, 56, 59, 73, 82, 101, 77, 51, 36, 119, 102, 48, 39,
        39, 104, 114, 97, 42, 115, 111, 53, 54, 56, 39, 73, 112, 38, 118, 82, 115, 56, 52, 57, 39,
        77, 82, 89, 83, 112, 37, 58, 116, 58, 104, 53, 113, 83, 103, 119, 112, 69, 114, 36, 66, 62,
        81, 44, 59, 115, 40, 67, 35, 36, 41, 96, 115, 118, 81, 117, 70, 36, 35, 35, 45, 68, 44, 35,
        35, 44, 103, 54, 56, 64, 50, 91, 84, 59, 46, 88, 83, 100, 78, 57, 81, 101, 41, 114, 112,
        116, 46, 95, 75, 45, 35, 53, 119, 70, 41, 115, 80, 39, 35, 35, 112, 35, 67, 48, 99, 37, 45,
        71, 98, 37, 104, 100, 43, 60, 45, 106, 39, 65, 105, 42, 120, 38, 38, 72, 77, 107, 84, 93,
        67, 39, 79, 83, 108, 35, 35, 53, 82, 71, 91, 74, 88, 97, 72, 78, 59, 100, 39, 117, 65, 35,
        120, 46, 95, 85, 59, 46, 96, 80, 85, 64, 40, 90, 51, 100, 116, 52, 114, 49, 53, 50, 64, 58,
        118, 44, 39, 82, 46, 83, 106, 39, 119, 35, 48, 60, 45, 59, 107, 80, 73, 41, 70, 102, 74,
        38, 35, 65, 89, 74, 38, 35, 47, 47, 41, 62, 45, 107, 61, 109, 61, 42, 88, 110, 75, 36, 62,
        61, 41, 55, 50, 76, 93, 48, 73, 37, 62, 46, 71, 54, 57, 48, 97, 58, 36, 35, 35, 60, 44, 41,
        59, 63, 59, 55, 50, 35, 63, 120, 57, 43, 100, 59, 94, 86, 39, 57, 59, 106, 89, 64, 59, 41,
        98, 114, 35, 113, 94, 89, 81, 112, 120, 58, 88, 35, 84, 101, 36, 90, 94, 39, 61, 45, 61,
        98, 71, 104, 76, 102, 58, 68, 54, 38, 98, 78, 119, 90, 57, 45, 90, 68, 35, 110, 94, 57, 72,
        104, 76, 77, 114, 53, 71, 59, 39, 93, 100, 38, 54, 39, 119, 89, 109, 84, 70, 109, 76, 60,
        76, 68, 41, 70, 94, 37, 91, 116, 67, 39, 56, 59, 43, 57, 69, 35, 67, 36, 103, 37, 35, 53,
        89, 62, 113, 57, 119, 73, 62, 80, 40, 57, 109, 73, 91, 62, 107, 67, 45, 101, 107, 76, 67,
        47, 82, 38, 67, 72, 43, 115, 39, 66, 59, 75, 45, 77, 54, 36, 69, 66, 37, 105, 115, 48, 48,
        58, 43, 65, 52, 91, 55, 120, 107, 115, 46, 76, 114, 78, 107, 48, 38, 69, 41, 119, 73, 76,
        89, 70, 64, 50, 76, 39, 48, 78, 98, 36, 43, 112, 118, 60, 40, 50, 46, 55, 54, 56, 47, 70,
        114, 89, 38, 104, 36, 94, 51, 105, 38, 64, 43, 71, 37, 74, 84, 39, 60, 45, 44, 118, 96, 51,
        59, 95, 41, 73, 57, 77, 94, 65, 69, 93, 67, 78, 63, 67, 108, 50, 65, 90, 103, 43, 37, 52,
        105, 84, 112, 84, 51, 60, 110, 45, 38, 37, 72, 37, 98, 60, 70, 68, 106, 50, 77, 60, 104,
        72, 61, 38, 69, 104, 60, 50, 76, 101, 110, 36, 98, 42, 97, 84, 88, 61, 45, 56, 81, 120, 78,
        41, 107, 49, 49, 73, 77, 49, 99, 94, 106, 37, 57, 115, 60, 76, 60, 78, 70, 83, 111, 41, 66,
        63, 43, 60, 45, 40, 71, 120, 115, 70, 44, 94, 45, 69, 104, 64, 36, 52, 100, 88, 104, 78,
        36, 43, 35, 114, 120, 75, 56, 39, 106, 101, 39, 68, 55, 107, 96, 101, 59, 41, 50, 112, 89,
        119, 80, 65, 39, 95, 112, 57, 38, 64, 94, 49, 56, 109, 108, 49, 94, 91, 64, 103, 52, 116,
        42, 91, 74, 79, 97, 42, 91, 61, 81, 112, 55, 40, 113, 74, 95, 111, 79, 76, 94, 40, 39, 55,
        102, 66, 38, 72, 113, 45, 58, 115, 102, 44, 115, 78, 106, 56, 120, 113, 94, 62, 36, 85, 52,
        79, 93, 71, 75, 120, 39, 109, 57, 41, 98, 64, 112, 55, 89, 115, 118, 75, 51, 119, 94, 89,
        82, 45, 67, 100, 81, 42, 58, 73, 114, 60, 40, 36, 117, 38, 41, 35, 40, 38, 63, 76, 57, 82,
        103, 51, 72, 41, 52, 102, 105, 69, 112, 94, 105, 73, 57, 79, 56, 75, 110, 84, 106, 44, 93,
        72, 63, 68, 42, 114, 55, 39, 77, 59, 80, 119, 90, 57, 75, 48, 69, 94, 107, 38, 45, 99, 112,
        73, 59, 46, 112, 47, 54, 95, 118, 119, 111, 70, 77, 86, 60, 45, 62, 35, 37, 88, 105, 46,
        76, 120, 86, 110, 114, 85, 40, 52, 38, 56, 47, 80, 43, 58, 104, 76, 83, 75, 106, 36, 35,
        85, 37, 93, 52, 57, 116, 39, 73, 58, 114, 103, 77, 105, 39, 70, 76, 64, 97, 58, 48, 89, 45,
        117, 65, 91, 51, 57, 39, 44, 40, 118, 98, 109, 97, 42, 104, 85, 37, 60, 45, 83, 82, 70, 96,
        84, 116, 58, 53, 52, 50, 82, 95, 86, 86, 36, 112, 64, 91, 112, 56, 68, 86, 91, 65, 44, 63,
        49, 56, 51, 57, 70, 87, 100, 70, 60, 84, 100, 100, 70, 60, 57, 65, 104, 45, 54, 38, 57,
        116, 87, 111, 68, 108, 104, 93, 38, 49, 83, 112, 71, 77, 113, 62, 84, 105, 49, 79, 42, 72,
        38, 35, 40, 65, 76, 56, 91, 95, 80, 37, 46, 77, 62, 118, 94, 45, 41, 41, 113, 79, 84, 42,
        70, 53, 67, 113, 48, 96, 89, 101, 37, 43, 36, 66, 54, 105, 58, 55, 64, 48, 73, 88, 60, 78,
        43, 84, 43, 48, 77, 108, 77, 66, 80, 81, 42, 86, 106, 62, 83, 115, 68, 60, 85, 52, 74, 72,
        89, 56, 107, 68, 50, 41, 50, 102, 85, 47, 77, 35, 36, 101, 46, 41, 84, 52, 44, 95, 61, 56,
        104, 76, 105, 109, 91, 38, 41, 59, 63, 85, 107, 75, 39, 45, 120, 63, 39, 40, 58, 115, 105,
        73, 102, 76, 60, 36, 112, 70, 77, 96, 105, 60, 63, 37, 87, 40, 109, 71, 68, 72, 77, 37, 62,
        105, 87, 80, 44, 35, 35, 80, 96, 37, 47, 76, 60, 101, 88, 105, 58, 64, 90, 57, 67, 46, 55,
        111, 61, 64, 40, 112, 88, 100, 65, 79, 47, 78, 76, 81, 56, 108, 80, 108, 43, 72, 80, 79,
        81, 97, 56, 119, 68, 56, 61, 94, 71, 108, 80, 97, 56, 84, 75, 73, 49, 67, 106, 104, 115,
        67, 84, 83, 76, 74, 77, 39, 47, 87, 108, 62, 45, 83, 40, 113, 119, 37, 115, 102, 47, 64,
        37, 35, 66, 54, 59, 47, 85, 55, 75, 93, 117, 90, 98, 105, 94, 79, 99, 94, 50, 110, 60, 98,
        104, 80, 109, 85, 107, 77, 119, 62, 37, 116, 60, 41, 39, 109, 69, 86, 69, 39, 39, 110, 96,
        87, 110, 74, 114, 97, 36, 94, 84, 75, 118, 88, 53, 66, 62, 59, 95, 97, 83, 69, 75, 39, 44,
        40, 104, 119, 97, 48, 58, 105, 52, 71, 63, 46, 66, 99, 105, 46, 40, 88, 91, 63, 98, 42, 40,
        36, 44, 61, 45, 110, 60, 46, 81, 37, 96, 40, 88, 61, 63, 43, 64, 65, 109, 42, 74, 115, 48,
        38, 61, 51, 98, 104, 56, 75, 93, 109, 76, 60, 76, 111, 78, 115, 39, 54, 44, 39, 56, 53, 96,
        48, 63, 116, 47, 39, 95, 85, 53, 57, 64, 93, 100, 100, 70, 60, 35, 76, 100, 70, 60, 101,
        87, 100, 70, 60, 79, 117, 78, 47, 52, 53, 114, 89, 60, 45, 76, 64, 38, 35, 43, 102, 109,
        62, 54, 57, 61, 76, 98, 44, 79, 99, 90, 86, 47, 41, 59, 84, 84, 109, 56, 86, 73, 59, 63,
        37, 79, 116, 74, 60, 40, 98, 52, 109, 113, 55, 77, 54, 58, 117, 63, 75, 82, 100, 70, 60,
        103, 82, 64, 50, 76, 61, 70, 78, 85, 45, 60, 98, 91, 40, 57, 99, 47, 77, 76, 51, 109, 59,
        90, 91, 36, 111, 70, 51, 103, 41, 71, 65, 87, 113, 112, 65, 82, 99, 61, 60, 82, 79, 117,
        55, 99, 76, 53, 108, 59, 45, 91, 65, 93, 37, 47, 43, 102, 115, 100, 59, 108, 35, 83, 97,
        102, 84, 47, 102, 42, 87, 93, 48, 61, 79, 39, 36, 40, 84, 98, 60, 91, 41, 42, 64, 101, 55,
        55, 53, 82, 45, 58, 89, 111, 98, 37, 103, 42, 62, 108, 42, 58, 120, 80, 63, 89, 98, 46, 53,
        41, 37, 119, 95, 73, 63, 55, 117, 107, 53, 74, 67, 43, 70, 83, 40, 109, 35, 105, 39, 107,
        46, 39, 97, 48, 105, 41, 57, 60, 55, 98, 39, 102, 115, 39, 53, 57, 104, 113, 36, 42, 53,
        85, 104, 118, 35, 35, 112, 105, 94, 56, 43, 104, 73, 69, 66, 70, 96, 110, 118, 111, 96, 59,
        39, 108, 48, 46, 94, 83, 49, 60, 45, 119, 85, 75, 50, 47, 67, 111, 104, 53, 56, 75, 75,
        104, 76, 106, 77, 61, 83, 79, 42, 114, 102, 79, 96, 43, 113, 67, 96, 87, 45, 79, 110, 46,
        61, 65, 74, 53, 54, 62, 62, 105, 50, 64, 50, 76, 72, 54, 65, 58, 38, 53, 113, 96, 63, 57,
        73, 51, 64, 64, 39, 48, 52, 38, 112, 50, 47, 76, 86, 97, 42, 84, 45, 52, 60, 45, 105, 51,
        59, 77, 57, 85, 118, 90, 100, 43, 78, 55, 62, 98, 42, 101, 73, 119, 103, 58, 67, 67, 41,
        99, 60, 62, 110, 79, 38, 35, 60, 73, 71, 101, 59, 95, 95, 46, 116, 104, 106, 90, 108, 60,
        37, 119, 40, 87, 107, 50, 120, 109, 112, 52, 81, 64, 73, 35, 73, 57, 44, 68, 70, 93, 117,
        55, 45, 80, 61, 46, 45, 95, 58, 89, 74, 93, 97, 83, 64, 86, 63, 54, 42, 67, 40, 41, 100,
        79, 112, 55, 58, 87, 76, 44, 98, 38, 51, 82, 103, 47, 46, 99, 109, 77, 57, 38, 114, 94, 62,
        36, 40, 62, 46, 90, 45, 73, 38, 74, 40, 81, 48, 72, 100, 53, 81, 37, 55, 67, 111, 45, 98,
        96, 45, 99, 60, 78, 40, 54, 114, 64, 105, 112, 43, 65, 117, 114, 75, 60, 109, 56, 54, 81,
        73, 116, 104, 42, 35, 118, 59, 45, 79, 66, 113, 105, 43, 76, 55, 119, 68, 69, 45, 73, 114,
        56, 75, 91, 39, 109, 43, 68, 68, 83, 76, 119, 75, 38, 47, 46, 63, 45, 86, 37, 85, 95, 37,
        51, 58, 113, 75, 78, 117, 36, 95, 98, 42, 66, 45, 107, 112, 55, 78, 97, 68, 39, 81, 100,
        87, 81, 80, 75, 89, 113, 91, 64, 62, 80, 41, 104, 73, 59, 42, 95, 70, 93, 117, 96, 82, 98,
        91, 46, 106, 56, 95, 81, 47, 60, 38, 62, 117, 117, 43, 86, 115, 72, 36, 115, 77, 57, 84,
        65, 37, 63, 41, 40, 118, 109, 74, 56, 48, 41, 44, 80, 55, 69, 62, 41, 116, 106, 68, 37, 50,
        76, 61, 45, 116, 35, 102, 75, 91, 37, 96, 118, 61, 81, 56, 60, 70, 102, 78, 107, 103, 103,
        94, 111, 73, 98, 97, 104, 42, 35, 56, 47, 81, 116, 36, 70, 38, 58, 75, 42, 45, 40, 78, 47,
        39, 43, 49, 118, 77, 66, 44, 117, 40, 41, 45, 97, 46, 86, 85, 85, 42, 35, 91, 101, 37, 103,
        65, 65, 79, 40, 83, 62, 87, 108, 65, 50, 41, 59, 83, 97, 62, 103, 88, 109, 56, 89, 66, 96,
        49, 100, 64, 75, 35, 110, 93, 55, 54, 45, 97, 36, 85, 44, 109, 70, 60, 102, 88, 93, 105,
        100, 113, 100, 41, 60, 51, 44, 93, 74, 55, 74, 109, 87, 52, 96, 54, 93, 117, 107, 115, 61,
        52, 45, 55, 50, 76, 40, 106, 69, 107, 43, 58, 98, 74, 48, 77, 94, 113, 45, 56, 68, 109, 95,
        90, 63, 48, 111, 108, 80, 49, 67, 57, 83, 97, 38, 72, 91, 100, 38, 99, 36, 111, 111, 81,
        85, 106, 93, 69, 120, 100, 42, 51, 90, 77, 64, 45, 87, 71, 87, 50, 37, 115, 39, 44, 66, 45,
        95, 77, 37, 62, 37, 85, 108, 58, 35, 47, 39, 120, 111, 70, 77, 57, 81, 88, 45, 36, 46, 81,
        78, 39, 62, 91, 37, 36, 90, 36, 117, 70, 54, 112, 65, 54, 75, 105, 50, 79, 53, 58, 56, 119,
        42, 118, 80, 49, 60, 45, 49, 96, 91, 71, 44, 41, 45, 109, 35, 62, 48, 96, 80, 38, 35, 101,
        98, 35, 46, 51, 105, 41, 114, 116, 66, 54, 49, 40, 111, 39, 36, 63, 88, 51, 66, 60, 47, 82,
        57, 48, 59, 101, 90, 93, 37, 78, 99, 113, 59, 45, 84, 108, 93, 35, 70, 62, 50, 81, 102,
        116, 94, 97, 101, 95, 53, 116, 75, 76, 57, 77, 85, 101, 57, 98, 42, 115, 76, 69, 81, 57,
        53, 67, 38, 96, 61, 71, 63, 64, 77, 106, 61, 119, 104, 42, 39, 51, 69, 62, 61, 45, 60, 41,
        71, 116, 42, 73, 119, 41, 39, 81, 71, 58, 96, 64, 73, 119, 79, 102, 55, 38, 93, 49, 105,
        39, 83, 48, 49, 66, 43, 69, 118, 47, 78, 97, 99, 35, 57, 83, 59, 61, 59, 89, 81, 112, 103,
        95, 54, 85, 96, 42, 107, 86, 89, 51, 57, 120, 75, 44, 91, 47, 54, 65, 106, 55, 58, 39, 49,
        66, 109, 45, 95, 49, 69, 89, 102, 97, 49, 43, 111, 38, 111, 52, 104, 112, 55, 75, 78, 95,
        81, 40, 79, 108, 73, 111, 64, 83, 37, 59, 106, 86, 100, 110, 48, 39, 49, 60, 86, 99, 53,
        50, 61, 117, 96, 51, 94, 111, 45, 110, 49, 39, 103, 52, 118, 53, 56, 72, 106, 38, 54, 95,
        116, 55, 36, 35, 35, 63, 77, 41, 99, 60, 36, 98, 103, 81, 95, 39, 83, 89, 40, 40, 45, 120,
        107, 65, 35, 89, 40, 44, 112, 39, 72, 57, 114, 73, 86, 89, 45, 98, 44, 39, 37, 98, 67, 80,
        70, 55, 46, 74, 60, 85, 112, 94, 44, 40, 100, 85, 49, 86, 89, 42, 53, 35, 87, 107, 84, 85,
        62, 104, 49, 57, 119, 44, 87, 81, 104, 76, 73, 41, 51, 83, 35, 102, 36, 50, 40, 101, 98,
        44, 106, 114, 42, 98, 59, 51, 86, 119, 93, 42, 55, 78, 72, 37, 36, 99, 52, 86, 115, 44,
        101, 68, 57, 62, 88, 87, 56, 63, 78, 93, 111, 43, 40, 42, 112, 103, 67, 37, 47, 55, 50, 76,
        86, 45, 117, 60, 72, 112, 44, 51, 64, 101, 94, 57, 85, 66, 49, 74, 43, 97, 107, 57, 45, 84,
        78, 47, 109, 104, 75, 80, 103, 43, 65, 74, 89, 100, 36, 77, 108, 118, 65, 70, 95, 106, 67,
        75, 42, 46, 79, 45, 94, 40, 54, 51, 97, 100, 77, 84, 45, 62, 87, 37, 105, 101, 119, 83, 56,
        87, 54, 109, 50, 114, 116, 67, 112, 111, 39, 82, 83, 49, 82, 56, 52, 61, 64, 112, 97, 84,
        75, 116, 41, 62, 61, 37, 38, 49, 91, 41, 42, 118, 112, 39, 117, 43, 120, 44, 86, 114, 119,
        78, 59, 38, 93, 107, 117, 79, 57, 74, 68, 98, 103, 61, 112, 79, 36, 74, 42, 46, 106, 86,
        101, 59, 117, 39, 109, 48, 100, 114, 57, 108, 44, 60, 42, 119, 77, 75, 42, 79, 101, 61,
        103, 56, 108, 86, 95, 75, 69, 66, 70, 107, 79, 39, 111, 85, 93, 94, 61, 91, 45, 55, 57, 50,
        35, 111, 107, 44, 41, 105, 93, 108, 82, 56, 113, 81, 50, 111, 65, 56, 119, 99, 82, 67, 90,
        94, 55, 119, 47, 78, 106, 104, 59, 63, 46, 115, 116, 88, 63, 81, 49, 62, 83, 49, 113, 52,
        66, 110, 36, 41, 75, 49, 60, 45, 114, 71, 100, 79, 39, 36, 87, 114, 46, 76, 99, 46, 67, 71,
        41, 36, 47, 42, 74, 76, 52, 116, 78, 82, 47, 44, 83, 86, 79, 51, 44, 97, 85, 119, 39, 68,
        74, 78, 58, 41, 83, 115, 59, 119, 71, 110, 57, 65, 51, 50, 105, 106, 119, 37, 70, 76, 43,
        90, 48, 70, 110, 46, 85, 57, 59, 114, 101, 83, 113, 41, 98, 109, 73, 51, 50, 85, 61, 61,
        53, 65, 76, 117, 71, 38, 35, 86, 102, 49, 51, 57, 56, 47, 112, 86, 111, 49, 42, 99, 45, 40,
        97, 89, 49, 54, 56, 111, 60, 96, 74, 115, 83, 98, 107, 45, 44, 49, 78, 59, 36, 62, 48, 58,
        79, 85, 97, 115, 40, 51, 58, 56, 90, 57, 55, 50, 76, 83, 102, 70, 56, 101, 98, 61, 99, 45,
        59, 62, 83, 80, 119, 55, 46, 54, 104, 110, 51, 109, 96, 57, 94, 88, 107, 110, 40, 114, 46,
        113, 83, 91, 48, 59, 84, 37, 38, 81, 99, 61, 43, 83, 84, 82, 120, 88, 39, 113, 49, 66, 78,
        107, 51, 38, 42, 101, 117, 50, 59, 38, 56, 113, 36, 38, 120, 62, 81, 35, 81, 55, 94, 84,
        102, 43, 54, 60, 40, 100, 37, 90, 86, 109, 106, 50, 98, 68, 105, 37, 46, 51, 76, 50, 110,
        43, 52, 87, 39, 36, 80, 105, 68, 68, 71, 41, 103, 44, 114, 37, 43, 63, 44, 36, 64, 63, 117,
        111, 117, 53, 116, 83, 101, 50, 97, 78, 95, 65, 81, 85, 42, 60, 104, 96, 101, 45, 71, 73,
        55, 41, 63, 79, 75, 50, 65, 46, 100, 55, 95, 99, 41, 63, 119, 81, 53, 65, 83, 64, 68, 76,
        51, 114, 35, 55, 102, 83, 107, 103, 108, 54, 45, 43, 43, 68, 58, 39, 65, 44, 117, 113, 55,
        83, 118, 108, 66, 36, 112, 99, 112, 72, 39, 113, 51, 110, 48, 35, 95, 37, 100, 89, 35, 120,
        67, 112, 114, 45, 108, 60, 70, 48, 78, 82, 64, 45, 35, 35, 70, 69, 86, 54, 78, 84, 70, 54,
        35, 35, 36, 108, 56, 52, 78, 49, 119, 63, 65, 79, 62, 39, 73, 65, 79, 85, 82, 81, 35, 35,
        86, 94, 70, 118, 45, 88, 70, 98, 71, 77, 55, 70, 108, 40, 78, 60, 51, 68, 104, 76, 71, 70,
        37, 113, 46, 49, 114, 67, 36, 35, 58, 84, 95, 95, 38, 80, 105, 54, 56, 37, 48, 120, 105,
        95, 38, 91, 113, 70, 74, 40, 55, 55, 106, 95, 38, 74, 87, 111, 70, 46, 86, 55, 51, 53, 38,
        84, 44, 91, 82, 42, 58, 120, 70, 82, 42, 75, 53, 62, 62, 35, 96, 98, 87, 45, 63, 52, 78,
        101, 95, 38, 54, 78, 101, 95, 38, 54, 78, 101, 95, 38, 110, 96, 107, 114, 45, 35, 71, 74,
        99, 77, 54, 88, 59, 117, 77, 54, 88, 59, 117, 77, 40, 46, 97, 46, 46, 94, 50, 84, 107, 76,
        37, 111, 82, 40, 35, 59, 117, 46, 84, 37, 102, 65, 114, 37, 52, 116, 74, 56, 38, 62, 60,
        49, 61, 71, 72, 90, 95, 43, 109, 57, 47, 35, 72, 49, 70, 94, 82, 35, 83, 67, 35, 42, 78,
        61, 66, 65, 57, 40, 68, 63, 118, 91, 85, 105, 70, 89, 62, 62, 94, 56, 112, 44, 75, 75, 70,
        46, 87, 93, 76, 50, 57, 117, 76, 107, 76, 108, 117, 47, 43, 52, 84, 60, 88, 111, 73, 66,
        38, 104, 120, 61, 84, 49, 80, 99, 68, 97, 66, 38, 59, 72, 72, 43, 45, 65, 70, 114, 63, 40,
        109, 57, 72, 90, 86, 41, 70, 75, 83, 56, 74, 67, 119, 59, 83, 68, 61, 54, 91, 94, 47, 68,
        90, 85, 76, 96, 69, 85, 68, 102, 93, 71, 71, 108, 71, 38, 62, 119, 36, 41, 70, 46, 47, 94,
        110, 51, 43, 114, 108, 111, 43, 68, 66, 59, 53, 115, 73, 89, 71, 78, 107, 43, 105, 49, 116,
        45, 54, 57, 74, 103, 45, 45, 48, 112, 97, 111, 55, 83, 109, 35, 75, 41, 112, 100, 72, 87,
        38, 59, 76, 117, 68, 78, 72, 64, 72, 62, 35, 47, 88, 45, 84, 73, 40, 59, 80, 62, 35, 44,
        71, 99, 62, 35, 48, 83, 117, 62, 35, 52, 96, 49, 63, 35, 56, 108, 67, 63, 35, 60, 120, 85,
        63, 35, 64, 46, 105, 63, 35, 68, 58, 37, 64, 35, 72, 70, 55, 64, 35, 76, 82, 73, 64, 35,
        80, 95, 91, 64, 35, 84, 107, 110, 64, 35, 88, 119, 42, 65, 35, 93, 45, 61, 65, 35, 97, 57,
        79, 65, 35, 100, 60, 70, 38, 35, 42, 59, 71, 35, 35, 46, 71, 89, 35, 35, 50, 83, 108, 35,
        35, 54, 96, 40, 36, 35, 58, 108, 58, 36, 35, 62, 120, 76, 36, 35, 66, 46, 96, 36, 35, 70,
        58, 114, 36, 35, 74, 70, 46, 37, 35, 78, 82, 64, 37, 35, 82, 95, 82, 37, 35, 86, 107, 101,
        37, 35, 90, 119, 119, 37, 35, 95, 45, 52, 38, 35, 51, 94, 82, 104, 37, 83, 102, 108, 114,
        45, 107, 39, 77, 83, 46, 111, 63, 46, 53, 47, 115, 87, 101, 108, 47, 119, 112, 69, 77, 48,
        37, 51, 39, 47, 49, 41, 75, 94, 102, 49, 45, 100, 62, 71, 50, 49, 38, 118, 40, 51, 53, 62,
        86, 96, 51, 57, 86, 55, 65, 52, 61, 111, 110, 120, 52, 65, 49, 79, 89, 53, 69, 73, 48, 59,
        54, 73, 98, 103, 114, 54, 77, 36, 72, 83, 55, 81, 60, 41, 53, 56, 67, 53, 119, 44, 59, 87,
        111, 65, 42, 35, 91, 37, 84, 42, 35, 96, 49, 103, 42, 35, 100, 61, 35, 43, 35, 104, 73, 53,
        43, 35, 108, 85, 71, 43, 35, 112, 98, 89, 43, 35, 116, 110, 108, 43, 35, 120, 36, 41, 44,
        35, 38, 49, 59, 44, 35, 42, 61, 77, 44, 35, 46, 73, 96, 44, 35, 50, 85, 114, 44, 35, 54,
        98, 46, 45, 35, 59, 119, 91, 72, 35, 105, 81, 116, 65, 35, 109, 94, 48, 66, 35, 113, 106,
        66, 66, 35, 117, 118, 84, 66, 35, 35, 45, 104, 66, 35, 39, 57, 36, 67, 35, 43, 69, 54, 67,
        35, 47, 81, 72, 67, 35, 51, 94, 90, 67, 35, 55, 106, 109, 67, 35, 59, 118, 41, 68, 35, 63,
        44, 60, 68, 35, 67, 56, 78, 68, 35, 71, 68, 97, 68, 35, 75, 80, 115, 68, 35, 79, 93, 47,
        69, 35, 103, 49, 65, 53, 35, 75, 65, 42, 49, 35, 103, 67, 49, 55, 35, 77, 71, 100, 59, 35,
        56, 40, 48, 50, 35, 76, 45, 100, 51, 35, 114, 87, 77, 52, 35, 72, 103, 97, 49, 35, 44, 60,
        119, 48, 35, 84, 46, 106, 60, 35, 79, 35, 39, 50, 35, 67, 89, 78, 49, 35, 113, 97, 94, 58,
        35, 95, 52, 109, 51, 35, 111, 64, 47, 61, 35, 101, 71, 56, 61, 35, 116, 56, 74, 53, 35, 96,
        43, 55, 56, 35, 52, 117, 73, 45, 35, 109, 51, 66, 50, 35, 83, 66, 91, 56, 35, 81, 48, 64,
        56, 35, 105, 91, 42, 57, 35, 105, 79, 110, 56, 35, 49, 78, 109, 59, 35, 94, 115, 78, 57,
        35, 113, 104, 60, 57, 35, 58, 61, 120, 45, 35, 80, 59, 75, 50, 35, 36, 37, 88, 57, 35, 98,
        67, 43, 46, 35, 82, 103, 59, 60, 35, 109, 78, 61, 46, 35, 77, 84, 70, 46, 35, 82, 90, 79,
        46, 35, 50, 63, 41, 52, 35, 89, 35, 40, 47, 35, 91, 41, 49, 47, 35, 98, 59, 76, 47, 35,
        100, 65, 85, 47, 35, 48, 83, 118, 59, 35, 108, 89, 36, 48, 35, 110, 96, 45, 48, 35, 115,
        102, 54, 48, 35, 40, 70, 50, 52, 35, 119, 114, 72, 48, 35, 37, 47, 101, 48, 35, 84, 109,
        68, 60, 35, 37, 74, 83, 77, 70, 111, 118, 101, 58, 67, 84, 66, 69, 88, 73, 58, 60, 101,
        104, 50, 103, 41, 66, 44, 51, 104, 50, 94, 71, 51, 105, 59, 35, 100, 51, 106, 68, 62, 41,
        52, 107, 77, 89, 68, 52, 108, 86, 117, 96, 52, 109, 96, 58, 38, 53, 110, 105, 85, 65, 53,
        64, 40, 65, 53, 66, 65, 49, 93, 80, 66, 66, 58, 120, 108, 66, 67, 67, 61, 50, 67, 68, 76,
        88, 77, 67, 69, 85, 116, 105, 67, 102, 38, 48, 103, 50, 39, 116, 78, 63, 80, 71, 84, 52,
        67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71,
        84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67,
        80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 45, 113, 101, 107, 67, 96,
        46, 57, 107, 69, 103, 94, 43, 70, 36, 107, 119, 86, 105, 70, 74, 84, 66, 38, 53, 75, 84,
        66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53,
        75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66,
        38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53,
        111, 44, 94, 60, 45, 50, 56, 90, 73, 39, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79,
        63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63,
        59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59,
        120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 59, 55, 113,
        45, 35, 108, 76, 89, 73, 58, 120, 118, 68, 61, 35, 0,
    ]
};
#[no_mangle]
pub unsafe fn nk_font_atlas_add_compressed_base85(
    mut atlas: *mut nk_font_atlas,
    mut data_base85: *const libc::c_char,
    mut height: f32,
    mut config: *const nk_font_config,
) -> *mut nk_font {
    let mut compressed_size: libc::c_int = 0;
    let mut compressed_data: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut font: *mut nk_font = 0 as *mut nk_font;
    if atlas.is_null()
        || data_base85.is_null()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
    {
        return 0 as *mut nk_font;
    } else {
        compressed_size = (nk_strlen(data_base85) + 4i32) / 5i32 * 4i32;
        compressed_data = (*atlas).temporary.alloc.expect("non-null function pointer")(
            (*atlas).temporary.userdata,
            0 as *mut libc::c_void,
            compressed_size as nk_size,
        );
        if compressed_data.is_null() {
            return 0 as *mut nk_font;
        } else {
            nk_decode_85(
                compressed_data as *mut libc::c_uchar,
                data_base85 as *const libc::c_uchar,
            );
            font = nk_font_atlas_add_compressed(
                atlas,
                compressed_data,
                compressed_size as nk_size,
                height,
                config,
            );
            (*atlas).temporary.free.expect("non-null function pointer")(
                (*atlas).temporary.userdata,
                compressed_data,
            );
            return font;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_font_atlas_add_compressed(
    mut atlas: *mut nk_font_atlas,
    mut compressed_data: *mut libc::c_void,
    mut compressed_size: nk_size,
    mut height: f32,
    mut config: *const nk_font_config,
) -> *mut nk_font {
    let mut decompressed_size: libc::c_uint = 0;
    let mut decompressed_data: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut cfg: nk_font_config = nk_font_config {
        next: 0 as *mut nk_font_config,
        ttf_blob: 0 as *mut libc::c_void,
        ttf_size: 0,
        ttf_data_owned_by_atlas: 0,
        merge_mode: 0,
        pixel_snap: 0,
        oversample_v: 0,
        oversample_h: 0,
        padding: [0; 3],
        size: 0.,
        coord_type: NK_COORD_UV,
        spacing: nk_vec2 { x: 0., y: 0. },
        range: 0 as *const nk_rune,
        font: 0 as *mut nk_baked_font,
        fallback_glyph: 0,
        n: 0 as *mut nk_font_config,
        p: 0 as *mut nk_font_config,
    };
    if atlas.is_null()
        || compressed_data.is_null()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
    {
        return 0 as *mut nk_font;
    } else {
        decompressed_size = nk_decompress_length(compressed_data as *mut libc::c_uchar);
        decompressed_data = (*atlas).permanent.alloc.expect("non-null function pointer")(
            (*atlas).permanent.userdata,
            0 as *mut libc::c_void,
            decompressed_size as nk_size,
        );
        if decompressed_data.is_null() {
            return 0 as *mut nk_font;
        } else {
            nk_decompress(
                decompressed_data as *mut libc::c_uchar,
                compressed_data as *mut libc::c_uchar,
                compressed_size as libc::c_uint,
            );
            cfg = if !config.is_null() {
                *config
            } else {
                nk_font_config(height)
            };
            cfg.ttf_blob = decompressed_data;
            cfg.ttf_size = decompressed_size as nk_size;
            cfg.size = height;
            cfg.ttf_data_owned_by_atlas = 1i32 as libc::c_uchar;
            return nk_font_atlas_add(atlas, &mut cfg);
        }
    };
}
unsafe fn nk_decompress(
    mut output: *mut libc::c_uchar,
    mut i: *mut libc::c_uchar,
    mut length: libc::c_uint,
) -> libc::c_uint {
    let mut olen: libc::c_uint = 0;
    if ((*i.offset(0isize) as libc::c_int) << 24i32)
        + (((*i.offset((0i32 + 1i32) as isize) as libc::c_int) << 16i32)
            + (((*i.offset((0i32 + 1i32 + 1i32) as isize) as libc::c_int) << 8i32)
                + *i.offset((0i32 + 1i32 + 1i32 + 1i32) as isize) as libc::c_int))
        != 1471938560i32
    {
        return 0i32 as libc::c_uint;
    } else if ((*i.offset(4isize) as libc::c_int) << 24i32)
        + (((*i.offset((4i32 + 1i32) as isize) as libc::c_int) << 16i32)
            + (((*i.offset((4i32 + 1i32 + 1i32) as isize) as libc::c_int) << 8i32)
                + *i.offset((4i32 + 1i32 + 1i32 + 1i32) as isize) as libc::c_int))
        != 0i32
    {
        /* error! stream is > 4GB */
        return 0i32 as libc::c_uint;
    } else {
        olen = nk_decompress_length(i);
        nk__barrier2 = i;
        nk__barrier3 = i.offset(length as isize);
        nk__barrier = output.offset(olen as isize);
        nk__barrier4 = output;
        i = i.offset(16isize);
        nk__dout = output;
        loop {
            let mut old_i: *mut libc::c_uchar = i;
            i = nk_decompress_token(i);
            if i == old_i {
                if *i as libc::c_int == 5i32 && *i.offset(1isize) as libc::c_int == 250i32 {
                    if nk__dout != output.offset(olen as isize) {
                        return 0i32 as libc::c_uint;
                    } else if nk_adler32(1i32 as libc::c_uint, output, olen)
                        != (((*i.offset(2isize) as libc::c_int) << 24i32)
                            + (((*i.offset((2i32 + 1i32) as isize) as libc::c_int) << 16i32)
                                + (((*i.offset((2i32 + 1i32 + 1i32) as isize) as libc::c_int)
                                    << 8i32)
                                    + *i.offset((2i32 + 1i32 + 1i32 + 1i32) as isize)
                                        as libc::c_int))) as libc::c_uint
                    {
                        return 0i32 as libc::c_uint;
                    } else {
                        return olen;
                    }
                } else {
                    return 0i32 as libc::c_uint;
                }
            } else {
                if !(nk__dout > output.offset(olen as isize)) {
                    continue;
                }
                return 0i32 as libc::c_uint;
            }
        }
    };
}
static mut nk__dout: *mut libc::c_uchar =
    unsafe { 0 as *const libc::c_uchar as *mut libc::c_uchar };
unsafe fn nk_adler32(
    mut adler32: libc::c_uint,
    mut buffer: *mut libc::c_uchar,
    mut buflen: libc::c_uint,
) -> libc::c_uint {
    let ADLER_MOD: libc::c_ulong = 65521i32 as libc::c_ulong;
    let mut s1: libc::c_ulong = (adler32 & 65535i32 as libc::c_uint) as libc::c_ulong;
    let mut s2: libc::c_ulong = (adler32 >> 16i32) as libc::c_ulong;
    let mut blocklen: libc::c_ulong = 0;
    let mut i: libc::c_ulong = 0;
    blocklen = buflen.wrapping_rem(5552i32 as libc::c_uint) as libc::c_ulong;
    while 0 != buflen {
        i = 0i32 as libc::c_ulong;
        while i.wrapping_add(7i32 as libc::c_ulong) < blocklen {
            s1 = s1.wrapping_add(*buffer.offset(0isize) as libc::c_ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(1isize) as libc::c_ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(2isize) as libc::c_ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(3isize) as libc::c_ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(4isize) as libc::c_ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(5isize) as libc::c_ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(6isize) as libc::c_ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(7isize) as libc::c_ulong);
            s2 = s2.wrapping_add(s1);
            buffer = buffer.offset(8isize);
            i = i.wrapping_add(8i32 as libc::c_ulong)
        }
        while i < blocklen {
            let fresh51 = buffer;
            buffer = buffer.offset(1);
            s1 = s1.wrapping_add(*fresh51 as libc::c_ulong);
            s2 = s2.wrapping_add(s1);
            i = i.wrapping_add(1)
        }
        s1 = s1.wrapping_rem(ADLER_MOD);
        s2 = s2.wrapping_rem(ADLER_MOD);
        buflen = buflen.wrapping_sub(blocklen as libc::c_uint);
        blocklen = 5552i32 as libc::c_ulong
    }
    return ((s2 << 16i32) as libc::c_uint).wrapping_add(s1 as libc::c_uint);
}
unsafe fn nk_decompress_token(mut i: *mut libc::c_uchar) -> *mut libc::c_uchar {
    if *i as libc::c_int >= 32i32 {
        /* use fewer if's for cases that expand small */
        if *i as libc::c_int >= 128i32 {
            nk__match(
                nk__dout
                    .offset(-(*i.offset(1isize) as libc::c_int as isize))
                    .offset(-1isize),
                (*i.offset(0isize) as libc::c_uint)
                    .wrapping_sub(128i32 as libc::c_uint)
                    .wrapping_add(1i32 as libc::c_uint),
            );
            i = i.offset(2isize)
        } else if *i as libc::c_int >= 64i32 {
            nk__match(
                nk__dout.offset(
                    -((((*i.offset(0isize) as libc::c_int) << 8i32)
                        + *i.offset((0i32 + 1i32) as isize) as libc::c_int
                        - 16384i32 + 1i32) as isize),
                ),
                (*i.offset(2isize) as libc::c_uint).wrapping_add(1i32 as libc::c_uint),
            );
            i = i.offset(3isize)
        } else {
            /* *i >= 0x20 */
            nk__lit(
                i.offset(1isize),
                (*i.offset(0isize) as libc::c_uint)
                    .wrapping_sub(32i32 as libc::c_uint)
                    .wrapping_add(1i32 as libc::c_uint),
            );
            i = i.offset((1i32 + (*i.offset(0isize) as libc::c_int - 32i32 + 1i32)) as isize)
        }
    } else if *i as libc::c_int >= 24i32 {
        nk__match(
            nk__dout.offset(
                -((((*i.offset(0isize) as libc::c_int) << 16i32)
                    + (((*i.offset((0i32 + 1i32) as isize) as libc::c_int) << 8i32)
                        + *i.offset((0i32 + 1i32 + 1i32) as isize) as libc::c_int)
                    - 1572864i32 + 1i32) as libc::c_uint as isize),
            ),
            (*i.offset(3isize) as libc::c_uint).wrapping_add(1i32 as libc::c_uint),
        );
        i = i.offset(4isize)
    } else if *i as libc::c_int >= 16i32 {
        nk__match(
            nk__dout.offset(
                -((((*i.offset(0isize) as libc::c_int) << 16i32)
                    + (((*i.offset((0i32 + 1i32) as isize) as libc::c_int) << 8i32)
                        + *i.offset((0i32 + 1i32 + 1i32) as isize) as libc::c_int)
                    - 1048576i32 + 1i32) as libc::c_uint as isize),
            ),
            ((((*i.offset(3isize) as libc::c_int) << 8i32)
                + *i.offset((3i32 + 1i32) as isize) as libc::c_int) as libc::c_uint)
                .wrapping_add(1i32 as libc::c_uint),
        );
        i = i.offset(5isize)
    } else if *i as libc::c_int >= 8i32 {
        nk__lit(
            i.offset(2isize),
            ((((*i.offset(0isize) as libc::c_int) << 8i32)
                + *i.offset((0i32 + 1i32) as isize) as libc::c_int) as libc::c_uint)
                .wrapping_sub(2048i32 as libc::c_uint)
                .wrapping_add(1i32 as libc::c_uint),
        );
        i = i.offset(
            (2i32 + (((*i.offset(0isize) as libc::c_int) << 8i32)
                + *i.offset((0i32 + 1i32) as isize) as libc::c_int - 2048i32
                + 1i32)) as isize,
        )
    } else if *i as libc::c_int == 7i32 {
        nk__lit(
            i.offset(3isize),
            ((((*i.offset(1isize) as libc::c_int) << 8i32)
                + *i.offset((1i32 + 1i32) as isize) as libc::c_int) as libc::c_uint)
                .wrapping_add(1i32 as libc::c_uint),
        );
        i = i.offset(
            (3i32 + (((*i.offset(1isize) as libc::c_int) << 8i32)
                + *i.offset((1i32 + 1i32) as isize) as libc::c_int
                + 1i32)) as isize,
        )
    } else if *i as libc::c_int == 6i32 {
        nk__match(
            nk__dout.offset(
                -((((*i.offset(1isize) as libc::c_int) << 16i32)
                    + (((*i.offset((1i32 + 1i32) as isize) as libc::c_int) << 8i32)
                        + *i.offset((1i32 + 1i32 + 1i32) as isize) as libc::c_int)
                    + 1i32) as libc::c_uint as isize),
            ),
            (*i.offset(4isize) as libc::c_uint).wrapping_add(1u32),
        );
        i = i.offset(5isize)
    } else if *i as libc::c_int == 4i32 {
        nk__match(
            nk__dout.offset(
                -((((*i.offset(1isize) as libc::c_int) << 16i32)
                    + (((*i.offset((1i32 + 1i32) as isize) as libc::c_int) << 8i32)
                        + *i.offset((1i32 + 1i32 + 1i32) as isize) as libc::c_int)
                    + 1i32) as libc::c_uint as isize),
            ),
            ((((*i.offset(4isize) as libc::c_int) << 8i32)
                + *i.offset((4i32 + 1i32) as isize) as libc::c_int) as libc::c_uint)
                .wrapping_add(1u32),
        );
        i = i.offset(6isize)
    }
    return i;
}
unsafe fn nk__match(mut data: *mut libc::c_uchar, mut length: libc::c_uint) -> () {
    /* INVERSE of memmove... write each byte before copying the next...*/
    if nk__dout.offset(length as isize) > nk__barrier {
        nk__dout = nk__dout.offset(length as isize);
        return;
    } else if data < nk__barrier4 {
        nk__dout = nk__barrier.offset(1isize);
        return;
    } else {
        loop {
            let fresh52 = length;
            length = length.wrapping_sub(1);
            if !(0 != fresh52) {
                break;
            }
            let fresh54 = nk__dout;
            nk__dout = nk__dout.offset(1);
            let fresh53 = data;
            data = data.offset(1);
            *fresh54 = *fresh53
        }
        return;
    };
}
static mut nk__barrier: *mut libc::c_uchar =
    unsafe { 0 as *const libc::c_uchar as *mut libc::c_uchar };
static mut nk__barrier4: *mut libc::c_uchar =
    unsafe { 0 as *const libc::c_uchar as *mut libc::c_uchar };
unsafe fn nk__lit(mut data: *mut libc::c_uchar, mut length: libc::c_uint) -> () {
    if nk__dout.offset(length as isize) > nk__barrier {
        nk__dout = nk__dout.offset(length as isize);
        return;
    } else if data < nk__barrier2 {
        nk__dout = nk__barrier.offset(1isize);
        return;
    } else {
        nk_memcopy(
            nk__dout as *mut libc::c_void,
            data as *const libc::c_void,
            length as nk_size,
        );
        nk__dout = nk__dout.offset(length as isize);
        return;
    };
}
static mut nk__barrier2: *mut libc::c_uchar =
    unsafe { 0 as *const libc::c_uchar as *mut libc::c_uchar };
static mut nk__barrier3: *mut libc::c_uchar =
    unsafe { 0 as *const libc::c_uchar as *mut libc::c_uchar };
unsafe fn nk_decompress_length(mut input: *mut libc::c_uchar) -> libc::c_uint {
    return (((*input.offset(8isize) as libc::c_int) << 24i32)
        + ((*input.offset(9isize) as libc::c_int) << 16i32)
        + ((*input.offset(10isize) as libc::c_int) << 8i32)
        + *input.offset(11isize) as libc::c_int) as libc::c_uint;
}
unsafe fn nk_decode_85(mut dst: *mut libc::c_uchar, mut src: *const libc::c_uchar) -> () {
    while 0 != *src {
        let mut tmp: libc::c_uint = nk_decode_85_byte(*src.offset(0isize) as libc::c_char)
            .wrapping_add(
                (85i32 as libc::c_uint).wrapping_mul(
                    nk_decode_85_byte(*src.offset(1isize) as libc::c_char).wrapping_add(
                        (85i32 as libc::c_uint).wrapping_mul(
                            nk_decode_85_byte(*src.offset(2isize) as libc::c_char).wrapping_add(
                                (85i32 as libc::c_uint).wrapping_mul(
                                    nk_decode_85_byte(*src.offset(3isize) as libc::c_char)
                                        .wrapping_add((85i32 as libc::c_uint).wrapping_mul(
                                            nk_decode_85_byte(*src.offset(4isize) as libc::c_char),
                                        )),
                                ),
                            ),
                        ),
                    ),
                ),
            );
        /* we can't assume little-endianess. */
        *dst.offset(0isize) = (tmp >> 0i32 & 255i32 as libc::c_uint) as libc::c_uchar;
        *dst.offset(1isize) = (tmp >> 8i32 & 255i32 as libc::c_uint) as libc::c_uchar;
        *dst.offset(2isize) = (tmp >> 16i32 & 255i32 as libc::c_uint) as libc::c_uchar;
        *dst.offset(3isize) = (tmp >> 24i32 & 255i32 as libc::c_uint) as libc::c_uchar;
        src = src.offset(5isize);
        dst = dst.offset(4isize)
    }
}
unsafe fn nk_decode_85_byte(mut c: libc::c_char) -> libc::c_uint {
    return (if c as libc::c_int >= '\\' as i32 {
        c as libc::c_int - 36i32
    } else {
        c as libc::c_int - 35i32
    }) as libc::c_uint;
}
#[no_mangle]
pub unsafe fn nk_font_atlas_add_from_memory(
    mut atlas: *mut nk_font_atlas,
    mut memory: *mut libc::c_void,
    mut size: nk_size,
    mut height: f32,
    mut config: *const nk_font_config,
) -> *mut nk_font {
    let mut cfg: nk_font_config = nk_font_config {
        next: 0 as *mut nk_font_config,
        ttf_blob: 0 as *mut libc::c_void,
        ttf_size: 0,
        ttf_data_owned_by_atlas: 0,
        merge_mode: 0,
        pixel_snap: 0,
        oversample_v: 0,
        oversample_h: 0,
        padding: [0; 3],
        size: 0.,
        coord_type: NK_COORD_UV,
        spacing: nk_vec2 { x: 0., y: 0. },
        range: 0 as *const nk_rune,
        font: 0 as *mut nk_baked_font,
        fallback_glyph: 0,
        n: 0 as *mut nk_font_config,
        p: 0 as *mut nk_font_config,
    };
    if atlas.is_null()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
        || memory.is_null()
        || 0 == size
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
    {
        return 0 as *mut nk_font;
    } else {
        cfg = if !config.is_null() {
            *config
        } else {
            nk_font_config(height)
        };
        cfg.ttf_blob = memory;
        cfg.ttf_size = size;
        cfg.size = height;
        cfg.ttf_data_owned_by_atlas = 0i32 as libc::c_uchar;
        return nk_font_atlas_add(atlas, &mut cfg);
    };
}
#[no_mangle]
pub unsafe fn nk_font_atlas_add_from_file(
    mut atlas: *mut nk_font_atlas,
    mut file_path: *const libc::c_char,
    mut height: f32,
    mut config: *const nk_font_config,
) -> *mut nk_font {
    let mut size: nk_size = 0;
    let mut memory: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut cfg: nk_font_config = nk_font_config {
        next: 0 as *mut nk_font_config,
        ttf_blob: 0 as *mut libc::c_void,
        ttf_size: 0,
        ttf_data_owned_by_atlas: 0,
        merge_mode: 0,
        pixel_snap: 0,
        oversample_v: 0,
        oversample_h: 0,
        padding: [0; 3],
        size: 0.,
        coord_type: NK_COORD_UV,
        spacing: nk_vec2 { x: 0., y: 0. },
        range: 0 as *const nk_rune,
        font: 0 as *mut nk_baked_font,
        fallback_glyph: 0,
        n: 0 as *mut nk_font_config,
        p: 0 as *mut nk_font_config,
    };
    if atlas.is_null() || file_path.is_null() {
        return 0 as *mut nk_font;
    } else {
        memory = nk_file_load(file_path, &mut size, &mut (*atlas).permanent);
        if memory.is_null() {
            return 0 as *mut nk_font;
        } else {
            cfg = if !config.is_null() {
                *config
            } else {
                nk_font_config(height)
            };
            cfg.ttf_blob = memory as *mut libc::c_void;
            cfg.ttf_size = size;
            cfg.size = height;
            cfg.ttf_data_owned_by_atlas = 1i32 as libc::c_uchar;
            return nk_font_atlas_add(atlas, &mut cfg);
        }
    };
}
unsafe fn nk_file_load(
    mut path: *const libc::c_char,
    mut siz: *mut nk_size,
    mut alloc: *mut nk_allocator,
) -> *mut libc::c_char {
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fd: *mut FILE = 0 as *mut FILE;
    let mut ret: libc::c_long = 0;
    if path.is_null() || siz.is_null() || alloc.is_null() {
        return 0 as *mut libc::c_char;
    } else {
        fd = libc::fopen(path, b"rb\x00" as *const u8 as *const libc::c_char);
        if fd.is_null() {
            return 0 as *mut libc::c_char;
        } else {
            libc::fseek(fd, 0i32 as libc::c_long, 2i32);
            ret = libc::ftell(fd);
            if ret < 0i32 as libc::c_long {
                libc::fclose(fd);
                return 0 as *mut libc::c_char;
            } else {
                *siz = ret as nk_size;
                libc::fseek(fd, 0i32 as libc::c_long, 0i32);
                buf = (*alloc).alloc.expect("non-null function pointer")(
                    (*alloc).userdata,
                    0 as *mut libc::c_void,
                    *siz,
                ) as *mut libc::c_char;
                if buf.is_null() {
                    libc::fclose(fd);
                    return 0 as *mut libc::c_char;
                } else {
                    *siz = libc::fread(buf as *mut libc::c_void, 1, *siz as usize, fd) as u64;
                    libc::fclose(fd);
                    return buf;
                }
            }
        }
    };
}
#[no_mangle]
pub unsafe fn nk_font_atlas_bake(
    mut atlas: *mut nk_font_atlas,
    mut width: *mut libc::c_int,
    mut height: *mut libc::c_int,
    mut fmt: nk_font_atlas_format,
) -> *const libc::c_void {
    let mut current_block: u64;
    let mut i: libc::c_int = 0i32;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp_size: nk_size = 0;
    let mut img_size: nk_size = 0;
    let mut font_iter: *mut nk_font = 0 as *mut nk_font;
    let mut baker: *mut nk_font_baker = 0 as *mut nk_font_baker;
    if atlas.is_null()
        || width.is_null()
        || height.is_null()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
    {
        return 0 as *const libc::c_void;
    } else {
        /* no font added so just use default font */
        if 0 == (*atlas).font_num {
            (*atlas).default_font =
                nk_font_atlas_add_default(atlas, 13.0f32, 0 as *const nk_font_config)
        }
        if 0 == (*atlas).font_num {
            return 0 as *const libc::c_void;
        } else {
            /* allocate temporary baker memory required for the baking process */
            nk_font_baker_memory(
                &mut tmp_size,
                &mut (*atlas).glyph_count,
                (*atlas).config,
                (*atlas).font_num,
            );
            tmp = (*atlas).temporary.alloc.expect("non-null function pointer")(
                (*atlas).temporary.userdata,
                0 as *mut libc::c_void,
                tmp_size,
            );
            if !tmp.is_null() {
                /* allocate glyph memory for all fonts */
                baker = nk_font_baker(
                    tmp,
                    (*atlas).glyph_count,
                    (*atlas).font_num,
                    &mut (*atlas).temporary,
                );
                (*atlas).glyphs = (*atlas).permanent.alloc.expect("non-null function pointer")(
                    (*atlas).permanent.userdata,
                    0 as *mut libc::c_void,
                    (::std::mem::size_of::<nk_font_glyph>() as libc::c_ulong)
                        .wrapping_mul((*atlas).glyph_count as nk_size),
                ) as *mut nk_font_glyph;
                if !(*atlas).glyphs.is_null() {
                    /* pack all glyphs into a tight fit space */
                    (*atlas).custom.w = (90i32 * 2i32 + 1i32) as libc::c_short;
                    (*atlas).custom.h = (27i32 + 1i32) as libc::c_short;
                    if !(0 == nk_font_bake_pack(
                        baker,
                        &mut img_size,
                        width,
                        height,
                        &mut (*atlas).custom,
                        (*atlas).config,
                        (*atlas).font_num,
                        &mut (*atlas).temporary,
                    )) {
                        /* allocate memory for the baked image font atlas */
                        (*atlas).pixel =
                            (*atlas).temporary.alloc.expect("non-null function pointer")(
                                (*atlas).temporary.userdata,
                                0 as *mut libc::c_void,
                                img_size,
                            );
                        if !(*atlas).pixel.is_null() {
                            /* bake glyphs and custom white pixel into image */
                            nk_font_bake(
                                baker,
                                (*atlas).pixel,
                                *width,
                                *height,
                                (*atlas).glyphs,
                                (*atlas).glyph_count,
                                (*atlas).config,
                                (*atlas).font_num,
                            );
                            nk_font_bake_custom_data(
                                (*atlas).pixel,
                                *width,
                                *height,
                                (*atlas).custom,
                                nk_custom_cursor_data.as_ptr(),
                                90i32,
                                27i32,
                                '.' as i32 as libc::c_char,
                                'X' as i32 as libc::c_char,
                            );
                            if fmt as libc::c_uint
                                == NK_FONT_ATLAS_RGBA32 as libc::c_int as libc::c_uint
                            {
                                /* convert alpha8 image into rgba32 image */
                                let mut img_rgba: *mut libc::c_void =
                                    (*atlas).temporary.alloc.expect("non-null function pointer")(
                                        (*atlas).temporary.userdata,
                                        0 as *mut libc::c_void,
                                        (*width * *height * 4i32) as nk_size,
                                    );
                                if img_rgba.is_null() {
                                    current_block = 10139445023164747751;
                                } else {
                                    nk_font_bake_convert(img_rgba, *width, *height, (*atlas).pixel);
                                    (*atlas).temporary.free.expect("non-null function pointer")(
                                        (*atlas).temporary.userdata,
                                        (*atlas).pixel,
                                    );
                                    (*atlas).pixel = img_rgba;
                                    current_block = 1394248824506584008;
                                }
                            } else {
                                current_block = 1394248824506584008;
                            }
                            match current_block {
                                10139445023164747751 => {}
                                _ => {
                                    (*atlas).tex_width = *width;
                                    (*atlas).tex_height = *height;
                                    /* initialize each font */
                                    font_iter = (*atlas).fonts;
                                    while !font_iter.is_null() {
                                        let mut font: *mut nk_font =
                                            font_iter;
                                        let mut config: *mut nk_font_config =
                                            (*font).config;
                                        nk_font_init(
                                            font,
                                            (*config).size,
                                            (*config).fallback_glyph,
                                            (*atlas).glyphs,
                                            (*config).font,
                                            nk_handle_ptr(0 as *mut libc::c_void),
                                        );
                                        font_iter = (*font_iter).next
                                    }
                                    /* initialize each cursor */
                                    static mut nk_cursor_data: [[nk_vec2; 3]; 7] = unsafe {
                                        [
                                            [
                                                nk_vec2 {
                                                    x: 0i32 as f32,
                                                    y: 3i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 12i32 as f32,
                                                    y: 19i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 0i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                            ],
                                            [
                                                nk_vec2 {
                                                    x: 13i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 7i32 as f32,
                                                    y: 16i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 4i32 as f32,
                                                    y: 8i32 as f32,
                                                },
                                            ],
                                            [
                                                nk_vec2 {
                                                    x: 31i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 23i32 as f32,
                                                    y: 23i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 11i32 as f32,
                                                    y: 11i32 as f32,
                                                },
                                            ],
                                            [
                                                nk_vec2 {
                                                    x: 21i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 9i32 as f32,
                                                    y: 23i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 5i32 as f32,
                                                    y: 11i32 as f32,
                                                },
                                            ],
                                            [
                                                nk_vec2 {
                                                    x: 55i32 as f32,
                                                    y: 18i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 23i32 as f32,
                                                    y: 9i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 11i32 as f32,
                                                    y: 5i32 as f32,
                                                },
                                            ],
                                            [
                                                nk_vec2 {
                                                    x: 73i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 17i32 as f32,
                                                    y: 17i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 9i32 as f32,
                                                    y: 9i32 as f32,
                                                },
                                            ],
                                            [
                                                nk_vec2 {
                                                    x: 55i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 17i32 as f32,
                                                    y: 17i32 as f32,
                                                },
                                                nk_vec2 {
                                                    x: 9i32 as f32,
                                                    y: 9i32 as f32,
                                                },
                                            ],
                                        ]
                                    };
                                    /* Pos      Size        Offset */
                                    i = 0i32;
                                    while i < NK_CURSOR_COUNT as libc::c_int {
                                        let mut cursor: *mut nk_cursor =
                                            &mut (*atlas).cursors[i as usize]
                                                as *mut nk_cursor;
                                        (*cursor).img.w = *width as libc::c_ushort;
                                        (*cursor).img.h = *height as libc::c_ushort;
                                        (*cursor).img.region[0usize] =
                                            ((*atlas).custom.x as libc::c_int as f32
                                                + nk_cursor_data[i as usize][0usize].x)
                                                as libc::c_ushort;
                                        (*cursor).img.region[1usize] =
                                            ((*atlas).custom.y as libc::c_int as f32
                                                + nk_cursor_data[i as usize][0usize].y)
                                                as libc::c_ushort;
                                        (*cursor).img.region[2usize] =
                                            nk_cursor_data[i as usize][1usize].x as libc::c_ushort;
                                        (*cursor).img.region[3usize] =
                                            nk_cursor_data[i as usize][1usize].y as libc::c_ushort;
                                        (*cursor).size = nk_cursor_data[i as usize][1usize];
                                        (*cursor).offset = nk_cursor_data[i as usize][2usize];
                                        i += 1
                                    }
                                    /* free temporary memory */
                                    (*atlas).temporary.free.expect("non-null function pointer")(
                                        (*atlas).temporary.userdata,
                                        tmp,
                                    );
                                    return (*atlas).pixel;
                                }
                            }
                        }
                    }
                }
            }
            /* error so cleanup all memory */
            if !tmp.is_null() {
                (*atlas).temporary.free.expect("non-null function pointer")(
                    (*atlas).temporary.userdata,
                    tmp,
                );
            }
            if !(*atlas).glyphs.is_null() {
                (*atlas).permanent.free.expect("non-null function pointer")(
                    (*atlas).permanent.userdata,
                    (*atlas).glyphs as *mut libc::c_void,
                );
                (*atlas).glyphs = 0 as *mut nk_font_glyph
            }
            if !(*atlas).pixel.is_null() {
                (*atlas).temporary.free.expect("non-null function pointer")(
                    (*atlas).temporary.userdata,
                    (*atlas).pixel,
                );
                (*atlas).pixel = 0 as *mut libc::c_void
            }
            return 0 as *const libc::c_void;
        }
    };
}
unsafe fn nk_font_init(
    mut font: *mut nk_font,
    mut pixel_height: f32,
    mut fallback_codepoint: nk_rune,
    mut glyphs: *mut nk_font_glyph,
    mut baked_font: *const nk_baked_font,
    mut atlas: nk_handle,
) -> () {
    let mut baked: nk_baked_font = nk_baked_font {
        height: 0.,
        ascent: 0.,
        descent: 0.,
        glyph_offset: 0,
        glyph_count: 0,
        ranges: 0 as *const nk_rune,
    };
    if font.is_null() || glyphs.is_null() || baked_font.is_null() {
        return;
    } else {
        baked = *baked_font;
        (*font).fallback = 0 as *const nk_font_glyph;
        (*font).info = baked;
        (*font).scale = pixel_height / (*font).info.height;
        (*font).glyphs =
            &mut *glyphs.offset((*baked_font).glyph_offset as isize) as *mut nk_font_glyph;
        (*font).texture = atlas;
        (*font).fallback_codepoint = fallback_codepoint;
        (*font).fallback = nk_font_find_glyph(font, fallback_codepoint);
        (*font).handle.height = (*font).info.height * (*font).scale;
        (*font).handle.width = Some(nk_font_text_width);
        (*font).handle.userdata.ptr = font as *mut libc::c_void;
        (*font).handle.query = Some(nk_font_query_font_glyph);
        (*font).handle.texture = (*font).texture;
        return;
    };
}
unsafe fn nk_font_query_font_glyph(
    mut handle: nk_handle,
    mut height: f32,
    mut glyph: *mut nk_user_font_glyph,
    mut codepoint: nk_rune,
    mut next_codepoint: nk_rune,
) -> () {
    let mut scale: f32 = 0.;
    let mut g: *const nk_font_glyph = 0 as *const nk_font_glyph;
    let mut font: *mut nk_font = 0 as *mut nk_font;
    font = handle.ptr as *mut nk_font;
    if font.is_null() || glyph.is_null() {
        return;
    } else {
        scale = height / (*font).info.height;
        g = nk_font_find_glyph(font, codepoint);
        (*glyph).width = ((*g).x1 - (*g).x0) * scale;
        (*glyph).height = ((*g).y1 - (*g).y0) * scale;
        (*glyph).offset = nk_vec2((*g).x0 * scale, (*g).y0 * scale);
        (*glyph).xadvance = (*g).xadvance * scale;
        (*glyph).uv[0usize] = nk_vec2((*g).u0, (*g).v0);
        (*glyph).uv[1usize] = nk_vec2((*g).u1, (*g).v1);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_font_find_glyph(
    mut font: *mut nk_font,
    mut unicode: nk_rune,
) -> *const nk_font_glyph {
    let mut i: libc::c_int = 0i32;
    let mut count: libc::c_int = 0;
    let mut total_glyphs: libc::c_int = 0i32;
    let mut glyph: *const nk_font_glyph = 0 as *const nk_font_glyph;
    let mut iter: *const nk_font_config = 0 as *const nk_font_config;
    if font.is_null() || (*font).glyphs.is_null() {
        return 0 as *const nk_font_glyph;
    } else {
        glyph = (*font).fallback;
        iter = (*font).config;
        loop {
            count = nk_range_count((*iter).range);
            i = 0i32;
            while i < count {
                let mut f: nk_rune = *(*iter).range.offset((i * 2i32 + 0i32) as isize);
                let mut t: nk_rune = *(*iter).range.offset((i * 2i32 + 1i32) as isize);
                let mut diff: libc::c_int =
                    t.wrapping_sub(f).wrapping_add(1i32 as libc::c_uint) as libc::c_int;
                if unicode >= f && unicode <= t {
                    return &mut *(*font).glyphs.offset(
                        (total_glyphs as nk_rune).wrapping_add(unicode.wrapping_sub(f)) as isize,
                    ) as *mut nk_font_glyph;
                } else {
                    total_glyphs += diff;
                    i += 1
                }
            }
            iter = (*iter).n;
            if !(iter != (*font).config) {
                break;
            }
        }
        return glyph;
    };
}
unsafe fn nk_range_count(mut range: *const nk_rune) -> libc::c_int {
    let mut iter: *const nk_rune = range;
    if range.is_null() {
        return 0i32;
    } else {
        loop {
            let fresh55 = iter;
            iter = iter.offset(1);
            if !(*fresh55 != 0i32 as libc::c_uint) {
                break;
            }
        }
        return if iter == range {
            0i32
        } else {
            (range.ptr_offset_to(iter).expect("bad offset_to") as libc::c_long
                / 2i32 as libc::c_long) as libc::c_int
        };
    };
}
unsafe fn nk_font_text_width(
    mut handle: nk_handle,
    mut height: f32,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
) -> f32 {
    let mut unicode: nk_rune = 0;
    let mut text_len: libc::c_int = 0i32;
    let mut text_width: f32 = 0i32 as f32;
    let mut glyph_len: libc::c_int = 0i32;
    let mut scale: f32 = 0i32 as f32;
    let mut font: *mut nk_font = handle.ptr as *mut nk_font;
    if font.is_null() || text.is_null() || 0 == len {
        return 0i32 as f32;
    } else {
        scale = height / (*font).info.height;
        text_len = nk_utf_decode(text, &mut unicode, len);
        glyph_len = text_len;
        if 0 == glyph_len {
            return 0i32 as f32;
        } else {
            while text_len <= len && 0 != glyph_len {
                let mut g: *const nk_font_glyph = 0 as *const nk_font_glyph;
                if unicode == 65533i32 as libc::c_uint {
                    break;
                }
                /* query currently drawn glyph information */
                g = nk_font_find_glyph(font, unicode);
                text_width += (*g).xadvance * scale;
                /* offset next glyph */
                glyph_len =
                    nk_utf_decode(text.offset(text_len as isize), &mut unicode, len - text_len);
                text_len += glyph_len
            }
            return text_width;
        }
    };
}
unsafe fn nk_font_bake_convert(
    mut out_memory: *mut libc::c_void,
    mut img_width: libc::c_int,
    mut img_height: libc::c_int,
    mut in_memory: *const libc::c_void,
) -> () {
    let mut n: libc::c_int = 0i32;
    let mut dst: *mut nk_rune = 0 as *mut nk_rune;
    let mut src: *const nk_byte = 0 as *const nk_byte;
    if out_memory.is_null() || in_memory.is_null() || 0 == img_height || 0 == img_width {
        return;
    } else {
        dst = out_memory as *mut nk_rune;
        src = in_memory as *const nk_byte;
        n = img_width * img_height;
        while n > 0i32 {
            let fresh57 = dst;
            dst = dst.offset(1);
            let fresh56 = src;
            src = src.offset(1);
            *fresh57 = (*fresh56 as nk_rune) << 24i32 | 16777215i32 as libc::c_uint;
            n -= 1
        }
        return;
    };
}
static mut nk_custom_cursor_data: [libc::c_char; 2431] = unsafe {
    [
        46, 46, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 88, 88, 88, 88, 88, 88, 45, 32, 32,
        32, 32, 88, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 88, 88, 88, 88, 88, 88, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 88, 88, 88, 88, 88, 88, 46, 46,
        45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 88,
        46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 45, 88, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 88, 45, 45, 45, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 88, 88, 46, 88, 88, 88, 45, 32, 32, 88, 46, 46, 46,
        88, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 88, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 45, 88, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 88, 88, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 88, 32, 32, 45, 32, 88, 46, 46, 46, 46, 46, 88,
        32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32,
        32, 32, 45, 88, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 88, 88, 88, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 45, 32, 32, 88, 46, 88, 32, 32, 45, 88, 46, 46, 46, 46, 46, 46, 46, 88, 45,
        32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32,
        45, 88, 46, 46, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 46, 46, 88, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 45, 32, 32, 88, 46, 88, 32, 32, 45, 88, 88, 88, 88, 46, 88, 88, 88, 88, 45, 32, 32,
        32, 32, 32, 32, 32, 88, 88, 88, 88, 46, 88, 88, 88, 88, 32, 32, 32, 32, 32, 32, 32, 45, 88,
        46, 88, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 88, 46, 88, 32, 88, 46, 88, 88, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32,
        45, 32, 32, 88, 46, 88, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 88, 32,
        32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 88, 46, 88, 32, 32, 32, 88, 88, 88, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 45, 32,
        32, 88, 46, 88, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 88, 88,
        32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32,
        32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46,
        88, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 45, 32, 32, 88,
        46, 88, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32,
        32, 32, 88, 46, 88, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32,
        88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32,
        32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 88,
        32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 88, 46, 46, 88, 32, 32, 32, 32,
        88, 46, 88, 32, 32, 32, 32, 88, 46, 46, 88, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 88,
        46, 88, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32,
        32, 32, 32, 88, 46, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32, 45, 32, 32, 88, 46, 88, 32, 32,
        45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 88, 46, 46, 46, 88, 88, 88, 88, 88, 88, 46,
        88, 88, 88, 88, 88, 88, 46, 46, 46, 88, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46,
        88, 32, 32, 32, 88, 88, 45, 88, 88, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 88, 46, 46, 46, 46, 46, 46, 46, 88, 32, 32, 32, 45, 32, 32, 88, 46, 88, 32, 32, 45, 32,
        32, 32, 88, 46, 88, 32, 32, 32, 45, 88, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88,
        32, 88, 46, 88, 45, 88, 46, 88, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88,
        46, 46, 46, 46, 46, 46, 46, 46, 88, 32, 32, 45, 32, 32, 88, 46, 88, 32, 32, 45, 32, 32, 32,
        88, 46, 88, 32, 32, 32, 45, 32, 88, 46, 46, 46, 88, 88, 88, 88, 88, 88, 46, 88, 88, 88, 88,
        88, 88, 46, 46, 46, 88, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 46,
        46, 88, 45, 88, 46, 46, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 88, 32, 45, 88, 88, 88, 46, 88, 88, 88, 45, 32, 32, 32, 88, 46,
        88, 32, 32, 32, 45, 32, 32, 88, 46, 46, 88, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 88,
        46, 46, 88, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 88,
        45, 88, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 88, 45, 88, 46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 88, 46, 88, 32,
        32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 88, 46, 88,
        32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 88, 45, 88,
        46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 46,
        88, 88, 88, 88, 88, 45, 88, 88, 88, 88, 88, 88, 88, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32,
        45, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 88, 88, 32, 32, 32,
        32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 88, 45, 88, 46, 46,
        46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 88, 46, 46, 88, 32,
        32, 32, 32, 45, 45, 45, 45, 45, 45, 45, 45, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 88, 88, 88, 88, 88, 88, 45, 88, 88, 88, 88, 88,
        88, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 88, 32, 88, 46, 46, 88, 32, 32,
        32, 45, 32, 32, 32, 32, 32, 32, 32, 45, 88, 88, 88, 88, 46, 88, 88, 88, 88, 45, 32, 32, 32,
        32, 32, 32, 32, 88, 88, 88, 88, 46, 88, 88, 88, 88, 32, 32, 32, 32, 32, 32, 32, 45, 45, 45,
        45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
        45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 88, 46, 88, 32, 32, 88, 46, 46, 88, 32, 32, 32, 45,
        32, 32, 32, 32, 32, 32, 32, 45, 88, 46, 46, 46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 32, 32,
        32, 32, 88, 46, 46, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32,
        88, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 45, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 88, 46, 46, 88, 32, 32, 45, 32, 32,
        32, 32, 32, 32, 32, 45, 32, 88, 46, 46, 46, 46, 46, 88, 32, 45, 32, 32, 32, 32, 32, 32, 32,
        32, 88, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 88, 46, 88,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 45, 32, 32, 88, 46, 46, 46, 88, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        88, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 46, 88, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 88, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88,
        46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 88, 46, 46, 46, 88, 88, 88, 88, 88,
        88, 88, 88, 88, 88, 88, 88, 88, 46, 46, 46, 88, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 32, 32, 32, 32, 32, 32, 32, 32, 45,
        32, 32, 32, 32, 88, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 45, 45,
        45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
        45, 45, 45, 45, 45, 45, 45, 45, 45, 32, 88, 46, 46, 46, 88, 88, 88, 88, 88, 88, 88, 88, 88,
        88, 88, 88, 88, 46, 46, 46, 88, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 88, 46, 46, 88, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88,
        46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
        32, 32, 45, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 88, 32,
        32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0,
    ]
};
unsafe fn nk_font_bake_custom_data(
    mut img_memory: *mut libc::c_void,
    mut img_width: libc::c_int,
    mut img_height: libc::c_int,
    mut img_dst: nk_recti,
    mut texture_data_mask: *const libc::c_char,
    mut tex_width: libc::c_int,
    mut tex_height: libc::c_int,
    mut white: libc::c_char,
    mut black: libc::c_char,
) -> () {
    let mut pixels: *mut nk_byte = 0 as *mut nk_byte;
    let mut y: libc::c_int = 0i32;
    let mut x: libc::c_int = 0i32;
    let mut n: libc::c_int = 0i32;
    if img_memory.is_null() || 0 == img_width || 0 == img_height || texture_data_mask.is_null() {
        return;
    } else {
        pixels = img_memory as *mut nk_byte;
        y = 0i32;
        n = 0i32;
        while y < tex_height {
            x = 0i32;
            while x < tex_width {
                let off0: libc::c_int =
                    img_dst.x as libc::c_int + x + (img_dst.y as libc::c_int + y) * img_width;
                let off1: libc::c_int = off0 + 1i32 + tex_width;
                *pixels.offset(off0 as isize) = (if *texture_data_mask.offset(n as isize)
                    as libc::c_int
                    == white as libc::c_int
                {
                    255i32
                } else {
                    0i32
                }) as nk_byte;
                *pixels.offset(off1 as isize) = (if *texture_data_mask.offset(n as isize)
                    as libc::c_int
                    == black as libc::c_int
                {
                    255i32
                } else {
                    0i32
                }) as nk_byte;
                x += 1;
                n += 1
            }
            y += 1
        }
        return;
    };
}
unsafe fn nk_font_bake(
    mut baker: *mut nk_font_baker,
    mut image_memory: *mut libc::c_void,
    mut width: libc::c_int,
    mut height: libc::c_int,
    mut glyphs: *mut nk_font_glyph,
    mut glyphs_count: libc::c_int,
    mut config_list: *const nk_font_config,
    mut font_count: libc::c_int,
) -> () {
    let mut input_i: libc::c_int = 0i32;
    let mut glyph_n: nk_rune = 0i32 as nk_rune;
    let mut config_iter: *const nk_font_config = 0 as *const nk_font_config;
    let mut it: *const nk_font_config = 0 as *const nk_font_config;
    if image_memory.is_null()
        || 0 == width
        || 0 == height
        || config_list.is_null()
        || 0 == font_count
        || glyphs.is_null()
        || 0 == glyphs_count
    {
        return;
    } else {
        /* second font pass: render glyphs */
        nk_zero(
            image_memory,
            (width as nk_size).wrapping_mul(height as nk_size),
        );
        (*baker).spc.pixels = image_memory as *mut libc::c_uchar;
        (*baker).spc.height = height;
        input_i = 0i32;
        config_iter = config_list;
        while input_i < font_count && !config_iter.is_null() {
            it = config_iter;
            loop {
                let mut cfg: *const nk_font_config = it;
                let fresh58 = input_i;
                input_i = input_i + 1;
                let mut tmp: *mut nk_font_bake_data =
                    &mut *(*baker).build.offset(fresh58 as isize) as *mut nk_font_bake_data;
                nk_tt_PackSetOversampling(
                    &mut (*baker).spc,
                    (*cfg).oversample_h as libc::c_uint,
                    (*cfg).oversample_v as libc::c_uint,
                );
                nk_tt_PackFontRangesRenderIntoRects(
                    &mut (*baker).spc,
                    &mut (*tmp).info,
                    (*tmp).ranges,
                    (*tmp).range_count as libc::c_int,
                    (*tmp).rects,
                    &mut (*baker).alloc,
                );
                it = (*it).n;
                if !(it != config_iter) {
                    break;
                }
            }
            config_iter = (*config_iter).next
        }
        nk_tt_PackEnd(&mut (*baker).spc, &mut (*baker).alloc);
        /* third pass: setup font and glyphs */
        input_i = 0i32;
        config_iter = config_list;
        while input_i < font_count && !config_iter.is_null() {
            it = config_iter;
            loop {
                let mut i: nk_size = 0i32 as nk_size;
                let mut char_idx: libc::c_int = 0i32;
                let mut glyph_count: nk_rune = 0i32 as nk_rune;
                let mut cfg_0: *const nk_font_config = it;
                let fresh59 = input_i;
                input_i = input_i + 1;
                let mut tmp_0: *mut nk_font_bake_data =
                    &mut *(*baker).build.offset(fresh59 as isize) as *mut nk_font_bake_data;
                let mut dst_font: *mut nk_baked_font = (*cfg_0).font;
                let mut font_scale: f32 =
                    nk_tt_ScaleForPixelHeight(&mut (*tmp_0).info, (*cfg_0).size);
                let mut unscaled_ascent: libc::c_int = 0;
                let mut unscaled_descent: libc::c_int = 0;
                let mut unscaled_line_gap: libc::c_int = 0;
                nk_tt_GetFontVMetrics(
                    &mut (*tmp_0).info,
                    &mut unscaled_ascent,
                    &mut unscaled_descent,
                    &mut unscaled_line_gap,
                );
                /* fill baked font */
                if 0 == (*cfg_0).merge_mode {
                    (*dst_font).ranges = (*cfg_0).range;
                    (*dst_font).height = (*cfg_0).size;
                    (*dst_font).ascent = unscaled_ascent as f32 * font_scale;
                    (*dst_font).descent = unscaled_descent as f32 * font_scale;
                    (*dst_font).glyph_offset = glyph_n
                }
                /* fill own baked font glyph array */
                i = 0i32 as nk_size;
                while i < (*tmp_0).range_count as libc::c_ulong {
                    let mut range: *mut nk_tt_pack_range =
                        &mut *(*tmp_0).ranges.offset(i as isize) as *mut nk_tt_pack_range;
                    char_idx = 0i32;
                    while char_idx < (*range).num_chars {
                        let mut codepoint: nk_rune = 0i32 as nk_rune;
                        let mut dummy_x: f32 = 0i32 as f32;
                        let mut dummy_y: f32 = 0i32 as f32;
                        let mut q: nk_tt_aligned_quad = nk_tt_aligned_quad {
                            x0: 0.,
                            y0: 0.,
                            s0: 0.,
                            t0: 0.,
                            x1: 0.,
                            y1: 0.,
                            s1: 0.,
                            t1: 0.,
                        };
                        let mut glyph: *mut nk_font_glyph = 0 as *mut nk_font_glyph;
                        /* query glyph bounds from stb_truetype */
                        let mut pc: *const nk_tt_packedchar =
                            &mut *(*range).chardata_for_range.offset(char_idx as isize)
                                as *mut nk_tt_packedchar;
                        if !(0 == (*pc).x0 && 0 == (*pc).x1 && 0 == (*pc).y0 && 0 == (*pc).y1) {
                            codepoint =
                                ((*range).first_unicode_codepoint_in_range + char_idx) as nk_rune;
                            nk_tt_GetPackedQuad(
                                (*range).chardata_for_range,
                                width,
                                height,
                                char_idx,
                                &mut dummy_x,
                                &mut dummy_y,
                                &mut q,
                                0i32,
                            );
                            /* fill own glyph type with data */
                            glyph = &mut *glyphs.offset(
                                (*dst_font)
                                    .glyph_offset
                                    .wrapping_add((*dst_font).glyph_count)
                                    .wrapping_add(glyph_count)
                                    as isize,
                            ) as *mut nk_font_glyph;
                            (*glyph).codepoint = codepoint;
                            (*glyph).x0 = q.x0;
                            (*glyph).y0 = q.y0;
                            (*glyph).x1 = q.x1;
                            (*glyph).y1 = q.y1;
                            (*glyph).y0 += (*dst_font).ascent + 0.5f32;
                            (*glyph).y1 += (*dst_font).ascent + 0.5f32;
                            (*glyph).w = (*glyph).x1 - (*glyph).x0 + 0.5f32;
                            (*glyph).h = (*glyph).y1 - (*glyph).y0;
                            if (*cfg_0).coord_type as libc::c_uint
                                == NK_COORD_PIXEL as libc::c_int as libc::c_uint
                            {
                                (*glyph).u0 = q.s0 * width as f32;
                                (*glyph).v0 = q.t0 * height as f32;
                                (*glyph).u1 = q.s1 * width as f32;
                                (*glyph).v1 = q.t1 * height as f32
                            } else {
                                (*glyph).u0 = q.s0;
                                (*glyph).v0 = q.t0;
                                (*glyph).u1 = q.s1;
                                (*glyph).v1 = q.t1
                            }
                            (*glyph).xadvance = (*pc).xadvance + (*cfg_0).spacing.x;
                            if 0 != (*cfg_0).pixel_snap {
                                (*glyph).xadvance =
                                    ((*glyph).xadvance + 0.5f32) as libc::c_int as f32
                            }
                            glyph_count = glyph_count.wrapping_add(1)
                        }
                        char_idx += 1
                    }
                    i = i.wrapping_add(1)
                }
                (*dst_font).glyph_count = ((*dst_font).glyph_count as libc::c_uint)
                    .wrapping_add(glyph_count) as nk_rune
                    as nk_rune;
                glyph_n = (glyph_n as libc::c_uint).wrapping_add(glyph_count) as nk_rune as nk_rune;
                it = (*it).n;
                if !(it != config_iter) {
                    break;
                }
            }
            config_iter = (*config_iter).next
        }
        return;
    };
}
unsafe fn nk_tt_GetPackedQuad(
    mut chardata: *mut nk_tt_packedchar,
    mut pw: libc::c_int,
    mut ph: libc::c_int,
    mut char_index: libc::c_int,
    mut xpos: *mut f32,
    mut ypos: *mut f32,
    mut q: *mut nk_tt_aligned_quad,
    mut align_to_integer: libc::c_int,
) -> () {
    let mut x: f32 = 0.;
    let mut tx: libc::c_int = 0;
    let mut ty: libc::c_int = 0;
    let mut y: f32 = 0.;
    let mut ipw: f32 = 1.0f32 / pw as f32;
    let mut iph: f32 = 1.0f32 / ph as f32;
    let mut b: *mut nk_tt_packedchar = chardata.offset(char_index as isize);
    if 0 != align_to_integer {
        tx = nk_ifloorf(*xpos + (*b).xoff + 0.5f32);
        ty = nk_ifloorf(*ypos + (*b).yoff + 0.5f32);
        x = tx as f32;
        y = ty as f32;
        (*q).x0 = x;
        (*q).y0 = y;
        (*q).x1 = x + (*b).xoff2 - (*b).xoff;
        (*q).y1 = y + (*b).yoff2 - (*b).yoff
    } else {
        (*q).x0 = *xpos + (*b).xoff;
        (*q).y0 = *ypos + (*b).yoff;
        (*q).x1 = *xpos + (*b).xoff2;
        (*q).y1 = *ypos + (*b).yoff2
    }
    (*q).s0 = (*b).x0 as libc::c_int as f32 * ipw;
    (*q).t0 = (*b).y0 as libc::c_int as f32 * iph;
    (*q).s1 = (*b).x1 as libc::c_int as f32 * ipw;
    (*q).t1 = (*b).y1 as libc::c_int as f32 * iph;
    *xpos += (*b).xadvance;
}
unsafe fn nk_tt_ScaleForPixelHeight(
    mut info: *const nk_tt_fontinfo,
    mut height: f32,
) -> f32 {
    let mut fheight: libc::c_int =
        nk_ttSHORT((*info).data.offset((*info).hhea as isize).offset(4isize)) as libc::c_int
            - nk_ttSHORT((*info).data.offset((*info).hhea as isize).offset(6isize)) as libc::c_int;
    return height / fheight as f32;
}
unsafe fn nk_ttSHORT(mut p: *const nk_byte) -> nk_short {
    return (*p.offset(0isize) as libc::c_int * 256i32 + *p.offset(1isize) as libc::c_int)
        as nk_short;
}
unsafe fn nk_tt_GetFontVMetrics(
    mut info: *const nk_tt_fontinfo,
    mut ascent: *mut libc::c_int,
    mut descent: *mut libc::c_int,
    mut lineGap: *mut libc::c_int,
) -> () {
    if !ascent.is_null() {
        *ascent =
            nk_ttSHORT((*info).data.offset((*info).hhea as isize).offset(4isize)) as libc::c_int
    }
    if !descent.is_null() {
        *descent =
            nk_ttSHORT((*info).data.offset((*info).hhea as isize).offset(6isize)) as libc::c_int
    }
    if !lineGap.is_null() {
        *lineGap =
            nk_ttSHORT((*info).data.offset((*info).hhea as isize).offset(8isize)) as libc::c_int
    };
}
unsafe fn nk_tt_PackEnd(mut spc: *mut nk_tt_pack_context, mut alloc: *mut nk_allocator) -> () {
    (*alloc).free.expect("non-null function pointer")((*alloc).userdata, (*spc).nodes);
    (*alloc).free.expect("non-null function pointer")((*alloc).userdata, (*spc).pack_info);
}
unsafe fn nk_tt_PackFontRangesRenderIntoRects(
    mut spc: *mut nk_tt_pack_context,
    mut info: *mut nk_tt_fontinfo,
    mut ranges: *mut nk_tt_pack_range,
    mut num_ranges: libc::c_int,
    mut rects: *mut nk_rp_rect,
    mut alloc: *mut nk_allocator,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut return_value: libc::c_int = 1i32;
    /* save current values */
    let mut old_h_over: libc::c_int = (*spc).h_oversample as libc::c_int;
    let mut old_v_over: libc::c_int = (*spc).v_oversample as libc::c_int;
    /* rects array must be big enough to accommodate all characters in the given ranges */
    k = 0i32;
    i = 0i32;
    while i < num_ranges {
        let mut fh: f32 = (*ranges.offset(i as isize)).font_size;
        let mut recip_h: f32 = 0.;
        let mut recip_v: f32 = 0.;
        let mut sub_x: f32 = 0.;
        let mut sub_y: f32 = 0.;
        let mut scale: f32 = if fh > 0i32 as f32 {
            nk_tt_ScaleForPixelHeight(info, fh)
        } else {
            nk_tt_ScaleForMappingEmToPixels(info, -fh)
        };
        (*spc).h_oversample = (*ranges.offset(i as isize)).h_oversample as libc::c_uint;
        (*spc).v_oversample = (*ranges.offset(i as isize)).v_oversample as libc::c_uint;
        recip_h = 1.0f32 / (*spc).h_oversample as f32;
        recip_v = 1.0f32 / (*spc).v_oversample as f32;
        sub_x = nk_tt__oversample_shift((*spc).h_oversample as libc::c_int);
        sub_y = nk_tt__oversample_shift((*spc).v_oversample as libc::c_int);
        j = 0i32;
        while j < (*ranges.offset(i as isize)).num_chars {
            let mut r: *mut nk_rp_rect = &mut *rects.offset(k as isize) as *mut nk_rp_rect;
            if 0 != (*r).was_packed {
                let mut bc: *mut nk_tt_packedchar = &mut *(*ranges.offset(i as isize))
                    .chardata_for_range
                    .offset(j as isize)
                    as *mut nk_tt_packedchar;
                let mut advance: libc::c_int = 0;
                let mut lsb: libc::c_int = 0;
                let mut x0: libc::c_int = 0;
                let mut y0: libc::c_int = 0;
                let mut x1: libc::c_int = 0;
                let mut y1: libc::c_int = 0;
                let mut codepoint: libc::c_int =
                    if 0 != (*ranges.offset(i as isize)).first_unicode_codepoint_in_range {
                        (*ranges.offset(i as isize)).first_unicode_codepoint_in_range + j
                    } else {
                        *(*ranges.offset(i as isize))
                            .array_of_unicode_codepoints
                            .offset(j as isize)
                    };
                let mut glyph: libc::c_int = nk_tt_FindGlyphIndex(info, codepoint);
                let mut pad: nk_rp_coord = (*spc).padding as nk_rp_coord;
                /* pad on left and top */
                (*r).x = ((*r).x as libc::c_int + pad as libc::c_int) as nk_rp_coord;
                (*r).y = ((*r).y as libc::c_int + pad as libc::c_int) as nk_rp_coord;
                (*r).w = ((*r).w as libc::c_int - pad as libc::c_int) as nk_rp_coord;
                (*r).h = ((*r).h as libc::c_int - pad as libc::c_int) as nk_rp_coord;
                nk_tt_GetGlyphHMetrics(info, glyph, &mut advance, &mut lsb);
                nk_tt_GetGlyphBitmapBox(
                    info,
                    glyph,
                    scale * (*spc).h_oversample as f32,
                    scale * (*spc).v_oversample as f32,
                    &mut x0,
                    &mut y0,
                    &mut x1,
                    &mut y1,
                );
                nk_tt_MakeGlyphBitmapSubpixel(
                    info,
                    (*spc)
                        .pixels
                        .offset((*r).x as libc::c_int as isize)
                        .offset(((*r).y as libc::c_int * (*spc).stride_in_bytes) as isize),
                    ((*r).w as libc::c_uint)
                        .wrapping_sub((*spc).h_oversample)
                        .wrapping_add(1i32 as libc::c_uint) as libc::c_int,
                    ((*r).h as libc::c_uint)
                        .wrapping_sub((*spc).v_oversample)
                        .wrapping_add(1i32 as libc::c_uint) as libc::c_int,
                    (*spc).stride_in_bytes,
                    scale * (*spc).h_oversample as f32,
                    scale * (*spc).v_oversample as f32,
                    0i32 as f32,
                    0i32 as f32,
                    glyph,
                    alloc,
                );
                if (*spc).h_oversample > 1i32 as libc::c_uint {
                    nk_tt__h_prefilter(
                        (*spc)
                            .pixels
                            .offset((*r).x as libc::c_int as isize)
                            .offset(((*r).y as libc::c_int * (*spc).stride_in_bytes) as isize),
                        (*r).w as libc::c_int,
                        (*r).h as libc::c_int,
                        (*spc).stride_in_bytes,
                        (*spc).h_oversample as libc::c_int,
                    );
                }
                if (*spc).v_oversample > 1i32 as libc::c_uint {
                    nk_tt__v_prefilter(
                        (*spc)
                            .pixels
                            .offset((*r).x as libc::c_int as isize)
                            .offset(((*r).y as libc::c_int * (*spc).stride_in_bytes) as isize),
                        (*r).w as libc::c_int,
                        (*r).h as libc::c_int,
                        (*spc).stride_in_bytes,
                        (*spc).v_oversample as libc::c_int,
                    );
                }
                (*bc).x0 = (*r).x;
                (*bc).y0 = (*r).y;
                (*bc).x1 = ((*r).x as libc::c_int + (*r).w as libc::c_int) as nk_ushort;
                (*bc).y1 = ((*r).y as libc::c_int + (*r).h as libc::c_int) as nk_ushort;
                (*bc).xadvance = scale * advance as f32;
                (*bc).xoff = x0 as f32 * recip_h + sub_x;
                (*bc).yoff = y0 as f32 * recip_v + sub_y;
                (*bc).xoff2 = (x0 as f32 + (*r).w as libc::c_int as f32)
                    * recip_h + sub_x;
                (*bc).yoff2 =
                    (y0 as f32 + (*r).h as libc::c_int as f32) * recip_v + sub_y
            } else {
                return_value = 0i32
            }
            k += 1;
            j += 1
        }
        i += 1
    }
    /* restore original values */
    (*spc).h_oversample = old_h_over as libc::c_uint;
    (*spc).v_oversample = old_v_over as libc::c_uint;
    return return_value;
}
unsafe fn nk_tt_ScaleForMappingEmToPixels(
    mut info: *const nk_tt_fontinfo,
    mut pixels: f32,
) -> f32 {
    let mut unitsPerEm: libc::c_int =
        nk_ttUSHORT((*info).data.offset((*info).head as isize).offset(18isize)) as libc::c_int;
    return pixels / unitsPerEm as f32;
}
unsafe fn nk_ttUSHORT(mut p: *const nk_byte) -> nk_ushort {
    return (*p.offset(0isize) as libc::c_int * 256i32 + *p.offset(1isize) as libc::c_int)
        as nk_ushort;
}
unsafe fn nk_tt__v_prefilter(
    mut pixels: *mut libc::c_uchar,
    mut w: libc::c_int,
    mut h: libc::c_int,
    mut stride_in_bytes: libc::c_int,
    mut kernel_width: libc::c_int,
) -> () {
    let mut buffer: [libc::c_uchar; 8] = [0; 8];
    let mut safe_h: libc::c_int = h - kernel_width;
    let mut j: libc::c_int = 0;
    j = 0i32;
    while j < w {
        let mut i: libc::c_int = 0;
        let mut total: libc::c_uint = 0;
        nk_memset(
            buffer.as_mut_ptr() as *mut libc::c_void,
            0i32,
            kernel_width as nk_size,
        );
        total = 0i32 as libc::c_uint;
        /* make kernel_width a constant in common cases so compiler can optimize out the divide */
        match kernel_width {
            2 => {
                i = 0i32;
                while i <= safe_h {
                    total = total.wrapping_add(
                        (*pixels.offset((i * stride_in_bytes) as isize) as libc::c_int
                            - buffer[(i & 8i32 - 1i32) as usize] as libc::c_int)
                            as libc::c_uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] =
                        *pixels.offset((i * stride_in_bytes) as isize);
                    *pixels.offset((i * stride_in_bytes) as isize) =
                        total.wrapping_div(2i32 as libc::c_uint) as libc::c_uchar;
                    i += 1
                }
            }
            3 => {
                i = 0i32;
                while i <= safe_h {
                    total = total.wrapping_add(
                        (*pixels.offset((i * stride_in_bytes) as isize) as libc::c_int
                            - buffer[(i & 8i32 - 1i32) as usize] as libc::c_int)
                            as libc::c_uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] =
                        *pixels.offset((i * stride_in_bytes) as isize);
                    *pixels.offset((i * stride_in_bytes) as isize) =
                        total.wrapping_div(3i32 as libc::c_uint) as libc::c_uchar;
                    i += 1
                }
            }
            4 => {
                i = 0i32;
                while i <= safe_h {
                    total = total.wrapping_add(
                        (*pixels.offset((i * stride_in_bytes) as isize) as libc::c_int
                            - buffer[(i & 8i32 - 1i32) as usize] as libc::c_int)
                            as libc::c_uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] =
                        *pixels.offset((i * stride_in_bytes) as isize);
                    *pixels.offset((i * stride_in_bytes) as isize) =
                        total.wrapping_div(4i32 as libc::c_uint) as libc::c_uchar;
                    i += 1
                }
            }
            5 => {
                i = 0i32;
                while i <= safe_h {
                    total = total.wrapping_add(
                        (*pixels.offset((i * stride_in_bytes) as isize) as libc::c_int
                            - buffer[(i & 8i32 - 1i32) as usize] as libc::c_int)
                            as libc::c_uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] =
                        *pixels.offset((i * stride_in_bytes) as isize);
                    *pixels.offset((i * stride_in_bytes) as isize) =
                        total.wrapping_div(5i32 as libc::c_uint) as libc::c_uchar;
                    i += 1
                }
            }
            _ => {
                i = 0i32;
                while i <= safe_h {
                    total = total.wrapping_add(
                        (*pixels.offset((i * stride_in_bytes) as isize) as libc::c_int
                            - buffer[(i & 8i32 - 1i32) as usize] as libc::c_int)
                            as libc::c_uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] =
                        *pixels.offset((i * stride_in_bytes) as isize);
                    *pixels.offset((i * stride_in_bytes) as isize) =
                        total.wrapping_div(kernel_width as libc::c_uint) as libc::c_uchar;
                    i += 1
                }
            }
        }
        while i < h {
            total = total.wrapping_sub(buffer[(i & 8i32 - 1i32) as usize] as libc::c_uint);
            *pixels.offset((i * stride_in_bytes) as isize) =
                total.wrapping_div(kernel_width as libc::c_uint) as libc::c_uchar;
            i += 1
        }
        pixels = pixels.offset(1isize);
        j += 1
    }
}
unsafe fn nk_tt__h_prefilter(
    mut pixels: *mut libc::c_uchar,
    mut w: libc::c_int,
    mut h: libc::c_int,
    mut stride_in_bytes: libc::c_int,
    mut kernel_width: libc::c_int,
) -> () {
    let mut buffer: [libc::c_uchar; 8] = [0; 8];
    let mut safe_w: libc::c_int = w - kernel_width;
    let mut j: libc::c_int = 0;
    j = 0i32;
    while j < h {
        let mut i: libc::c_int = 0;
        let mut total: libc::c_uint = 0;
        nk_memset(
            buffer.as_mut_ptr() as *mut libc::c_void,
            0i32,
            kernel_width as nk_size,
        );
        total = 0i32 as libc::c_uint;
        /* make kernel_width a constant in common cases so compiler can optimize out the divide */
        match kernel_width {
            2 => {
                i = 0i32;
                while i <= safe_w {
                    total = total.wrapping_add(
                        (*pixels.offset(i as isize) as libc::c_int
                            - buffer[(i & 8i32 - 1i32) as usize] as libc::c_int)
                            as libc::c_uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] = *pixels.offset(i as isize);
                    *pixels.offset(i as isize) =
                        total.wrapping_div(2i32 as libc::c_uint) as libc::c_uchar;
                    i += 1
                }
            }
            3 => {
                i = 0i32;
                while i <= safe_w {
                    total = total.wrapping_add(
                        (*pixels.offset(i as isize) as libc::c_int
                            - buffer[(i & 8i32 - 1i32) as usize] as libc::c_int)
                            as libc::c_uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] = *pixels.offset(i as isize);
                    *pixels.offset(i as isize) =
                        total.wrapping_div(3i32 as libc::c_uint) as libc::c_uchar;
                    i += 1
                }
            }
            4 => {
                i = 0i32;
                while i <= safe_w {
                    total = total.wrapping_add(
                        (*pixels.offset(i as isize) as libc::c_uint)
                            .wrapping_sub(buffer[(i & 8i32 - 1i32) as usize] as libc::c_uint),
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] = *pixels.offset(i as isize);
                    *pixels.offset(i as isize) =
                        total.wrapping_div(4i32 as libc::c_uint) as libc::c_uchar;
                    i += 1
                }
            }
            5 => {
                i = 0i32;
                while i <= safe_w {
                    total = total.wrapping_add(
                        (*pixels.offset(i as isize) as libc::c_int
                            - buffer[(i & 8i32 - 1i32) as usize] as libc::c_int)
                            as libc::c_uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] = *pixels.offset(i as isize);
                    *pixels.offset(i as isize) =
                        total.wrapping_div(5i32 as libc::c_uint) as libc::c_uchar;
                    i += 1
                }
            }
            _ => {
                i = 0i32;
                while i <= safe_w {
                    total = total.wrapping_add(
                        (*pixels.offset(i as isize) as libc::c_int
                            - buffer[(i & 8i32 - 1i32) as usize] as libc::c_int)
                            as libc::c_uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] = *pixels.offset(i as isize);
                    *pixels.offset(i as isize) =
                        total.wrapping_div(kernel_width as libc::c_uint) as libc::c_uchar;
                    i += 1
                }
            }
        }
        while i < w {
            total = total.wrapping_sub(buffer[(i & 8i32 - 1i32) as usize] as libc::c_uint);
            *pixels.offset(i as isize) =
                total.wrapping_div(kernel_width as libc::c_uint) as libc::c_uchar;
            i += 1
        }
        pixels = pixels.offset(stride_in_bytes as isize);
        j += 1
    }
}
unsafe fn nk_tt_FindGlyphIndex(
    mut info: *const nk_tt_fontinfo,
    mut unicode_codepoint: libc::c_int,
) -> libc::c_int {
    let mut data: *const nk_byte = (*info).data;
    let mut index_map: nk_uint = (*info).index_map as nk_uint;
    let mut format: nk_ushort = nk_ttUSHORT(data.offset(index_map as isize).offset(0isize));
    if format as libc::c_int == 0i32 {
        /* apple byte encoding */
        let mut bytes: nk_int =
            nk_ttUSHORT(data.offset(index_map as isize).offset(2isize)) as nk_int;
        if unicode_codepoint < bytes - 6i32 {
            return *data
                .offset(index_map as isize)
                .offset(6isize)
                .offset(unicode_codepoint as isize) as libc::c_int;
        } else {
            return 0i32;
        }
    } else if format as libc::c_int == 6i32 {
        let mut first: nk_uint =
            nk_ttUSHORT(data.offset(index_map as isize).offset(6isize)) as nk_uint;
        let mut count: nk_uint =
            nk_ttUSHORT(data.offset(index_map as isize).offset(8isize)) as nk_uint;
        if unicode_codepoint as nk_uint >= first
            && (unicode_codepoint as nk_uint) < first.wrapping_add(count)
        {
            return nk_ttUSHORT(
                data.offset(index_map as isize)
                    .offset(10isize)
                    .offset(((unicode_codepoint - first as libc::c_int) * 2i32) as isize),
            ) as libc::c_int;
        } else {
            return 0i32;
        }
    } else if format as libc::c_int == 2i32 {
        /* @TODO: high-byte mapping for japanese/chinese/korean */
        return 0i32;
    } else if format as libc::c_int == 4i32 {
        /* standard mapping for windows fonts: binary search collection of ranges */
        let mut segcount: nk_ushort = (nk_ttUSHORT(data.offset(index_map as isize).offset(6isize))
            as libc::c_int >> 1i32) as nk_ushort;
        let mut searchRange: nk_ushort = (nk_ttUSHORT(
            data.offset(index_map as isize).offset(8isize),
        ) as libc::c_int >> 1i32) as nk_ushort;
        let mut entrySelector: nk_ushort =
            nk_ttUSHORT(data.offset(index_map as isize).offset(10isize));
        let mut rangeShift: nk_ushort = (nk_ttUSHORT(
            data.offset(index_map as isize).offset(12isize),
        ) as libc::c_int >> 1i32) as nk_ushort;
        /* do a binary search of the segments */
        let mut endCount: nk_uint = index_map.wrapping_add(14i32 as libc::c_uint);
        let mut search: nk_uint = endCount;
        if unicode_codepoint > 65535i32 {
            return 0i32;
        } else {
            /* they lie from endCount .. endCount + segCount */
            /* but searchRange is the nearest power of two, so... */
            if unicode_codepoint
                >= nk_ttUSHORT(
                    data.offset(search as isize)
                        .offset((rangeShift as libc::c_int * 2i32) as isize),
                ) as libc::c_int
            {
                search = (search as libc::c_uint)
                    .wrapping_add((rangeShift as libc::c_int * 2i32) as nk_uint)
                    as nk_uint as nk_uint
            }
            /* now decrement to bias correctly to find smallest */
            search =
                (search as libc::c_uint).wrapping_sub(2i32 as libc::c_uint) as nk_uint as nk_uint;
            while 0 != entrySelector {
                let mut end: nk_ushort = 0;
                searchRange = (searchRange as libc::c_int >> 1i32) as nk_ushort;
                end = nk_ttUSHORT(
                    data.offset(search as isize)
                        .offset((searchRange as libc::c_int * 2i32) as isize),
                );
                if unicode_codepoint > end as libc::c_int {
                    search = (search as libc::c_uint)
                        .wrapping_add((searchRange as libc::c_int * 2i32) as nk_uint)
                        as nk_uint as nk_uint
                }
                entrySelector = entrySelector.wrapping_sub(1)
            }
            search =
                (search as libc::c_uint).wrapping_add(2i32 as libc::c_uint) as nk_uint as nk_uint;
            let mut offset: nk_ushort = 0;
            let mut start: nk_ushort = 0;
            let mut item: nk_ushort = (search.wrapping_sub(endCount) >> 1i32) as nk_ushort;
            start = nk_ttUSHORT(
                data.offset(index_map as isize)
                    .offset(14isize)
                    .offset((segcount as libc::c_int * 2i32) as isize)
                    .offset(2isize)
                    .offset((2i32 * item as libc::c_int) as isize),
            );
            if unicode_codepoint < start as libc::c_int {
                return 0i32;
            } else {
                offset = nk_ttUSHORT(
                    data.offset(index_map as isize)
                        .offset(14isize)
                        .offset((segcount as libc::c_int * 6i32) as isize)
                        .offset(2isize)
                        .offset((2i32 * item as libc::c_int) as isize),
                );
                if offset as libc::c_int == 0i32 {
                    return (unicode_codepoint
                        + nk_ttSHORT(
                            data.offset(index_map as isize)
                                .offset(14isize)
                                .offset((segcount as libc::c_int * 4i32) as isize)
                                .offset(2isize)
                                .offset((2i32 * item as libc::c_int) as isize),
                        ) as libc::c_int) as nk_ushort as libc::c_int;
                } else {
                    return nk_ttUSHORT(
                        data.offset(offset as libc::c_int as isize)
                            .offset(((unicode_codepoint - start as libc::c_int) * 2i32) as isize)
                            .offset(index_map as isize)
                            .offset(14isize)
                            .offset((segcount as libc::c_int * 6i32) as isize)
                            .offset(2isize)
                            .offset((2i32 * item as libc::c_int) as isize),
                    ) as libc::c_int;
                }
            }
        }
    } else if format as libc::c_int == 12i32 || format as libc::c_int == 13i32 {
        let mut ngroups: nk_uint = nk_ttULONG(data.offset(index_map as isize).offset(12isize));
        let mut low: nk_int = 0;
        let mut high: nk_int = 0;
        low = 0i32;
        high = ngroups as nk_int;
        /* Binary search the right group. */
        while low < high {
            /* rounds down, so low <= mid < high */
            let mut mid: nk_int = low + (high - low >> 1i32);
            let mut start_char: nk_uint = nk_ttULONG(
                data.offset(index_map as isize)
                    .offset(16isize)
                    .offset((mid * 12i32) as isize),
            );
            let mut end_char: nk_uint = nk_ttULONG(
                data.offset(index_map as isize)
                    .offset(16isize)
                    .offset((mid * 12i32) as isize)
                    .offset(4isize),
            );
            if (unicode_codepoint as nk_uint) < start_char {
                high = mid
            } else if unicode_codepoint as nk_uint > end_char {
                low = mid + 1i32
            } else {
                let mut start_glyph: nk_uint = nk_ttULONG(
                    data.offset(index_map as isize)
                        .offset(16isize)
                        .offset((mid * 12i32) as isize)
                        .offset(8isize),
                );
                if format as libc::c_int == 12i32 {
                    return start_glyph as libc::c_int + unicode_codepoint
                        - start_char as libc::c_int;
                } else {
                    return start_glyph as libc::c_int;
                }
            }
        }
        /* not found */
        return 0i32;
    } else {
        return 0i32;
    };
}
unsafe fn nk_ttULONG(mut p: *const nk_byte) -> nk_uint {
    return (((*p.offset(0isize) as libc::c_int) << 24i32)
        + ((*p.offset(1isize) as libc::c_int) << 16i32)
        + ((*p.offset(2isize) as libc::c_int) << 8i32)
        + *p.offset(3isize) as libc::c_int) as nk_uint;
}
unsafe fn nk_tt_MakeGlyphBitmapSubpixel(
    mut info: *const nk_tt_fontinfo,
    mut output: *mut libc::c_uchar,
    mut out_w: libc::c_int,
    mut out_h: libc::c_int,
    mut out_stride: libc::c_int,
    mut scale_x: f32,
    mut scale_y: f32,
    mut shift_x: f32,
    mut shift_y: f32,
    mut glyph: libc::c_int,
    mut alloc: *mut nk_allocator,
) -> () {
    let mut ix0: libc::c_int = 0;
    let mut iy0: libc::c_int = 0;
    let mut vertices: *mut nk_tt_vertex = 0 as *mut nk_tt_vertex;
    let mut num_verts: libc::c_int = nk_tt_GetGlyphShape(info, alloc, glyph, &mut vertices);
    let mut gbm: nk_tt__bitmap = nk_tt__bitmap {
        w: 0,
        h: 0,
        stride: 0,
        pixels: 0 as *mut libc::c_uchar,
    };
    nk_tt_GetGlyphBitmapBoxSubpixel(
        info,
        glyph,
        scale_x,
        scale_y,
        shift_x,
        shift_y,
        &mut ix0,
        &mut iy0,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
    );
    gbm.pixels = output;
    gbm.w = out_w;
    gbm.h = out_h;
    gbm.stride = out_stride;
    if 0 != gbm.w && 0 != gbm.h {
        nk_tt_Rasterize(
            &mut gbm,
            0.3499999940395355f32,
            vertices,
            num_verts,
            scale_x,
            scale_y,
            shift_x,
            shift_y,
            ix0,
            iy0,
            1i32,
            alloc,
        );
    }
    (*alloc).free.expect("non-null function pointer")(
        (*alloc).userdata,
        vertices as *mut libc::c_void,
    );
}
unsafe fn nk_tt_GetGlyphShape(
    mut info: *const nk_tt_fontinfo,
    mut alloc: *mut nk_allocator,
    mut glyph_index: libc::c_int,
    mut pvertices: *mut *mut nk_tt_vertex,
) -> libc::c_int {
    let mut dx: nk_short = 0;
    let mut dy: nk_short = 0;
    let mut numberOfContours: nk_short = 0;
    let mut endPtsOfContours: *const nk_byte = 0 as *const nk_byte;
    let mut data: *const nk_byte = (*info).data;
    let mut vertices: *mut nk_tt_vertex = 0 as *mut nk_tt_vertex;
    let mut num_vertices: libc::c_int = 0i32;
    let mut g: libc::c_int = nk_tt__GetGlyfOffset(info, glyph_index);
    *pvertices = 0 as *mut nk_tt_vertex;
    if g < 0i32 {
        return 0i32;
    } else {
        numberOfContours = nk_ttSHORT(data.offset(g as isize));
        if numberOfContours as libc::c_int > 0i32 {
            let mut flags: nk_byte = 0i32 as nk_byte;
            let mut flagcount: nk_byte = 0;
            let mut ins: nk_int = 0;
            let mut i: nk_int = 0;
            let mut j: nk_int = 0i32;
            let mut m: nk_int = 0;
            let mut n: nk_int = 0;
            let mut next_move: nk_int = 0;
            let mut was_off: nk_int = 0i32;
            let mut off: nk_int = 0;
            let mut start_off: nk_int = 0i32;
            let mut x: nk_int = 0;
            let mut y: nk_int = 0;
            let mut cx: nk_int = 0;
            let mut cy: nk_int = 0;
            let mut sx: nk_int = 0;
            let mut sy: nk_int = 0;
            let mut scx: nk_int = 0;
            let mut scy: nk_int = 0;
            let mut points: *const nk_byte = 0 as *const nk_byte;
            endPtsOfContours = data.offset(g as isize).offset(10isize);
            ins = nk_ttUSHORT(
                data.offset(g as isize)
                    .offset(10isize)
                    .offset((numberOfContours as libc::c_int * 2i32) as isize),
            ) as nk_int;
            points = data
                .offset(g as isize)
                .offset(10isize)
                .offset((numberOfContours as libc::c_int * 2i32) as isize)
                .offset(2isize)
                .offset(ins as isize);
            n = 1i32 + nk_ttUSHORT(
                endPtsOfContours
                    .offset((numberOfContours as libc::c_int * 2i32) as isize)
                    .offset(-2isize),
            ) as libc::c_int;
            /* a loose bound on how many vertices we might need */
            m = n + 2i32 * numberOfContours as libc::c_int;
            vertices = (*alloc).alloc.expect("non-null function pointer")(
                (*alloc).userdata,
                0 as *mut libc::c_void,
                (m as nk_size).wrapping_mul(::std::mem::size_of::<nk_tt_vertex>() as libc::c_ulong),
            ) as *mut nk_tt_vertex;
            if vertices.is_null() {
                return 0i32;
            } else {
                next_move = 0i32;
                flagcount = 0i32 as nk_byte;
                /* in first pass, we load uninterpreted data into the allocated array */
                /* above, shifted to the end of the array so we won't overwrite it when */
                /* we create our final data starting from the front */
                /* starting offset for uninterpreted data, regardless of how m ends up being calculated */
                off = m - n;
                /* first load flags */
                i = 0i32;
                while i < n {
                    if flagcount as libc::c_int == 0i32 {
                        let fresh60 = points;
                        points = points.offset(1);
                        flags = *fresh60;
                        if 0 != flags as libc::c_int & 8i32 {
                            let fresh61 = points;
                            points = points.offset(1);
                            flagcount = *fresh61
                        }
                    } else {
                        flagcount = flagcount.wrapping_sub(1)
                    }
                    (*vertices.offset((off + i) as isize)).type_0 = flags;
                    i += 1
                }
                /* now load x coordinates */
                x = 0i32;
                i = 0i32;
                while i < n {
                    flags = (*vertices.offset((off + i) as isize)).type_0;
                    if 0 != flags as libc::c_int & 2i32 {
                        let fresh62 = points;
                        points = points.offset(1);
                        dx = *fresh62 as nk_short;
                        /* ??? */
                        x += if 0 != flags as libc::c_int & 16i32 {
                            dx as libc::c_int
                        } else {
                            -(dx as libc::c_int)
                        }
                    } else if 0 == flags as libc::c_int & 16i32 {
                        x = x + (*points.offset(0isize) as libc::c_int * 256i32
                            + *points.offset(1isize) as libc::c_int)
                            as nk_short as libc::c_int;
                        points = points.offset(2isize)
                    }
                    (*vertices.offset((off + i) as isize)).x = x as nk_short;
                    i += 1
                }
                /* now load y coordinates */
                y = 0i32;
                i = 0i32;
                while i < n {
                    flags = (*vertices.offset((off + i) as isize)).type_0;
                    if 0 != flags as libc::c_int & 4i32 {
                        let fresh63 = points;
                        points = points.offset(1);
                        dy = *fresh63 as nk_short;
                        /* ??? */
                        y += if 0 != flags as libc::c_int & 32i32 {
                            dy as libc::c_int
                        } else {
                            -(dy as libc::c_int)
                        }
                    } else if 0 == flags as libc::c_int & 32i32 {
                        y = y + (*points.offset(0isize) as libc::c_int * 256i32
                            + *points.offset(1isize) as libc::c_int)
                            as nk_short as libc::c_int;
                        points = points.offset(2isize)
                    }
                    (*vertices.offset((off + i) as isize)).y = y as nk_short;
                    i += 1
                }
                /* now convert them to our format */
                num_vertices = 0i32;
                scy = 0i32;
                scx = scy;
                cy = scx;
                cx = cy;
                sy = cx;
                sx = sy;
                i = 0i32;
                while i < n {
                    flags = (*vertices.offset((off + i) as isize)).type_0;
                    x = (*vertices.offset((off + i) as isize)).x as nk_int;
                    y = (*vertices.offset((off + i) as isize)).y as nk_int;
                    if next_move == i {
                        if i != 0i32 {
                            num_vertices = nk_tt__close_shape(
                                vertices,
                                num_vertices,
                                was_off,
                                start_off,
                                sx,
                                sy,
                                scx,
                                scy,
                                cx,
                                cy,
                            )
                        }
                        /* now start the new one                */
                        start_off = (0 == flags as libc::c_int & 1i32) as libc::c_int;
                        if 0 != start_off {
                            /* if we start off with an off-curve point, then when we need to find a point on the curve */
                            /* where we can start, and we need to save some state for when we wraparound. */
                            scx = x;
                            scy = y;
                            if 0 == (*vertices.offset((off + i + 1i32) as isize)).type_0
                                as libc::c_int & 1i32
                            {
                                /* next point is also a curve point, so interpolate an on-point curve */
                                sx = x + (*vertices.offset((off + i + 1i32) as isize)).x as nk_int
                                    >> 1i32;
                                sy = y + (*vertices.offset((off + i + 1i32) as isize)).y as nk_int
                                    >> 1i32
                            } else {
                                /* otherwise just use the next point as our start point */
                                sx = (*vertices.offset((off + i + 1i32) as isize)).x as nk_int;
                                sy = (*vertices.offset((off + i + 1i32) as isize)).y as nk_int;
                                /* we're using point i+1 as the starting point, so skip it */
                                i += 1
                            }
                        } else {
                            sx = x;
                            sy = y
                        }
                        let fresh64 = num_vertices;
                        num_vertices = num_vertices + 1;
                        nk_tt_setvertex(
                            &mut *vertices.offset(fresh64 as isize),
                            NK_TT_vmove as libc::c_int as nk_byte,
                            sx,
                            sy,
                            0i32,
                            0i32,
                        );
                        was_off = 0i32;
                        next_move = 1i32
                            + nk_ttUSHORT(endPtsOfContours.offset((j * 2i32) as isize))
                                as libc::c_int;
                        j += 1
                    } else if 0 == flags as libc::c_int & 1i32 {
                        /* if it's a curve */
                        /* two off-curve control points in a row means interpolate an on-curve midpoint */
                        if 0 != was_off {
                            let fresh65 = num_vertices;
                            num_vertices = num_vertices + 1;
                            nk_tt_setvertex(
                                &mut *vertices.offset(fresh65 as isize),
                                NK_TT_vcurve as libc::c_int as nk_byte,
                                cx + x >> 1i32,
                                cy + y >> 1i32,
                                cx,
                                cy,
                            );
                        }
                        cx = x;
                        cy = y;
                        was_off = 1i32
                    } else {
                        if 0 != was_off {
                            let fresh66 = num_vertices;
                            num_vertices = num_vertices + 1;
                            nk_tt_setvertex(
                                &mut *vertices.offset(fresh66 as isize),
                                NK_TT_vcurve as libc::c_int as nk_byte,
                                x,
                                y,
                                cx,
                                cy,
                            );
                        } else {
                            let fresh67 = num_vertices;
                            num_vertices = num_vertices + 1;
                            nk_tt_setvertex(
                                &mut *vertices.offset(fresh67 as isize),
                                NK_TT_vline as libc::c_int as nk_byte,
                                x,
                                y,
                                0i32,
                                0i32,
                            );
                        }
                        was_off = 0i32
                    }
                    i += 1
                }
                num_vertices = nk_tt__close_shape(
                    vertices,
                    num_vertices,
                    was_off,
                    start_off,
                    sx,
                    sy,
                    scx,
                    scy,
                    cx,
                    cy,
                )
            }
        } else if numberOfContours as libc::c_int == -1i32 {
            /* Compound shapes. */
            let mut more: libc::c_int = 1i32;
            let mut comp: *const nk_byte = data.offset(g as isize).offset(10isize);
            num_vertices = 0i32;
            vertices = 0 as *mut nk_tt_vertex;
            while 0 != more {
                let mut flags_0: nk_ushort = 0;
                let mut gidx: nk_ushort = 0;
                let mut comp_num_verts: libc::c_int = 0i32;
                let mut i_0: libc::c_int = 0;
                let mut comp_verts: *mut nk_tt_vertex = 0 as *mut nk_tt_vertex;
                let mut tmp: *mut nk_tt_vertex = 0 as *mut nk_tt_vertex;
                let mut mtx: [f32; 6] = [
                    1i32 as f32,
                    0i32 as f32,
                    0i32 as f32,
                    1i32 as f32,
                    0i32 as f32,
                    0i32 as f32,
                ];
                let mut m_0: f32 = 0.;
                let mut n_0: f32 = 0.;
                flags_0 = nk_ttSHORT(comp) as nk_ushort;
                comp = comp.offset(2isize);
                gidx = nk_ttSHORT(comp) as nk_ushort;
                comp = comp.offset(2isize);
                if 0 != flags_0 as libc::c_int & 2i32 {
                    /* XY values */
                    if 0 != flags_0 as libc::c_int & 1i32 {
                        /* shorts */
                        mtx[4usize] = nk_ttSHORT(comp) as f32;
                        comp = comp.offset(2isize);
                        mtx[5usize] = nk_ttSHORT(comp) as f32;
                        comp = comp.offset(2isize)
                    } else {
                        mtx[4usize] = *(comp as *const libc::c_char) as f32;
                        comp = comp.offset(1isize);
                        mtx[5usize] = *(comp as *const libc::c_char) as f32;
                        comp = comp.offset(1isize)
                    }
                }
                /* @TODO handle matching point */
                if 0 != flags_0 as libc::c_int & 1i32 << 3i32 {
                    /* WE_HAVE_A_SCALE */
                    mtx[3usize] = nk_ttSHORT(comp) as libc::c_int as f32 / 16384.0f32;
                    mtx[0usize] = mtx[3usize];
                    comp = comp.offset(2isize);
                    mtx[2usize] = 0i32 as f32;
                    mtx[1usize] = mtx[2usize]
                } else if 0 != flags_0 as libc::c_int & 1i32 << 6i32 {
                    /* WE_HAVE_AN_X_AND_YSCALE */
                    mtx[0usize] = nk_ttSHORT(comp) as libc::c_int as f32 / 16384.0f32;
                    comp = comp.offset(2isize);
                    mtx[2usize] = 0i32 as f32;
                    mtx[1usize] = mtx[2usize];
                    mtx[3usize] = nk_ttSHORT(comp) as libc::c_int as f32 / 16384.0f32;
                    comp = comp.offset(2isize)
                } else if 0 != flags_0 as libc::c_int & 1i32 << 7i32 {
                    /* WE_HAVE_A_TWO_BY_TWO */
                    mtx[0usize] = nk_ttSHORT(comp) as libc::c_int as f32 / 16384.0f32;
                    comp = comp.offset(2isize);
                    mtx[1usize] = nk_ttSHORT(comp) as libc::c_int as f32 / 16384.0f32;
                    comp = comp.offset(2isize);
                    mtx[2usize] = nk_ttSHORT(comp) as libc::c_int as f32 / 16384.0f32;
                    comp = comp.offset(2isize);
                    mtx[3usize] = nk_ttSHORT(comp) as libc::c_int as f32 / 16384.0f32;
                    comp = comp.offset(2isize)
                }
                /* Find transformation scales. */
                m_0 = nk_sqrt(mtx[0usize] * mtx[0usize] + mtx[1usize] * mtx[1usize]);
                n_0 = nk_sqrt(mtx[2usize] * mtx[2usize] + mtx[3usize] * mtx[3usize]);
                /* Get indexed glyph. */
                comp_num_verts =
                    nk_tt_GetGlyphShape(info, alloc, gidx as libc::c_int, &mut comp_verts);
                if comp_num_verts > 0i32 {
                    /* Transform vertices. */
                    i_0 = 0i32;
                    while i_0 < comp_num_verts {
                        let mut v: *mut nk_tt_vertex =
                            &mut *comp_verts.offset(i_0 as isize) as *mut nk_tt_vertex;
                        let mut x_0: libc::c_short = 0;
                        let mut y_0: libc::c_short = 0;
                        x_0 = (*v).x;
                        y_0 = (*v).y;
                        (*v).x = (m_0 * (mtx[0usize] * x_0 as libc::c_int as f32
                            + mtx[2usize] * y_0 as libc::c_int as f32
                            + mtx[4usize])) as libc::c_short;
                        (*v).y = (n_0 * (mtx[1usize] * x_0 as libc::c_int as f32
                            + mtx[3usize] * y_0 as libc::c_int as f32
                            + mtx[5usize])) as libc::c_short;
                        x_0 = (*v).cx;
                        y_0 = (*v).cy;
                        (*v).cx = (m_0 * (mtx[0usize] * x_0 as libc::c_int as f32
                            + mtx[2usize] * y_0 as libc::c_int as f32
                            + mtx[4usize])) as libc::c_short;
                        (*v).cy = (n_0 * (mtx[1usize] * x_0 as libc::c_int as f32
                            + mtx[3usize] * y_0 as libc::c_int as f32
                            + mtx[5usize])) as libc::c_short;
                        i_0 += 1
                    }
                    /* Append vertices. */
                    tmp = (*alloc).alloc.expect("non-null function pointer")(
                        (*alloc).userdata,
                        0 as *mut libc::c_void,
                        ((num_vertices + comp_num_verts) as nk_size)
                            .wrapping_mul(::std::mem::size_of::<nk_tt_vertex>() as libc::c_ulong),
                    ) as *mut nk_tt_vertex;
                    if tmp.is_null() {
                        if !vertices.is_null() {
                            (*alloc).free.expect("non-null function pointer")(
                                (*alloc).userdata,
                                vertices as *mut libc::c_void,
                            );
                        }
                        if !comp_verts.is_null() {
                            (*alloc).free.expect("non-null function pointer")(
                                (*alloc).userdata,
                                comp_verts as *mut libc::c_void,
                            );
                        }
                        return 0i32;
                    } else {
                        if num_vertices > 0i32 {
                            nk_memcopy(
                                tmp as *mut libc::c_void,
                                vertices as *const libc::c_void,
                                (num_vertices as nk_size).wrapping_mul(::std::mem::size_of::<
                                    nk_tt_vertex,
                                >(
                                )
                                    as libc::c_ulong),
                            );
                        }
                        nk_memcopy(
                            tmp.offset(num_vertices as isize) as *mut libc::c_void,
                            comp_verts as *const libc::c_void,
                            (comp_num_verts as nk_size)
                                .wrapping_mul(
                                    ::std::mem::size_of::<nk_tt_vertex>() as libc::c_ulong
                                ),
                        );
                        if !vertices.is_null() {
                            (*alloc).free.expect("non-null function pointer")(
                                (*alloc).userdata,
                                vertices as *mut libc::c_void,
                            );
                        }
                        vertices = tmp;
                        (*alloc).free.expect("non-null function pointer")(
                            (*alloc).userdata,
                            comp_verts as *mut libc::c_void,
                        );
                        num_vertices += comp_num_verts
                    }
                }
                /* More components ? */
                more = flags_0 as libc::c_int & 1i32 << 5i32
            }
        } else {
            assert!(numberOfContours < 0);
        }
        /* @TODO other compound variations? */
        /* numberOfCounters == 0, do nothing */
        *pvertices = vertices;
        return num_vertices;
    };
}
unsafe fn nk_sqrt(mut x: f32) -> f32 {
    return x * nk_inv_sqrt(x);
}
unsafe fn nk_tt__GetGlyfOffset(
    mut info: *const nk_tt_fontinfo,
    mut glyph_index: libc::c_int,
) -> libc::c_int {
    let mut g1: libc::c_int = 0;
    let mut g2: libc::c_int = 0;
    if glyph_index >= (*info).numGlyphs {
        /* glyph index out of range */
        return -1i32;
    } else if (*info).indexToLocFormat >= 2i32 {
        /* unknown index->glyph map format */
        return -1i32;
    } else {
        if (*info).indexToLocFormat == 0i32 {
            g1 = (*info).glyf
                + nk_ttUSHORT(
                    (*info)
                        .data
                        .offset((*info).loca as isize)
                        .offset((glyph_index * 2i32) as isize),
                ) as libc::c_int * 2i32;
            g2 = (*info).glyf
                + nk_ttUSHORT(
                    (*info)
                        .data
                        .offset((*info).loca as isize)
                        .offset((glyph_index * 2i32) as isize)
                        .offset(2isize),
                ) as libc::c_int * 2i32
        } else {
            g1 = (*info).glyf
                + nk_ttULONG(
                    (*info)
                        .data
                        .offset((*info).loca as isize)
                        .offset((glyph_index * 4i32) as isize),
                ) as libc::c_int;
            g2 = (*info).glyf
                + nk_ttULONG(
                    (*info)
                        .data
                        .offset((*info).loca as isize)
                        .offset((glyph_index * 4i32) as isize)
                        .offset(4isize),
                ) as libc::c_int
        }
        /* if length is 0, return -1 */
        return if g1 == g2 { -1i32 } else { g1 };
    };
}
unsafe fn nk_tt__close_shape(
    mut vertices: *mut nk_tt_vertex,
    mut num_vertices: libc::c_int,
    mut was_off: libc::c_int,
    mut start_off: libc::c_int,
    mut sx: nk_int,
    mut sy: nk_int,
    mut scx: nk_int,
    mut scy: nk_int,
    mut cx: nk_int,
    mut cy: nk_int,
) -> libc::c_int {
    if 0 != start_off {
        if 0 != was_off {
            let fresh68 = num_vertices;
            num_vertices = num_vertices + 1;
            nk_tt_setvertex(
                &mut *vertices.offset(fresh68 as isize),
                NK_TT_vcurve as libc::c_int as nk_byte,
                cx + scx >> 1i32,
                cy + scy >> 1i32,
                cx,
                cy,
            );
        }
        let fresh69 = num_vertices;
        num_vertices = num_vertices + 1;
        nk_tt_setvertex(
            &mut *vertices.offset(fresh69 as isize),
            NK_TT_vcurve as libc::c_int as nk_byte,
            sx,
            sy,
            scx,
            scy,
        );
    } else if 0 != was_off {
        let fresh70 = num_vertices;
        num_vertices = num_vertices + 1;
        nk_tt_setvertex(
            &mut *vertices.offset(fresh70 as isize),
            NK_TT_vcurve as libc::c_int as nk_byte,
            sx,
            sy,
            cx,
            cy,
        );
    } else {
        let fresh71 = num_vertices;
        num_vertices = num_vertices + 1;
        nk_tt_setvertex(
            &mut *vertices.offset(fresh71 as isize),
            NK_TT_vline as libc::c_int as nk_byte,
            sx,
            sy,
            0i32,
            0i32,
        );
    }
    return num_vertices;
}
unsafe fn nk_tt_setvertex(
    mut v: *mut nk_tt_vertex,
    mut type_0: nk_byte,
    mut x: nk_int,
    mut y: nk_int,
    mut cx: nk_int,
    mut cy: nk_int,
) -> () {
    (*v).type_0 = type_0;
    (*v).x = x as nk_short;
    (*v).y = y as nk_short;
    (*v).cx = cx as nk_short;
    (*v).cy = cy as nk_short;
}
unsafe fn nk_tt_Rasterize(
    mut result: *mut nk_tt__bitmap,
    mut flatness_in_pixels: f32,
    mut vertices: *mut nk_tt_vertex,
    mut num_verts: libc::c_int,
    mut scale_x: f32,
    mut scale_y: f32,
    mut shift_x: f32,
    mut shift_y: f32,
    mut x_off: libc::c_int,
    mut y_off: libc::c_int,
    mut invert: libc::c_int,
    mut alloc: *mut nk_allocator,
) -> () {
    let mut scale: f32 = if scale_x > scale_y { scale_y } else { scale_x };
    let mut winding_count: libc::c_int = 0;
    let mut winding_lengths: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut windings: *mut nk_tt__point = nk_tt_FlattenCurves(
        vertices,
        num_verts,
        flatness_in_pixels / scale,
        &mut winding_lengths,
        &mut winding_count,
        alloc,
    );
    if !windings.is_null() {
        nk_tt__rasterize(
            result,
            windings,
            winding_lengths,
            winding_count,
            scale_x,
            scale_y,
            shift_x,
            shift_y,
            x_off,
            y_off,
            invert,
            alloc,
        );
        (*alloc).free.expect("non-null function pointer")(
            (*alloc).userdata,
            winding_lengths as *mut libc::c_void,
        );
        (*alloc).free.expect("non-null function pointer")(
            (*alloc).userdata,
            windings as *mut libc::c_void,
        );
    };
}
unsafe fn nk_tt_FlattenCurves(
    mut vertices: *mut nk_tt_vertex,
    mut num_verts: libc::c_int,
    mut objspace_flatness: f32,
    mut contour_lengths: *mut *mut libc::c_int,
    mut num_contours: *mut libc::c_int,
    mut alloc: *mut nk_allocator,
) -> *mut nk_tt__point {
    let mut current_block: u64;
    /* returns number of contours */
    let mut points: *mut nk_tt__point = 0 as *mut nk_tt__point;
    let mut num_points: libc::c_int = 0i32;
    let mut objspace_flatness_squared: f32 = objspace_flatness * objspace_flatness;
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0i32;
    let mut start: libc::c_int = 0i32;
    let mut pass: libc::c_int = 0;
    /* count how many "moves" there are to get the contour count */
    i = 0i32;
    while i < num_verts {
        if (*vertices.offset(i as isize)).type_0 as libc::c_int == NK_TT_vmove as libc::c_int {
            n += 1
        }
        i += 1
    }
    *num_contours = n;
    if n == 0i32 {
        return 0 as *mut nk_tt__point;
    } else {
        *contour_lengths = (*alloc).alloc.expect("non-null function pointer")(
            (*alloc).userdata,
            0 as *mut libc::c_void,
            (::std::mem::size_of::<libc::c_int>() as libc::c_ulong).wrapping_mul(n as nk_size),
        ) as *mut libc::c_int;
        if (*contour_lengths).is_null() {
            *num_contours = 0i32;
            return 0 as *mut nk_tt__point;
        } else {
            /* make two passes through the points so we don't need to realloc */
            pass = 0i32;
            loop {
                if !(pass < 2i32) {
                    current_block = 6483416627284290920;
                    break;
                }
                let mut x: f32 = 0i32 as f32;
                let mut y: f32 = 0i32 as f32;
                if pass == 1i32 {
                    points = (*alloc).alloc.expect("non-null function pointer")(
                        (*alloc).userdata,
                        0 as *mut libc::c_void,
                        (num_points as nk_size)
                            .wrapping_mul(::std::mem::size_of::<nk_tt__point>() as libc::c_ulong),
                    ) as *mut nk_tt__point;
                    if points.is_null() {
                        current_block = 13292377088154198382;
                        break;
                    }
                }
                num_points = 0i32;
                n = -1i32;
                i = 0i32;
                while i < num_verts {
                    match (*vertices.offset(i as isize)).type_0 as libc::c_int {
                        1 => {
                            /* start the next contour */
                            if n >= 0i32 {
                                *(*contour_lengths).offset(n as isize) = num_points - start
                            }
                            n += 1;
                            start = num_points;
                            x = (*vertices.offset(i as isize)).x as f32;
                            y = (*vertices.offset(i as isize)).y as f32;
                            let fresh72 = num_points;
                            num_points = num_points + 1;
                            nk_tt__add_point(points, fresh72, x, y);
                        }
                        2 => {
                            x = (*vertices.offset(i as isize)).x as f32;
                            y = (*vertices.offset(i as isize)).y as f32;
                            let fresh73 = num_points;
                            num_points = num_points + 1;
                            nk_tt__add_point(points, fresh73, x, y);
                        }
                        3 => {
                            nk_tt__tesselate_curve(
                                points,
                                &mut num_points,
                                x,
                                y,
                                (*vertices.offset(i as isize)).cx as f32,
                                (*vertices.offset(i as isize)).cy as f32,
                                (*vertices.offset(i as isize)).x as f32,
                                (*vertices.offset(i as isize)).y as f32,
                                objspace_flatness_squared,
                                0i32,
                            );
                            x = (*vertices.offset(i as isize)).x as f32;
                            y = (*vertices.offset(i as isize)).y as f32
                        }
                        _ => {}
                    }
                    i += 1
                }
                *(*contour_lengths).offset(n as isize) = num_points - start;
                pass += 1
            }
            match current_block {
                13292377088154198382 => {
                    (*alloc).free.expect("non-null function pointer")(
                        (*alloc).userdata,
                        points as *mut libc::c_void,
                    );
                    (*alloc).free.expect("non-null function pointer")(
                        (*alloc).userdata,
                        *contour_lengths as *mut libc::c_void,
                    );
                    *contour_lengths = 0 as *mut libc::c_int;
                    *num_contours = 0i32;
                    return 0 as *mut nk_tt__point;
                }
                _ => return points,
            }
        }
    };
}
unsafe fn nk_tt__tesselate_curve(
    mut points: *mut nk_tt__point,
    mut num_points: *mut libc::c_int,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
    mut x2: f32,
    mut y2: f32,
    mut objspace_flatness_squared: f32,
    mut n: libc::c_int,
) -> libc::c_int {
    /* tesselate until threshold p is happy...
     * @TODO warped to compensate for non-linear stretching */
    /* midpoint */
    let mut mx: f32 = (x0 + 2i32 as f32 * x1 + x2) / 4i32 as f32;
    let mut my: f32 = (y0 + 2i32 as f32 * y1 + y2) / 4i32 as f32;
    /* versus directly drawn line */
    let mut dx: f32 = (x0 + x2) / 2i32 as f32 - mx;
    let mut dy: f32 = (y0 + y2) / 2i32 as f32 - my;
    /* 65536 segments on one curve better be enough! */
    if n > 16i32 {
        return 1i32;
    } else {
        /* half-pixel error allowed... need to be smaller if AA */
        if dx * dx + dy * dy > objspace_flatness_squared {
            nk_tt__tesselate_curve(
                points,
                num_points,
                x0,
                y0,
                (x0 + x1) / 2.0f32,
                (y0 + y1) / 2.0f32,
                mx,
                my,
                objspace_flatness_squared,
                n + 1i32,
            );
            nk_tt__tesselate_curve(
                points,
                num_points,
                mx,
                my,
                (x1 + x2) / 2.0f32,
                (y1 + y2) / 2.0f32,
                x2,
                y2,
                objspace_flatness_squared,
                n + 1i32,
            );
        } else {
            nk_tt__add_point(points, *num_points, x2, y2);
            *num_points = *num_points + 1i32
        }
        return 1i32;
    };
}
unsafe fn nk_tt__add_point(
    mut points: *mut nk_tt__point,
    mut n: libc::c_int,
    mut x: f32,
    mut y: f32,
) -> () {
    if points.is_null() {
        /* during first pass, it's unallocated */
        return;
    } else {
        (*points.offset(n as isize)).x = x;
        (*points.offset(n as isize)).y = y;
        return;
    };
}
unsafe fn nk_tt__rasterize(
    mut result: *mut nk_tt__bitmap,
    mut pts: *mut nk_tt__point,
    mut wcount: *mut libc::c_int,
    mut windings: libc::c_int,
    mut scale_x: f32,
    mut scale_y: f32,
    mut shift_x: f32,
    mut shift_y: f32,
    mut off_x: libc::c_int,
    mut off_y: libc::c_int,
    mut invert: libc::c_int,
    mut alloc: *mut nk_allocator,
) -> () {
    let mut y_scale_inv: f32 = if 0 != invert { -scale_y } else { scale_y };
    let mut e: *mut nk_tt__edge = 0 as *mut nk_tt__edge;
    let mut n: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut m: libc::c_int = 0;
    let mut vsubsample: libc::c_int = 1i32;
    /* vsubsample should divide 255 evenly; otherwise we won't reach full opacity */
    /* now we have to blow out the windings into explicit edge lists */
    n = 0i32;
    i = 0i32;
    while i < windings {
        n += *wcount.offset(i as isize);
        i += 1
    }
    e = (*alloc).alloc.expect("non-null function pointer")(
        (*alloc).userdata,
        0 as *mut libc::c_void,
        (::std::mem::size_of::<nk_tt__edge>() as libc::c_ulong).wrapping_mul((n + 1i32) as nk_size),
    ) as *mut nk_tt__edge;
    if e.is_null() {
        return;
    } else {
        n = 0i32;
        m = 0i32;
        i = 0i32;
        while i < windings {
            let mut p: *mut nk_tt__point = pts.offset(m as isize);
            m += *wcount.offset(i as isize);
            j = *wcount.offset(i as isize) - 1i32;
            k = 0i32;
            while k < *wcount.offset(i as isize) {
                let mut a: libc::c_int = k;
                let mut b: libc::c_int = j;
                /* skip the edge if horizontal */
                if !((*p.offset(j as isize)).y == (*p.offset(k as isize)).y) {
                    /* add edge from j to k to the list */
                    (*e.offset(n as isize)).invert = 0i32;
                    if 0 != if 0 != invert {
                        ((*p.offset(j as isize)).y > (*p.offset(k as isize)).y) as libc::c_int
                    } else {
                        ((*p.offset(j as isize)).y < (*p.offset(k as isize)).y) as libc::c_int
                    } {
                        (*e.offset(n as isize)).invert = 1i32;
                        a = j;
                        b = k
                    }
                    (*e.offset(n as isize)).x0 = (*p.offset(a as isize)).x * scale_x + shift_x;
                    (*e.offset(n as isize)).y0 = ((*p.offset(a as isize)).y * y_scale_inv + shift_y)
                        * vsubsample as f32;
                    (*e.offset(n as isize)).x1 = (*p.offset(b as isize)).x * scale_x + shift_x;
                    (*e.offset(n as isize)).y1 = ((*p.offset(b as isize)).y * y_scale_inv + shift_y)
                        * vsubsample as f32;
                    n += 1
                }
                let fresh74 = k;
                k = k + 1;
                j = fresh74
            }
            i += 1
        }
        /* now sort the edges by their highest point (should snap to integer, and then by x) */
        /*STBTT_sort(e, n, sizeof(e[0]), nk_tt__edge_compare); */
        nk_tt__sort_edges(e, n);
        /* now, traverse the scanlines and find the intersections on each scanline, use xor winding rule */
        nk_tt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, alloc);
        (*alloc).free.expect("non-null function pointer")(
            (*alloc).userdata,
            e as *mut libc::c_void,
        );
        return;
    };
}
unsafe fn nk_tt__rasterize_sorted_edges(
    mut result: *mut nk_tt__bitmap,
    mut e: *mut nk_tt__edge,
    mut n: libc::c_int,
    mut vsubsample: libc::c_int,
    mut off_x: libc::c_int,
    mut off_y: libc::c_int,
    mut alloc: *mut nk_allocator,
) -> () {
    let mut z_1: *mut nk_tt__active_edge = 0 as *mut nk_tt__active_edge;
    /* directly AA rasterize edges w/o supersampling */
    let mut hh: nk_tt__hheap = nk_tt__hheap {
        alloc: nk_allocator {
            userdata: nk_handle {
                ptr: 0 as *mut libc::c_void,
            },
            alloc: None,
            free: None,
        },
        head: 0 as *mut nk_tt__hheap_chunk,
        first_free: 0 as *mut libc::c_void,
        num_remaining_in_head_chunk: 0,
    };
    let mut active: *mut nk_tt__active_edge = 0 as *mut nk_tt__active_edge;
    let mut y: libc::c_int = 0;
    let mut j: libc::c_int = 0i32;
    let mut i: libc::c_int = 0;
    let mut scanline_data: [f32; 129] = [0.; 129];
    let mut scanline: *mut f32 = 0 as *mut f32;
    let mut scanline2: *mut f32 = 0 as *mut f32;
    nk_zero(
        &mut hh as *mut nk_tt__hheap as *mut libc::c_void,
        ::std::mem::size_of::<nk_tt__hheap>() as libc::c_ulong,
    );
    hh.alloc = *alloc;
    if (*result).w > 64i32 {
        scanline = (*alloc).alloc.expect("non-null function pointer")(
            (*alloc).userdata,
            0 as *mut libc::c_void,
            (((*result).w * 2i32 + 1i32) as nk_size)
                .wrapping_mul(::std::mem::size_of::<f32>() as libc::c_ulong),
        ) as *mut f32
    } else {
        scanline = scanline_data.as_mut_ptr()
    }
    scanline2 = scanline.offset((*result).w as isize);
    y = off_y;
    (*e.offset(n as isize)).y0 = (off_y + (*result).h) as f32 + 1i32 as f32;
    while j < (*result).h {
        /* find center of pixel for this scanline */
        let mut scan_y_top: f32 = y as f32 + 0.0f32;
        let mut scan_y_bottom: f32 = y as f32 + 1.0f32;
        let mut step: *mut *mut nk_tt__active_edge = &mut active;
        nk_memset(
            scanline as *mut libc::c_void,
            0i32,
            ((*result).w as nk_size)
                .wrapping_mul(::std::mem::size_of::<f32>() as libc::c_ulong),
        );
        nk_memset(
            scanline2 as *mut libc::c_void,
            0i32,
            (((*result).w + 1i32) as nk_size)
                .wrapping_mul(::std::mem::size_of::<f32>() as libc::c_ulong),
        );
        /* update all active edges; */
        /* remove all active edges that terminate before the top of this scanline */
        while !(*step).is_null() {
            let mut z: *mut nk_tt__active_edge = *step;
            if (*z).ey <= scan_y_top {
                /* delete from list */
                *step = (*z).next;
                (*z).direction = 0i32 as f32;
                nk_tt__hheap_free(&mut hh, z as *mut libc::c_void);
            } else {
                step = &mut (**step).next as *mut *mut nk_tt__active_edge
            }
        }
        /* insert all edges that start before the bottom of this scanline */
        while (*e).y0 <= scan_y_bottom {
            if (*e).y0 != (*e).y1 {
                let mut z_0: *mut nk_tt__active_edge =
                    nk_tt__new_active(&mut hh, e, off_x, scan_y_top);
                if !z_0.is_null() {
                    /* insert at front */
                    (*z_0).next = active;
                    active = z_0
                }
            }
            e = e.offset(1isize)
        }
        /* now process all active edges */
        if !active.is_null() {
            nk_tt__fill_active_edges_new(
                scanline,
                scanline2.offset(1isize),
                (*result).w,
                active,
                scan_y_top,
            );
        }
        let mut sum: f32 = 0i32 as f32;
        i = 0i32;
        while i < (*result).w {
            let mut k: f32 = 0.;
            let mut m: libc::c_int = 0;
            sum += *scanline2.offset(i as isize);
            k = *scanline.offset(i as isize) + sum;
            k = if k < 0i32 as f32 { -k } else { k } * 255.0f32 + 0.5f32;
            m = k as libc::c_int;
            if m > 255i32 {
                m = 255i32
            }
            *(*result).pixels.offset((j * (*result).stride + i) as isize) = m as libc::c_uchar;
            i += 1
        }
        /* advance all the edges */
        step = &mut active;
        while !(*step).is_null() {
            z_1 = *step;
            /* advance to position for current scanline */
            (*z_1).fx += (*z_1).fdx;
            /* advance through list */
            step = &mut (**step).next as *mut *mut nk_tt__active_edge
        }
        y += 1;
        j += 1
    }
    nk_tt__hheap_cleanup(&mut hh);
    if scanline != scanline_data.as_mut_ptr() {
        (*alloc).free.expect("non-null function pointer")(
            (*alloc).userdata,
            scanline as *mut libc::c_void,
        );
    };
}
unsafe fn nk_tt__hheap_cleanup(mut hh: *mut nk_tt__hheap) -> () {
    let mut c: *mut nk_tt__hheap_chunk = (*hh).head;
    while !c.is_null() {
        let mut n: *mut nk_tt__hheap_chunk = (*c).next;
        (*hh).alloc.free.expect("non-null function pointer")(
            (*hh).alloc.userdata,
            c as *mut libc::c_void,
        );
        c = n
    }
}
unsafe fn nk_tt__fill_active_edges_new(
    mut scanline: *mut f32,
    mut scanline_fill: *mut f32,
    mut len: libc::c_int,
    mut e: *mut nk_tt__active_edge,
    mut y_top: f32,
) -> () {
    let mut x: libc::c_int = 0;
    let mut height: f32 = 0.;
    let mut t: f32 = 0.;
    let mut y_bottom: f32 = y_top + 1i32 as f32;
    while !e.is_null() {
        /* brute force every pixel */
        /* compute intersection points with top & bottom */
        if (*e).fdx == 0i32 as f32 {
            let mut x0: f32 = (*e).fx;
            if x0 < len as f32 {
                if x0 >= 0i32 as f32 {
                    nk_tt__handle_clipped_edge(
                        scanline,
                        x0 as libc::c_int,
                        e,
                        x0,
                        y_top,
                        x0,
                        y_bottom,
                    );
                    nk_tt__handle_clipped_edge(
                        scanline_fill.offset(-1isize),
                        x0 as libc::c_int + 1i32,
                        e,
                        x0,
                        y_top,
                        x0,
                        y_bottom,
                    );
                } else {
                    nk_tt__handle_clipped_edge(
                        scanline_fill.offset(-1isize),
                        0i32,
                        e,
                        x0,
                        y_top,
                        x0,
                        y_bottom,
                    );
                }
            }
        } else {
            let mut x0_0: f32 = (*e).fx;
            let mut dx: f32 = (*e).fdx;
            let mut xb: f32 = x0_0 + dx;
            let mut x_top: f32 = 0.;
            let mut x_bottom: f32 = 0.;
            let mut y0: f32 = 0.;
            let mut y1: f32 = 0.;
            let mut dy: f32 = (*e).fdy;
            /* compute endpoints of line segment clipped to this scanline (if the */
            /* line segment starts on this scanline. x0 is the intersection of the */
            /* line with y_top, but that may be off the line segment. */
            if (*e).sy > y_top {
                x_top = x0_0 + dx * ((*e).sy - y_top);
                y0 = (*e).sy
            } else {
                x_top = x0_0;
                y0 = y_top
            }
            if (*e).ey < y_bottom {
                x_bottom = x0_0 + dx * ((*e).ey - y_top);
                y1 = (*e).ey
            } else {
                x_bottom = xb;
                y1 = y_bottom
            }
            if x_top >= 0i32 as f32
                && x_bottom >= 0i32 as f32
                && x_top < len as f32
                && x_bottom < len as f32
            {
                /* from here on, we don't have to range check x values */
                if x_top as libc::c_int == x_bottom as libc::c_int {
                    height = 0.;
                    /* simple case, only spans one pixel */
                    x = x_top as libc::c_int;
                    height = y1 - y0;
                    *scanline.offset(x as isize) += (*e).direction
                        * (1.0f32
                            - (x_top - x as f32 + (x_bottom - x as f32))
                                / 2.0f32)
                        * height;
                    /* everything right of this pixel is filled */
                    *scanline_fill.offset(x as isize) += (*e).direction * height
                } else {
                    let mut x_0: libc::c_int = 0;
                    let mut x1: libc::c_int = 0;
                    let mut x2: libc::c_int = 0;
                    let mut y_crossing: f32 = 0.;
                    let mut step: f32 = 0.;
                    let mut sign: f32 = 0.;
                    let mut area: f32 = 0.;
                    /* covers 2+ pixels */
                    if x_top > x_bottom {
                        /* flip scanline vertically; signed area is the same */
                        t = 0.;
                        y0 = y_bottom - (y0 - y_top);
                        y1 = y_bottom - (y1 - y_top);
                        t = y0;
                        y0 = y1;
                        y1 = t;
                        t = x_bottom;
                        x_bottom = x_top;
                        x_top = t;
                        dx = -dx;
                        dy = -dy;
                        t = x0_0;
                        x0_0 = xb;
                        xb = t
                    }
                    x1 = x_top as libc::c_int;
                    x2 = x_bottom as libc::c_int;
                    /* compute intersection with y axis at x1+1 */
                    y_crossing = (x1 as f32 + 1i32 as f32 - x0_0) * dy + y_top;
                    sign = (*e).direction;
                    /* area of the rectangle covered from y0..y_crossing */
                    area = sign * (y_crossing - y0);
                    /* area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing) */
                    *scanline.offset(x1 as isize) += area * (1.0f32
                        - (x_top - x1 as f32 + (x1 + 1i32 - x1) as f32)
                            / 2.0f32);
                    step = sign * dy;
                    x_0 = x1 + 1i32;
                    while x_0 < x2 {
                        *scanline.offset(x_0 as isize) += area + step / 2i32 as f32;
                        area += step;
                        x_0 += 1
                    }
                    y_crossing += dy * (x2 - (x1 + 1i32)) as f32;
                    *scanline.offset(x2 as isize) += area + sign * (1.0f32
                        - ((x2 - x2) as f32 + (x_bottom - x2 as f32)) / 2.0f32)
                        * (y1 - y_crossing);
                    *scanline_fill.offset(x2 as isize) += sign * (y1 - y0)
                }
            } else {
                /* if edge goes outside of box we're drawing, we require */
                /* clipping logic. since this does not match the intended use */
                /* of this library, we use a different, very slow brute */
                /* force implementation */
                let mut x_1: libc::c_int = 0;
                x_1 = 0i32;
                while x_1 < len {
                    /* cases: */
                    /* */
                    /* there can be up to two intersections with the pixel. any intersection */
                    /* with left or right edges can be handled by splitting into two (or three) */
                    /* regions. intersections with top & bottom do not necessitate case-wise logic. */
                    /* */
                    /* the old way of doing this found the intersections with the left & right edges, */
                    /* then used some simple logic to produce up to three segments in sorted order */
                    /* from top-to-bottom. however, this had a problem: if an x edge was epsilon */
                    /* across the x border, then the corresponding y position might not be distinct */
                    /* from the other y segment, and it might ignored as an empty segment. to avoid */
                    /* that, we need to explicitly produce segments based on x positions. */
                    /* rename variables to clear pairs */
                    let mut ya: f32 = y_top;
                    let mut x1_0: f32 = x_1 as f32;
                    let mut x2_0: f32 = (x_1 + 1i32) as f32;
                    let mut x3: f32 = xb;
                    let mut y3: f32 = y_bottom;
                    let mut yb: f32 = 0.;
                    let mut y2: f32 = 0.;
                    yb = (x_1 as f32 - x0_0) / dx + y_top;
                    y2 = (x_1 as f32 + 1i32 as f32 - x0_0) / dx + y_top;
                    if x0_0 < x1_0 && x3 > x2_0 {
                        /* three segments descending down-right */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x1_0, yb);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x1_0, yb, x2_0, y2);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x2_0, y2, x3, y3);
                    } else if x3 < x1_0 && x0_0 > x2_0 {
                        /* three segments descending down-left */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x2_0, y2);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x2_0, y2, x1_0, yb);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x1_0, yb, x3, y3);
                    } else if x0_0 < x1_0 && x3 > x1_0 {
                        /* two segments across x, down-right */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x1_0, yb);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x1_0, yb, x3, y3);
                    } else if x3 < x1_0 && x0_0 > x1_0 {
                        /* two segments across x, down-left */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x1_0, yb);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x1_0, yb, x3, y3);
                    } else if x0_0 < x2_0 && x3 > x2_0 {
                        /* two segments across x+1, down-right */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x2_0, y2);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x2_0, y2, x3, y3);
                    } else if x3 < x2_0 && x0_0 > x2_0 {
                        /* two segments across x+1, down-left */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x2_0, y2);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x2_0, y2, x3, y3);
                    } else {
                        /* one segment */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x3, y3);
                    }
                    x_1 += 1
                }
            }
        }
        e = (*e).next
    }
}
unsafe fn nk_tt__handle_clipped_edge(
    mut scanline: *mut f32,
    mut x: libc::c_int,
    mut e: *mut nk_tt__active_edge,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
) -> () {
    if y0 == y1 {
        return;
    } else if y0 > (*e).ey {
        return;
    } else if y1 < (*e).sy {
        return;
    } else {
        if y0 < (*e).sy {
            x0 += (x1 - x0) * ((*e).sy - y0) / (y1 - y0);
            y0 = (*e).sy
        }
        if y1 > (*e).ey {
            x1 += (x1 - x0) * ((*e).ey - y1) / (y1 - y0);
            y1 = (*e).ey
        }
        if !(x0 == x as f32) {
            if !(x0 == (x + 1i32) as f32) {
                if !(x0 <= x as f32) {
                    assert!(x0 >= (x + 1i32) as f32);
                }
            }
        }
        if x0 <= x as f32 && x1 <= x as f32 {
            *scanline.offset(x as isize) += (*e).direction * (y1 - y0)
        } else if !(x0 >= (x + 1i32) as f32 && x1 >= (x + 1i32) as f32) {
            /* coverage = 1 - average x position */
            *scanline.offset(x as isize) += (*e).direction
                * (y1 - y0)
                * (1.0f32 - (x0 - x as f32 + (x1 - x as f32)) / 2.0f32)
        }
        return;
    };
}
unsafe fn nk_tt__new_active(
    mut hh: *mut nk_tt__hheap,
    mut e: *mut nk_tt__edge,
    mut off_x: libc::c_int,
    mut start_point: f32,
) -> *mut nk_tt__active_edge {
    let mut z: *mut nk_tt__active_edge = nk_tt__hheap_alloc(
        hh,
        ::std::mem::size_of::<nk_tt__active_edge>() as libc::c_ulong,
    ) as *mut nk_tt__active_edge;
    let mut dxdy: f32 = ((*e).x1 - (*e).x0) / ((*e).y1 - (*e).y0);
    /*STBTT_assert(e->y0 <= start_point); */
    if z.is_null() {
        return z;
    } else {
        (*z).fdx = dxdy;
        (*z).fdy = if dxdy != 0i32 as f32 {
            1i32 as f32 / dxdy
        } else {
            0i32 as f32
        };
        (*z).fx = (*e).x0 + dxdy * (start_point - (*e).y0);
        (*z).fx -= off_x as f32;
        (*z).direction = if 0 != (*e).invert { 1.0f32 } else { -1.0f32 };
        (*z).sy = (*e).y0;
        (*z).ey = (*e).y1;
        (*z).next = 0 as *mut nk_tt__active_edge;
        return z;
    };
}
unsafe fn nk_tt__hheap_alloc(mut hh: *mut nk_tt__hheap, mut size: nk_size) -> *mut libc::c_void {
    if !(*hh).first_free.is_null() {
        let mut p: *mut libc::c_void = (*hh).first_free;
        (*hh).first_free = *(p as *mut *mut libc::c_void);
        return p;
    } else {
        if (*hh).num_remaining_in_head_chunk == 0i32 {
            let mut count: libc::c_int = if size < 32i32 as libc::c_ulong {
                2000i32
            } else if size < 128i32 as libc::c_ulong {
                800i32
            } else {
                100i32
            };
            let mut c: *mut nk_tt__hheap_chunk =
                (*hh).alloc.alloc.expect("non-null function pointer")(
                    (*hh).alloc.userdata,
                    0 as *mut libc::c_void,
                    (::std::mem::size_of::<nk_tt__hheap_chunk>() as libc::c_ulong)
                        .wrapping_add(size.wrapping_mul(count as nk_size)),
                ) as *mut nk_tt__hheap_chunk;
            if c.is_null() {
                return 0 as *mut libc::c_void;
            } else {
                (*c).next = (*hh).head;
                (*hh).head = c;
                (*hh).num_remaining_in_head_chunk = count
            }
        }
        (*hh).num_remaining_in_head_chunk -= 1;
        return ((*hh).head as *mut libc::c_char)
            .offset(size.wrapping_mul((*hh).num_remaining_in_head_chunk as nk_size) as isize)
            as *mut libc::c_void;
    };
}
unsafe fn nk_tt__hheap_free(mut hh: *mut nk_tt__hheap, mut p: *mut libc::c_void) -> () {
    let ref mut fresh75 = *(p as *mut *mut libc::c_void);
    *fresh75 = (*hh).first_free;
    (*hh).first_free = p;
}
unsafe fn nk_tt__sort_edges(mut p: *mut nk_tt__edge, mut n: libc::c_int) -> () {
    nk_tt__sort_edges_quicksort(p, n);
    nk_tt__sort_edges_ins_sort(p, n);
}
unsafe fn nk_tt__sort_edges_ins_sort(mut p: *mut nk_tt__edge, mut n: libc::c_int) -> () {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    i = 1i32;
    while i < n {
        let mut t: nk_tt__edge = *p.offset(i as isize);
        let mut a: *mut nk_tt__edge = &mut t;
        j = i;
        while j > 0i32 {
            let mut b: *mut nk_tt__edge = &mut *p.offset((j - 1i32) as isize) as *mut nk_tt__edge;
            let mut c: libc::c_int = ((*a).y0 < (*b).y0) as libc::c_int;
            if 0 == c {
                break;
            }
            *p.offset(j as isize) = *p.offset((j - 1i32) as isize);
            j -= 1
        }
        if i != j {
            *p.offset(j as isize) = t
        }
        i += 1
    }
}
unsafe fn nk_tt__sort_edges_quicksort(mut p: *mut nk_tt__edge, mut n: libc::c_int) -> () {
    let mut z: libc::c_int = 0;
    /* threshold for transitioning to insertion sort */
    while n > 12i32 {
        let mut t: nk_tt__edge = nk_tt__edge {
            x0: 0.,
            y0: 0.,
            x1: 0.,
            y1: 0.,
            invert: 0,
        };
        let mut c01: libc::c_int = 0;
        let mut c12: libc::c_int = 0;
        let mut c: libc::c_int = 0;
        let mut m: libc::c_int = 0;
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        /* compute median of three */
        m = n >> 1i32;
        c01 = ((*p.offset(0isize)).y0 < (*p.offset(m as isize)).y0) as libc::c_int;
        c12 = ((*p.offset(m as isize)).y0 < (*p.offset((n - 1i32) as isize)).y0) as libc::c_int;
        /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
        if c01 != c12 {
            /* otherwise, we'll need to swap something else to middle */
            z = 0;
            c = ((*p.offset(0isize)).y0 < (*p.offset((n - 1i32) as isize)).y0) as libc::c_int;
            /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
            /* 0<mid && mid>n:  0>n => 0; 0<n => n */
            z = if c == c12 { 0i32 } else { n - 1i32 };
            t = *p.offset(z as isize);
            *p.offset(z as isize) = *p.offset(m as isize);
            *p.offset(m as isize) = t
        }
        /* now p[m] is the median-of-three */
        /* swap it to the beginning so it won't move around */
        t = *p.offset(0isize);
        *p.offset(0isize) = *p.offset(m as isize);
        *p.offset(m as isize) = t;
        /* partition loop */
        i = 1i32;
        j = n - 1i32;
        loop {
            /* handling of equality is crucial here */
            /* for sentinels & efficiency with duplicates */
            while (*p.offset(i as isize)).y0 < (*p.offset(0isize)).y0 {
                i += 1
            }
            while (*p.offset(0isize)).y0 < (*p.offset(j as isize)).y0 {
                j -= 1
            }
            /* make sure we haven't crossed */
            if i >= j {
                break;
            }
            t = *p.offset(i as isize);
            *p.offset(i as isize) = *p.offset(j as isize);
            *p.offset(j as isize) = t;
            i += 1;
            j -= 1
        }
        /* recurse on smaller side, iterate on larger */
        if j < n - i {
            nk_tt__sort_edges_quicksort(p, j);
            p = p.offset(i as isize);
            n = n - i
        } else {
            nk_tt__sort_edges_quicksort(p.offset(i as isize), n - i);
            n = j
        }
    }
}
unsafe fn nk_tt_GetGlyphBitmapBoxSubpixel(
    mut font: *const nk_tt_fontinfo,
    mut glyph: libc::c_int,
    mut scale_x: f32,
    mut scale_y: f32,
    mut shift_x: f32,
    mut shift_y: f32,
    mut ix0: *mut libc::c_int,
    mut iy0: *mut libc::c_int,
    mut ix1: *mut libc::c_int,
    mut iy1: *mut libc::c_int,
) -> () {
    let mut x0: libc::c_int = 0;
    let mut y0: libc::c_int = 0;
    let mut x1: libc::c_int = 0;
    let mut y1: libc::c_int = 0;
    if 0 == nk_tt_GetGlyphBox(font, glyph, &mut x0, &mut y0, &mut x1, &mut y1) {
        /* e.g. space character */
        if !ix0.is_null() {
            *ix0 = 0i32
        }
        if !iy0.is_null() {
            *iy0 = 0i32
        }
        if !ix1.is_null() {
            *ix1 = 0i32
        }
        if !iy1.is_null() {
            *iy1 = 0i32
        }
    } else {
        /* move to integral bboxes (treating pixels as little squares, what pixels get touched)? */
        if !ix0.is_null() {
            *ix0 = nk_ifloorf(x0 as f32 * scale_x + shift_x)
        }
        if !iy0.is_null() {
            *iy0 = nk_ifloorf(-y1 as f32 * scale_y + shift_y)
        }
        if !ix1.is_null() {
            *ix1 = nk_iceilf(x1 as f32 * scale_x + shift_x)
        }
        if !iy1.is_null() {
            *iy1 = nk_iceilf(-y0 as f32 * scale_y + shift_y)
        }
    };
}
unsafe fn nk_tt_GetGlyphBox(
    mut info: *const nk_tt_fontinfo,
    mut glyph_index: libc::c_int,
    mut x0: *mut libc::c_int,
    mut y0: *mut libc::c_int,
    mut x1: *mut libc::c_int,
    mut y1: *mut libc::c_int,
) -> libc::c_int {
    let mut g: libc::c_int = nk_tt__GetGlyfOffset(info, glyph_index);
    if g < 0i32 {
        return 0i32;
    } else {
        if !x0.is_null() {
            *x0 = nk_ttSHORT((*info).data.offset(g as isize).offset(2isize)) as libc::c_int
        }
        if !y0.is_null() {
            *y0 = nk_ttSHORT((*info).data.offset(g as isize).offset(4isize)) as libc::c_int
        }
        if !x1.is_null() {
            *x1 = nk_ttSHORT((*info).data.offset(g as isize).offset(6isize)) as libc::c_int
        }
        if !y1.is_null() {
            *y1 = nk_ttSHORT((*info).data.offset(g as isize).offset(8isize)) as libc::c_int
        }
        return 1i32;
    };
}
unsafe fn nk_tt_GetGlyphBitmapBox(
    mut font: *const nk_tt_fontinfo,
    mut glyph: libc::c_int,
    mut scale_x: f32,
    mut scale_y: f32,
    mut ix0: *mut libc::c_int,
    mut iy0: *mut libc::c_int,
    mut ix1: *mut libc::c_int,
    mut iy1: *mut libc::c_int,
) -> () {
    nk_tt_GetGlyphBitmapBoxSubpixel(
        font, glyph, scale_x, scale_y, 0.0f32, 0.0f32, ix0, iy0, ix1, iy1,
    );
}
unsafe fn nk_tt_GetGlyphHMetrics(
    mut info: *const nk_tt_fontinfo,
    mut glyph_index: libc::c_int,
    mut advanceWidth: *mut libc::c_int,
    mut leftSideBearing: *mut libc::c_int,
) -> () {
    let mut numOfLongHorMetrics: nk_ushort =
        nk_ttUSHORT((*info).data.offset((*info).hhea as isize).offset(34isize));
    if glyph_index < numOfLongHorMetrics as libc::c_int {
        if !advanceWidth.is_null() {
            *advanceWidth = nk_ttSHORT(
                (*info)
                    .data
                    .offset((*info).hmtx as isize)
                    .offset((4i32 * glyph_index) as isize),
            ) as libc::c_int
        }
        if !leftSideBearing.is_null() {
            *leftSideBearing = nk_ttSHORT(
                (*info)
                    .data
                    .offset((*info).hmtx as isize)
                    .offset((4i32 * glyph_index) as isize)
                    .offset(2isize),
            ) as libc::c_int
        }
    } else {
        if !advanceWidth.is_null() {
            *advanceWidth = nk_ttSHORT(
                (*info)
                    .data
                    .offset((*info).hmtx as isize)
                    .offset((4i32 * (numOfLongHorMetrics as libc::c_int - 1i32)) as isize),
            ) as libc::c_int
        }
        if !leftSideBearing.is_null() {
            *leftSideBearing = nk_ttSHORT(
                (*info)
                    .data
                    .offset((*info).hmtx as isize)
                    .offset((4i32 * numOfLongHorMetrics as libc::c_int) as isize)
                    .offset((2i32 * (glyph_index - numOfLongHorMetrics as libc::c_int)) as isize),
            ) as libc::c_int
        }
    };
}
unsafe fn nk_tt__oversample_shift(mut oversample: libc::c_int) -> f32 {
    if 0 == oversample {
        return 0.0f32;
    } else {
        return -(oversample - 1i32) as f32 / (2.0f32 * oversample as f32);
    };
}
unsafe fn nk_tt_PackSetOversampling(
    mut spc: *mut nk_tt_pack_context,
    mut h_oversample: libc::c_uint,
    mut v_oversample: libc::c_uint,
) -> () {
    if h_oversample <= 8i32 as libc::c_uint {
        (*spc).h_oversample = h_oversample
    }
    if v_oversample <= 8i32 as libc::c_uint {
        (*spc).v_oversample = v_oversample
    };
}
unsafe fn nk_font_bake_pack(
    mut baker: *mut nk_font_baker,
    mut image_memory: *mut nk_size,
    mut width: *mut libc::c_int,
    mut height: *mut libc::c_int,
    mut custom: *mut nk_recti,
    mut config_list: *const nk_font_config,
    mut count: libc::c_int,
    mut alloc: *mut nk_allocator,
) -> libc::c_int {
    let mut custom_space: nk_rp_rect = nk_rp_rect {
        id: 0,
        w: 0,
        h: 0,
        x: 0,
        y: 0,
        was_packed: 0,
    };
    static mut max_height: nk_size = unsafe { (1024i32 * 32i32) as nk_size };
    let mut config_iter: *const nk_font_config = 0 as *const nk_font_config;
    let mut it: *const nk_font_config = 0 as *const nk_font_config;
    let mut total_glyph_count: libc::c_int = 0i32;
    let mut total_range_count: libc::c_int = 0i32;
    let mut range_count: libc::c_int = 0i32;
    let mut i: libc::c_int = 0i32;
    if image_memory.is_null()
        || width.is_null()
        || height.is_null()
        || config_list.is_null()
        || 0 == count
    {
        return nk_false as libc::c_int;
    } else {
        config_iter = config_list;
        while !config_iter.is_null() {
            it = config_iter;
            loop {
                range_count = nk_range_count((*it).range);
                total_range_count += range_count;
                total_glyph_count += nk_range_glyph_count((*it).range, range_count);
                it = (*it).n;
                if !(it != config_iter) {
                    break;
                }
            }
            config_iter = (*config_iter).next
        }
        /* setup font baker from temporary memory */
        config_iter = config_list;
        while !config_iter.is_null() {
            it = config_iter;
            loop {
                let fresh76 = i;
                i = i + 1;
                if 0 == nk_tt_InitFont(
                    &mut (*(*baker).build.offset(fresh76 as isize)).info,
                    (*it).ttf_blob as *const libc::c_uchar,
                    0i32,
                ) {
                    return nk_false as libc::c_int;
                } else {
                    it = (*it).n;
                    if !(it != config_iter) {
                        break;
                    }
                }
            }
            config_iter = (*config_iter).next
        }
        *height = 0i32;
        *width = if total_glyph_count > 1000i32 {
            1024i32
        } else {
            512i32
        };
        nk_tt_PackBegin(
            &mut (*baker).spc,
            0 as *mut libc::c_uchar,
            *width,
            max_height as libc::c_int,
            0i32,
            1i32,
            alloc,
        );
        let mut input_i: libc::c_int = 0i32;
        let mut range_n: libc::c_int = 0i32;
        let mut rect_n: libc::c_int = 0i32;
        let mut char_n: libc::c_int = 0i32;
        if !custom.is_null() {
            /* pack custom user data first so it will be in the upper left corner*/
            custom_space = nk_rp_rect {
                id: 0,
                w: 0,
                h: 0,
                x: 0,
                y: 0,
                was_packed: 0,
            };
            nk_zero(
                &mut custom_space as *mut nk_rp_rect as *mut libc::c_void,
                ::std::mem::size_of::<nk_rp_rect>() as libc::c_ulong,
            );
            custom_space.w = (*custom).w as nk_rp_coord;
            custom_space.h = (*custom).h as nk_rp_coord;
            nk_tt_PackSetOversampling(
                &mut (*baker).spc,
                1i32 as libc::c_uint,
                1i32 as libc::c_uint,
            );
            nk_rp_pack_rects(
                (*baker).spc.pack_info as *mut nk_rp_context,
                &mut custom_space,
                1i32,
            );
            *height = if *height < custom_space.y as libc::c_int + custom_space.h as libc::c_int {
                custom_space.y as libc::c_int + custom_space.h as libc::c_int
            } else {
                *height
            };
            (*custom).x = custom_space.x as libc::c_short;
            (*custom).y = custom_space.y as libc::c_short;
            (*custom).w = custom_space.w as libc::c_short;
            (*custom).h = custom_space.h as libc::c_short
        }
        /* first font pass: pack all glyphs */
        input_i = 0i32;
        config_iter = config_list;
        while input_i < count && !config_iter.is_null() {
            it = config_iter;
            loop {
                let mut n: libc::c_int = 0i32;
                let mut glyph_count: libc::c_int = 0;
                let mut in_range: *const nk_rune = 0 as *const nk_rune;
                let mut cfg: *const nk_font_config = it;
                let fresh77 = input_i;
                input_i = input_i + 1;
                let mut tmp: *mut nk_font_bake_data =
                    &mut *(*baker).build.offset(fresh77 as isize) as *mut nk_font_bake_data;
                /* count glyphs + ranges in current font */
                glyph_count = 0i32;
                range_count = 0i32;
                in_range = (*cfg).range;
                while 0 != *in_range.offset(0isize) && 0 != *in_range.offset(1isize) {
                    glyph_count += (*in_range.offset(1isize)).wrapping_sub(*in_range.offset(0isize))
                        as libc::c_int + 1i32;
                    range_count += 1;
                    in_range = in_range.offset(2isize)
                }
                /* setup ranges  */
                (*tmp).ranges = (*baker).ranges.offset(range_n as isize);
                (*tmp).range_count = range_count as nk_rune;
                range_n += range_count;
                i = 0i32;
                while i < range_count {
                    in_range = &*(*cfg).range.offset((i * 2i32) as isize) as *const nk_rune;
                    (*(*tmp).ranges.offset(i as isize)).font_size = (*cfg).size;
                    (*(*tmp).ranges.offset(i as isize)).first_unicode_codepoint_in_range =
                        *in_range.offset(0isize) as libc::c_int;
                    (*(*tmp).ranges.offset(i as isize)).num_chars =
                        (*in_range.offset(1isize)).wrapping_sub(*in_range.offset(0isize))
                            as libc::c_int + 1i32;
                    let ref mut fresh78 = (*(*tmp).ranges.offset(i as isize)).chardata_for_range;
                    *fresh78 = (*baker).packed_chars.offset(char_n as isize);
                    char_n += (*(*tmp).ranges.offset(i as isize)).num_chars;
                    i += 1
                }
                /* pack */
                (*tmp).rects = (*baker).rects.offset(rect_n as isize);
                rect_n += glyph_count;
                nk_tt_PackSetOversampling(
                    &mut (*baker).spc,
                    (*cfg).oversample_h as libc::c_uint,
                    (*cfg).oversample_v as libc::c_uint,
                );
                n = nk_tt_PackFontRangesGatherRects(
                    &mut (*baker).spc,
                    &mut (*tmp).info,
                    (*tmp).ranges,
                    (*tmp).range_count as libc::c_int,
                    (*tmp).rects,
                );
                nk_rp_pack_rects(
                    (*baker).spc.pack_info as *mut nk_rp_context,
                    (*tmp).rects,
                    n,
                );
                /* texture height */
                i = 0i32;
                while i < n {
                    if 0 != (*(*tmp).rects.offset(i as isize)).was_packed {
                        *height = if *height
                            < (*(*tmp).rects.offset(i as isize)).y as libc::c_int
                                + (*(*tmp).rects.offset(i as isize)).h as libc::c_int
                        {
                            (*(*tmp).rects.offset(i as isize)).y as libc::c_int
                                + (*(*tmp).rects.offset(i as isize)).h as libc::c_int
                        } else {
                            *height
                        }
                    }
                    i += 1
                }
                it = (*it).n;
                if !(it != config_iter) {
                    break;
                }
            }
            config_iter = (*config_iter).next
        }
        *height = nk_round_up_pow2(*height as nk_uint) as libc::c_int;
        *image_memory = (*width as nk_size).wrapping_mul(*height as nk_size);
        return nk_true as libc::c_int;
    };
}
unsafe fn nk_rp_pack_rects(
    mut context: *mut nk_rp_context,
    mut rects: *mut nk_rp_rect,
    mut num_rects: libc::c_int,
) -> () {
    let mut i: libc::c_int = 0;
    /* we use the 'was_packed' field internally to allow sorting/unsorting */
    i = 0i32;
    while i < num_rects {
        (*rects.offset(i as isize)).was_packed = i;
        i += 1
    }
    /* sort according to heuristic */
    nk_rp_qsort(
        rects,
        num_rects as libc::c_uint,
        Some(nk_rect_height_compare),
    );
    i = 0i32;
    while i < num_rects {
        let mut fr: nk_rp__findresult = nk_rp__skyline_pack_rectangle(
            context,
            (*rects.offset(i as isize)).w as libc::c_int,
            (*rects.offset(i as isize)).h as libc::c_int,
        );
        if !fr.prev_link.is_null() {
            (*rects.offset(i as isize)).x = fr.x as nk_rp_coord;
            (*rects.offset(i as isize)).y = fr.y as nk_rp_coord
        } else {
            let ref mut fresh79 = (*rects.offset(i as isize)).y;
            *fresh79 = 65535i32 as nk_rp_coord;
            (*rects.offset(i as isize)).x = *fresh79
        }
        i += 1
    }
    /* unsort */
    nk_rp_qsort(
        rects,
        num_rects as libc::c_uint,
        Some(nk_rect_original_order),
    );
    /* set was_packed flags */
    i = 0i32;
    while i < num_rects {
        (*rects.offset(i as isize)).was_packed = !((*rects.offset(i as isize)).x as libc::c_int
            == 65535i32
            && (*rects.offset(i as isize)).y as libc::c_int == 65535i32)
            as libc::c_int;
        i += 1
    }
}
unsafe fn nk_rect_original_order(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut p: *const nk_rp_rect = a as *const nk_rp_rect;
    let mut q: *const nk_rp_rect = b as *const nk_rp_rect;
    return if (*p).was_packed < (*q).was_packed {
        -1i32
    } else {
        ((*p).was_packed > (*q).was_packed) as libc::c_int
    };
}
unsafe fn nk_rp_qsort(
    mut array: *mut nk_rp_rect,
    mut len: libc::c_uint,
    mut cmp: Option<unsafe fn(_: *const libc::c_void, _: *const libc::c_void) -> libc::c_int>,
) -> () {
    let mut right: libc::c_uint = 0;
    let mut left: libc::c_uint = 0i32 as libc::c_uint;
    let mut stack: [libc::c_uint; 64] = [0; 64];
    /* iterative quick sort */
    let mut pos: libc::c_uint = 0i32 as libc::c_uint;
    let mut seed: libc::c_uint = len
        .wrapping_div(2i32 as libc::c_uint)
        .wrapping_mul(69069i32 as libc::c_uint)
        .wrapping_add(1i32 as libc::c_uint);
    loop {
        if left.wrapping_add(1i32 as libc::c_uint) < len {
            let mut pivot: nk_rp_rect = nk_rp_rect {
                id: 0,
                w: 0,
                h: 0,
                x: 0,
                y: 0,
                was_packed: 0,
            };
            let mut tmp: nk_rp_rect = nk_rp_rect {
                id: 0,
                w: 0,
                h: 0,
                x: 0,
                y: 0,
                was_packed: 0,
            };
            if pos == 64i32 as libc::c_uint {
                pos = 0i32 as libc::c_uint;
                len = stack[pos as usize]
            }
            pivot = *array
                .offset(left.wrapping_add(seed.wrapping_rem(len.wrapping_sub(left))) as isize);
            seed = seed
                .wrapping_mul(69069i32 as libc::c_uint)
                .wrapping_add(1i32 as libc::c_uint);
            let fresh80 = pos;
            pos = pos.wrapping_add(1);
            stack[fresh80 as usize] = len;
            right = left.wrapping_sub(1i32 as libc::c_uint);
            loop {
                right = right.wrapping_add(1);
                if cmp.expect("non-null function pointer")(
                    &mut *array.offset(right as isize) as *mut nk_rp_rect as *const libc::c_void,
                    &mut pivot as *mut nk_rp_rect as *const libc::c_void,
                ) < 0i32
                {
                    continue;
                }
                loop {
                    len = len.wrapping_sub(1);
                    if !(cmp.expect("non-null function pointer")(
                        &mut pivot as *mut nk_rp_rect as *const libc::c_void,
                        &mut *array.offset(len as isize) as *mut nk_rp_rect as *const libc::c_void,
                    ) < 0i32)
                    {
                        break;
                    }
                }
                if right >= len {
                    break;
                }
                tmp = *array.offset(right as isize);
                *array.offset(right as isize) = *array.offset(len as isize);
                *array.offset(len as isize) = tmp
            }
            len = len.wrapping_add(1)
        } else {
            if pos == 0i32 as libc::c_uint {
                break;
            }
            left = len;
            pos = pos.wrapping_sub(1);
            len = stack[pos as usize]
        }
    }
}
unsafe fn nk_rp__skyline_pack_rectangle(
    mut context: *mut nk_rp_context,
    mut width: libc::c_int,
    mut height: libc::c_int,
) -> nk_rp__findresult {
    let mut next_0: *mut nk_rp_node = 0 as *mut nk_rp_node;
    let mut next: *mut nk_rp_node = 0 as *mut nk_rp_node;
    /* find best position according to heuristic */
    let mut res: nk_rp__findresult = nk_rp__skyline_find_best_pos(context, width, height);
    let mut node: *mut nk_rp_node = 0 as *mut nk_rp_node;
    let mut cur: *mut nk_rp_node = 0 as *mut nk_rp_node;
    /* bail if: */
    /*    1. it failed */
    /*    2. the best node doesn't fit (we don't always check this) */
    /*    3. we're out of memory */
    if res.prev_link.is_null()
        || res.y + height > (*context).height
        || (*context).free_head.is_null()
    {
        res.prev_link = 0 as *mut *mut nk_rp_node;
        return res;
    } else {
        /* on success, create new node */
        node = (*context).free_head;
        (*node).x = res.x as nk_rp_coord;
        (*node).y = (res.y + height) as nk_rp_coord;
        (*context).free_head = (*node).next;
        /* insert the new node into the right starting point, and */
        /* let 'cur' point to the remaining nodes needing to be */
        /* stitched back in */
        cur = *res.prev_link;
        if ((*cur).x as libc::c_int) < res.x {
            /* preserve the existing one, so start testing with the next one */
            next = (*cur).next;
            (*cur).next = node;
            cur = next
        } else {
            *res.prev_link = node
        }
        /* from here, traverse cur and free the nodes, until we get to one */
        /* that shouldn't be freed */
        while !(*cur).next.is_null() && (*(*cur).next).x as libc::c_int <= res.x + width {
            next_0 = (*cur).next;
            /* move the current node to the free list */
            (*cur).next = (*context).free_head;
            (*context).free_head = cur;
            cur = next_0
        }
        /* stitch the list back in */
        (*node).next = cur;
        if ((*cur).x as libc::c_int) < res.x + width {
            (*cur).x = (res.x + width) as nk_rp_coord
        }
        return res;
    };
}
unsafe fn nk_rp__skyline_find_best_pos(
    mut c: *mut nk_rp_context,
    mut width: libc::c_int,
    mut height: libc::c_int,
) -> nk_rp__findresult {
    let mut best_waste: libc::c_int = 1i32 << 30i32;
    let mut best_x: libc::c_int = 0;
    let mut best_y: libc::c_int = 1i32 << 30i32;
    let mut fr: nk_rp__findresult = nk_rp__findresult {
        x: 0,
        y: 0,
        prev_link: 0 as *mut *mut nk_rp_node,
    };
    let mut prev: *mut *mut nk_rp_node = 0 as *mut *mut nk_rp_node;
    let mut node: *mut nk_rp_node = 0 as *mut nk_rp_node;
    let mut tail: *mut nk_rp_node = 0 as *mut nk_rp_node;
    let mut best: *mut *mut nk_rp_node = 0 as *mut *mut nk_rp_node;
    /* align to multiple of c->align */
    width = width + (*c).align - 1i32;
    width -= width % (*c).align;
    node = (*c).active_head;
    prev = &mut (*c).active_head as *mut *mut nk_rp_node;
    while (*node).x as libc::c_int + width <= (*c).width {
        let mut y: libc::c_int = 0;
        let mut waste: libc::c_int = 0;
        y = nk_rp__skyline_find_min_y(c, node, (*node).x as libc::c_int, width, &mut waste);
        /* actually just want to test BL */
        if (*c).heuristic == NK_RP_HEURISTIC_Skyline_BL_sortHeight as libc::c_int {
            /* bottom left */
            if y < best_y {
                best_y = y;
                best = prev
            }
        } else if y + height <= (*c).height {
            /* can only use it if it first vertically */
            if y < best_y || y == best_y && waste < best_waste {
                best_y = y;
                best_waste = waste;
                best = prev
            }
        }
        prev = &mut (*node).next as *mut *mut nk_rp_node;
        node = (*node).next
    }
    best_x = if best.is_null() {
        0i32
    } else {
        (**best).x as libc::c_int
    };
    /* if doing best-fit (BF), we also have to try aligning right edge to each node position */
    /* */
    /* e.g, if fitting */
    /* */
    /*     ____________________ */
    /*    |____________________| */
    /* */
    /*            into */
    /* */
    /*   |                         | */
    /*   |             ____________| */
    /*   |____________| */
    /* */
    /* then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned */
    /* */
    /* This makes BF take about 2x the time */
    if (*c).heuristic == NK_RP_HEURISTIC_Skyline_BF_sortHeight as libc::c_int {
        tail = (*c).active_head;
        node = (*c).active_head;
        prev = &mut (*c).active_head as *mut *mut nk_rp_node;
        /* find first node that's admissible */
        while ((*tail).x as libc::c_int) < width {
            tail = (*tail).next
        }
        while !tail.is_null() {
            let mut xpos: libc::c_int = (*tail).x as libc::c_int - width;
            let mut y_0: libc::c_int = 0;
            let mut waste_0: libc::c_int = 0;
            /* find the left position that matches this */
            while (*(*node).next).x as libc::c_int <= xpos {
                prev = &mut (*node).next as *mut *mut nk_rp_node;
                node = (*node).next
            }
            y_0 = nk_rp__skyline_find_min_y(c, node, xpos, width, &mut waste_0);
            if y_0 + height < (*c).height {
                if y_0 <= best_y {
                    if y_0 < best_y
                        || waste_0 < best_waste
                        || waste_0 == best_waste && xpos < best_x
                    {
                        best_x = xpos;
                        best_y = y_0;
                        best_waste = waste_0;
                        best = prev
                    }
                }
            }
            tail = (*tail).next
        }
    }
    fr.prev_link = best;
    fr.x = best_x;
    fr.y = best_y;
    return fr;
}
unsafe fn nk_rp__skyline_find_min_y(
    mut c: *mut nk_rp_context,
    mut first: *mut nk_rp_node,
    mut x0: libc::c_int,
    mut width: libc::c_int,
    mut pwaste: *mut libc::c_int,
) -> libc::c_int {
    let mut node: *mut nk_rp_node = first;
    let mut x1: libc::c_int = x0 + width;
    let mut min_y: libc::c_int = 0;
    let mut visited_width: libc::c_int = 0;
    let mut waste_area: libc::c_int = 0;
    /* we ended up handling this in the caller for efficiency */
    min_y = 0i32;
    waste_area = 0i32;
    visited_width = 0i32;
    while ((*node).x as libc::c_int) < x1 {
        if (*node).y as libc::c_int > min_y {
            /* raise min_y higher. */
            /* we've accounted for all waste up to min_y, */
            /* but we'll now add more waste for everything we've visited */
            waste_area += visited_width * ((*node).y as libc::c_int - min_y);
            min_y = (*node).y as libc::c_int;
            /* the first time through, visited_width might be reduced */
            if ((*node).x as libc::c_int) < x0 {
                visited_width += (*(*node).next).x as libc::c_int - x0
            } else {
                visited_width += (*(*node).next).x as libc::c_int - (*node).x as libc::c_int
            }
        } else {
            /* add waste area */
            let mut under_width: libc::c_int =
                (*(*node).next).x as libc::c_int - (*node).x as libc::c_int;
            if under_width + visited_width > width {
                under_width = width - visited_width
            }
            waste_area += under_width * (min_y - (*node).y as libc::c_int);
            visited_width += under_width
        }
        node = (*node).next
    }
    *pwaste = waste_area;
    return min_y;
}
unsafe fn nk_rect_height_compare(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut p: *const nk_rp_rect = a as *const nk_rp_rect;
    let mut q: *const nk_rp_rect = b as *const nk_rp_rect;
    if (*p).h as libc::c_int > (*q).h as libc::c_int {
        return -1i32;
    } else if ((*p).h as libc::c_int) < (*q).h as libc::c_int {
        return 1i32;
    } else {
        return if (*p).w as libc::c_int > (*q).w as libc::c_int {
            -1i32
        } else {
            (((*p).w as libc::c_int) < (*q).w as libc::c_int) as libc::c_int
        };
    };
}
unsafe fn nk_tt_PackFontRangesGatherRects(
    mut spc: *mut nk_tt_pack_context,
    mut info: *mut nk_tt_fontinfo,
    mut ranges: *mut nk_tt_pack_range,
    mut num_ranges: libc::c_int,
    mut rects: *mut nk_rp_rect,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    /* rects array must be big enough to accommodate all characters in the given ranges */
    let mut k: libc::c_int = 0;
    k = 0i32;
    i = 0i32;
    while i < num_ranges {
        let mut fh: f32 = (*ranges.offset(i as isize)).font_size;
        let mut scale: f32 = if fh > 0i32 as f32 {
            nk_tt_ScaleForPixelHeight(info, fh)
        } else {
            nk_tt_ScaleForMappingEmToPixels(info, -fh)
        };
        (*ranges.offset(i as isize)).h_oversample = (*spc).h_oversample as libc::c_uchar;
        (*ranges.offset(i as isize)).v_oversample = (*spc).v_oversample as libc::c_uchar;
        j = 0i32;
        while j < (*ranges.offset(i as isize)).num_chars {
            let mut x0: libc::c_int = 0;
            let mut y0: libc::c_int = 0;
            let mut x1: libc::c_int = 0;
            let mut y1: libc::c_int = 0;
            let mut codepoint: libc::c_int =
                if 0 != (*ranges.offset(i as isize)).first_unicode_codepoint_in_range {
                    (*ranges.offset(i as isize)).first_unicode_codepoint_in_range + j
                } else {
                    *(*ranges.offset(i as isize))
                        .array_of_unicode_codepoints
                        .offset(j as isize)
                };
            let mut glyph: libc::c_int = nk_tt_FindGlyphIndex(info, codepoint);
            nk_tt_GetGlyphBitmapBoxSubpixel(
                info,
                glyph,
                scale * (*spc).h_oversample as f32,
                scale * (*spc).v_oversample as f32,
                0i32 as f32,
                0i32 as f32,
                &mut x0,
                &mut y0,
                &mut x1,
                &mut y1,
            );
            (*rects.offset(k as isize)).w =
                (x1 - x0 + (*spc).padding + (*spc).h_oversample as libc::c_int - 1i32)
                    as nk_rp_coord;
            (*rects.offset(k as isize)).h =
                (y1 - y0 + (*spc).padding + (*spc).v_oversample as libc::c_int - 1i32)
                    as nk_rp_coord;
            k += 1;
            j += 1
        }
        i += 1
    }
    return k;
}
unsafe fn nk_tt_PackBegin(
    mut spc: *mut nk_tt_pack_context,
    mut pixels: *mut libc::c_uchar,
    mut pw: libc::c_int,
    mut ph: libc::c_int,
    mut stride_in_bytes: libc::c_int,
    mut padding: libc::c_int,
    mut alloc: *mut nk_allocator,
) -> libc::c_int {
    let mut num_nodes: libc::c_int = pw - padding;
    let mut context: *mut nk_rp_context = (*alloc).alloc.expect("non-null function pointer")(
        (*alloc).userdata,
        0 as *mut libc::c_void,
        ::std::mem::size_of::<nk_rp_context>() as libc::c_ulong,
    ) as *mut nk_rp_context;
    let mut nodes: *mut nk_rp_node = (*alloc).alloc.expect("non-null function pointer")(
        (*alloc).userdata,
        0 as *mut libc::c_void,
        (::std::mem::size_of::<nk_rp_node>() as libc::c_ulong).wrapping_mul(num_nodes as nk_size),
    ) as *mut nk_rp_node;
    if context.is_null() || nodes.is_null() {
        if !context.is_null() {
            (*alloc).free.expect("non-null function pointer")(
                (*alloc).userdata,
                context as *mut libc::c_void,
            );
        }
        if !nodes.is_null() {
            (*alloc).free.expect("non-null function pointer")(
                (*alloc).userdata,
                nodes as *mut libc::c_void,
            );
        }
        return 0i32;
    } else {
        (*spc).width = pw;
        (*spc).height = ph;
        (*spc).pixels = pixels;
        (*spc).pack_info = context as *mut libc::c_void;
        (*spc).nodes = nodes as *mut libc::c_void;
        (*spc).padding = padding;
        (*spc).stride_in_bytes = if stride_in_bytes != 0i32 {
            stride_in_bytes
        } else {
            pw
        };
        (*spc).h_oversample = 1i32 as libc::c_uint;
        (*spc).v_oversample = 1i32 as libc::c_uint;
        nk_rp_init_target(context, pw - padding, ph - padding, nodes, num_nodes);
        if !pixels.is_null() {
            nk_memset(pixels as *mut libc::c_void, 0i32, (pw * ph) as nk_size);
        }
        /* background of 0 around pixels */
        return 1i32;
    };
}
unsafe fn nk_rp_init_target(
    mut context: *mut nk_rp_context,
    mut width: libc::c_int,
    mut height: libc::c_int,
    mut nodes: *mut nk_rp_node,
    mut num_nodes: libc::c_int,
) -> () {
    let mut i: libc::c_int = 0;
    i = 0i32;
    while i < num_nodes - 1i32 {
        let ref mut fresh81 = (*nodes.offset(i as isize)).next;
        *fresh81 = &mut *nodes.offset((i + 1i32) as isize) as *mut nk_rp_node;
        i += 1
    }
    let ref mut fresh82 = (*nodes.offset(i as isize)).next;
    *fresh82 = 0 as *mut nk_rp_node;
    (*context).init_mode = NK_RP__INIT_skyline as libc::c_int;
    (*context).heuristic = NK_RP_HEURISTIC_Skyline_default as libc::c_int;
    (*context).free_head = &mut *nodes.offset(0isize) as *mut nk_rp_node;
    (*context).active_head = &mut (*context).extra[0usize] as *mut nk_rp_node;
    (*context).width = width;
    (*context).height = height;
    (*context).num_nodes = num_nodes;
    nk_rp_setup_allow_out_of_mem(context, 0i32);
    /* node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly) */
    (*context).extra[0usize].x = 0i32 as nk_rp_coord;
    (*context).extra[0usize].y = 0i32 as nk_rp_coord;
    (*context).extra[0usize].next = &mut (*context).extra[1usize] as *mut nk_rp_node;
    (*context).extra[1usize].x = width as nk_rp_coord;
    (*context).extra[1usize].y = 65535i32 as nk_rp_coord;
    (*context).extra[1usize].next = 0 as *mut nk_rp_node;
}
unsafe fn nk_rp_setup_allow_out_of_mem(
    mut context: *mut nk_rp_context,
    mut allow_out_of_mem: libc::c_int,
) -> () {
    if 0 != allow_out_of_mem {
        /* if it's ok to run out of memory, then don't bother aligning them; */
        /* this gives better packing, but may fail due to OOM (even though */
        /* the rectangles easily fit). @TODO a smarter approach would be to only */
        /* quantize once we've hit OOM, then we could get rid of this parameter. */
        (*context).align = 1i32
    } else {
        (*context).align = ((*context).width + (*context).num_nodes - 1i32) / (*context).num_nodes
    };
}
unsafe fn nk_tt_InitFont(
    mut info: *mut nk_tt_fontinfo,
    mut data2: *const libc::c_uchar,
    mut fontstart: libc::c_int,
) -> libc::c_int {
    let mut cmap: nk_uint = 0;
    let mut t: nk_uint = 0;
    let mut i: nk_int = 0;
    let mut numTables: nk_int = 0;
    let mut data: *const nk_byte = data2;
    (*info).data = data;
    (*info).fontstart = fontstart;
    /* required */
    cmap = nk_tt__find_table(
        data,
        fontstart as nk_uint,
        b"cmap\x00" as *const u8 as *const libc::c_char,
    );
    /* required */
    (*info).loca = nk_tt__find_table(
        data,
        fontstart as nk_uint,
        b"loca\x00" as *const u8 as *const libc::c_char,
    ) as libc::c_int;
    /* required */
    (*info).head = nk_tt__find_table(
        data,
        fontstart as nk_uint,
        b"head\x00" as *const u8 as *const libc::c_char,
    ) as libc::c_int;
    /* required */
    (*info).glyf = nk_tt__find_table(
        data,
        fontstart as nk_uint,
        b"glyf\x00" as *const u8 as *const libc::c_char,
    ) as libc::c_int;
    /* required */
    (*info).hhea = nk_tt__find_table(
        data,
        fontstart as nk_uint,
        b"hhea\x00" as *const u8 as *const libc::c_char,
    ) as libc::c_int;
    /* required */
    (*info).hmtx = nk_tt__find_table(
        data,
        fontstart as nk_uint,
        b"hmtx\x00" as *const u8 as *const libc::c_char,
    ) as libc::c_int;
    /* not required */
    (*info).kern = nk_tt__find_table(
        data,
        fontstart as nk_uint,
        b"kern\x00" as *const u8 as *const libc::c_char,
    ) as libc::c_int;
    if 0 == cmap
        || 0 == (*info).loca
        || 0 == (*info).head
        || 0 == (*info).glyf
        || 0 == (*info).hhea
        || 0 == (*info).hmtx
    {
        return 0i32;
    } else {
        t = nk_tt__find_table(
            data,
            fontstart as nk_uint,
            b"maxp\x00" as *const u8 as *const libc::c_char,
        );
        if 0 != t {
            (*info).numGlyphs = nk_ttUSHORT(data.offset(t as isize).offset(4isize)) as libc::c_int
        } else {
            (*info).numGlyphs = 65535i32
        }
        /* find a cmap encoding table we understand *now* to avoid searching */
        /* later. (todo: could make this installable) */
        /* the same regardless of glyph. */
        numTables = nk_ttUSHORT(data.offset(cmap as isize).offset(2isize)) as nk_int;
        (*info).index_map = 0i32;
        i = 0i32;
        while i < numTables {
            let mut encoding_record: nk_uint = cmap
                .wrapping_add(4i32 as libc::c_uint)
                .wrapping_add((8i32 as libc::c_uint).wrapping_mul(i as nk_uint));
            /* find an encoding we understand: */
            match nk_ttUSHORT(data.offset(encoding_record as isize)) as libc::c_int {
                3 => {
                    match nk_ttUSHORT(data.offset(encoding_record as isize).offset(2isize))
                        as libc::c_int
                    {
                        1 | 10 => {
                            /* MS/Unicode */
                            (*info).index_map = cmap.wrapping_add(nk_ttULONG(
                                data.offset(encoding_record as isize).offset(4isize),
                            )) as libc::c_int
                        }
                        _ => {}
                    }
                }
                0 => {
                    /* Mac/iOS has these */
                    /* all the encodingIDs are unicode, so we don't bother to check it */
                    (*info).index_map = cmap.wrapping_add(nk_ttULONG(
                        data.offset(encoding_record as isize).offset(4isize),
                    )) as libc::c_int
                }
                _ => {}
            }
            i += 1
        }
        if (*info).index_map == 0i32 {
            return 0i32;
        } else {
            (*info).indexToLocFormat =
                nk_ttUSHORT(data.offset((*info).head as isize).offset(50isize)) as libc::c_int;
            return 1i32;
        }
    };
}
unsafe fn nk_tt__find_table(
    mut data: *const nk_byte,
    mut fontstart: nk_uint,
    mut tag: *const libc::c_char,
) -> nk_uint {
    /* @OPTIMIZE: binary search */
    let mut num_tables: nk_int =
        nk_ttUSHORT(data.offset(fontstart as isize).offset(4isize)) as nk_int;
    let mut tabledir: nk_uint = fontstart.wrapping_add(12i32 as libc::c_uint);
    let mut i: nk_int = 0;
    i = 0i32;
    while i < num_tables {
        let mut loc: nk_uint = tabledir.wrapping_add((16i32 * i) as nk_uint);
        if *data.offset(loc as isize).offset(0isize).offset(0isize) as libc::c_int
            == *tag.offset(0isize) as libc::c_int
            && *data.offset(loc as isize).offset(0isize).offset(1isize) as libc::c_int
                == *tag.offset(1isize) as libc::c_int
            && *data.offset(loc as isize).offset(0isize).offset(2isize) as libc::c_int
                == *tag.offset(2isize) as libc::c_int
            && *data.offset(loc as isize).offset(0isize).offset(3isize) as libc::c_int
                == *tag.offset(3isize) as libc::c_int
        {
            return nk_ttULONG(data.offset(loc as isize).offset(8isize));
        } else {
            i += 1
        }
    }
    return 0i32 as nk_uint;
}
unsafe fn nk_range_glyph_count(mut range: *const nk_rune, mut count: libc::c_int) -> libc::c_int {
    let mut i: libc::c_int = 0i32;
    let mut total_glyphs: libc::c_int = 0i32;
    i = 0i32;
    while i < count {
        let mut diff: libc::c_int = 0;
        let mut f: nk_rune = *range.offset((i * 2i32 + 0i32) as isize);
        let mut t: nk_rune = *range.offset((i * 2i32 + 1i32) as isize);
        diff = t.wrapping_sub(f).wrapping_add(1i32 as libc::c_uint) as libc::c_int;
        total_glyphs += diff;
        i += 1
    }
    return total_glyphs;
}
unsafe fn nk_font_baker(
    mut memory: *mut libc::c_void,
    mut glyph_count: libc::c_int,
    mut count: libc::c_int,
    mut alloc: *mut nk_allocator,
) -> *mut nk_font_baker {
    let mut baker: *mut nk_font_baker = 0 as *mut nk_font_baker;
    if memory.is_null() {
        return 0 as *mut nk_font_baker;
    } else {
        /* setup baker inside a memory block  */
        baker = ((memory as *mut nk_byte)
            .offset(nk_baker_align.wrapping_sub(1i32 as libc::c_ulong) as isize)
            as libc::c_long as nk_size
            & !nk_baker_align.wrapping_sub(1i32 as libc::c_ulong)) as libc::c_long
            as *mut libc::c_void as *mut nk_font_baker;
        (*baker).build = ((baker.offset(1isize) as *mut nk_byte)
            .offset(nk_build_align.wrapping_sub(1i32 as libc::c_ulong) as isize)
            as libc::c_long as nk_size
            & !nk_build_align.wrapping_sub(1i32 as libc::c_ulong))
            as libc::c_long as *mut libc::c_void as *mut nk_font_bake_data;
        (*baker).packed_chars = (((*baker).build.offset(count as isize) as *mut nk_byte)
            .offset(nk_char_align.wrapping_sub(1i32 as libc::c_ulong) as isize)
            as libc::c_long as nk_size
            & !nk_char_align.wrapping_sub(1i32 as libc::c_ulong))
            as libc::c_long as *mut libc::c_void
            as *mut nk_tt_packedchar;
        (*baker).rects = (((*baker).packed_chars.offset(glyph_count as isize) as *mut nk_byte)
            .offset(nk_rect_align.wrapping_sub(1i32 as libc::c_ulong) as isize)
            as libc::c_long as nk_size
            & !nk_rect_align.wrapping_sub(1i32 as libc::c_ulong))
            as libc::c_long as *mut libc::c_void as *mut nk_rp_rect;
        (*baker).ranges = (((*baker).rects.offset(glyph_count as isize) as *mut nk_byte)
            .offset(nk_range_align.wrapping_sub(1i32 as libc::c_ulong) as isize)
            as libc::c_long as nk_size
            & !nk_range_align.wrapping_sub(1i32 as libc::c_ulong))
            as libc::c_long as *mut libc::c_void as *mut nk_tt_pack_range;
        (*baker).alloc = *alloc;
        return baker;
    };
}

const nk_range_align: nk_size = ::std::mem::align_of::<nk_tt_pack_range>() as nk_size;
const nk_rect_align: nk_size = ::std::mem::align_of::<nk_rp_rect>() as nk_size;
const nk_char_align: nk_size = ::std::mem::align_of::<nk_tt_packedchar>() as nk_size;
const nk_build_align: nk_size = ::std::mem::align_of::<nk_font_bake_data>() as nk_size;
const nk_baker_align: nk_size = ::std::mem::align_of::<nk_font_baker>() as nk_size;

unsafe fn nk_font_baker_memory(
    mut temp: *mut nk_size,
    mut glyph_count: *mut libc::c_int,
    mut config_list: *mut nk_font_config,
    mut count: libc::c_int,
) -> () {
    let mut range_count: libc::c_int = 0i32;
    let mut total_range_count: libc::c_int = 0i32;
    let mut iter: *mut nk_font_config = 0 as *mut nk_font_config;
    let mut i: *mut nk_font_config = 0 as *mut nk_font_config;
    if config_list.is_null() {
        *temp = 0i32 as nk_size;
        *glyph_count = 0i32;
        return;
    } else {
        *glyph_count = 0i32;
        iter = config_list;
        while !iter.is_null() {
            i = iter;
            loop {
                if (*i).range.is_null() {
                    (*iter).range = nk_font_default_glyph_ranges()
                }
                range_count = nk_range_count((*i).range);
                total_range_count += range_count;
                *glyph_count += nk_range_glyph_count((*i).range, range_count);
                i = (*i).n;
                if !(i != iter) {
                    break;
                }
            }
            iter = (*iter).next
        }
        *temp = (*glyph_count as nk_size)
            .wrapping_mul(::std::mem::size_of::<nk_rp_rect>() as libc::c_ulong);
        *temp = (*temp as libc::c_ulong).wrapping_add(
            (total_range_count as nk_size)
                .wrapping_mul(::std::mem::size_of::<nk_tt_pack_range>() as libc::c_ulong),
        ) as nk_size as nk_size;
        *temp = (*temp as libc::c_ulong).wrapping_add(
            (*glyph_count as nk_size)
                .wrapping_mul(::std::mem::size_of::<nk_tt_packedchar>() as libc::c_ulong),
        ) as nk_size as nk_size;
        *temp = (*temp as libc::c_ulong).wrapping_add(
            (count as nk_size)
                .wrapping_mul(::std::mem::size_of::<nk_font_bake_data>() as libc::c_ulong),
        ) as nk_size as nk_size;
        *temp = (*temp as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<nk_font_baker>() as libc::c_ulong)
            as nk_size as nk_size;
        *temp = (*temp as libc::c_ulong).wrapping_add(
            nk_rect_align
                .wrapping_add(nk_range_align)
                .wrapping_add(nk_char_align),
        ) as nk_size as nk_size;
        *temp = (*temp as libc::c_ulong).wrapping_add(nk_build_align.wrapping_add(nk_baker_align))
            as nk_size as nk_size;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_font_atlas_end(
    mut atlas: *mut nk_font_atlas,
    mut texture: nk_handle,
    mut null: *mut nk_draw_null_texture,
) -> () {
    let mut i: libc::c_int = 0i32;
    let mut font_iter: *mut nk_font = 0 as *mut nk_font;
    if atlas.is_null() {
        if null.is_null() {
            return;
        } else {
            (*null).texture = texture;
            (*null).uv = nk_vec2(0.5f32, 0.5f32)
        }
    }
    if !null.is_null() {
        (*null).texture = texture;
        (*null).uv.x = ((*atlas).custom.x as libc::c_int as f32 + 0.5f32)
            / (*atlas).tex_width as f32;
        (*null).uv.y = ((*atlas).custom.y as libc::c_int as f32 + 0.5f32)
            / (*atlas).tex_height as f32
    }
    font_iter = (*atlas).fonts;
    while !font_iter.is_null() {
        (*font_iter).texture = texture;
        (*font_iter).handle.texture = texture;
        font_iter = (*font_iter).next
    }
    i = 0i32;
    while i < NK_CURSOR_COUNT as libc::c_int {
        (*atlas).cursors[i as usize].img.handle = texture;
        i += 1
    }
    (*atlas).temporary.free.expect("non-null function pointer")(
        (*atlas).temporary.userdata,
        (*atlas).pixel,
    );
    (*atlas).pixel = 0 as *mut libc::c_void;
    (*atlas).tex_width = 0i32;
    (*atlas).tex_height = 0i32;
    (*atlas).custom.x = 0i32 as libc::c_short;
    (*atlas).custom.y = 0i32 as libc::c_short;
    (*atlas).custom.w = 0i32 as libc::c_short;
    (*atlas).custom.h = 0i32 as libc::c_short;
}
#[no_mangle]
pub unsafe fn nk_font_atlas_cleanup(mut atlas: *mut nk_font_atlas) -> () {
    if atlas.is_null() || (*atlas).permanent.alloc.is_none() || (*atlas).permanent.free.is_none() {
        return;
    } else {
        if !(*atlas).config.is_null() {
            let mut iter: *mut nk_font_config = 0 as *mut nk_font_config;
            iter = (*atlas).config;
            while !iter.is_null() {
                let mut i: *mut nk_font_config = 0 as *mut nk_font_config;
                i = (*iter).n;
                while i != iter {
                    (*atlas).permanent.free.expect("non-null function pointer")(
                        (*atlas).permanent.userdata,
                        (*i).ttf_blob,
                    );
                    (*i).ttf_blob = 0 as *mut libc::c_void;
                    i = (*i).n
                }
                (*atlas).permanent.free.expect("non-null function pointer")(
                    (*atlas).permanent.userdata,
                    (*iter).ttf_blob,
                );
                (*iter).ttf_blob = 0 as *mut libc::c_void;
                iter = (*iter).next
            }
        }
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_font_atlas_clear(mut atlas: *mut nk_font_atlas) -> () {
    if atlas.is_null() || (*atlas).permanent.alloc.is_none() || (*atlas).permanent.free.is_none() {
        return;
    } else {
        if !(*atlas).config.is_null() {
            let mut iter: *mut nk_font_config = 0 as *mut nk_font_config;
            let mut next: *mut nk_font_config = 0 as *mut nk_font_config;
            iter = (*atlas).config;
            while !iter.is_null() {
                let mut i: *mut nk_font_config = 0 as *mut nk_font_config;
                let mut n: *mut nk_font_config = 0 as *mut nk_font_config;
                i = (*iter).n;
                while i != iter {
                    n = (*i).n;
                    if !(*i).ttf_blob.is_null() {
                        (*atlas).permanent.free.expect("non-null function pointer")(
                            (*atlas).permanent.userdata,
                            (*i).ttf_blob,
                        );
                    }
                    (*atlas).permanent.free.expect("non-null function pointer")(
                        (*atlas).permanent.userdata,
                        i as *mut libc::c_void,
                    );
                    i = n
                }
                next = (*iter).next;
                if !(*i).ttf_blob.is_null() {
                    (*atlas).permanent.free.expect("non-null function pointer")(
                        (*atlas).permanent.userdata,
                        (*iter).ttf_blob,
                    );
                }
                (*atlas).permanent.free.expect("non-null function pointer")(
                    (*atlas).permanent.userdata,
                    iter as *mut libc::c_void,
                );
                iter = next
            }
            (*atlas).config = 0 as *mut nk_font_config
        }
        if !(*atlas).fonts.is_null() {
            let mut iter_0: *mut nk_font = 0 as *mut nk_font;
            let mut next_0: *mut nk_font = 0 as *mut nk_font;
            iter_0 = (*atlas).fonts;
            while !iter_0.is_null() {
                next_0 = (*iter_0).next;
                (*atlas).permanent.free.expect("non-null function pointer")(
                    (*atlas).permanent.userdata,
                    iter_0 as *mut libc::c_void,
                );
                iter_0 = next_0
            }
            (*atlas).fonts = 0 as *mut nk_font
        }
        if !(*atlas).glyphs.is_null() {
            (*atlas).permanent.free.expect("non-null function pointer")(
                (*atlas).permanent.userdata,
                (*atlas).glyphs as *mut libc::c_void,
            );
        }
        nk_zero(
            atlas as *mut libc::c_void,
            ::std::mem::size_of::<nk_font_atlas>() as libc::c_ulong,
        );
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_buffer_init_default(mut buffer: *mut nk_buffer) -> () {
    let mut alloc: nk_allocator = nk_allocator {
        userdata: nk_handle {
            ptr: 0 as *mut libc::c_void,
        },
        alloc: None,
        free: None,
    };
    alloc.userdata.ptr = 0 as *mut libc::c_void;
    alloc.alloc = Some(nk_malloc);
    alloc.free = Some(nk_mfree);
    nk_buffer_init(buffer, &mut alloc, (4i32 * 1024i32) as nk_size);
}
#[no_mangle]
pub unsafe fn nk_buffer_info(mut s: *mut nk_memory_status, mut b: *mut nk_buffer) -> () {
    if s.is_null() || b.is_null() {
        return;
    } else {
        (*s).allocated = (*b).allocated;
        (*s).size = (*b).memory.size;
        (*s).needed = (*b).needed;
        (*s).memory = (*b).memory.ptr;
        (*s).calls = (*b).calls;
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_buffer_push(
    mut b: *mut nk_buffer,
    mut type_0: nk_buffer_allocation_type,
    mut memory: *const libc::c_void,
    mut size: nk_size,
    mut align: nk_size,
) -> () {
    let mut mem: *mut libc::c_void = nk_buffer_alloc(b, type_0, size, align);
    if mem.is_null() {
        return;
    } else {
        nk_memcopy(mem, memory, size);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_buffer_memory_const(mut buffer: *const nk_buffer) -> *const libc::c_void {
    if buffer.is_null() {
        return 0 as *const libc::c_void;
    } else {
        return (*buffer).memory.ptr;
    };
}
#[no_mangle]
pub unsafe fn nk_str_init_default(mut str: *mut nk_str) -> () {
    let mut alloc: nk_allocator = nk_allocator {
        userdata: nk_handle {
            ptr: 0 as *mut libc::c_void,
        },
        alloc: None,
        free: None,
    };
    alloc.userdata.ptr = 0 as *mut libc::c_void;
    alloc.alloc = Some(nk_malloc);
    alloc.free = Some(nk_mfree);
    nk_buffer_init(&mut (*str).buffer, &mut alloc, 32i32 as nk_size);
    (*str).len = 0i32;
}
#[no_mangle]
pub unsafe fn nk_str_init(
    mut str: *mut nk_str,
    mut alloc: *const nk_allocator,
    mut size: nk_size,
) -> () {
    nk_buffer_init(&mut (*str).buffer, alloc, size);
    (*str).len = 0i32;
}
#[no_mangle]
pub unsafe fn nk_str_clear(mut str: *mut nk_str) -> () {
    nk_buffer_clear(&mut (*str).buffer);
    (*str).len = 0i32;
}
#[no_mangle]
pub unsafe fn nk_str_free(mut str: *mut nk_str) -> () {
    nk_buffer_free(&mut (*str).buffer);
    (*str).len = 0i32;
}
#[no_mangle]
pub unsafe fn nk_str_append_str_char(
    mut s: *mut nk_str,
    mut str: *const libc::c_char,
) -> libc::c_int {
    return nk_str_append_text_char(s, str, nk_strlen(str));
}
#[no_mangle]
pub unsafe fn nk_str_append_text_utf8(
    mut str: *mut nk_str,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0i32;
    let mut byte_len: libc::c_int = 0i32;
    let mut unicode: nk_rune = 0;
    if str.is_null() || text.is_null() || 0 == len {
        return 0i32;
    } else {
        i = 0i32;
        while i < len {
            byte_len += nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
            i += 1
        }
        nk_str_append_text_char(str, text, byte_len);
        return len;
    };
}
#[no_mangle]
pub unsafe fn nk_str_append_str_utf8(
    mut str: *mut nk_str,
    mut text: *const libc::c_char,
) -> libc::c_int {
    let mut runes: libc::c_int = 0i32;
    let mut byte_len: libc::c_int = 0i32;
    let mut num_runes: libc::c_int = 0i32;
    let mut glyph_len: libc::c_int = 0i32;
    let mut unicode: nk_rune = 0;
    if str.is_null() || text.is_null() {
        return 0i32;
    } else {
        byte_len = nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
        glyph_len = byte_len;
        while unicode != '\u{0}' as i32 as libc::c_uint && 0 != glyph_len {
            glyph_len = nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
            byte_len += glyph_len;
            num_runes += 1
        }
        nk_str_append_text_char(str, text, byte_len);
        return runes;
    };
}
#[no_mangle]
pub unsafe fn nk_str_append_text_runes(
    mut str: *mut nk_str,
    mut text: *const nk_rune,
    mut len: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0i32;
    let mut byte_len: libc::c_int = 0i32;
    let mut glyph: nk_glyph = [0; 4];
    if str.is_null() || text.is_null() || 0 == len {
        return 0i32;
    } else {
        i = 0i32;
        while i < len {
            byte_len = nk_utf_encode(*text.offset(i as isize), glyph.as_mut_ptr(), 4i32);
            if 0 == byte_len {
                break;
            }
            nk_str_append_text_char(str, glyph.as_mut_ptr(), byte_len);
            i += 1
        }
        return len;
    };
}
#[no_mangle]
pub unsafe fn nk_str_append_str_runes(
    mut str: *mut nk_str,
    mut runes: *const nk_rune,
) -> libc::c_int {
    let mut i: libc::c_int = 0i32;
    let mut glyph: nk_glyph = [0; 4];
    let mut byte_len: libc::c_int = 0;
    if str.is_null() || runes.is_null() {
        return 0i32;
    } else {
        while *runes.offset(i as isize) != '\u{0}' as i32 as libc::c_uint {
            byte_len = nk_utf_encode(*runes.offset(i as isize), glyph.as_mut_ptr(), 4i32);
            nk_str_append_text_char(str, glyph.as_mut_ptr(), byte_len);
            i += 1
        }
        return i;
    };
}
#[no_mangle]
pub unsafe fn nk_str_insert_text_char(
    mut str: *mut nk_str,
    mut pos: libc::c_int,
    mut text: *const libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    return nk_str_insert_text_utf8(str, pos, text, len);
}
#[no_mangle]
pub unsafe fn nk_str_insert_str_char(
    mut str: *mut nk_str,
    mut pos: libc::c_int,
    mut text: *const libc::c_char,
) -> libc::c_int {
    return nk_str_insert_text_utf8(str, pos, text, nk_strlen(text));
}
#[no_mangle]
pub unsafe fn nk_str_insert_str_utf8(
    mut str: *mut nk_str,
    mut pos: libc::c_int,
    mut text: *const libc::c_char,
) -> libc::c_int {
    let mut runes: libc::c_int = 0i32;
    let mut byte_len: libc::c_int = 0i32;
    let mut num_runes: libc::c_int = 0i32;
    let mut glyph_len: libc::c_int = 0i32;
    let mut unicode: nk_rune = 0;
    if str.is_null() || text.is_null() {
        return 0i32;
    } else {
        byte_len = nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
        glyph_len = byte_len;
        while unicode != '\u{0}' as i32 as libc::c_uint && 0 != glyph_len {
            glyph_len = nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
            byte_len += glyph_len;
            num_runes += 1
        }
        nk_str_insert_at_rune(str, pos, text, byte_len);
        return runes;
    };
}
#[no_mangle]
pub unsafe fn nk_str_insert_str_runes(
    mut str: *mut nk_str,
    mut pos: libc::c_int,
    mut runes: *const nk_rune,
) -> libc::c_int {
    let mut i: libc::c_int = 0i32;
    let mut glyph: nk_glyph = [0; 4];
    let mut byte_len: libc::c_int = 0;
    if str.is_null() || runes.is_null() {
        return 0i32;
    } else {
        while *runes.offset(i as isize) != '\u{0}' as i32 as libc::c_uint {
            byte_len = nk_utf_encode(*runes.offset(i as isize), glyph.as_mut_ptr(), 4i32);
            nk_str_insert_at_rune(str, pos + i, glyph.as_mut_ptr(), byte_len);
            i += 1
        }
        return i;
    };
}
#[no_mangle]
pub unsafe fn nk_str_remove_runes(mut str: *mut nk_str, mut len: libc::c_int) -> () {
    let mut index: libc::c_int = 0;
    let mut begin: *const libc::c_char = 0 as *const libc::c_char;
    let mut end: *const libc::c_char = 0 as *const libc::c_char;
    let mut unicode: nk_rune = 0;
    if str.is_null() || len < 0i32 {
        return;
    } else if len >= (*str).len {
        (*str).len = 0i32;
        return;
    } else {
        index = (*str).len - len;
        begin = nk_str_at_rune(str, index, &mut unicode, &mut len);
        end = ((*str).buffer.memory.ptr as *const libc::c_char)
            .offset((*str).buffer.allocated as isize);
        nk_str_remove_chars(
            str,
            begin.ptr_offset_to(end).expect("bad offset_to") as libc::c_long as libc::c_int + 1i32,
        );
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_str_at_char(mut s: *mut nk_str, mut pos: libc::c_int) -> *mut libc::c_char {
    if s.is_null() || pos > (*s).buffer.allocated as libc::c_int {
        return 0 as *mut libc::c_char;
    } else {
        return ((*s).buffer.memory.ptr as *mut nk_byte).offset(pos as isize) as *mut libc::c_void
            as *mut libc::c_char;
    };
}
#[no_mangle]
pub unsafe fn nk_str_at_char_const(
    mut s: *const nk_str,
    mut pos: libc::c_int,
) -> *const libc::c_char {
    if s.is_null() || pos > (*s).buffer.allocated as libc::c_int {
        return 0 as *const libc::c_char;
    } else {
        return ((*s).buffer.memory.ptr as *mut nk_byte).offset(pos as isize) as *mut libc::c_void
            as *mut libc::c_char;
    };
}
#[no_mangle]
pub unsafe fn nk_str_get(mut s: *mut nk_str) -> *mut libc::c_char {
    if s.is_null() || 0 == (*s).len || 0 == (*s).buffer.allocated {
        return 0 as *mut libc::c_char;
    } else {
        return (*s).buffer.memory.ptr as *mut libc::c_char;
    };
}
#[no_mangle]
pub unsafe fn nk_filter_ascii(mut box_0: *const nk_text_edit, mut unicode: nk_rune) -> libc::c_int {
    if unicode > 128i32 as libc::c_uint {
        return nk_false as libc::c_int;
    } else {
        return nk_true as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_filter_hex(mut box_0: *const nk_text_edit, mut unicode: nk_rune) -> libc::c_int {
    if (unicode < '0' as i32 as libc::c_uint || unicode > '9' as i32 as libc::c_uint)
        && (unicode < 'a' as i32 as libc::c_uint || unicode > 'f' as i32 as libc::c_uint)
        && (unicode < 'A' as i32 as libc::c_uint || unicode > 'F' as i32 as libc::c_uint)
    {
        return nk_false as libc::c_int;
    } else {
        return nk_true as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_filter_oct(mut box_0: *const nk_text_edit, mut unicode: nk_rune) -> libc::c_int {
    if unicode < '0' as i32 as libc::c_uint || unicode > '7' as i32 as libc::c_uint {
        return nk_false as libc::c_int;
    } else {
        return nk_true as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_filter_binary(
    mut box_0: *const nk_text_edit,
    mut unicode: nk_rune,
) -> libc::c_int {
    if unicode != '0' as i32 as libc::c_uint && unicode != '1' as i32 as libc::c_uint {
        return nk_false as libc::c_int;
    } else {
        return nk_true as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_textedit_init_default(mut state: *mut nk_text_edit) -> () {
    if state.is_null() {
        return;
    } else {
        nk_memset(
            state as *mut libc::c_void,
            0i32,
            ::std::mem::size_of::<nk_text_edit>() as libc::c_ulong,
        );
        nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, None);
        nk_str_init_default(&mut (*state).string);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_textedit_init(
    mut state: *mut nk_text_edit,
    mut alloc: *mut nk_allocator,
    mut size: nk_size,
) -> () {
    if state.is_null() || alloc.is_null() {
        return;
    } else {
        nk_memset(
            state as *mut libc::c_void,
            0i32,
            ::std::mem::size_of::<nk_text_edit>() as libc::c_ulong,
        );
        nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, None);
        nk_str_init(&mut (*state).string, alloc, size);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_textedit_init_fixed(
    mut state: *mut nk_text_edit,
    mut memory: *mut libc::c_void,
    mut size: nk_size,
) -> () {
    if state.is_null() || memory.is_null() || 0 == size {
        return;
    } else {
        nk_memset(
            state as *mut libc::c_void,
            0i32,
            ::std::mem::size_of::<nk_text_edit>() as libc::c_ulong,
        );
        nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, None);
        nk_str_init_fixed(&mut (*state).string, memory, size);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_textedit_free(mut state: *mut nk_text_edit) -> () {
    if state.is_null() {
        return;
    } else {
        nk_str_free(&mut (*state).string);
        return;
    };
}
#[no_mangle]
pub unsafe fn nk_textedit_paste(
    mut state: *mut nk_text_edit,
    mut ctext: *const libc::c_char,
    mut len: libc::c_int,
) -> libc::c_int {
    /* API paste: replace existing selection with passed-in text */
    let mut glyphs: libc::c_int = 0;
    let mut text: *const libc::c_char = ctext;
    if (*state).mode as libc::c_int == NK_TEXT_EDIT_MODE_VIEW as libc::c_int {
        return 0i32;
    } else {
        /* if there's a selection, the paste should delete it */
        nk_textedit_clamp(state);
        nk_textedit_delete_selection(state);
        /* try to insert the characters */
        glyphs = nk_utf_len(ctext, len);
        if 0 != nk_str_insert_text_char(&mut (*state).string, (*state).cursor, text, len) {
            nk_textedit_makeundo_insert(state, (*state).cursor, glyphs);
            (*state).cursor += len;
            (*state).has_preferred_x = 0i32 as libc::c_uchar;
            return 1i32;
        } else {
            /* remove the undo since we didn't actually insert the characters */
            if 0 != (*state).undo.undo_point {
                (*state).undo.undo_point -= 1
            }
            return 0i32;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_stroke_curve(
    mut b: *mut nk_command_buffer,
    mut ax: f32,
    mut ay: f32,
    mut ctrl0x: f32,
    mut ctrl0y: f32,
    mut ctrl1x: f32,
    mut ctrl1y: f32,
    mut bx: f32,
    mut by: f32,
    mut line_thickness: f32,
    mut col: nk_color,
) -> () {
    let mut cmd: *mut nk_command_curve = 0 as *mut nk_command_curve;
    if b.is_null() || col.a as libc::c_int == 0i32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_CURVE,
            ::std::mem::size_of::<nk_command_curve>() as libc::c_ulong,
        ) as *mut nk_command_curve;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).line_thickness = line_thickness as libc::c_ushort;
            (*cmd).begin.x = ax as libc::c_short;
            (*cmd).begin.y = ay as libc::c_short;
            (*cmd).ctrl[0usize].x = ctrl0x as libc::c_short;
            (*cmd).ctrl[0usize].y = ctrl0y as libc::c_short;
            (*cmd).ctrl[1usize].x = ctrl1x as libc::c_short;
            (*cmd).ctrl[1usize].y = ctrl1y as libc::c_short;
            (*cmd).end.x = bx as libc::c_short;
            (*cmd).end.y = by as libc::c_short;
            (*cmd).color = col;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_stroke_circle(
    mut b: *mut nk_command_buffer,
    mut r: nk_rect,
    mut line_thickness: f32,
    mut c: nk_color,
) -> () {
    let mut cmd: *mut nk_command_circle = 0 as *mut nk_command_circle;
    if b.is_null()
        || r.w == 0i32 as f32
        || r.h == 0i32 as f32
        || line_thickness <= 0i32 as f32
    {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const nk_rect = &mut (*b).clip as *mut nk_rect;
            if (*clip).x > r.x + r.w
                || (*clip).x + (*clip).w < r.x
                || (*clip).y > r.y + r.h
                || (*clip).y + (*clip).h < r.y
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_CIRCLE,
            ::std::mem::size_of::<nk_command_circle>() as libc::c_ulong,
        ) as *mut nk_command_circle;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).line_thickness = line_thickness as libc::c_ushort;
            (*cmd).x = r.x as libc::c_short;
            (*cmd).y = r.y as libc::c_short;
            (*cmd).w = (if r.w < 0i32 as f32 {
                0i32 as f32
            } else {
                r.w
            }) as libc::c_ushort;
            (*cmd).h = (if r.h < 0i32 as f32 {
                0i32 as f32
            } else {
                r.h
            }) as libc::c_ushort;
            (*cmd).color = c;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_stroke_arc(
    mut b: *mut nk_command_buffer,
    mut cx: f32,
    mut cy: f32,
    mut radius: f32,
    mut a_min: f32,
    mut a_max: f32,
    mut line_thickness: f32,
    mut c: nk_color,
) -> () {
    let mut cmd: *mut nk_command_arc = 0 as *mut nk_command_arc;
    if b.is_null() || c.a as libc::c_int == 0i32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_ARC,
            ::std::mem::size_of::<nk_command_arc>() as libc::c_ulong,
        ) as *mut nk_command_arc;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).line_thickness = line_thickness as libc::c_ushort;
            (*cmd).cx = cx as libc::c_short;
            (*cmd).cy = cy as libc::c_short;
            (*cmd).r = radius as libc::c_ushort;
            (*cmd).a[0usize] = a_min;
            (*cmd).a[1usize] = a_max;
            (*cmd).color = c;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_stroke_triangle(
    mut b: *mut nk_command_buffer,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
    mut x2: f32,
    mut y2: f32,
    mut line_thickness: f32,
    mut c: nk_color,
) -> () {
    let mut cmd: *mut nk_command_triangle = 0 as *mut nk_command_triangle;
    if b.is_null() || c.a as libc::c_int == 0i32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const nk_rect = &mut (*b).clip as *mut nk_rect;
            if !((*clip).x <= x0
                && x0 < (*clip).x + (*clip).w
                && ((*clip).y <= y0 && y0 < (*clip).y + (*clip).h))
                && !((*clip).x <= x1
                    && x1 < (*clip).x + (*clip).w
                    && ((*clip).y <= y1 && y1 < (*clip).y + (*clip).h))
                && !((*clip).x <= x2
                    && x2 < (*clip).x + (*clip).w
                    && ((*clip).y <= y2 && y2 < (*clip).y + (*clip).h))
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_TRIANGLE,
            ::std::mem::size_of::<nk_command_triangle>() as libc::c_ulong,
        ) as *mut nk_command_triangle;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).line_thickness = line_thickness as libc::c_ushort;
            (*cmd).a.x = x0 as libc::c_short;
            (*cmd).a.y = y0 as libc::c_short;
            (*cmd).b.x = x1 as libc::c_short;
            (*cmd).b.y = y1 as libc::c_short;
            (*cmd).c.x = x2 as libc::c_short;
            (*cmd).c.y = y2 as libc::c_short;
            (*cmd).color = c;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_stroke_polyline(
    mut b: *mut nk_command_buffer,
    mut points: *mut f32,
    mut point_count: libc::c_int,
    mut line_thickness: f32,
    mut col: nk_color,
) -> () {
    let mut i: libc::c_int = 0;
    let mut size: nk_size = 0i32 as nk_size;
    let mut cmd: *mut nk_command_polyline = 0 as *mut nk_command_polyline;
    if b.is_null() || col.a as libc::c_int == 0i32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        size = (::std::mem::size_of::<nk_command_polyline>() as libc::c_ulong).wrapping_add(
            (::std::mem::size_of::<libc::c_short>() as libc::c_ulong)
                .wrapping_mul(2i32 as libc::c_ulong)
                .wrapping_mul(point_count as nk_size),
        );
        cmd = nk_command_buffer_push(b, NK_COMMAND_POLYLINE, size) as *mut nk_command_polyline;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).color = col;
            (*cmd).point_count = point_count as libc::c_ushort;
            (*cmd).line_thickness = line_thickness as libc::c_ushort;
            i = 0i32;
            while i < point_count {
                (*cmd).points[i as usize].x = *points.offset((i * 2i32) as isize) as libc::c_short;
                (*cmd).points[i as usize].y =
                    *points.offset((i * 2i32 + 1i32) as isize) as libc::c_short;
                i += 1
            }
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_stroke_polygon(
    mut b: *mut nk_command_buffer,
    mut points: *mut f32,
    mut point_count: libc::c_int,
    mut line_thickness: f32,
    mut col: nk_color,
) -> () {
    let mut i: libc::c_int = 0;
    let mut size: nk_size = 0i32 as nk_size;
    let mut cmd: *mut nk_command_polygon = 0 as *mut nk_command_polygon;
    if b.is_null() || col.a as libc::c_int == 0i32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        size = (::std::mem::size_of::<nk_command_polygon>() as libc::c_ulong).wrapping_add(
            (::std::mem::size_of::<libc::c_short>() as libc::c_ulong)
                .wrapping_mul(2i32 as libc::c_ulong)
                .wrapping_mul(point_count as nk_size),
        );
        cmd = nk_command_buffer_push(b, NK_COMMAND_POLYGON, size) as *mut nk_command_polygon;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).color = col;
            (*cmd).line_thickness = line_thickness as libc::c_ushort;
            (*cmd).point_count = point_count as libc::c_ushort;
            i = 0i32;
            while i < point_count {
                (*cmd).points[i as usize].x = *points.offset((i * 2i32) as isize) as libc::c_short;
                (*cmd).points[i as usize].y =
                    *points.offset((i * 2i32 + 1i32) as isize) as libc::c_short;
                i += 1
            }
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_fill_arc(
    mut b: *mut nk_command_buffer,
    mut cx: f32,
    mut cy: f32,
    mut radius: f32,
    mut a_min: f32,
    mut a_max: f32,
    mut c: nk_color,
) -> () {
    let mut cmd: *mut nk_command_arc_filled = 0 as *mut nk_command_arc_filled;
    if b.is_null() || c.a as libc::c_int == 0i32 {
        return;
    } else {
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_ARC_FILLED,
            ::std::mem::size_of::<nk_command_arc_filled>() as libc::c_ulong,
        ) as *mut nk_command_arc_filled;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).cx = cx as libc::c_short;
            (*cmd).cy = cy as libc::c_short;
            (*cmd).r = radius as libc::c_ushort;
            (*cmd).a[0usize] = a_min;
            (*cmd).a[1usize] = a_max;
            (*cmd).color = c;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_fill_polygon(
    mut b: *mut nk_command_buffer,
    mut points: *mut f32,
    mut point_count: libc::c_int,
    mut col: nk_color,
) -> () {
    let mut i: libc::c_int = 0;
    let mut size: nk_size = 0i32 as nk_size;
    let mut cmd: *mut nk_command_polygon_filled = 0 as *mut nk_command_polygon_filled;
    if b.is_null() || col.a as libc::c_int == 0i32 {
        return;
    } else {
        size = (::std::mem::size_of::<nk_command_polygon_filled>() as libc::c_ulong).wrapping_add(
            (::std::mem::size_of::<libc::c_short>() as libc::c_ulong)
                .wrapping_mul(2i32 as libc::c_ulong)
                .wrapping_mul(point_count as nk_size),
        );
        cmd = nk_command_buffer_push(b, NK_COMMAND_POLYGON_FILLED, size)
            as *mut nk_command_polygon_filled;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).color = col;
            (*cmd).point_count = point_count as libc::c_ushort;
            i = 0i32;
            while i < point_count {
                (*cmd).points[i as usize].x =
                    *points.offset((i * 2i32 + 0i32) as isize) as libc::c_short;
                (*cmd).points[i as usize].y =
                    *points.offset((i * 2i32 + 1i32) as isize) as libc::c_short;
                i += 1
            }
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_push_custom(
    mut b: *mut nk_command_buffer,
    mut r: nk_rect,
    mut cb: nk_command_custom_callback,
    mut usr: nk_handle,
) -> () {
    let mut cmd: *mut nk_command_custom = 0 as *mut nk_command_custom;
    if b.is_null() {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut c: *const nk_rect = &mut (*b).clip as *mut nk_rect;
            if (*c).w == 0i32 as f32 || (*c).h == 0i32 as f32
                || ((*c).x > r.x + r.w
                    || (*c).x + (*c).w < r.x
                    || (*c).y > r.y + r.h
                    || (*c).y + (*c).h < r.y)
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_CUSTOM,
            ::std::mem::size_of::<nk_command_custom>() as libc::c_ulong,
        ) as *mut nk_command_custom;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).x = r.x as libc::c_short;
            (*cmd).y = r.y as libc::c_short;
            (*cmd).w = (if (0i32 as f32) < r.w {
                r.w
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).h = (if (0i32 as f32) < r.h {
                r.h
            } else {
                0i32 as f32
            }) as libc::c_ushort;
            (*cmd).callback_data = usr;
            (*cmd).callback = cb;
            return;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_input_has_mouse_click(mut i: *const nk_input, mut id: nk_buttons) -> libc::c_int {
    let mut btn: *const nk_mouse_button = 0 as *const nk_mouse_button;
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        btn = &(*i).mouse.buttons[id as usize] as *const nk_mouse_button;
        return if 0 != (*btn).clicked && (*btn).down == nk_false as libc::c_int {
            nk_true as libc::c_int
        } else {
            nk_false as libc::c_int
        };
    };
}
#[no_mangle]
pub unsafe fn nk_input_any_mouse_click_in_rect(
    mut in_0: *const nk_input,
    mut b: nk_rect,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut down: libc::c_int = 0i32;
    i = 0i32;
    while i < NK_BUTTON_MAX as libc::c_int {
        down = (0 != down || 0 != nk_input_is_mouse_click_in_rect(in_0, i as nk_buttons, b))
            as libc::c_int;
        i += 1
    }
    return down;
}
#[no_mangle]
pub unsafe fn nk_input_is_mouse_released(
    mut i: *const nk_input,
    mut id: nk_buttons,
) -> libc::c_int {
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        return (0 == (*i).mouse.buttons[id as usize].down
            && 0 != (*i).mouse.buttons[id as usize].clicked) as libc::c_int;
    };
}
#[no_mangle]
pub unsafe fn nk_input_is_key_released(mut i: *const nk_input, mut key: nk_keys) -> libc::c_int {
    let mut k: *const nk_key = 0 as *const nk_key;
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        k = &(*i).keyboard.keys[key as usize] as *const nk_key;
        if 0 == (*k).down && 0 != (*k).clicked
            || 0 != (*k).down && (*k).clicked >= 2i32 as libc::c_uint
        {
            return nk_true as libc::c_int;
        } else {
            return nk_false as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_input_is_key_down(mut i: *const nk_input, mut key: nk_keys) -> libc::c_int {
    let mut k: *const nk_key = 0 as *const nk_key;
    if i.is_null() {
        return nk_false as libc::c_int;
    } else {
        k = &(*i).keyboard.keys[key as usize] as *const nk_key;
        if 0 != (*k).down {
            return nk_true as libc::c_int;
        } else {
            return nk_false as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe fn nk_style_item_image(mut img: nk_image) -> nk_style_item {
    let mut i: nk_style_item = nk_style_item {
        type_0: NK_STYLE_ITEM_COLOR,
        data: nk_style_item_data {
            image: nk_image {
                handle: nk_handle {
                    ptr: 0 as *mut libc::c_void,
                },
                w: 0,
                h: 0,
                region: [0; 4],
            },
        },
    };
    i.type_0 = NK_STYLE_ITEM_IMAGE;
    i.data.image = img;
    return i;
}
static mut nk_red: nk_color = unsafe {
    nk_color {
        r: 255i32 as nk_byte,
        g: 0i32 as nk_byte,
        b: 0i32 as nk_byte,
        a: 255i32 as nk_byte,
    }
};
static mut nk_green: nk_color = unsafe {
    nk_color {
        r: 0i32 as nk_byte,
        g: 255i32 as nk_byte,
        b: 0i32 as nk_byte,
        a: 255i32 as nk_byte,
    }
};
static mut nk_blue: nk_color = unsafe {
    nk_color {
        r: 0i32 as nk_byte,
        g: 0i32 as nk_byte,
        b: 255i32 as nk_byte,
        a: 255i32 as nk_byte,
    }
};
static mut nk_black: nk_color = unsafe {
    nk_color {
        r: 0i32 as nk_byte,
        g: 0i32 as nk_byte,
        b: 0i32 as nk_byte,
        a: 255i32 as nk_byte,
    }
};
static mut nk_yellow: nk_color = unsafe {
    nk_color {
        r: 255i32 as nk_byte,
        g: 255i32 as nk_byte,
        b: 0i32 as nk_byte,
        a: 255i32 as nk_byte,
    }
};
