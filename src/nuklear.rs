#![allow(dead_code,
         mutable_transmutes,
         non_camel_case_types,
         non_snake_case,
         non_upper_case_globals,
         unused_mut,
         unused_comparisons,
         unused_assignments,
         unused_unsafe,
         unused_variables)]

use input::*;
use libc;
use math::*;
use offset_to::OffsetTo;
use std::{mem, ptr};

pub type Void = libc::c_void;

pub type Char = libc::c_char;
pub type Uchar = libc::c_uchar;

pub type Short = libc::c_short;
pub type Ushort = libc::c_ushort;

pub type Int = libc::c_int;
pub type Uint = libc::c_uint;

pub type Long = libc::c_long;
pub type Ulong = libc::c_ulong;

pub type Size = Ulong;
pub type Ptr = Ulong;

pub type Hash = u32;
pub type Flags = u32;
pub type Rune = u32;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Buffer {
    pub marker: [BufferMarker; 2],
    pub pool: Allocator,
    pub type_0: AllocationType,
    pub memory: Memory,
    pub grow_factor: f32,
    pub allocated: Size,
    pub needed: Size,
    pub calls: Size,
    pub size: Size,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Memory {
    pub ptr: *mut Void,
    pub size: Size,
}

pub type AllocationType = Uint;
pub const NK_BUFFER_DYNAMIC: AllocationType = 1;
pub const NK_BUFFER_FIXED: AllocationType = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Allocator {
    pub userdata: Handle,
    pub alloc: PluginAlloc,
    pub free: PluginFree,
}

pub type PluginFree = Option<unsafe fn(_: Handle, _: *mut Void) -> ()>;

#[derive(Copy, Clone)]
#[repr(C)]
pub union Handle {
    pub ptr: *mut Void,
    pub id: Int,
}

pub type PluginAlloc = Option<unsafe fn(_: Handle, _: *mut Void, _: Size) -> *mut Void>;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct BufferMarker {
    pub active: Int,
    pub offset: Size,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandBuffer {
    pub base: *mut Buffer,
    pub clip: Rect,
    pub use_clipping: Int,
    pub userdata: Handle,
    pub begin: Size,
    pub end: Size,
    pub last: Size,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct DrawCommand {
    pub elem_count: Uint,
    pub clip_rect: Rect,
    pub texture: Handle,
    pub userdata: Handle,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConvertConfig {
    pub global_alpha: f32,
    pub line_AA: AntiAliasing,
    pub shape_AA: AntiAliasing,
    pub circle_segment_count: Uint,
    pub arc_segment_count: Uint,
    pub curve_segment_count: Uint,
    pub null: DrawNullTexture,
    pub vertex_layout: *const DrawVertexLayoutElement,
    pub vertex_size: Size,
    pub vertex_alignment: Size,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DrawVertexLayoutElement {
    pub attribute: DrawVertexLayoutAttribute,
    pub format: DrawVertexLayoutFormat,
    pub offset: Size,
}
pub type DrawVertexLayoutFormat = Uint;
pub const NK_FORMAT_COUNT: DrawVertexLayoutFormat = 19;
pub const NK_FORMAT_COLOR_END: DrawVertexLayoutFormat = 18;
pub const NK_FORMAT_RGBA32: DrawVertexLayoutFormat = 18;
pub const NK_FORMAT_RGB32: DrawVertexLayoutFormat = 17;
pub const NK_FORMAT_R32G32B32A32_DOUBLE: DrawVertexLayoutFormat = 16;
pub const NK_FORMAT_R32G32B32A32_FLOAT: DrawVertexLayoutFormat = 15;
pub const NK_FORMAT_R32G32B32A32: DrawVertexLayoutFormat = 14;
pub const NK_FORMAT_R16G15B16A16: DrawVertexLayoutFormat = 13;
pub const NK_FORMAT_B8G8R8A8: DrawVertexLayoutFormat = 12;
pub const NK_FORMAT_R8G8B8A8: DrawVertexLayoutFormat = 11;
pub const NK_FORMAT_R32G32B32: DrawVertexLayoutFormat = 10;
pub const NK_FORMAT_R16G15B16: DrawVertexLayoutFormat = 9;
pub const NK_FORMAT_R8G8B8: DrawVertexLayoutFormat = 8;
pub const NK_FORMAT_COLOR_BEGIN: DrawVertexLayoutFormat = 8;
pub const NK_FORMAT_DOUBLE: DrawVertexLayoutFormat = 7;
pub const NK_FORMAT_FLOAT: DrawVertexLayoutFormat = 6;
pub const NK_FORMAT_UINT: DrawVertexLayoutFormat = 5;
pub const NK_FORMAT_USHORT: DrawVertexLayoutFormat = 4;
pub const NK_FORMAT_UCHAR: DrawVertexLayoutFormat = 3;
pub const NK_FORMAT_SINT: DrawVertexLayoutFormat = 2;
pub const NK_FORMAT_SSHORT: DrawVertexLayoutFormat = 1;
pub const NK_FORMAT_SCHAR: DrawVertexLayoutFormat = 0;
/* build up path has a connection back to the beginning */
pub type DrawVertexLayoutAttribute = Uint;
pub const NK_VERTEX_ATTRIBUTE_COUNT: DrawVertexLayoutAttribute = 3;
pub const NK_VERTEX_TEXCOORD: DrawVertexLayoutAttribute = 2;
pub const NK_VERTEX_COLOR: DrawVertexLayoutAttribute = 1;
pub const NK_VERTEX_POSITION: DrawVertexLayoutAttribute = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DrawNullTexture {
    pub texture: Handle,
    pub uv: Point,
}

pub type AntiAliasing = Uint;
pub const NK_ANTI_ALIASING_ON: AntiAliasing = 1;
pub const NK_ANTI_ALIASING_OFF: AntiAliasing = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleItem {
    pub type_0: StyleItemType,
    pub data: nk_style_item_data,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union nk_style_item_data {
    image: Image,
    color: Color,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Image {
    pub handle: Handle,
    pub w: Ushort,
    pub h: Ushort,
    pub region: [Ushort; 4],
}
pub type StyleItemType = Uint;
pub const NK_STYLE_ITEM_IMAGE: StyleItemType = 1;
pub const NK_STYLE_ITEM_COLOR: StyleItemType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TextEdit {
    pub clip: Clipboard,
    pub string: Str,
    pub filter: PluginFilter,
    pub scrollbar: Point,
    pub cursor: Int,
    pub select_start: Int,
    pub select_end: Int,
    pub mode: Uchar,
    pub cursor_at_end_of_line: Uchar,
    pub initialized: Uchar,
    pub has_preferred_x: Uchar,
    pub single_line: Uchar,
    pub active: Uchar,
    pub padding1: Uchar,
    pub preferred_x: f32,
    pub undo: TextUndoState,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TextUndoState {
    pub undo_rec: [TextUndoRecord; 99],
    pub undo_char: [Rune; 999],
    pub undo_point: Short,
    pub redo_point: Short,
    pub undo_char_point: Short,
    pub redo_char_point: Short,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TextUndoRecord {
    pub where_0: Int,
    pub insert_length: Short,
    pub delete_length: Short,
    pub char_storage: Short,
}

pub type PluginFilter = Option<unsafe fn(_: *const TextEdit, _: Rune) -> Int>;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Str {
    pub buffer: Buffer,
    pub len: Int,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Clipboard {
    pub userdata: Handle,
    pub paste: PluginPaste,
    pub copy: PluginCopy,
}

pub type PluginCopy = Option<unsafe fn(_: Handle, _: *const Char, _: Int) -> ()>;

pub type PluginPaste = Option<unsafe fn(_: Handle, _: *mut TextEdit) -> ()>;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct DrawList {
    pub clip_rect: Rect,
    pub circle_vtx: [Point; 12],
    pub config: ConvertConfig,
    pub buffer: *mut Buffer,
    pub vertices: *mut Buffer,
    pub elements: *mut Buffer,
    pub element_count: Uint,
    pub vertex_count: Uint,
    pub cmd_count: Uint,
    pub cmd_offset: Size,
    pub path_count: Uint,
    pub path_offset: Uint,
    pub line_AA: AntiAliasing,
    pub shape_AA: AntiAliasing,
    pub userdata: Handle,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UserFont {
    pub userdata: Handle,
    pub height: f32,
    pub width: TextWidthF,
    pub query: QueryFontGlyphF,
    pub texture: Handle,
}

pub type QueryFontGlyphF =
    Option<unsafe fn(_: Handle, _: f32, _: *mut UserFontGlyph, _: Rune, _: Rune) -> ()>;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UserFontGlyph {
    pub uv: [Point; 2],
    pub offset: Point,
    pub width: f32,
    pub height: f32,
    pub xadvance: f32,
}

pub type TextWidthF = Option<unsafe fn(_: Handle, _: f32, _: *const Char, _: Int) -> f32>;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Panel {
    pub type_0: PanelType,
    pub flags: Flags,
    pub bounds: Rect,
    pub offset_x: *mut u32,
    pub offset_y: *mut u32,
    pub at_x: f32,
    pub at_y: f32,
    pub max_x: f32,
    pub footer_height: f32,
    pub header_height: f32,
    pub border: f32,
    pub has_scrolling: Uint,
    pub clip: Rect,
    pub menu: MenuState,
    pub row: RowLayout,
    pub chart: Chart,
    pub buffer: *mut CommandBuffer,
    pub parent: *mut Panel,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Chart {
    pub slot: Int,
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
    pub slots: [ChartSlot; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ChartSlot {
    pub type_0: ChartType,
    pub color: Color,
    pub highlight: Color,
    pub min: f32,
    pub max: f32,
    pub range: f32,
    pub count: Int,
    pub last: Point,
    pub index: Int,
}
pub type ChartType = Uint;
pub const NK_CHART_MAX: ChartType = 2;
pub const NK_CHART_COLUMN: ChartType = 1;
pub const NK_CHART_LINES: ChartType = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct RowLayout {
    pub type_0: PanelRowLayoutType,
    pub index: Int,
    pub height: f32,
    pub min_height: f32,
    pub columns: Int,
    pub ratio: *const f32,
    pub item_width: f32,
    pub item_height: f32,
    pub item_offset: f32,
    pub filled: f32,
    pub item: Rect,
    pub tree_depth: Int,
    pub templates: [f32; 16],
}

pub type PanelRowLayoutType = Uint;
pub const NK_LAYOUT_COUNT: PanelRowLayoutType = 9;
pub const NK_LAYOUT_TEMPLATE: PanelRowLayoutType = 8;
pub const NK_LAYOUT_STATIC: PanelRowLayoutType = 7;
pub const NK_LAYOUT_STATIC_FREE: PanelRowLayoutType = 6;
pub const NK_LAYOUT_STATIC_ROW: PanelRowLayoutType = 5;
pub const NK_LAYOUT_STATIC_FIXED: PanelRowLayoutType = 4;
pub const NK_LAYOUT_DYNAMIC: PanelRowLayoutType = 3;
pub const NK_LAYOUT_DYNAMIC_FREE: PanelRowLayoutType = 2;
pub const NK_LAYOUT_DYNAMIC_ROW: PanelRowLayoutType = 1;
pub const NK_LAYOUT_DYNAMIC_FIXED: PanelRowLayoutType = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct MenuState {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
    pub offset: Scroll,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Scroll {
    pub x: u32,
    pub y: u32,
}

pub type PanelType = Uint;
pub const NK_PANEL_TOOLTIP: PanelType = 128;
pub const NK_PANEL_MENU: PanelType = 64;
pub const NK_PANEL_COMBO: PanelType = 32;
pub const NK_PANEL_CONTEXTUAL: PanelType = 16;
pub const NK_PANEL_POPUP: PanelType = 4;
pub const NK_PANEL_GROUP: PanelType = 2;
pub const NK_PANEL_WINDOW: PanelType = 1;
pub const NK_PANEL_NONE: PanelType = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Context {
    pub input: Input,
    pub style: Style,
    pub memory: Buffer,
    pub clip: Clipboard,
    pub last_widget_state: Flags,
    pub button_behavior: ButtonBehavior,
    pub stacks: ConfigurationStacks,
    pub delta_time_seconds: f32,
    pub draw_list: DrawList,
    pub userdata: Handle,
    pub text_edit: TextEdit,
    pub overlay: CommandBuffer,
    pub build: Int,
    pub use_pool: Int,
    pub pool: Pool,
    pub begin: *mut Window,
    pub end: *mut Window,
    pub active: *mut Window,
    pub current: *mut Window,
    pub freelist: *mut PageElement,
    pub count: Uint,
    pub seq: Uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PageElement {
    pub data: nk_page_data,
    pub next: *mut PageElement,
    pub prev: *mut PageElement,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union nk_page_data {
    tbl: Table,
    pan: Panel,
    win: Window,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Window {
    pub seq: Uint,
    pub name: Hash,
    pub name_string: [Char; 64],
    pub flags: Flags,
    pub bounds: Rect,
    pub scrollbar: Scroll,
    pub buffer: CommandBuffer,
    pub layout: *mut Panel,
    pub scrollbar_hiding_timer: f32,
    pub property: PropertyState,
    pub popup: PopupState,
    pub edit: EditState,
    pub scrolled: Uint,
    pub tables: *mut Table,
    pub table_count: Uint,
    pub next: *mut Window,
    pub prev: *mut Window,
    pub parent: *mut Window,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Table {
    pub seq: Uint,
    pub size: Uint,
    pub keys: [Hash; 59],
    pub values: [u32; 59],
    pub next: *mut Table,
    pub prev: *mut Table,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct EditState {
    pub name: Hash,
    pub seq: Uint,
    pub old: Uint,
    pub active: Int,
    pub prev: Int,
    pub cursor: Int,
    pub sel_start: Int,
    pub sel_end: Int,
    pub scrollbar: Scroll,
    pub mode: Uchar,
    pub single_line: Uchar,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct PopupState {
    pub win: *mut Window,
    pub type_0: PanelType,
    pub buf: PopupBuffer,
    pub name: Hash,
    pub active: Int,
    pub combo_count: Uint,
    pub con_count: Uint,
    pub con_old: Uint,
    pub active_con: Uint,
    pub header: Rect,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct PopupBuffer {
    pub begin: Size,
    pub parent: Size,
    pub last: Size,
    pub end: Size,
    pub active: Int,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct PropertyState {
    pub active: Int,
    pub prev: Int,
    pub buffer: [Char; 64],
    pub length: Int,
    pub cursor: Int,
    pub select_start: Int,
    pub select_end: Int,
    pub name: Hash,
    pub seq: Uint,
    pub old: Uint,
    pub state: Int,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Pool {
    pub alloc: Allocator,
    pub type_0: AllocationType,
    pub page_count: Uint,
    pub pages: *mut Page,
    pub freelist: *mut PageElement,
    pub capacity: Uint,
    pub size: Size,
    pub cap: Size,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Page {
    pub size: Uint,
    pub next: *mut Page,
    pub win: [PageElement; 1],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigurationStacks {
    pub style_items: ConfigStackStyleItem,
    pub floats: ConfigStackFloat,
    pub vectors: ConfigStackPoint,
    pub flags: ConfigStackFlags,
    pub colors: ConfigStackColor,
    pub fonts: ConfigStackUserFont,
    pub button_behaviors: ConfigStackButtonBehavior,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackButtonBehavior {
    pub head: Int,
    pub elements: [ConfigStackButtonBehaviorElement; 8],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackButtonBehaviorElement {
    pub address: *mut ButtonBehavior,
    pub old_value: ButtonBehavior,
}

pub type ButtonBehavior = Uint;
pub const NK_BUTTON_REPEATER: ButtonBehavior = 1;
pub const NK_BUTTON_DEFAULT: ButtonBehavior = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackUserFont {
    pub head: Int,
    pub elements: [ConfigStackUserFontElement; 8],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackUserFontElement {
    pub address: *mut *const UserFont,
    pub old_value: *const UserFont,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackColor {
    pub head: Int,
    pub elements: [ConfigStackColorElement; 32],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackColorElement {
    pub address: *mut Color,
    pub old_value: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackFlags {
    pub head: Int,
    pub elements: [ConfigStackFlagsElement; 32],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackFlagsElement {
    pub address: *mut Flags,
    pub old_value: Flags,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackPoint {
    pub head: Int,
    pub elements: [ConfigStackPointElement; 16],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackPointElement {
    pub address: *mut Point,
    pub old_value: Point,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackFloat {
    pub head: Int,
    pub elements: [ConfigStackFloatElement; 32],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackFloatElement {
    pub address: *mut f32,
    pub old_value: f32,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackStyleItem {
    pub head: Int,
    pub elements: [ConfigStackStyleItemElement; 16],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ConfigStackStyleItemElement {
    pub address: *mut StyleItem,
    pub old_value: StyleItem,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Style {
    pub font: *const UserFont,
    pub cursors: [*const Cursor; 7],
    pub cursor_active: *const Cursor,
    pub cursor_last: *mut Cursor,
    pub cursor_visible: Int,
    pub text: StyleText,
    pub button: StyleButton,
    pub contextual_button: StyleButton,
    pub menu_button: StyleButton,
    pub option: StyleToggle,
    pub checkbox: StyleToggle,
    pub selectable: StyleSelectable,
    pub slider: StyleSlider,
    pub progress: StyleProgress,
    pub property: StyleProperty,
    pub edit: StyleEdit,
    pub chart: StyleChart,
    pub scrollh: StyleScrollbar,
    pub scrollv: StyleScrollbar,
    pub tab: StyleTab,
    pub combo: StyleCombo,
    pub window: StyleWindow,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleWindow {
    pub header: StyleWindowHeader,
    pub fixed_background: StyleItem,
    pub background: Color,
    pub border_color: Color,
    pub popup_border_color: Color,
    pub combo_border_color: Color,
    pub contextual_border_color: Color,
    pub menu_border_color: Color,
    pub group_border_color: Color,
    pub tooltip_border_color: Color,
    pub scaler: StyleItem,
    pub border: f32,
    pub combo_border: f32,
    pub contextual_border: f32,
    pub menu_border: f32,
    pub group_border: f32,
    pub tooltip_border: f32,
    pub popup_border: f32,
    pub min_row_height_padding: f32,
    pub rounding: f32,
    pub spacing: Point,
    pub scrollbar_size: Point,
    pub min_size: Point,
    pub padding: Point,
    pub group_padding: Point,
    pub popup_padding: Point,
    pub combo_padding: Point,
    pub contextual_padding: Point,
    pub menu_padding: Point,
    pub tooltip_padding: Point,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleWindowHeader {
    pub normal: StyleItem,
    pub hover: StyleItem,
    pub active: StyleItem,
    pub close_button: StyleButton,
    pub minimize_button: StyleButton,
    pub close_symbol: SymbolType,
    pub minimize_symbol: SymbolType,
    pub maximize_symbol: SymbolType,
    pub label_normal: Color,
    pub label_hover: Color,
    pub label_active: Color,
    pub align: StyleHeaderAlign,
    pub padding: Point,
    pub label_padding: Point,
    pub spacing: Point,
}

pub type StyleHeaderAlign = Uint;
pub const NK_HEADER_RIGHT: StyleHeaderAlign = 1;
pub const NK_HEADER_LEFT: StyleHeaderAlign = 0;

pub type SymbolType = Uint;
pub const NK_SYMBOL_MAX: SymbolType = 13;
pub const NK_SYMBOL_MINUS: SymbolType = 12;
pub const NK_SYMBOL_PLUS: SymbolType = 11;
pub const NK_SYMBOL_TRIANGLE_RIGHT: SymbolType = 10;
pub const NK_SYMBOL_TRIANGLE_LEFT: SymbolType = 9;
pub const NK_SYMBOL_TRIANGLE_DOWN: SymbolType = 8;
pub const NK_SYMBOL_TRIANGLE_UP: SymbolType = 7;
pub const NK_SYMBOL_RECT_OUTLINE: SymbolType = 6;
pub const NK_SYMBOL_RECT_SOLID: SymbolType = 5;
pub const NK_SYMBOL_CIRCLE_OUTLINE: SymbolType = 4;
pub const NK_SYMBOL_CIRCLE_SOLID: SymbolType = 3;
pub const NK_SYMBOL_UNDERSCORE: SymbolType = 2;
pub const NK_SYMBOL_X: SymbolType = 1;
pub const NK_SYMBOL_NONE: SymbolType = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleButton {
    pub normal: StyleItem,
    pub hover: StyleItem,
    pub active: StyleItem,
    pub border_color: Color,
    pub text_background: Color,
    pub text_normal: Color,
    pub text_hover: Color,
    pub text_active: Color,
    pub text_alignment: Flags,
    pub border: f32,
    pub rounding: f32,
    pub padding: Point,
    pub image_padding: Point,
    pub touch_padding: Point,
    pub userdata: Handle,
    pub draw_begin: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleCombo {
    pub normal: StyleItem,
    pub hover: StyleItem,
    pub active: StyleItem,
    pub border_color: Color,
    pub label_normal: Color,
    pub label_hover: Color,
    pub label_active: Color,
    pub symbol_normal: Color,
    pub symbol_hover: Color,
    pub symbol_active: Color,
    pub button: StyleButton,
    pub sym_normal: SymbolType,
    pub sym_hover: SymbolType,
    pub sym_active: SymbolType,
    pub border: f32,
    pub rounding: f32,
    pub content_padding: Point,
    pub button_padding: Point,
    pub spacing: Point,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleTab {
    pub background: StyleItem,
    pub border_color: Color,
    pub text: Color,
    pub tab_maximize_button: StyleButton,
    pub tab_minimize_button: StyleButton,
    pub node_maximize_button: StyleButton,
    pub node_minimize_button: StyleButton,
    pub sym_minimize: SymbolType,
    pub sym_maximize: SymbolType,
    pub border: f32,
    pub rounding: f32,
    pub indent: f32,
    pub padding: Point,
    pub spacing: Point,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleScrollbar {
    pub normal: StyleItem,
    pub hover: StyleItem,
    pub active: StyleItem,
    pub border_color: Color,
    pub cursor_normal: StyleItem,
    pub cursor_hover: StyleItem,
    pub cursor_active: StyleItem,
    pub cursor_border_color: Color,
    pub border: f32,
    pub rounding: f32,
    pub border_cursor: f32,
    pub rounding_cursor: f32,
    pub padding: Point,
    pub show_buttons: Int,
    pub inc_button: StyleButton,
    pub dec_button: StyleButton,
    pub inc_symbol: SymbolType,
    pub dec_symbol: SymbolType,
    pub userdata: Handle,
    pub draw_begin: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleChart {
    pub background: StyleItem,
    pub border_color: Color,
    pub selected_color: Color,
    pub color: Color,
    pub border: f32,
    pub rounding: f32,
    pub padding: Point,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleEdit {
    pub normal: StyleItem,
    pub hover: StyleItem,
    pub active: StyleItem,
    pub border_color: Color,
    pub scrollbar: StyleScrollbar,
    pub cursor_normal: Color,
    pub cursor_hover: Color,
    pub cursor_text_normal: Color,
    pub cursor_text_hover: Color,
    pub text_normal: Color,
    pub text_hover: Color,
    pub text_active: Color,
    pub selected_normal: Color,
    pub selected_hover: Color,
    pub selected_text_normal: Color,
    pub selected_text_hover: Color,
    pub border: f32,
    pub rounding: f32,
    pub cursor_size: f32,
    pub scrollbar_size: Point,
    pub padding: Point,
    pub row_padding: f32,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleProperty {
    pub normal: StyleItem,
    pub hover: StyleItem,
    pub active: StyleItem,
    pub border_color: Color,
    pub label_normal: Color,
    pub label_hover: Color,
    pub label_active: Color,
    pub sym_left: SymbolType,
    pub sym_right: SymbolType,
    pub border: f32,
    pub rounding: f32,
    pub padding: Point,
    pub edit: StyleEdit,
    pub inc_button: StyleButton,
    pub dec_button: StyleButton,
    pub userdata: Handle,
    pub draw_begin: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleProgress {
    pub normal: StyleItem,
    pub hover: StyleItem,
    pub active: StyleItem,
    pub border_color: Color,
    pub cursor_normal: StyleItem,
    pub cursor_hover: StyleItem,
    pub cursor_active: StyleItem,
    pub cursor_border_color: Color,
    pub rounding: f32,
    pub border: f32,
    pub cursor_border: f32,
    pub cursor_rounding: f32,
    pub padding: Point,
    pub userdata: Handle,
    pub draw_begin: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleSlider {
    pub normal: StyleItem,
    pub hover: StyleItem,
    pub active: StyleItem,
    pub border_color: Color,
    pub bar_normal: Color,
    pub bar_hover: Color,
    pub bar_active: Color,
    pub bar_filled: Color,
    pub cursor_normal: StyleItem,
    pub cursor_hover: StyleItem,
    pub cursor_active: StyleItem,
    pub border: f32,
    pub rounding: f32,
    pub bar_height: f32,
    pub padding: Point,
    pub spacing: Point,
    pub cursor_size: Point,
    pub show_buttons: Int,
    pub inc_button: StyleButton,
    pub dec_button: StyleButton,
    pub inc_symbol: SymbolType,
    pub dec_symbol: SymbolType,
    pub userdata: Handle,
    pub draw_begin: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleSelectable {
    pub normal: StyleItem,
    pub hover: StyleItem,
    pub pressed: StyleItem,
    pub normal_active: StyleItem,
    pub hover_active: StyleItem,
    pub pressed_active: StyleItem,
    pub text_normal: Color,
    pub text_hover: Color,
    pub text_pressed: Color,
    pub text_normal_active: Color,
    pub text_hover_active: Color,
    pub text_pressed_active: Color,
    pub text_background: Color,
    pub text_alignment: Flags,
    pub rounding: f32,
    pub padding: Point,
    pub touch_padding: Point,
    pub image_padding: Point,
    pub userdata: Handle,
    pub draw_begin: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleToggle {
    pub normal: StyleItem,
    pub hover: StyleItem,
    pub active: StyleItem,
    pub border_color: Color,
    pub cursor_normal: StyleItem,
    pub cursor_hover: StyleItem,
    pub text_normal: Color,
    pub text_hover: Color,
    pub text_active: Color,
    pub text_background: Color,
    pub text_alignment: Flags,
    pub padding: Point,
    pub touch_padding: Point,
    pub spacing: f32,
    pub border: f32,
    pub userdata: Handle,
    pub draw_begin: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
    pub draw_end: Option<unsafe fn(_: *mut CommandBuffer, _: Handle) -> ()>,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct StyleText {
    pub color: Color,
    pub padding: Point,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Cursor {
    pub img: Image,
    pub size: Point,
    pub offset: Point,
}

pub type unnamed = Uint;
pub const nk_true: unnamed = 1;
pub const nk_false: unnamed = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColorF {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct PointI {
    pub x: Short,
    pub y: Short,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct RectI {
    pub x: Short,
    pub y: Short,
    pub w: Short,
    pub h: Short,
}

pub type Glyph = [Char; 4];

pub type Heading = Uint;
pub const NK_LEFT: Heading = 3;
pub const NK_DOWN: Heading = 2;
pub const NK_RIGHT: Heading = 1;
pub const NK_UP: Heading = 0;

pub type Orientation = Uint;
pub const NK_HORIZONTAL: Orientation = 1;
pub const NK_VERTICAL: Orientation = 0;

pub type CollapseStates = Uint;
pub const NK_MAXIMIZED: CollapseStates = 1;
pub const NK_MINIMIZED: CollapseStates = 0;

pub type ShowStates = Uint;
pub const NK_SHOWN: ShowStates = 1;
pub const NK_HIDDEN: ShowStates = 0;

pub type ChartEvent = Uint;
pub const NK_CHART_CLICKED: ChartEvent = 2;
pub const NK_CHART_HOVERING: ChartEvent = 1;

pub type ColorFormat = Uint;
pub const NK_RGBA: ColorFormat = 1;
pub const NK_RGB: ColorFormat = 0;

pub type PopupType = Uint;
pub const NK_POPUP_DYNAMIC: PopupType = 1;
pub const NK_POPUP_STATIC: PopupType = 0;

pub type LayoutFormat = Uint;
pub const NK_STATIC: LayoutFormat = 1;
pub const NK_DYNAMIC: LayoutFormat = 0;

pub type TreeType = Uint;
pub const NK_TREE_TAB: TreeType = 1;
pub const NK_TREE_NODE: TreeType = 0;

pub const NK_COLOR_TEXT: StyleColors = 0;
pub const NK_COLOR_BORDER: StyleColors = 3;
pub const NK_COLOR_WINDOW: StyleColors = 1;
pub const NK_TEXT_CENTERED: TextAlignment = 18;
pub const NK_COLOR_HEADER: StyleColors = 2;
pub const NK_COLOR_TAB_HEADER: StyleColors = 27;
pub const NK_COLOR_COMBO: StyleColors = 19;
pub const NK_COLOR_CHART_COLOR: StyleColors = 21;
pub const NK_COLOR_CHART_COLOR_HIGHLIGHT: StyleColors = 22;
pub const NK_COLOR_CHART: StyleColors = 20;
pub const NK_COLOR_EDIT: StyleColors = 17;
pub const NK_COLOR_PROPERTY: StyleColors = 16;
pub const NK_COLOR_SCROLLBAR: StyleColors = 23;
pub const NK_COLOR_SCROLLBAR_CURSOR_ACTIVE: StyleColors = 26;
pub const NK_COLOR_SCROLLBAR_CURSOR_HOVER: StyleColors = 25;
pub const NK_COLOR_SCROLLBAR_CURSOR: StyleColors = 24;
pub const NK_COLOR_SLIDER_CURSOR_ACTIVE: StyleColors = 15;
pub const NK_COLOR_SLIDER_CURSOR_HOVER: StyleColors = 14;
pub const NK_COLOR_SLIDER_CURSOR: StyleColors = 13;
pub const NK_COLOR_SLIDER: StyleColors = 12;
pub const NK_COLOR_SELECT_ACTIVE: StyleColors = 11;
pub const NK_COLOR_SELECT: StyleColors = 10;
pub const NK_COLOR_TOGGLE_CURSOR: StyleColors = 9;
pub const NK_COLOR_TOGGLE_HOVER: StyleColors = 8;
pub const NK_COLOR_TOGGLE: StyleColors = 7;
pub const NK_COLOR_BUTTON_ACTIVE: StyleColors = 6;
pub const NK_COLOR_BUTTON_HOVER: StyleColors = 5;
pub const NK_COLOR_BUTTON: StyleColors = 4;

/* special window type growing up in height while being filled to a certain maximum height */
pub const NK_WINDOW_ROM: WindowFlags = 4096;
/* Hides window and stops any window interaction and drawing */
pub const NK_WINDOW_CLOSED: WindowFlags = 16384;
/* prevents all interaction caused by input to either window or widgets inside */
pub const NK_WINDOW_HIDDEN: WindowFlags = 8192;
/* Directly closes and frees the window at the end of the frame */
pub const NK_WINDOW_MINIMIZED: WindowFlags = 32768;
pub const NK_CURSOR_ARROW: StyleCursor = 0;
pub type BufferAllocationType = Uint;
pub const NK_BUFFER_MAX: BufferAllocationType = 2;
pub const NK_BUFFER_BACK: BufferAllocationType = 1;
pub const NK_BUFFER_FRONT: BufferAllocationType = 0;

pub type ConvertResult = Uint;
pub const NK_CONVERT_ELEMENT_BUFFER_FULL: ConvertResult = 8;
pub const NK_CONVERT_VERTEX_BUFFER_FULL: ConvertResult = 4;
pub const NK_CONVERT_COMMAND_BUFFER_FULL: ConvertResult = 2;
pub const NK_CONVERT_INVALID_PARAM: ConvertResult = 1;
pub const NK_CONVERT_SUCCESS: ConvertResult = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Command {
    pub type_0: CommandType,
    pub next: Size,
    pub userdata: Handle,
}

pub type CommandType = Uint;
pub const NK_COMMAND_CUSTOM: CommandType = 18;
pub const NK_COMMAND_IMAGE: CommandType = 17;
pub const NK_COMMAND_TEXT: CommandType = 16;
pub const NK_COMMAND_POLYLINE: CommandType = 15;
pub const NK_COMMAND_POLYGON_FILLED: CommandType = 14;
pub const NK_COMMAND_POLYGON: CommandType = 13;
pub const NK_COMMAND_TRIANGLE_FILLED: CommandType = 12;
pub const NK_COMMAND_TRIANGLE: CommandType = 11;
pub const NK_COMMAND_ARC_FILLED: CommandType = 10;
pub const NK_COMMAND_ARC: CommandType = 9;
pub const NK_COMMAND_CIRCLE_FILLED: CommandType = 8;
pub const NK_COMMAND_CIRCLE: CommandType = 7;
pub const NK_COMMAND_RECT_MULTI_COLOR: CommandType = 6;
pub const NK_COMMAND_RECT_FILLED: CommandType = 5;
pub const NK_COMMAND_RECT: CommandType = 4;
pub const NK_COMMAND_CURVE: CommandType = 3;
pub const NK_COMMAND_LINE: CommandType = 2;
pub const NK_COMMAND_SCISSOR: CommandType = 1;
pub const NK_COMMAND_NOP: CommandType = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandImage {
    pub header: Command,
    pub x: Short,
    pub y: Short,
    pub w: Ushort,
    pub h: Ushort,
    pub img: Image,
    pub col: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_0 {
    pub c: Char,
    pub _h: Command,
}

pub type CommandClipping = Uint;
pub const NK_CLIPPING_ON: CommandClipping = 1;
pub const NK_CLIPPING_OFF: CommandClipping = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandCustom {
    pub header: Command,
    pub x: Short,
    pub y: Short,
    pub w: Ushort,
    pub h: Ushort,
    pub callback_data: Handle,
    pub callback: CommandCustomCallback,
}

pub type CommandCustomCallback =
    Option<unsafe fn(_: *mut Void, _: Short, _: Short, _: Ushort, _: Ushort, _: Handle) -> ()>;

pub type DrawIndex = u16;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_1 {
    pub c: Char,
    pub _h: DrawIndex,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_2 {
    pub c: Char,
    pub _h: DrawCommand,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandText {
    pub header: Command,
    pub font: *const UserFont,
    pub background: Color,
    pub foreground: Color,
    pub x: Short,
    pub y: Short,
    pub w: Ushort,
    pub h: Ushort,
    pub height: f32,
    pub length: Int,
    pub string: [Char; 1],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandPolyline {
    pub header: Command,
    pub color: Color,
    pub line_thickness: Ushort,
    pub point_count: Ushort,
    pub points: [PointI; 1],
}

pub type DrawListStroke = Uint;
/* build up path has no connection back to the beginning */
pub const NK_STROKE_CLOSED: DrawListStroke = 1;
pub const NK_STROKE_OPEN: DrawListStroke = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub union unnamed_3 {
    i: u32,
    f: f32,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_4 {
    pub c: Char,
    pub _h: Point,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_5 {
    pub c: Char,
    pub _h: Point,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandPolygonFilled {
    pub header: Command,
    pub color: Color,
    pub point_count: Ushort,
    pub points: [PointI; 1],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_6 {
    pub c: Char,
    pub _h: Point,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandPolygon {
    pub header: Command,
    pub color: Color,
    pub line_thickness: Ushort,
    pub point_count: Ushort,
    pub points: [PointI; 1],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandTriangleFilled {
    pub header: Command,
    pub a: PointI,
    pub b: PointI,
    pub c: PointI,
    pub color: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandTriangle {
    pub header: Command,
    pub line_thickness: Ushort,
    pub a: PointI,
    pub b: PointI,
    pub c: PointI,
    pub color: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandArcFilled {
    pub header: Command,
    pub cx: Short,
    pub cy: Short,
    pub r: Ushort,
    pub a: [f32; 2],
    pub color: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandArc {
    pub header: Command,
    pub cx: Short,
    pub cy: Short,
    pub r: Ushort,
    pub line_thickness: Ushort,
    pub a: [f32; 2],
    pub color: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandCircleFilled {
    pub header: Command,
    pub x: Short,
    pub y: Short,
    pub w: Ushort,
    pub h: Ushort,
    pub color: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandCircle {
    pub header: Command,
    pub x: Short,
    pub y: Short,
    pub line_thickness: Ushort,
    pub w: Ushort,
    pub h: Ushort,
    pub color: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandRectMultiColor {
    pub header: Command,
    pub x: Short,
    pub y: Short,
    pub w: Ushort,
    pub h: Ushort,
    pub left: Color,
    pub top: Color,
    pub bottom: Color,
    pub right: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandRectFilled {
    pub header: Command,
    pub rounding: Ushort,
    pub x: Short,
    pub y: Short,
    pub w: Ushort,
    pub h: Ushort,
    pub color: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandRect {
    pub header: Command,
    pub rounding: Ushort,
    pub line_thickness: Ushort,
    pub x: Short,
    pub y: Short,
    pub w: Ushort,
    pub h: Ushort,
    pub color: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandCurve {
    pub header: Command,
    pub line_thickness: Ushort,
    pub begin: PointI,
    pub end: PointI,
    pub ctrl: [PointI; 2],
    pub color: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandLine {
    pub header: Command,
    pub line_thickness: Ushort,
    pub begin: PointI,
    pub end: PointI,
    pub color: Color,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct CommandScissor {
    pub header: Command,
    pub x: Short,
    pub y: Short,
    pub w: Ushort,
    pub h: Ushort,
}

pub type PanelFlags = Uint;
pub const NK_WINDOW_NO_INPUT: PanelFlags = 1024;
pub const NK_WINDOW_SCALE_LEFT: PanelFlags = 512;
pub const NK_WINDOW_BACKGROUND: PanelFlags = 256;
pub const NK_WINDOW_SCROLL_AUTO_HIDE: PanelFlags = 128;
pub const NK_WINDOW_TITLE: PanelFlags = 64;
pub const NK_WINDOW_NO_SCROLLBAR: PanelFlags = 32;
pub const NK_WINDOW_MINIMIZABLE: PanelFlags = 16;
pub const NK_WINDOW_CLOSABLE: PanelFlags = 8;
pub const NK_WINDOW_SCALABLE: PanelFlags = 4;
pub const NK_WINDOW_MOVABLE: PanelFlags = 2;
pub const NK_WINDOW_BORDER: PanelFlags = 1;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Text {
    pub padding: Point,
    pub background: Color,
    pub text: Color,
}

pub const NK_WIDGET_STATE_MODIFIED: WidgetStates = 2;
/* widget is neither active nor hovered */
pub const NK_WIDGET_STATE_INACTIVE: WidgetStates = 4;
/* widget has been hovered on the current frame */
pub const NK_WIDGET_STATE_ENTERED: WidgetStates = 8;
/* widget is being hovered */
pub const NK_WIDGET_STATE_HOVER: WidgetStates = 16;
/* widget is currently activated */
pub const NK_WIDGET_STATE_ACTIVED: WidgetStates = 32;
/* widget is from this frame on not hovered anymore */
pub const NK_WIDGET_STATE_LEFT: WidgetStates = 64;
/* widget is currently activated */
pub const NK_WIDGET_STATE_ACTIVE: WidgetStates = 34;
/* widget is being hovered */
pub const NK_WIDGET_STATE_HOVERED: WidgetStates = 18;

pub const NK_PANEL_SET_NONBLOCK: PanelSet = 240;

pub const NK_CURSOR_MOVE: StyleCursor = 2;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_7 {
    pub c: Char,
    pub _h: PageElement,
}

pub type WindowInsertLocation = Uint;
/* inserts window into the front of list (back of screen) */
pub const NK_INSERT_FRONT: WindowInsertLocation = 1;
/* inserts window into the back of list (front of screen) */
pub const NK_INSERT_BACK: WindowInsertLocation = 0;

pub const NK_WINDOW_DYNAMIC: WindowFlags = 2048;
pub const NK_WINDOW_PRIVATE: WindowFlags = 2048;
/* marks the window as minimized */
pub const NK_WINDOW_REMOVE_ROM: WindowFlags = 65536;

#[derive(Copy, Clone)]
#[repr(C)]
pub union unnamed_8 {
    i: *const u32,
    b: *const u8,
}

pub const NK_PANEL_SET_SUB: PanelSet = 246;
pub const NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT: StyleCursor = 6;

pub type WidgetLayoutStates = Uint;
/* The widget cannot be seen and is completely out of view */
pub const NK_WIDGET_INVALID: WidgetLayoutStates = 0;
/* The widget is completely inside the window and can be updated and drawn */
pub const NK_WIDGET_VALID: WidgetLayoutStates = 1;
/* The widget is partially visible and cannot be updated */
pub const NK_WIDGET_ROM: WidgetLayoutStates = 2;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ListView {
    pub begin: Int,
    pub end: Int,
    pub count: Int,
    pub total_height: Int,
    pub ctx: *mut Context,
    pub scroll_pointer: *mut u32,
    pub scroll_value: u32,
}
pub type WidgetStates = Uint;

pub type TextAlign = Uint;
pub const NK_TEXT_ALIGN_LEFT: TextAlign = 1;
pub const NK_TEXT_ALIGN_CENTERED: TextAlign = 2;
pub const NK_TEXT_ALIGN_RIGHT: TextAlign = 4;
pub const NK_TEXT_ALIGN_TOP: TextAlign = 8;
pub const NK_TEXT_ALIGN_MIDDLE: TextAlign = 16;
pub const NK_TEXT_ALIGN_BOTTOM: TextAlign = 32;

pub type TextAlignment = Uint;
pub const NK_TEXT_RIGHT: TextAlignment = 20;
pub const NK_TEXT_LEFT: TextAlignment = 17;

pub type ToggleType = Uint;
pub const NK_TOGGLE_OPTION: ToggleType = 1;
pub const NK_TOGGLE_CHECK: ToggleType = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub union Property {
    i: Int,
    f: f32,
    d: f64,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct PropertyVariant {
    pub kind: PropertyKind,
    pub value: Property,
    pub min_value: Property,
    pub max_value: Property,
    pub step: Property,
}

pub type PropertyKind = Uint;
pub const NK_PROPERTY_DOUBLE: PropertyKind = 2;
pub const NK_PROPERTY_FLOAT: PropertyKind = 1;
pub const NK_PROPERTY_INT: PropertyKind = 0;

pub type PropertyFilter = Uint;
pub const NK_FILTER_FLOAT: PropertyFilter = 1;
pub const NK_FILTER_INT: PropertyFilter = 0;

pub const NK_PROPERTY_DRAG: PropertyStatus = 2;
pub const NK_PROPERTY_DEFAULT: PropertyStatus = 0;
pub const NK_PROPERTY_EDIT: PropertyStatus = 1;

pub const NK_EDIT_FIELD: EditTypes = 608;
pub const NK_STOP_ON_NEW_LINE: unnamed_15 = 1;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TextFind {
    pub x: f32,
    pub y: f32,
    pub height: f32,
    pub first_char: Int,
    pub length: Int,
    pub prev_first: Int,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TextEditRow {
    pub x0: f32,
    pub x1: f32,
    pub baseline_y_delta: f32,
    pub ymin: f32,
    pub ymax: f32,
    pub num_chars: Int,
}

pub const NK_TEXT_EDIT_MODE_VIEW: TextEditMode = 0;
pub const NK_TEXT_EDIT_MODE_INSERT: TextEditMode = 1;
pub const NK_TEXT_EDIT_MODE_REPLACE: TextEditMode = 2;

pub type TextEditType = Uint;
pub const NK_TEXT_EDIT_MULTI_LINE: TextEditType = 1;
pub const NK_TEXT_EDIT_SINGLE_LINE: TextEditType = 0;

pub type EditFlags = Uint;
pub const NK_EDIT_GOTO_END_ON_ACTIVATE: EditFlags = 2048;
pub const NK_EDIT_MULTILINE: EditFlags = 1024;
pub const NK_EDIT_ALWAYS_INSERT_MODE: EditFlags = 512;
pub const NK_EDIT_NO_HORIZONTAL_SCROLL: EditFlags = 256;
pub const NK_EDIT_CTRL_ENTER_NEWLINE: EditFlags = 128;
pub const NK_EDIT_CLIPBOARD: EditFlags = 64;
pub const NK_EDIT_SELECTABLE: EditFlags = 32;
pub const NK_EDIT_NO_CURSOR: EditFlags = 16;
pub const NK_EDIT_ALLOW_TAB: EditFlags = 8;
pub const NK_EDIT_SIG_ENTER: EditFlags = 4;
pub const NK_EDIT_AUTO_SELECT: EditFlags = 2;
pub const NK_EDIT_READ_ONLY: EditFlags = 1;
pub const NK_EDIT_DEFAULT: EditFlags = 0;

pub type EditTypes = Uint;
pub const NK_EDIT_EDITOR: EditTypes = 1128;
pub const NK_EDIT_BOX: EditTypes = 1640;
pub const NK_EDIT_SIMPLE: EditTypes = 512;

pub type EditEvents = Uint;
pub const NK_EDIT_COMMITED: EditEvents = 16;
/* edit widget went from state active to state inactive */
pub const NK_EDIT_DEACTIVATED: EditEvents = 8;
/* edit widget went from state inactive to state active */
pub const NK_EDIT_ACTIVATED: EditEvents = 4;
/* edit widget is not active and is not being modified */
pub const NK_EDIT_INACTIVE: EditEvents = 2;
/* edit widget is currently being modified */
pub const NK_EDIT_ACTIVE: EditEvents = 1;

pub type StyleColors = Uint;
pub const NK_COLOR_COUNT: StyleColors = 28;
pub const NK_COLOR_EDIT_CURSOR: StyleColors = 18;

pub type StyleCursor = Uint;
pub const NK_CURSOR_TEXT: StyleCursor = 1;
pub const NK_CURSOR_COUNT: StyleCursor = 7;
pub const NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT: StyleCursor = 5;
pub const NK_CURSOR_RESIZE_HORIZONTAL: StyleCursor = 4;
pub const NK_CURSOR_RESIZE_VERTICAL: StyleCursor = 3;

pub type FontCoordType = Uint;
/* texture coordinates inside font glyphs are in absolute pixel */
pub const NK_COORD_PIXEL: FontCoordType = 1;
/* texture coordinates inside font glyphs are clamped between 0-1 */
pub const NK_COORD_UV: FontCoordType = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct Font {
    pub next: *mut Font,
    pub handle: UserFont,
    pub info: BakedFont,
    pub scale: f32,
    pub glyphs: *mut FontGlyph,
    pub fallback: *const FontGlyph,
    pub fallback_codepoint: Rune,
    pub texture: Handle,
    pub config: *mut FontConfig,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct FontConfig {
    pub next: *mut FontConfig,
    pub ttf_blob: *mut Void,
    pub ttf_size: Size,
    pub ttf_data_owned_by_atlas: Uchar,
    pub merge_mode: Uchar,
    pub pixel_snap: Uchar,
    pub oversample_v: Uchar,
    pub oversample_h: Uchar,
    pub padding: [Uchar; 3],
    pub size: f32,
    pub coord_type: FontCoordType,
    pub spacing: Point,
    pub range: *const Rune,
    pub font: *mut BakedFont,
    pub fallback_glyph: Rune,
    pub n: *mut FontConfig,
    pub p: *mut FontConfig,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct BakedFont {
    pub height: f32,
    pub ascent: f32,
    pub descent: f32,
    pub glyph_offset: Rune,
    pub glyph_count: Rune,
    pub ranges: *const Rune,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct FontGlyph {
    pub codepoint: Rune,
    pub xadvance: f32,
    pub x0: f32,
    pub y0: f32,
    pub x1: f32,
    pub y1: f32,
    pub w: f32,
    pub h: f32,
    pub u0: f32,
    pub v0: f32,
    pub u1: f32,
    pub v1: f32,
}

pub type FontAtlasFormat = Uint;
pub const NK_FONT_ATLAS_RGBA32: FontAtlasFormat = 1;
pub const NK_FONT_ATLAS_ALPHA8: FontAtlasFormat = 0;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct FontAtlas {
    pub pixel: *mut Void,
    pub tex_width: Int,
    pub tex_height: Int,
    pub permanent: Allocator,
    pub temporary: Allocator,
    pub custom: RectI,
    pub cursors: [Cursor; 7],
    pub glyph_count: Int,
    pub glyphs: *mut FontGlyph,
    pub default_font: *mut Font,
    pub fonts: *mut Font,
    pub config: *mut FontConfig,
    pub font_num: Int,
}

pub type FILE = libc::FILE;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct FontBaker {
    pub alloc: Allocator,
    pub spc: TtPackContext,
    pub build: *mut FontBackData,
    pub packed_chars: *mut TtPackedChar,
    pub rects: *mut RpRect,
    pub ranges: *mut TtPackRange,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtPackRange {
    pub font_size: f32,
    pub first_unicode_codepoint_in_range: Int,
    pub array_of_unicode_codepoints: *mut Int,
    pub num_chars: Int,
    pub chardata_for_range: *mut TtPackedChar,
    pub h_oversample: Uchar,
    pub v_oversample: Uchar,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtPackedChar {
    pub x0: Ushort,
    pub y0: Ushort,
    pub x1: Ushort,
    pub y1: Ushort,
    pub xoff: f32,
    pub yoff: f32,
    pub xadvance: f32,
    pub xoff2: f32,
    pub yoff2: f32,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct RpRect {
    pub id: Int,
    pub w: RpCoord,
    pub h: RpCoord,
    pub x: RpCoord,
    pub y: RpCoord,
    pub was_packed: Int,
}

pub type RpCoord = Ushort;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct FontBackData {
    pub info: TtFontInfo,
    pub rects: *mut RpRect,
    pub ranges: *mut TtPackRange,
    pub range_count: Rune,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtFontInfo {
    pub data: *const Uchar,
    pub fontstart: Int,
    pub numGlyphs: Int,
    pub loca: Int,
    pub head: Int,
    pub glyf: Int,
    pub hhea: Int,
    pub hmtx: Int,
    pub kern: Int,
    pub index_map: Int,
    pub indexToLocFormat: Int,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtPackContext {
    pub pack_info: *mut Void,
    pub width: Int,
    pub height: Int,
    pub stride_in_bytes: Int,
    pub padding: Int,
    pub h_oversample: Uint,
    pub v_oversample: Uint,
    pub pixels: *mut Uchar,
    pub nodes: *mut Void,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtAlignedQuad {
    pub x0: f32,
    pub y0: f32,
    pub s0: f32,
    pub t0: f32,
    pub x1: f32,
    pub y1: f32,
    pub s1: f32,
    pub t1: f32,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtVertex {
    pub x: Short,
    pub y: Short,
    pub cx: Short,
    pub cy: Short,
    pub type_0: Uchar,
    pub padding: Uchar,
}
pub const NK_TT_vline: unnamed_16 = 2;
pub const NK_TT_vcurve: unnamed_16 = 3;
pub const NK_TT_vmove: unnamed_16 = 1;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtBitmap {
    pub w: Int,
    pub h: Int,
    pub stride: Int,
    pub pixels: *mut Uchar,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtPoint {
    pub x: f32,
    pub y: f32,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtEdge {
    pub x0: f32,
    pub y0: f32,
    pub x1: f32,
    pub y1: f32,
    pub invert: Int,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtHheap {
    pub alloc: Allocator,
    pub head: *mut TtHheapChunk,
    pub first_free: *mut Void,
    pub num_remaining_in_head_chunk: Int,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtHheapChunk {
    pub next: *mut TtHheapChunk,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct TtActiveEdge {
    pub next: *mut TtActiveEdge,
    pub fx: f32,
    pub fdx: f32,
    pub fdy: f32,
    pub direction: f32,
    pub sy: f32,
    pub ey: f32,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct RpContext {
    pub width: Int,
    pub height: Int,
    pub align: Int,
    pub init_mode: Int,
    pub heuristic: Int,
    pub num_nodes: Int,
    pub active_head: *mut RpNode,
    pub free_head: *mut RpNode,
    pub extra: [RpNode; 2],
}
/* non-zero if valid packing */
/* 16 bytes, nominally */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RpNode {
    pub x: RpCoord,
    pub y: RpCoord,
    pub next: *mut RpNode,
}
/* we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2' */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RpFindResult {
    pub x: Int,
    pub y: Int,
    pub prev_link: *mut *mut RpNode,
}
pub const NK_RP_HEURISTIC_Skyline_BF_sortHeight: NK_RP_HEURISTIC = 1;
pub const NK_RP_HEURISTIC_Skyline_BL_sortHeight: NK_RP_HEURISTIC = 0;
pub const NK_RP_HEURISTIC_Skyline_default: NK_RP_HEURISTIC = 0;
pub const NK_RP__INIT_skyline: NK_RP_INIT_STATE = 1;
pub const NK_TT_PLATFORM_ID_UNICODE: unnamed_14 = 0;
pub const NK_TT_MS_EID_UNICODE_FULL: unnamed_17 = 10;
pub const NK_TT_MS_EID_UNICODE_BMP: unnamed_17 = 1;
pub const NK_TT_PLATFORM_ID_MICROSOFT: unnamed_14 = 3;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_9 {
    pub c: Char,
    pub _h: TtPackRange,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_10 {
    pub c: Char,
    pub _h: RpRect,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_11 {
    pub c: Char,
    pub _h: TtPackedChar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_12 {
    pub c: Char,
    pub _h: FontBackData,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unnamed_13 {
    pub c: Char,
    pub _h: FontBaker,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct MemoryStatus {
    pub memory: *mut Void,
    pub type_0: Uint,
    pub size: Size,
    pub allocated: Size,
    pub needed: Size,
    pub calls: Size,
}

pub type TextEditMode = Uint;
pub type PanelSet = Uint;
pub const NK_PANEL_SET_POPUP: PanelSet = 244;
pub type WindowFlags = Uint;
/* sets window widgets into a read only mode and does not allow input changes */
pub const NK_WINDOW_NOT_INTERACTIVE: WindowFlags = 5120;
pub const NK_TT_PLATFORM_ID_ISO: unnamed_14 = 2;
/* <= not same as 0, this makes us check the bitfield is 0 */
pub type unnamed_14 = Uint;
pub type unnamed_15 = Uint;
pub type NK_RP_HEURISTIC = Uint;
pub type PropertyStatus = Uint;
pub const NK_DO_NOT_STOP_ON_NEW_LINE: unnamed_15 = 0;
pub const NK_TT_PLATFORM_ID_MAC: unnamed_14 = 1;
pub type NK_RP_INIT_STATE = Uint;
pub const NK_TT_MS_EID_SHIFTJIS: unnamed_17 = 2;
pub type unnamed_16 = Uint;
pub const NK_TT_MS_EID_SYMBOL: unnamed_17 = 0;
/* encodingID for NK_TT_PLATFORM_ID_MICROSOFT */
pub type unnamed_17 = Uint;

pub unsafe fn nk_init_default(mut ctx: *mut Context, mut font: *const UserFont) -> Int {
    let mut alloc: Allocator = Allocator {
        userdata: Handle {
            ptr: 0 as *mut Void,
        },
        alloc: None,
        free: None,
    };
    alloc.userdata.ptr = 0 as *mut Void;
    alloc.alloc = Some(nk_malloc);
    alloc.free = Some(nk_mfree);
    return nk_init(ctx, &mut alloc, font);
}

pub unsafe fn nk_init(
    mut ctx: *mut Context,
    mut alloc: *mut Allocator,
    mut font: *const UserFont,
) -> Int {
    if alloc.is_null() {
        return 0i32;
    } else {
        nk_setup(ctx, font);
        nk_buffer_init(&mut (*ctx).memory, alloc, (4i32 * 1024i32) as Size);
        nk_pool_init(&mut (*ctx).pool, alloc, 16i32 as Uint);
        (*ctx).use_pool = nk_true as Int;
        return 1i32;
    };
}
unsafe fn nk_pool_init(mut pool: *mut Pool, mut alloc: *mut Allocator, mut capacity: Uint) -> () {
    nk_zero(pool as *mut Void, mem::size_of::<Pool>() as Ulong);
    (*pool).alloc = *alloc;
    (*pool).capacity = capacity;
    (*pool).type_0 = NK_BUFFER_DYNAMIC;
    (*pool).pages = 0 as *mut Page;
}
unsafe fn nk_zero(mut ptr: *mut Void, mut size: Size) -> () {
    nk_memset(ptr, 0i32, size);
}
unsafe fn nk_memset(mut ptr: *mut Void, mut c0: Int, mut size: Size) -> () {
    let mut dst: *mut u8 = ptr as *mut u8;
    let mut c: Uint = 0i32 as Uint;
    let mut t: Size = 0i32 as Size;
    c = c0 as u8 as Uint;
    if c != 0i32 as Uint {
        /* at least 16-bits  */
        c = c << 8i32 | c;
        if mem::size_of::<Uint>() as Ulong > 2i32 as Ulong {
            /* at least 32-bits*/
            c = c << 16i32 | c
        }
    }
    /* too small of a word count */
    dst = ptr as *mut u8;
    if size < (3i32 as Ulong).wrapping_mul(mem::size_of::<Uint>() as Ulong) {
        loop {
            let fresh0 = size;
            size = size.wrapping_sub(1);
            if !(0 != fresh0) {
                break;
            }
            let fresh1 = dst;
            dst = dst.offset(1);
            *fresh1 = c0 as u8
        }
        return;
    } else {
        /* align destination */
        t = dst as Long as Size & (mem::size_of::<Uint>() as Ulong).wrapping_sub(1i32 as Ulong);
        if t != 0i32 as Ulong {
            t = (mem::size_of::<Uint>() as Ulong).wrapping_sub(t);
            size = (size as Ulong).wrapping_sub(t) as Size as Size;
            loop {
                let fresh2 = dst;
                dst = dst.offset(1);
                *fresh2 = c0 as u8;
                t = t.wrapping_sub(1);
                if !(t != 0i32 as Ulong) {
                    break;
                }
            }
        }
        /* fill word */
        t = size.wrapping_div(mem::size_of::<Uint>() as Ulong);
        loop {
            *(dst as *mut Void as *mut Uint) = c;
            dst = dst.offset(mem::size_of::<Uint>() as Ulong as isize);
            t = t.wrapping_sub(1);
            if !(t != 0i32 as Ulong) {
                break;
            }
        }
        /* fill trailing bytes */
        t = size & (mem::size_of::<Uint>() as Ulong).wrapping_sub(1i32 as Ulong);
        if t != 0i32 as Ulong {
            loop {
                let fresh3 = dst;
                dst = dst.offset(1);
                *fresh3 = c0 as u8;
                t = t.wrapping_sub(1);
                if !(t != 0i32 as Ulong) {
                    break;
                }
            }
        }
        return;
    };
}

pub unsafe fn nk_buffer_init(
    mut b: *mut Buffer,
    mut a: *const Allocator,
    mut initial_size: Size,
) -> () {
    if b.is_null() || a.is_null() || 0 == initial_size {
        return;
    } else {
        nk_zero(b as *mut Void, mem::size_of::<Buffer>() as Ulong);
        (*b).type_0 = NK_BUFFER_DYNAMIC;
        (*b).memory.ptr = (*a).alloc.expect("non-null function pointer")(
            (*a).userdata,
            0 as *mut Void,
            initial_size,
        );
        (*b).memory.size = initial_size;
        (*b).size = initial_size;
        (*b).grow_factor = 2.0f32;
        (*b).pool = *a;
        return;
    };
}
unsafe fn nk_setup(mut ctx: *mut Context, mut font: *const UserFont) -> () {
    if ctx.is_null() {
        return;
    } else {
        nk_zero(ctx as *mut Void, mem::size_of::<Context>() as Ulong);
        nk_style_default(ctx);
        (*ctx).seq = 1i32 as Uint;
        if !font.is_null() {
            (*ctx).style.font = font
        }
        nk_draw_list_init(&mut (*ctx).draw_list);
        return;
    };
}

pub unsafe fn nk_draw_list_init(mut list: *mut DrawList) -> () {
    let mut i: Size = 0i32 as Size;
    if list.is_null() {
        return;
    } else {
        nk_zero(list as *mut Void, mem::size_of::<DrawList>() as Ulong);
        i = 0i32 as Size;
        while i < (mem::size_of::<[Point; 12]>() as Ulong)
            .wrapping_div(mem::size_of::<Point>() as Ulong)
        {
            let a: f32 = i as f32
                / (mem::size_of::<[Point; 12]>() as Ulong)
                    .wrapping_div(mem::size_of::<Point>() as Ulong) as f32
                * 2i32 as f32 * 3.1415927410125734f32;
            (*list).circle_vtx[i as usize].x = nk_cos(a);
            (*list).circle_vtx[i as usize].y = nk_sin(a);
            i = i.wrapping_add(1)
        }
        return;
    };
}
unsafe fn nk_sin(mut x: f32) -> f32 {
    static mut a0: f32 = unsafe { 1.9105930344931874e-31f32 };
    static mut a1: f32 = unsafe { 1.0008676052093506f32 };
    static mut a2: f32 = unsafe { -0.012127612717449665f32 };
    static mut a3: f32 = unsafe { -0.13807877898216248f32 };
    static mut a4: f32 = unsafe { -0.0267353393137455f32 };
    static mut a5: f32 = unsafe { 0.020802659913897516f32 };
    static mut a6: f32 = unsafe { -0.003039960516616702f32 };
    static mut a7: f32 = unsafe { 0.00013823564222548157f32 };
    return a0 + x * (a1 + x * (a2 + x * (a3 + x * (a4 + x * (a5 + x * (a6 + x * a7))))));
}
unsafe fn nk_cos(mut x: f32) -> f32 {
    static mut a0: f32 = unsafe { 1.0023859739303589f32 };
    static mut a1: f32 = unsafe { -0.03819199651479721f32 };
    static mut a2: f32 = unsafe { -0.3943823277950287f32 };
    static mut a3: f32 = unsafe { -0.1181340366601944f32 };
    static mut a4: f32 = unsafe { 0.10712379962205887f32 };
    static mut a5: f32 = unsafe { -0.018663715571165086f32 };
    static mut a6: f32 = unsafe { 0.00099014095030725f32 };
    static mut a7: f32 = unsafe { -5.2302214344429959e-14f32 };
    return a0 + x * (a1 + x * (a2 + x * (a3 + x * (a4 + x * (a5 + x * (a6 + x * a7))))));
}

pub unsafe fn nk_style_default(mut ctx: *mut Context) -> () {
    nk_style_from_table(ctx, 0 as *const Color);
}

pub unsafe fn nk_style_from_table(mut ctx: *mut Context, mut table: *const Color) -> () {
    let mut style: *mut Style = 0 as *mut Style;
    let mut text: *mut StyleText = 0 as *mut StyleText;
    let mut button: *mut StyleButton = 0 as *mut StyleButton;
    let mut toggle: *mut StyleToggle = 0 as *mut StyleToggle;
    let mut select: *mut StyleSelectable = 0 as *mut StyleSelectable;
    let mut slider: *mut StyleSlider = 0 as *mut StyleSlider;
    let mut prog: *mut StyleProgress = 0 as *mut StyleProgress;
    let mut scroll: *mut StyleScrollbar = 0 as *mut StyleScrollbar;
    let mut edit: *mut StyleEdit = 0 as *mut StyleEdit;
    let mut property: *mut StyleProperty = 0 as *mut StyleProperty;
    let mut combo: *mut StyleCombo = 0 as *mut StyleCombo;
    let mut chart: *mut StyleChart = 0 as *mut StyleChart;
    let mut tab: *mut StyleTab = 0 as *mut StyleTab;
    let mut win: *mut StyleWindow = 0 as *mut StyleWindow;
    if ctx.is_null() {
        return;
    } else {
        style = &mut (*ctx).style as *mut Style;
        table = if table.is_null() {
            nk_default_color_style.as_ptr()
        } else {
            table
        };
        /* default text */
        text = &mut (*style).text as *mut StyleText;
        (*text).color = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*text).padding = Point::new(0.0, 0.0);
        /* default button */
        button = &mut (*style).button as *mut StyleButton;
        nk_zero(button as *mut Void, mem::size_of::<StyleButton>() as Ulong);
        (*button).normal = nk_style_item_color(*table.offset(NK_COLOR_BUTTON as Int as isize));
        (*button).hover = nk_style_item_color(*table.offset(NK_COLOR_BUTTON_HOVER as Int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_BUTTON_ACTIVE as Int as isize));
        (*button).border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*button).text_background = *table.offset(NK_COLOR_BUTTON as Int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).padding = Point::new(2.0, 2.0);
        (*button).image_padding = Point::new(0.0, 0.0);
        (*button).touch_padding = Point::new(0.0, 0.0);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 1.0f32;
        (*button).rounding = 4.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* contextual button */
        button = &mut (*style).contextual_button as *mut StyleButton;
        nk_zero(button as *mut Void, mem::size_of::<StyleButton>() as Ulong);
        (*button).normal = nk_style_item_color(*table.offset(NK_COLOR_WINDOW as Int as isize));
        (*button).hover = nk_style_item_color(*table.offset(NK_COLOR_BUTTON_HOVER as Int as isize));
        (*button).active =
            nk_style_item_color(*table.offset(NK_COLOR_BUTTON_ACTIVE as Int as isize));
        (*button).border_color = *table.offset(NK_COLOR_WINDOW as Int as isize);
        (*button).text_background = *table.offset(NK_COLOR_WINDOW as Int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).padding = Point::new(2.0, 2.0);
        (*button).touch_padding = Point::new(0.0, 0.0);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 0.0;
        (*button).rounding = 0.0;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* menu button */
        button = &mut (*style).menu_button as *mut StyleButton;
        nk_zero(button as *mut Void, mem::size_of::<StyleButton>() as Ulong);
        (*button).normal = nk_style_item_color(*table.offset(NK_COLOR_WINDOW as Int as isize));
        (*button).hover = nk_style_item_color(*table.offset(NK_COLOR_WINDOW as Int as isize));
        (*button).active = nk_style_item_color(*table.offset(NK_COLOR_WINDOW as Int as isize));
        (*button).border_color = *table.offset(NK_COLOR_WINDOW as Int as isize);
        (*button).text_background = *table.offset(NK_COLOR_WINDOW as Int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).padding = Point::new(2.0, 2.0);
        (*button).touch_padding = Point::new(0.0, 0.0);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 0.0;
        (*button).rounding = 1.0;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* checkbox toggle */
        toggle = &mut (*style).checkbox as *mut StyleToggle;
        nk_zero(toggle as *mut Void, mem::size_of::<StyleToggle>() as Ulong);
        (*toggle).normal = nk_style_item_color(*table.offset(NK_COLOR_TOGGLE as Int as isize));
        (*toggle).hover = nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_HOVER as Int as isize));
        (*toggle).active =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_HOVER as Int as isize));
        (*toggle).cursor_normal =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_CURSOR as Int as isize));
        (*toggle).cursor_hover =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_CURSOR as Int as isize));
        (*toggle).userdata = nk_handle_ptr(0 as *mut Void);
        (*toggle).text_background = *table.offset(NK_COLOR_WINDOW as Int as isize);
        (*toggle).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*toggle).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*toggle).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*toggle).padding = Point::new(2.0f32, 2.0f32);
        (*toggle).touch_padding = Point::new(0i32 as f32, 0i32 as f32);
        (*toggle).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*toggle).border = 0.0f32;
        (*toggle).spacing = 4i32 as f32;
        /* option toggle */
        toggle = &mut (*style).option as *mut StyleToggle;
        nk_zero(toggle as *mut Void, mem::size_of::<StyleToggle>() as Ulong);
        (*toggle).normal = nk_style_item_color(*table.offset(NK_COLOR_TOGGLE as Int as isize));
        (*toggle).hover = nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_HOVER as Int as isize));
        (*toggle).active =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_HOVER as Int as isize));
        (*toggle).cursor_normal =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_CURSOR as Int as isize));
        (*toggle).cursor_hover =
            nk_style_item_color(*table.offset(NK_COLOR_TOGGLE_CURSOR as Int as isize));
        (*toggle).userdata = nk_handle_ptr(0 as *mut Void);
        (*toggle).text_background = *table.offset(NK_COLOR_WINDOW as Int as isize);
        (*toggle).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*toggle).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*toggle).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*toggle).padding = Point::new(3.0f32, 3.0f32);
        (*toggle).touch_padding = Point::new(0i32 as f32, 0i32 as f32);
        (*toggle).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*toggle).border = 0.0f32;
        (*toggle).spacing = 4i32 as f32;
        /* selectable */
        select = &mut (*style).selectable as *mut StyleSelectable;
        nk_zero(
            select as *mut Void,
            mem::size_of::<StyleSelectable>() as Ulong,
        );
        (*select).normal = nk_style_item_color(*table.offset(NK_COLOR_SELECT as Int as isize));
        (*select).hover = nk_style_item_color(*table.offset(NK_COLOR_SELECT as Int as isize));
        (*select).pressed = nk_style_item_color(*table.offset(NK_COLOR_SELECT as Int as isize));
        (*select).normal_active =
            nk_style_item_color(*table.offset(NK_COLOR_SELECT_ACTIVE as Int as isize));
        (*select).hover_active =
            nk_style_item_color(*table.offset(NK_COLOR_SELECT_ACTIVE as Int as isize));
        (*select).pressed_active =
            nk_style_item_color(*table.offset(NK_COLOR_SELECT_ACTIVE as Int as isize));
        (*select).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*select).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*select).text_pressed = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*select).text_normal_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*select).text_hover_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*select).text_pressed_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*select).padding = Point::new(2.0f32, 2.0f32);
        (*select).image_padding = Point::new(2.0f32, 2.0f32);
        (*select).touch_padding = Point::new(0i32 as f32, 0i32 as f32);
        (*select).userdata = nk_handle_ptr(0 as *mut Void);
        (*select).rounding = 0.0f32;
        (*select).draw_begin = None;
        (*select).draw_end = None;
        /* slider */
        slider = &mut (*style).slider as *mut StyleSlider;
        nk_zero(slider as *mut Void, mem::size_of::<StyleSlider>() as Ulong);
        (*slider).normal = nk_style_item_hide();
        (*slider).hover = nk_style_item_hide();
        (*slider).active = nk_style_item_hide();
        (*slider).bar_normal = *table.offset(NK_COLOR_SLIDER as Int as isize);
        (*slider).bar_hover = *table.offset(NK_COLOR_SLIDER as Int as isize);
        (*slider).bar_active = *table.offset(NK_COLOR_SLIDER as Int as isize);
        (*slider).bar_filled = *table.offset(NK_COLOR_SLIDER_CURSOR as Int as isize);
        (*slider).cursor_normal =
            nk_style_item_color(*table.offset(NK_COLOR_SLIDER_CURSOR as Int as isize));
        (*slider).cursor_hover =
            nk_style_item_color(*table.offset(NK_COLOR_SLIDER_CURSOR_HOVER as Int as isize));
        (*slider).cursor_active =
            nk_style_item_color(*table.offset(NK_COLOR_SLIDER_CURSOR_ACTIVE as Int as isize));
        (*slider).inc_symbol = NK_SYMBOL_TRIANGLE_RIGHT;
        (*slider).dec_symbol = NK_SYMBOL_TRIANGLE_LEFT;
        (*slider).cursor_size = Point::new(16i32 as f32, 16i32 as f32);
        (*slider).padding = Point::new(2i32 as f32, 2i32 as f32);
        (*slider).spacing = Point::new(2i32 as f32, 2i32 as f32);
        (*slider).userdata = nk_handle_ptr(0 as *mut Void);
        (*slider).show_buttons = nk_false as Int;
        (*slider).bar_height = 8i32 as f32;
        (*slider).rounding = 0i32 as f32;
        (*slider).draw_begin = None;
        (*slider).draw_end = None;
        /* slider buttons */
        button = &mut (*style).slider.inc_button as *mut StyleButton;
        (*button).normal = nk_style_item_color(nk_rgb(40i32, 40i32, 40i32));
        (*button).hover = nk_style_item_color(nk_rgb(42i32, 42i32, 42i32));
        (*button).active = nk_style_item_color(nk_rgb(44i32, 44i32, 44i32));
        (*button).border_color = nk_rgb(65i32, 65i32, 65i32);
        (*button).text_background = nk_rgb(40i32, 40i32, 40i32);
        (*button).text_normal = nk_rgb(175i32, 175i32, 175i32);
        (*button).text_hover = nk_rgb(175i32, 175i32, 175i32);
        (*button).text_active = nk_rgb(175i32, 175i32, 175i32);
        (*button).padding = Point::new(8.0f32, 8.0f32);
        (*button).touch_padding = Point::new(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 1.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        (*style).slider.dec_button = (*style).slider.inc_button;
        /* progressbar */
        prog = &mut (*style).progress as *mut StyleProgress;
        nk_zero(prog as *mut Void, mem::size_of::<StyleProgress>() as Ulong);
        (*prog).normal = nk_style_item_color(*table.offset(NK_COLOR_SLIDER as Int as isize));
        (*prog).hover = nk_style_item_color(*table.offset(NK_COLOR_SLIDER as Int as isize));
        (*prog).active = nk_style_item_color(*table.offset(NK_COLOR_SLIDER as Int as isize));
        (*prog).cursor_normal =
            nk_style_item_color(*table.offset(NK_COLOR_SLIDER_CURSOR as Int as isize));
        (*prog).cursor_hover =
            nk_style_item_color(*table.offset(NK_COLOR_SLIDER_CURSOR_HOVER as Int as isize));
        (*prog).cursor_active =
            nk_style_item_color(*table.offset(NK_COLOR_SLIDER_CURSOR_ACTIVE as Int as isize));
        (*prog).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*prog).cursor_border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*prog).userdata = nk_handle_ptr(0 as *mut Void);
        (*prog).padding = Point::new(4i32 as f32, 4i32 as f32);
        (*prog).rounding = 0i32 as f32;
        (*prog).border = 0i32 as f32;
        (*prog).cursor_rounding = 0i32 as f32;
        (*prog).cursor_border = 0i32 as f32;
        (*prog).draw_begin = None;
        (*prog).draw_end = None;
        /* scrollbars */
        scroll = &mut (*style).scrollh as *mut StyleScrollbar;
        nk_zero(
            scroll as *mut Void,
            mem::size_of::<StyleScrollbar>() as Ulong,
        );
        (*scroll).normal = nk_style_item_color(*table.offset(NK_COLOR_SCROLLBAR as Int as isize));
        (*scroll).hover = nk_style_item_color(*table.offset(NK_COLOR_SCROLLBAR as Int as isize));
        (*scroll).active = nk_style_item_color(*table.offset(NK_COLOR_SCROLLBAR as Int as isize));
        (*scroll).cursor_normal =
            nk_style_item_color(*table.offset(NK_COLOR_SCROLLBAR_CURSOR as Int as isize));
        (*scroll).cursor_hover =
            nk_style_item_color(*table.offset(NK_COLOR_SCROLLBAR_CURSOR_HOVER as Int as isize));
        (*scroll).cursor_active =
            nk_style_item_color(*table.offset(NK_COLOR_SCROLLBAR_CURSOR_ACTIVE as Int as isize));
        (*scroll).dec_symbol = NK_SYMBOL_CIRCLE_SOLID;
        (*scroll).inc_symbol = NK_SYMBOL_CIRCLE_SOLID;
        (*scroll).userdata = nk_handle_ptr(0 as *mut Void);
        (*scroll).border_color = *table.offset(NK_COLOR_SCROLLBAR as Int as isize);
        (*scroll).cursor_border_color = *table.offset(NK_COLOR_SCROLLBAR as Int as isize);
        (*scroll).padding = Point::new(0i32 as f32, 0i32 as f32);
        (*scroll).show_buttons = nk_false as Int;
        (*scroll).border = 0i32 as f32;
        (*scroll).rounding = 0i32 as f32;
        (*scroll).border_cursor = 0i32 as f32;
        (*scroll).rounding_cursor = 0i32 as f32;
        (*scroll).draw_begin = None;
        (*scroll).draw_end = None;
        (*style).scrollv = (*style).scrollh;
        /* scrollbars buttons */
        button = &mut (*style).scrollh.inc_button as *mut StyleButton;
        (*button).normal = nk_style_item_color(nk_rgb(40i32, 40i32, 40i32));
        (*button).hover = nk_style_item_color(nk_rgb(42i32, 42i32, 42i32));
        (*button).active = nk_style_item_color(nk_rgb(44i32, 44i32, 44i32));
        (*button).border_color = nk_rgb(65i32, 65i32, 65i32);
        (*button).text_background = nk_rgb(40i32, 40i32, 40i32);
        (*button).text_normal = nk_rgb(175i32, 175i32, 175i32);
        (*button).text_hover = nk_rgb(175i32, 175i32, 175i32);
        (*button).text_active = nk_rgb(175i32, 175i32, 175i32);
        (*button).padding = Point::new(4.0f32, 4.0f32);
        (*button).touch_padding = Point::new(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 1.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        (*style).scrollh.dec_button = (*style).scrollh.inc_button;
        (*style).scrollv.inc_button = (*style).scrollh.inc_button;
        (*style).scrollv.dec_button = (*style).scrollh.inc_button;
        /* edit */
        edit = &mut (*style).edit as *mut StyleEdit;
        nk_zero(edit as *mut Void, mem::size_of::<StyleEdit>() as Ulong);
        (*edit).normal = nk_style_item_color(*table.offset(NK_COLOR_EDIT as Int as isize));
        (*edit).hover = nk_style_item_color(*table.offset(NK_COLOR_EDIT as Int as isize));
        (*edit).active = nk_style_item_color(*table.offset(NK_COLOR_EDIT as Int as isize));
        (*edit).cursor_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).cursor_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).cursor_text_normal = *table.offset(NK_COLOR_EDIT as Int as isize);
        (*edit).cursor_text_hover = *table.offset(NK_COLOR_EDIT as Int as isize);
        (*edit).border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*edit).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).selected_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).selected_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).selected_text_normal = *table.offset(NK_COLOR_EDIT as Int as isize);
        (*edit).selected_text_hover = *table.offset(NK_COLOR_EDIT as Int as isize);
        (*edit).scrollbar_size = Point::new(10i32 as f32, 10i32 as f32);
        (*edit).scrollbar = (*style).scrollv;
        (*edit).padding = Point::new(4i32 as f32, 4i32 as f32);
        (*edit).row_padding = 2i32 as f32;
        (*edit).cursor_size = 4i32 as f32;
        (*edit).border = 1i32 as f32;
        (*edit).rounding = 0i32 as f32;
        /* property */
        property = &mut (*style).property as *mut StyleProperty;
        nk_zero(
            property as *mut Void,
            mem::size_of::<StyleProperty>() as Ulong,
        );
        (*property).normal = nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as Int as isize));
        (*property).hover = nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as Int as isize));
        (*property).active = nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as Int as isize));
        (*property).border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*property).label_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*property).label_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*property).label_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*property).sym_left = NK_SYMBOL_TRIANGLE_LEFT;
        (*property).sym_right = NK_SYMBOL_TRIANGLE_RIGHT;
        (*property).userdata = nk_handle_ptr(0 as *mut Void);
        (*property).padding = Point::new(4i32 as f32, 4i32 as f32);
        (*property).border = 1i32 as f32;
        (*property).rounding = 10i32 as f32;
        (*property).draw_begin = None;
        (*property).draw_end = None;
        /* property buttons */
        button = &mut (*style).property.dec_button as *mut StyleButton;
        nk_zero(button as *mut Void, mem::size_of::<StyleButton>() as Ulong);
        (*button).normal = nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as Int as isize));
        (*button).hover = nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as Int as isize));
        (*button).active = nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as Int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_PROPERTY as Int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).padding = Point::new(0.0f32, 0.0f32);
        (*button).touch_padding = Point::new(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        (*style).property.inc_button = (*style).property.dec_button;
        /* property edit */
        edit = &mut (*style).property.edit as *mut StyleEdit;
        nk_zero(edit as *mut Void, mem::size_of::<StyleEdit>() as Ulong);
        (*edit).normal = nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as Int as isize));
        (*edit).hover = nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as Int as isize));
        (*edit).active = nk_style_item_color(*table.offset(NK_COLOR_PROPERTY as Int as isize));
        (*edit).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*edit).cursor_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).cursor_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).cursor_text_normal = *table.offset(NK_COLOR_EDIT as Int as isize);
        (*edit).cursor_text_hover = *table.offset(NK_COLOR_EDIT as Int as isize);
        (*edit).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).selected_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).selected_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*edit).selected_text_normal = *table.offset(NK_COLOR_EDIT as Int as isize);
        (*edit).selected_text_hover = *table.offset(NK_COLOR_EDIT as Int as isize);
        (*edit).padding = Point::new(0i32 as f32, 0i32 as f32);
        (*edit).cursor_size = 8i32 as f32;
        (*edit).border = 0i32 as f32;
        (*edit).rounding = 0i32 as f32;
        /* chart */
        chart = &mut (*style).chart as *mut StyleChart;
        nk_zero(chart as *mut Void, mem::size_of::<StyleChart>() as Ulong);
        (*chart).background = nk_style_item_color(*table.offset(NK_COLOR_CHART as Int as isize));
        (*chart).border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*chart).selected_color = *table.offset(NK_COLOR_CHART_COLOR_HIGHLIGHT as Int as isize);
        (*chart).color = *table.offset(NK_COLOR_CHART_COLOR as Int as isize);
        (*chart).padding = Point::new(4i32 as f32, 4i32 as f32);
        (*chart).border = 0i32 as f32;
        (*chart).rounding = 0i32 as f32;
        /* combo */
        combo = &mut (*style).combo as *mut StyleCombo;
        (*combo).normal = nk_style_item_color(*table.offset(NK_COLOR_COMBO as Int as isize));
        (*combo).hover = nk_style_item_color(*table.offset(NK_COLOR_COMBO as Int as isize));
        (*combo).active = nk_style_item_color(*table.offset(NK_COLOR_COMBO as Int as isize));
        (*combo).border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*combo).label_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*combo).label_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*combo).label_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*combo).sym_normal = NK_SYMBOL_TRIANGLE_DOWN;
        (*combo).sym_hover = NK_SYMBOL_TRIANGLE_DOWN;
        (*combo).sym_active = NK_SYMBOL_TRIANGLE_DOWN;
        (*combo).content_padding = Point::new(4i32 as f32, 4i32 as f32);
        (*combo).button_padding = Point::new(0i32 as f32, 4i32 as f32);
        (*combo).spacing = Point::new(4i32 as f32, 0i32 as f32);
        (*combo).border = 1i32 as f32;
        (*combo).rounding = 0i32 as f32;
        /* combo button */
        button = &mut (*style).combo.button as *mut StyleButton;
        nk_zero(button as *mut Void, mem::size_of::<StyleButton>() as Ulong);
        (*button).normal = nk_style_item_color(*table.offset(NK_COLOR_COMBO as Int as isize));
        (*button).hover = nk_style_item_color(*table.offset(NK_COLOR_COMBO as Int as isize));
        (*button).active = nk_style_item_color(*table.offset(NK_COLOR_COMBO as Int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_COMBO as Int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).padding = Point::new(2.0f32, 2.0f32);
        (*button).touch_padding = Point::new(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* tab */
        tab = &mut (*style).tab as *mut StyleTab;
        (*tab).background = nk_style_item_color(*table.offset(NK_COLOR_TAB_HEADER as Int as isize));
        (*tab).border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*tab).text = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*tab).sym_minimize = NK_SYMBOL_TRIANGLE_RIGHT;
        (*tab).sym_maximize = NK_SYMBOL_TRIANGLE_DOWN;
        (*tab).padding = Point::new(4i32 as f32, 4i32 as f32);
        (*tab).spacing = Point::new(4i32 as f32, 4i32 as f32);
        (*tab).indent = 10.0f32;
        (*tab).border = 1i32 as f32;
        (*tab).rounding = 0i32 as f32;
        /* tab button */
        button = &mut (*style).tab.tab_minimize_button as *mut StyleButton;
        nk_zero(button as *mut Void, mem::size_of::<StyleButton>() as Ulong);
        (*button).normal = nk_style_item_color(*table.offset(NK_COLOR_TAB_HEADER as Int as isize));
        (*button).hover = nk_style_item_color(*table.offset(NK_COLOR_TAB_HEADER as Int as isize));
        (*button).active = nk_style_item_color(*table.offset(NK_COLOR_TAB_HEADER as Int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_TAB_HEADER as Int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).padding = Point::new(2.0f32, 2.0f32);
        (*button).touch_padding = Point::new(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        (*style).tab.tab_maximize_button = *button;
        /* node button */
        button = &mut (*style).tab.node_minimize_button as *mut StyleButton;
        nk_zero(button as *mut Void, mem::size_of::<StyleButton>() as Ulong);
        (*button).normal = nk_style_item_color(*table.offset(NK_COLOR_WINDOW as Int as isize));
        (*button).hover = nk_style_item_color(*table.offset(NK_COLOR_WINDOW as Int as isize));
        (*button).active = nk_style_item_color(*table.offset(NK_COLOR_WINDOW as Int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_TAB_HEADER as Int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).padding = Point::new(2.0f32, 2.0f32);
        (*button).touch_padding = Point::new(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        (*style).tab.node_maximize_button = *button;
        /* window header */
        win = &mut (*style).window as *mut StyleWindow;
        (*win).header.align = NK_HEADER_RIGHT;
        (*win).header.close_symbol = NK_SYMBOL_X;
        (*win).header.minimize_symbol = NK_SYMBOL_MINUS;
        (*win).header.maximize_symbol = NK_SYMBOL_PLUS;
        (*win).header.normal = nk_style_item_color(*table.offset(NK_COLOR_HEADER as Int as isize));
        (*win).header.hover = nk_style_item_color(*table.offset(NK_COLOR_HEADER as Int as isize));
        (*win).header.active = nk_style_item_color(*table.offset(NK_COLOR_HEADER as Int as isize));
        (*win).header.label_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*win).header.label_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*win).header.label_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*win).header.label_padding = Point::new(4i32 as f32, 4i32 as f32);
        (*win).header.padding = Point::new(4i32 as f32, 4i32 as f32);
        (*win).header.spacing = Point::new(0i32 as f32, 0i32 as f32);
        /* window header close button */
        button = &mut (*style).window.header.close_button as *mut StyleButton;
        nk_zero(button as *mut Void, mem::size_of::<StyleButton>() as Ulong);
        (*button).normal = nk_style_item_color(*table.offset(NK_COLOR_HEADER as Int as isize));
        (*button).hover = nk_style_item_color(*table.offset(NK_COLOR_HEADER as Int as isize));
        (*button).active = nk_style_item_color(*table.offset(NK_COLOR_HEADER as Int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_HEADER as Int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).padding = Point::new(0.0f32, 0.0f32);
        (*button).touch_padding = Point::new(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* window header minimize button */
        button = &mut (*style).window.header.minimize_button as *mut StyleButton;
        nk_zero(button as *mut Void, mem::size_of::<StyleButton>() as Ulong);
        (*button).normal = nk_style_item_color(*table.offset(NK_COLOR_HEADER as Int as isize));
        (*button).hover = nk_style_item_color(*table.offset(NK_COLOR_HEADER as Int as isize));
        (*button).active = nk_style_item_color(*table.offset(NK_COLOR_HEADER as Int as isize));
        (*button).border_color = nk_rgba(0i32, 0i32, 0i32, 0i32);
        (*button).text_background = *table.offset(NK_COLOR_HEADER as Int as isize);
        (*button).text_normal = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_hover = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).text_active = *table.offset(NK_COLOR_TEXT as Int as isize);
        (*button).padding = Point::new(0.0f32, 0.0f32);
        (*button).touch_padding = Point::new(0.0f32, 0.0f32);
        (*button).userdata = nk_handle_ptr(0 as *mut Void);
        (*button).text_alignment = NK_TEXT_CENTERED as Int as Flags;
        (*button).border = 0.0f32;
        (*button).rounding = 0.0f32;
        (*button).draw_begin = None;
        (*button).draw_end = None;
        /* window */
        (*win).background = *table.offset(NK_COLOR_WINDOW as Int as isize);
        (*win).fixed_background =
            nk_style_item_color(*table.offset(NK_COLOR_WINDOW as Int as isize));
        (*win).border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*win).popup_border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*win).combo_border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*win).contextual_border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*win).menu_border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*win).group_border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*win).tooltip_border_color = *table.offset(NK_COLOR_BORDER as Int as isize);
        (*win).scaler = nk_style_item_color(*table.offset(NK_COLOR_TEXT as Int as isize));
        (*win).rounding = 0.0f32;
        (*win).spacing = Point::new(4i32 as f32, 4i32 as f32);
        (*win).scrollbar_size = Point::new(10i32 as f32, 10i32 as f32);
        (*win).min_size = Point::new(64i32 as f32, 64i32 as f32);
        (*win).combo_border = 1.0f32;
        (*win).contextual_border = 1.0f32;
        (*win).menu_border = 1.0f32;
        (*win).group_border = 1.0f32;
        (*win).tooltip_border = 1.0f32;
        (*win).popup_border = 1.0f32;
        (*win).border = 2.0f32;
        (*win).min_row_height_padding = 8i32 as f32;
        (*win).padding = Point::new(4i32 as f32, 4i32 as f32);
        (*win).group_padding = Point::new(4i32 as f32, 4i32 as f32);
        (*win).popup_padding = Point::new(4i32 as f32, 4i32 as f32);
        (*win).combo_padding = Point::new(4i32 as f32, 4i32 as f32);
        (*win).contextual_padding = Point::new(4i32 as f32, 4i32 as f32);
        (*win).menu_padding = Point::new(4i32 as f32, 4i32 as f32);
        (*win).tooltip_padding = Point::new(4i32 as f32, 4i32 as f32);
        return;
    };
}

pub unsafe fn nk_style_item_color(mut col: Color) -> StyleItem {
    let mut i: StyleItem = StyleItem {
        type_0: NK_STYLE_ITEM_COLOR,
        data: nk_style_item_data {
            image: Image {
                handle: Handle {
                    ptr: 0 as *mut Void,
                },
                w: 0,
                h: 0,
                region: [0; 4],
            },
        },
    };
    i.type_0 = NK_STYLE_ITEM_COLOR;
    i.data.color = col;
    return i;
}

pub unsafe fn nk_handle_ptr(mut ptr: *mut Void) -> Handle {
    let mut handle: Handle = Handle {
        ptr: 0 as *mut Void,
    };
    handle.ptr = ptr;
    return handle;
}

pub unsafe fn nk_rgba(mut r: Int, mut g: Int, mut b: Int, mut a: Int) -> Color {
    let mut ret: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    ret.r = (if if r < 255i32 { r } else { 255i32 } < 0i32 {
        0i32
    } else if r < 255i32 {
        r
    } else {
        255i32
    }) as u8;
    ret.g = (if if g < 255i32 { g } else { 255i32 } < 0i32 {
        0i32
    } else if g < 255i32 {
        g
    } else {
        255i32
    }) as u8;
    ret.b = (if if b < 255i32 { b } else { 255i32 } < 0i32 {
        0i32
    } else if b < 255i32 {
        b
    } else {
        255i32
    }) as u8;
    ret.a = (if if a < 255i32 { a } else { 255i32 } < 0i32 {
        0i32
    } else if a < 255i32 {
        a
    } else {
        255i32
    }) as u8;
    return ret;
}

pub unsafe fn nk_rgb(mut r: Int, mut g: Int, mut b: Int) -> Color {
    let mut ret: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    ret.r = (if if r < 255i32 { r } else { 255i32 } < 0i32 {
        0i32
    } else if r < 255i32 {
        r
    } else {
        255i32
    }) as u8;
    ret.g = (if if g < 255i32 { g } else { 255i32 } < 0i32 {
        0i32
    } else if g < 255i32 {
        g
    } else {
        255i32
    }) as u8;
    ret.b = (if if b < 255i32 { b } else { 255i32 } < 0i32 {
        0i32
    } else if b < 255i32 {
        b
    } else {
        255i32
    }) as u8;
    ret.a = 255i32 as u8;
    return ret;
}

pub unsafe fn nk_style_item_hide() -> StyleItem {
    let mut i: StyleItem = StyleItem {
        type_0: NK_STYLE_ITEM_COLOR,
        data: nk_style_item_data {
            image: Image {
                handle: Handle {
                    ptr: 0 as *mut Void,
                },
                w: 0,
                h: 0,
                region: [0; 4],
            },
        },
    };
    i.type_0 = NK_STYLE_ITEM_COLOR;
    i.data.color = nk_rgba(0i32, 0i32, 0i32, 0i32);
    return i;
}
static mut nk_default_color_style: [Color; 28] = unsafe {
    [
        Color {
            r: 175i32 as u8,
            g: 175i32 as u8,
            b: 175i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 45i32 as u8,
            g: 45i32 as u8,
            b: 45i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 40i32 as u8,
            g: 40i32 as u8,
            b: 40i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 65i32 as u8,
            g: 65i32 as u8,
            b: 65i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 50i32 as u8,
            g: 50i32 as u8,
            b: 50i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 40i32 as u8,
            g: 40i32 as u8,
            b: 40i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 35i32 as u8,
            g: 35i32 as u8,
            b: 35i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 100i32 as u8,
            g: 100i32 as u8,
            b: 100i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 120i32 as u8,
            g: 120i32 as u8,
            b: 120i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 45i32 as u8,
            g: 45i32 as u8,
            b: 45i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 45i32 as u8,
            g: 45i32 as u8,
            b: 45i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 35i32 as u8,
            g: 35i32 as u8,
            b: 35i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 38i32 as u8,
            g: 38i32 as u8,
            b: 38i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 100i32 as u8,
            g: 100i32 as u8,
            b: 100i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 120i32 as u8,
            g: 120i32 as u8,
            b: 120i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 150i32 as u8,
            g: 150i32 as u8,
            b: 150i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 38i32 as u8,
            g: 38i32 as u8,
            b: 38i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 38i32 as u8,
            g: 38i32 as u8,
            b: 38i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 175i32 as u8,
            g: 175i32 as u8,
            b: 175i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 45i32 as u8,
            g: 45i32 as u8,
            b: 45i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 120i32 as u8,
            g: 120i32 as u8,
            b: 120i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 45i32 as u8,
            g: 45i32 as u8,
            b: 45i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 255i32 as u8,
            g: 0i32 as u8,
            b: 0i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 40i32 as u8,
            g: 40i32 as u8,
            b: 40i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 100i32 as u8,
            g: 100i32 as u8,
            b: 100i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 120i32 as u8,
            g: 120i32 as u8,
            b: 120i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 150i32 as u8,
            g: 150i32 as u8,
            b: 150i32 as u8,
            a: 255i32 as u8,
        },
        Color {
            r: 40i32 as u8,
            g: 40i32 as u8,
            b: 40i32 as u8,
            a: 255i32 as u8,
        },
    ]
};
unsafe fn nk_mfree(mut unused: Handle, mut ptr: *mut Void) -> () {
    libc::free(ptr);
}
unsafe fn nk_malloc(mut unused: Handle, mut old: *mut Void, mut size: Size) -> *mut Void {
    return libc::malloc(size as _);
}

pub unsafe fn nk_init_fixed(
    mut ctx: *mut Context,
    mut memory: *mut Void,
    mut size: Size,
    mut font: *const UserFont,
) -> Int {
    if memory.is_null() {
        return 0i32;
    } else {
        nk_setup(ctx, font);
        nk_buffer_init_fixed(&mut (*ctx).memory, memory, size);
        (*ctx).use_pool = nk_false as Int;
        return 1i32;
    };
}

pub unsafe fn nk_buffer_init_fixed(mut b: *mut Buffer, mut m: *mut Void, mut size: Size) -> () {
    if b.is_null() || m.is_null() || 0 == size {
        return;
    } else {
        nk_zero(b as *mut Void, mem::size_of::<Buffer>() as Ulong);
        (*b).type_0 = NK_BUFFER_FIXED;
        (*b).memory.ptr = m;
        (*b).memory.size = size;
        (*b).size = size;
        return;
    };
}

pub unsafe fn nk_init_custom(
    mut ctx: *mut Context,
    mut cmds: *mut Buffer,
    mut pool: *mut Buffer,
    mut font: *const UserFont,
) -> Int {
    let mut alloc: *mut Allocator = 0 as *mut Allocator;
    if cmds.is_null() || pool.is_null() {
        return 0i32;
    } else {
        nk_setup(ctx, font);
        (*ctx).memory = *cmds;
        if (*pool).type_0 as Uint == NK_BUFFER_FIXED as Int as Uint {
            /* take memory from buffer and alloc fixed pool */
            nk_pool_init_fixed(&mut (*ctx).pool, (*pool).memory.ptr, (*pool).memory.size);
        } else {
            /* create dynamic pool from buffer allocator */
            alloc = &mut (*pool).pool as *mut Allocator;
            nk_pool_init(&mut (*ctx).pool, alloc, 16i32 as Uint);
        }
        (*ctx).use_pool = nk_true as Int;
        return 1i32;
    };
}
unsafe fn nk_pool_init_fixed(mut pool: *mut Pool, mut memory: *mut Void, mut size: Size) -> () {
    nk_zero(pool as *mut Void, mem::size_of::<Pool>() as Ulong);
    if size < mem::size_of::<Page>() as Ulong {
        return;
    } else {
        (*pool).capacity = (size.wrapping_sub(mem::size_of::<Page>() as Ulong) as Uint as Ulong)
            .wrapping_div(mem::size_of::<PageElement>() as Ulong)
            as Uint;
        (*pool).pages = memory as *mut Page;
        (*pool).type_0 = NK_BUFFER_FIXED;
        (*pool).size = size;
        return;
    };
}

pub unsafe fn nk_clear(mut ctx: *mut Context) -> () {
    let mut iter: *mut Window = 0 as *mut Window;
    let mut next: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return;
    } else {
        if 0 != (*ctx).use_pool {
            nk_buffer_clear(&mut (*ctx).memory);
        } else {
            nk_buffer_reset(&mut (*ctx).memory, NK_BUFFER_FRONT);
        }
        (*ctx).build = 0i32;
        (*ctx).memory.calls = 0i32 as Size;
        (*ctx).last_widget_state = 0i32 as Flags;
        (*ctx).style.cursor_active = (*ctx).style.cursors[NK_CURSOR_ARROW as Int as usize];
        nk_memset(
            &mut (*ctx).overlay as *mut CommandBuffer as *mut Void,
            0i32,
            mem::size_of::<CommandBuffer>() as Ulong,
        );
        /* garbage collector */
        iter = (*ctx).begin;
        while !iter.is_null() {
            /* make sure valid minimized windows do not get removed */
            if 0 != (*iter).flags & NK_WINDOW_MINIMIZED as Int as Uint
                && 0 == (*iter).flags & NK_WINDOW_CLOSED as Int as Uint
                && (*iter).seq == (*ctx).seq
            {
                iter = (*iter).next
            } else {
                /* remove hotness from hidden or closed windows*/
                if (0 != (*iter).flags & NK_WINDOW_HIDDEN as Int as Uint
                    || 0 != (*iter).flags & NK_WINDOW_CLOSED as Int as Uint)
                    && iter == (*ctx).active
                {
                    (*ctx).active = (*iter).prev;
                    (*ctx).end = (*iter).prev;
                    if (*ctx).end.is_null() {
                        (*ctx).begin = 0 as *mut Window
                    }
                    if !(*ctx).active.is_null() {
                        (*(*ctx).active).flags &= !(NK_WINDOW_ROM as Int as Uint)
                    }
                }
                /* free unused popup windows */
                if !(*iter).popup.win.is_null() && (*(*iter).popup.win).seq != (*ctx).seq {
                    nk_free_window(ctx, (*iter).popup.win);
                    (*iter).popup.win = 0 as *mut Window
                }
                /* remove unused window state tables */
                let mut n: *mut Table = 0 as *mut Table;
                let mut it: *mut Table = (*iter).tables;
                while !it.is_null() {
                    n = (*it).next;
                    if (*it).seq != (*ctx).seq {
                        nk_remove_table(iter, it);
                        nk_zero(it as *mut Void, mem::size_of::<nk_page_data>() as Ulong);
                        nk_free_table(ctx, it);
                        if it == (*iter).tables {
                            (*iter).tables = n
                        }
                    }
                    it = n
                }
                /* window itself is not used anymore so free */
                if (*iter).seq != (*ctx).seq || 0 != (*iter).flags & NK_WINDOW_CLOSED as Int as Uint
                {
                    next = (*iter).next;
                    nk_remove_window(ctx, iter);
                    nk_free_window(ctx, iter);
                    iter = next
                } else {
                    iter = (*iter).next
                }
            }
        }
        (*ctx).seq = (*ctx).seq.wrapping_add(1);
        return;
    };
}
unsafe fn nk_free_window(mut ctx: *mut Context, mut win: *mut Window) -> () {
    /* unlink windows from list */
    let mut it: *mut Table = (*win).tables;
    if !(*win).popup.win.is_null() {
        nk_free_window(ctx, (*win).popup.win);
        (*win).popup.win = 0 as *mut Window
    }
    (*win).next = 0 as *mut Window;
    (*win).prev = 0 as *mut Window;
    while !it.is_null() {
        /*free window state tables */
        let mut n: *mut Table = (*it).next;
        nk_remove_table(win, it);
        nk_free_table(ctx, it);
        if it == (*win).tables {
            (*win).tables = n
        }
        it = n
    }
    /* link windows into freelist */
    let mut pd: *mut nk_page_data = ((if 0 != 1i32 {
        win
    } else {
        &mut (*(0 as *mut nk_page_data)).win as *mut Window
    }) as *mut Char)
        .offset(-(&mut (*(0 as *mut nk_page_data)).win as *mut Window as Ptr as isize))
        as *mut Void as *mut nk_page_data;
    let mut pe: *mut PageElement = ((if 0 != 1i32 {
        pd
    } else {
        &mut (*(0 as *mut PageElement)).data as *mut nk_page_data
    }) as *mut Char)
        .offset(-(&mut (*(0 as *mut PageElement)).data as *mut nk_page_data as Ptr as isize))
        as *mut Void as *mut PageElement;
    nk_free_page_element(ctx, pe);
}
unsafe fn nk_free_page_element(mut ctx: *mut Context, mut elem: *mut PageElement) -> () {
    /* we have a pool so just add to free list */
    if 0 != (*ctx).use_pool {
        nk_link_page_element_into_freelist(ctx, elem);
        return;
    } else {
        /* if possible remove last element from back of fixed memory buffer */
        let mut elem_end: *mut Void = elem.offset(1isize) as *mut Void;
        let mut buffer_end: *mut Void =
            ((*ctx).memory.memory.ptr as *mut u8).offset((*ctx).memory.size as isize) as *mut Void;
        if elem_end == buffer_end {
            (*ctx).memory.size = ((*ctx).memory.size as Ulong)
                .wrapping_sub(mem::size_of::<PageElement>() as Ulong)
                as Size as Size
        } else {
            nk_link_page_element_into_freelist(ctx, elem);
        }
        return;
    };
}
unsafe fn nk_link_page_element_into_freelist(
    mut ctx: *mut Context,
    mut elem: *mut PageElement,
) -> () {
    /* link table into freelist */
    if (*ctx).freelist.is_null() {
        (*ctx).freelist = elem
    } else {
        (*elem).next = (*ctx).freelist;
        (*ctx).freelist = elem
    };
}
unsafe fn nk_free_table(mut ctx: *mut Context, mut tbl: *mut Table) -> () {
    let mut pd: *mut nk_page_data = ((if 0 != 1i32 {
        tbl
    } else {
        &mut (*(0 as *mut nk_page_data)).tbl as *mut Table
    }) as *mut Char)
        .offset(-(&mut (*(0 as *mut nk_page_data)).tbl as *mut Table as Ptr as isize))
        as *mut Void as *mut nk_page_data;
    let mut pe: *mut PageElement = ((if 0 != 1i32 {
        pd
    } else {
        &mut (*(0 as *mut PageElement)).data as *mut nk_page_data
    }) as *mut Char)
        .offset(-(&mut (*(0 as *mut PageElement)).data as *mut nk_page_data as Ptr as isize))
        as *mut Void as *mut PageElement;
    nk_free_page_element(ctx, pe);
}
unsafe fn nk_remove_table(mut win: *mut Window, mut tbl: *mut Table) -> () {
    if (*win).tables == tbl {
        (*win).tables = (*tbl).next
    }
    if !(*tbl).next.is_null() {
        (*(*tbl).next).prev = (*tbl).prev
    }
    if !(*tbl).prev.is_null() {
        (*(*tbl).prev).next = (*tbl).next
    }
    (*tbl).next = 0 as *mut Table;
    (*tbl).prev = 0 as *mut Table;
}
unsafe fn nk_remove_window(mut ctx: *mut Context, mut win: *mut Window) -> () {
    if win == (*ctx).begin || win == (*ctx).end {
        if win == (*ctx).begin {
            (*ctx).begin = (*win).next;
            if !(*win).next.is_null() {
                (*(*win).next).prev = 0 as *mut Window
            }
        }
        if win == (*ctx).end {
            (*ctx).end = (*win).prev;
            if !(*win).prev.is_null() {
                (*(*win).prev).next = 0 as *mut Window
            }
        }
    } else {
        if !(*win).next.is_null() {
            (*(*win).next).prev = (*win).prev
        }
        if !(*win).prev.is_null() {
            (*(*win).prev).next = (*win).next
        }
    }
    if win == (*ctx).active || (*ctx).active.is_null() {
        (*ctx).active = (*ctx).end;
        if !(*ctx).end.is_null() {
            (*(*ctx).end).flags &= !(NK_WINDOW_ROM as Int as Flags)
        }
    }
    (*win).next = 0 as *mut Window;
    (*win).prev = 0 as *mut Window;
    (*ctx).count = (*ctx).count.wrapping_sub(1);
}

pub unsafe fn nk_buffer_reset(mut buffer: *mut Buffer, mut type_0: BufferAllocationType) -> () {
    if buffer.is_null() {
        return;
    } else {
        if type_0 as Uint == NK_BUFFER_BACK as Int as Uint {
            /* reset back buffer either back to marker or empty */
            (*buffer).needed = ((*buffer).needed as Ulong).wrapping_sub(
                (*buffer)
                    .memory
                    .size
                    .wrapping_sub((*buffer).marker[type_0 as usize].offset),
            ) as Size as Size;
            if 0 != (*buffer).marker[type_0 as usize].active {
                (*buffer).size = (*buffer).marker[type_0 as usize].offset
            } else {
                (*buffer).size = (*buffer).memory.size
            }
            (*buffer).marker[type_0 as usize].active = nk_false as Int
        } else {
            /* reset front buffer either back to back marker or empty */
            (*buffer).needed = ((*buffer).needed as Ulong).wrapping_sub(
                (*buffer)
                    .allocated
                    .wrapping_sub((*buffer).marker[type_0 as usize].offset),
            ) as Size as Size;
            if 0 != (*buffer).marker[type_0 as usize].active {
                (*buffer).allocated = (*buffer).marker[type_0 as usize].offset
            } else {
                (*buffer).allocated = 0i32 as Size
            }
            (*buffer).marker[type_0 as usize].active = nk_false as Int
        }
        return;
    };
}

pub unsafe fn nk_buffer_clear(mut b: *mut Buffer) -> () {
    if b.is_null() {
        return;
    } else {
        (*b).allocated = 0i32 as Size;
        (*b).size = (*b).memory.size;
        (*b).calls = 0i32 as Size;
        (*b).needed = 0i32 as Size;
        return;
    };
}

pub unsafe fn nk_free(mut ctx: *mut Context) -> () {
    if ctx.is_null() {
        return;
    } else {
        nk_buffer_free(&mut (*ctx).memory);
        if 0 != (*ctx).use_pool {
            nk_pool_free(&mut (*ctx).pool);
        }
        nk_zero(
            &mut (*ctx).input as *mut Input as *mut Void,
            mem::size_of::<Input>() as Ulong,
        );
        nk_zero(
            &mut (*ctx).style as *mut Style as *mut Void,
            mem::size_of::<Style>() as Ulong,
        );
        nk_zero(
            &mut (*ctx).memory as *mut Buffer as *mut Void,
            mem::size_of::<Buffer>() as Ulong,
        );
        (*ctx).seq = 0i32 as Uint;
        (*ctx).build = 0i32;
        (*ctx).begin = 0 as *mut Window;
        (*ctx).end = 0 as *mut Window;
        (*ctx).active = 0 as *mut Window;
        (*ctx).current = 0 as *mut Window;
        (*ctx).freelist = 0 as *mut PageElement;
        (*ctx).count = 0i32 as Uint;
        return;
    };
}
unsafe fn nk_pool_free(mut pool: *mut Pool) -> () {
    let mut iter: *mut Page = (*pool).pages;
    if pool.is_null() {
        return;
    } else if (*pool).type_0 as Uint == NK_BUFFER_FIXED as Int as Uint {
        return;
    } else {
        while !iter.is_null() {
            let mut next: *mut Page = (*iter).next;
            (*pool).alloc.free.expect("non-null function pointer")(
                (*pool).alloc.userdata,
                iter as *mut Void,
            );
            iter = next
        }
        return;
    };
}

pub unsafe fn nk_buffer_free(mut b: *mut Buffer) -> () {
    if b.is_null() || (*b).memory.ptr.is_null() {
        return;
    } else if (*b).type_0 as Uint == NK_BUFFER_FIXED as Int as Uint {
        return;
    } else if (*b).pool.free.is_none() {
        return;
    } else {
        (*b).pool.free.expect("non-null function pointer")((*b).pool.userdata, (*b).memory.ptr);
        return;
    };
}

pub unsafe fn nk_set_user_data(mut ctx: *mut Context, mut handle: Handle) -> () {
    if ctx.is_null() {
        return;
    } else {
        (*ctx).userdata = handle;
        if !(*ctx).current.is_null() {
            (*(*ctx).current).buffer.userdata = handle
        }
        return;
    };
}

pub unsafe fn nk_input_begin(mut ctx: *mut Context) -> () {
    let mut i: Int = 0;
    let mut in_0: *mut Input = 0 as *mut Input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut Input;
        i = 0i32;
        while i < NK_BUTTON_MAX as Int {
            (*in_0).mouse.buttons[i as usize].clicked = 0i32 as Uint;
            i += 1
        }
        (*in_0).keyboard.text_len = 0i32;
        (*in_0).mouse.scroll_delta = Point::new(0i32 as f32, 0i32 as f32);
        (*in_0).mouse.prev.x = (*in_0).mouse.pos.x;
        (*in_0).mouse.prev.y = (*in_0).mouse.pos.y;
        (*in_0).mouse.delta.x = 0i32 as f32;
        (*in_0).mouse.delta.y = 0i32 as f32;
        i = 0i32;
        while i < NK_KEY_MAX as Int {
            (*in_0).keyboard.keys[i as usize].clicked = 0i32 as Uint;
            i += 1
        }
        return;
    };
}

pub unsafe fn nk_input_motion(mut ctx: *mut Context, mut x: Int, mut y: Int) -> () {
    let mut in_0: *mut Input = 0 as *mut Input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut Input;
        (*in_0).mouse.pos.x = x as f32;
        (*in_0).mouse.pos.y = y as f32;
        (*in_0).mouse.delta.x = (*in_0).mouse.pos.x - (*in_0).mouse.prev.x;
        (*in_0).mouse.delta.y = (*in_0).mouse.pos.y - (*in_0).mouse.prev.y;
        return;
    };
}

pub unsafe fn nk_input_key(mut ctx: *mut Context, mut key: Keys, mut down: Int) -> () {
    let mut in_0: *mut Input = 0 as *mut Input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut Input;
        if (*in_0).keyboard.keys[key as usize].down != down {
            (*in_0).keyboard.keys[key as usize].clicked =
                (*in_0).keyboard.keys[key as usize].clicked.wrapping_add(1)
        }
        (*in_0).keyboard.keys[key as usize].down = down;
        return;
    };
}

pub unsafe fn nk_input_button(
    mut ctx: *mut Context,
    mut id: Buttons,
    mut x: Int,
    mut y: Int,
    mut down: Int,
) -> () {
    let mut btn: *mut MouseButton = 0 as *mut MouseButton;
    let mut in_0: *mut Input = 0 as *mut Input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut Input;
        if (*in_0).mouse.buttons[id as usize].down == down {
            return;
        } else {
            btn = &mut (*in_0).mouse.buttons[id as usize] as *mut MouseButton;
            (*btn).clicked_pos.x = x as f32;
            (*btn).clicked_pos.y = y as f32;
            (*btn).down = down;
            (*btn).clicked = (*btn).clicked.wrapping_add(1);
            return;
        }
    };
}

pub unsafe fn nk_input_scroll(mut ctx: *mut Context, mut val: Point) -> () {
    if ctx.is_null() {
        return;
    } else {
        (*ctx).input.mouse.scroll_delta.x += val.x;
        (*ctx).input.mouse.scroll_delta.y += val.y;
        return;
    };
}

pub unsafe fn nk_input_char(mut ctx: *mut Context, mut c: Char) -> () {
    let mut glyph: Glyph = [0; 4];
    if ctx.is_null() {
        return;
    } else {
        glyph[0usize] = c;
        nk_input_glyph(ctx, glyph.as_mut_ptr() as *const Char);
        return;
    };
}

pub unsafe fn nk_input_glyph(mut ctx: *mut Context, mut glyph: *const Char) -> () {
    let mut len: Int = 0i32;
    let mut unicode: Rune = 0;
    let mut in_0: *mut Input = 0 as *mut Input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut Input;
        len = nk_utf_decode(glyph, &mut unicode, 4i32);
        if 0 != len && (*in_0).keyboard.text_len + len < 16i32 {
            nk_utf_encode(
                unicode,
                &mut (*in_0).keyboard.text[(*in_0).keyboard.text_len as usize],
                16i32 - (*in_0).keyboard.text_len,
            );
            (*in_0).keyboard.text_len += len
        }
        return;
    };
}

pub unsafe fn nk_utf_encode(mut u: Rune, mut c: *mut Char, mut clen: Int) -> Int {
    let mut len: Int = 0;
    let mut i: Int = 0;
    len = nk_utf_validate(&mut u, 0i32);
    if clen < len || 0 == len || len > 4i32 {
        return 0i32;
    } else {
        i = len - 1i32;
        while i != 0i32 {
            *c.offset(i as isize) = nk_utf_encode_byte(u, 0i32);
            u >>= 6i32;
            i -= 1
        }
        *c.offset(0isize) = nk_utf_encode_byte(u, len);
        return len;
    };
}
unsafe fn nk_utf_encode_byte(mut u: Rune, mut i: Int) -> Char {
    return (nk_utfbyte[i as usize] as Int | u as u8 as Int & !(nk_utfmask[i as usize] as Int))
        as Char;
}
static mut nk_utfmask: [u8; 5] = unsafe {
    [
        192i32 as u8,
        128i32 as u8,
        224i32 as u8,
        240i32 as u8,
        248i32 as u8,
    ]
};
static mut nk_utfbyte: [u8; 5] = unsafe {
    [
        128i32 as u8,
        0i32 as u8,
        192i32 as u8,
        224i32 as u8,
        240i32 as u8,
    ]
};
unsafe fn nk_utf_validate(mut u: *mut Rune, mut i: Int) -> Int {
    if u.is_null() {
        return 0i32;
    } else {
        if !(nk_utfmin[i as usize] <= *u && *u < nk_utfmax[i as usize])
            || 55296i32 as Uint <= *u && *u < 57343i32 as Uint
        {
            *u = 65533i32 as Rune
        }
        i = 1i32;
        while *u > nk_utfmax[i as usize] {
            i += 1
        }
        return i;
    };
}
static mut nk_utfmax: [u32; 5] = unsafe {
    [
        1114111i32 as u32,
        127i32 as u32,
        2047i32 as u32,
        65535i32 as u32,
        1114111i32 as u32,
    ]
};
static mut nk_utfmin: [u32; 5] = unsafe {
    [
        0i32 as u32,
        0i32 as u32,
        128i32 as u32,
        2048i32 as u32,
        65536i32 as u32,
    ]
};

pub unsafe fn nk_utf_decode(mut c: *const Char, mut u: *mut Rune, mut clen: Int) -> Int {
    let mut i: Int = 0;
    let mut j: Int = 0;
    let mut len: Int = 0;
    let mut type_0: Int = 0i32;
    let mut udecoded: Rune = 0;
    if c.is_null() || u.is_null() {
        return 0i32;
    } else if 0 == clen {
        return 0i32;
    } else {
        *u = 65533i32 as Rune;
        udecoded = nk_utf_decode_byte(*c.offset(0isize), &mut len);
        if !(1i32 <= len && len < 4i32) {
            return 1i32;
        } else {
            i = 1i32;
            j = 1i32;
            while i < clen && j < len {
                udecoded =
                    udecoded << 6i32 | nk_utf_decode_byte(*c.offset(i as isize), &mut type_0);
                if type_0 != 0i32 {
                    return j;
                } else {
                    i += 1;
                    j += 1
                }
            }
            if j < len {
                return 0i32;
            } else {
                *u = udecoded;
                nk_utf_validate(u, len);
                return len;
            }
        }
    };
}
unsafe fn nk_utf_decode_byte(mut c: Char, mut i: *mut Int) -> Rune {
    if i.is_null() {
        return 0i32 as Rune;
    } else {
        *i = 0i32;
        while *i < (mem::size_of::<[u8; 5]>() as Ulong).wrapping_div(mem::size_of::<u8>() as Ulong)
            as Int
        {
            if c as u8 as Int & nk_utfmask[*i as usize] as Int == nk_utfbyte[*i as usize] as Int {
                return (c as Int & !(nk_utfmask[*i as usize] as Int)) as u8 as Rune;
            } else {
                *i += 1
            }
        }
        return 0i32 as Rune;
    };
}

pub unsafe fn nk_input_unicode(mut ctx: *mut Context, mut unicode: Rune) -> () {
    let mut rune: Glyph = [0; 4];
    if ctx.is_null() {
        return;
    } else {
        nk_utf_encode(unicode, rune.as_mut_ptr(), 4i32);
        nk_input_glyph(ctx, rune.as_mut_ptr() as *const Char);
        return;
    };
}

pub unsafe fn nk_input_end(mut ctx: *mut Context) -> () {
    let mut in_0: *mut Input = 0 as *mut Input;
    if ctx.is_null() {
        return;
    } else {
        in_0 = &mut (*ctx).input as *mut Input;
        if 0 != (*in_0).mouse.grab {
            (*in_0).mouse.grab = 0i32 as Uchar
        }
        if 0 != (*in_0).mouse.ungrab {
            (*in_0).mouse.grabbed = 0i32 as Uchar;
            (*in_0).mouse.ungrab = 0i32 as Uchar;
            (*in_0).mouse.grab = 0i32 as Uchar
        }
        return;
    };
}

pub unsafe fn nk__begin(mut ctx: *mut Context) -> *const Command {
    let mut iter: *mut Window = 0 as *mut Window;
    let mut buffer: *mut u8 = 0 as *mut u8;
    if ctx.is_null() {
        return 0 as *const Command;
    } else if 0 == (*ctx).count {
        return 0 as *const Command;
    } else {
        buffer = (*ctx).memory.memory.ptr as *mut u8;
        if 0 == (*ctx).build {
            nk_build(ctx);
            (*ctx).build = nk_true as Int
        }
        iter = (*ctx).begin;
        while !iter.is_null()
            && ((*iter).buffer.begin == (*iter).buffer.end
                || 0 != (*iter).flags & NK_WINDOW_HIDDEN as Int as Uint
                || (*iter).seq != (*ctx).seq)
        {
            iter = (*iter).next
        }
        if iter.is_null() {
            return 0 as *const Command;
        } else {
            return (buffer as *const u8).offset((*iter).buffer.begin as isize) as *const Void
                as *const Command;
        }
    };
}
unsafe fn nk_build(mut ctx: *mut Context) -> () {
    let mut mouse_bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut cursor: *const Cursor = 0 as *const Cursor;
    let mut it: *mut Window = 0 as *mut Window;
    let mut cmd: *mut Command = 0 as *mut Command;
    let mut buffer: *mut u8 = 0 as *mut u8;
    /* draw cursor overlay */
    if (*ctx).style.cursor_active.is_null() {
        (*ctx).style.cursor_active = (*ctx).style.cursors[NK_CURSOR_ARROW as Int as usize]
    }
    if !(*ctx).style.cursor_active.is_null()
        && 0 == (*ctx).input.mouse.grabbed
        && 0 != (*ctx).style.cursor_visible
    {
        mouse_bounds = Rect {
            x: 0.,
            y: 0.,
            w: 0.,
            h: 0.,
        };
        cursor = (*ctx).style.cursor_active;
        nk_command_buffer_init(&mut (*ctx).overlay, &mut (*ctx).memory, NK_CLIPPING_OFF);
        nk_start_buffer(ctx, &mut (*ctx).overlay);
        mouse_bounds.x = (*ctx).input.mouse.pos.x - (*cursor).offset.x;
        mouse_bounds.y = (*ctx).input.mouse.pos.y - (*cursor).offset.y;
        mouse_bounds.w = (*cursor).size.x;
        mouse_bounds.h = (*cursor).size.y;
        nk_draw_image(&mut (*ctx).overlay, mouse_bounds, &(*cursor).img, nk_white);
        nk_finish_buffer(ctx, &mut (*ctx).overlay);
    }
    /* build one big draw command list out of all window buffers */
    it = (*ctx).begin;
    buffer = (*ctx).memory.memory.ptr as *mut u8;
    while !it.is_null() {
        let mut next: *mut Window = (*it).next;
        if !((*it).buffer.last == (*it).buffer.begin
            || 0 != (*it).flags & NK_WINDOW_HIDDEN as Int as Uint
            || (*it).seq != (*ctx).seq)
        {
            cmd = buffer.offset((*it).buffer.last as isize) as *mut Void as *mut Command;
            while !next.is_null()
                && ((*next).buffer.last == (*next).buffer.begin
                    || 0 != (*next).flags & NK_WINDOW_HIDDEN as Int as Uint
                    || (*next).seq != (*ctx).seq)
            {
                /* skip empty command buffers */
                next = (*next).next
            }
            if !next.is_null() {
                (*cmd).next = (*next).buffer.begin
            }
        }
        it = next
    }
    /* append all popup draw commands into lists */
    it = (*ctx).begin;
    while !it.is_null() {
        let mut next_0: *mut Window = (*it).next;
        let mut buf: *mut PopupBuffer = 0 as *mut PopupBuffer;
        if !(0 == (*it).popup.buf.active) {
            buf = &mut (*it).popup.buf as *mut PopupBuffer;
            (*cmd).next = (*buf).begin;
            cmd = buffer.offset((*buf).last as isize) as *mut Void as *mut Command;
            (*buf).active = nk_false as Int
        }
        it = next_0
    }
    if !cmd.is_null() {
        /* append overlay commands */
        if (*ctx).overlay.end != (*ctx).overlay.begin {
            (*cmd).next = (*ctx).overlay.begin
        } else {
            (*cmd).next = (*ctx).memory.allocated
        }
    };
}
unsafe fn nk_finish_buffer(mut ctx: *mut Context, mut buffer: *mut CommandBuffer) -> () {
    if ctx.is_null() || buffer.is_null() {
        return;
    } else {
        (*buffer).end = (*ctx).memory.allocated;
        return;
    };
}
static mut nk_white: Color = unsafe {
    Color {
        r: 255i32 as u8,
        g: 255i32 as u8,
        b: 255i32 as u8,
        a: 255i32 as u8,
    }
};

pub unsafe fn nk_draw_image(
    mut b: *mut CommandBuffer,
    mut r: Rect,
    mut img: *const Image,
    mut col: Color,
) -> () {
    let mut cmd: *mut CommandImage = 0 as *mut CommandImage;
    if b.is_null() {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut c: *const Rect = &mut (*b).clip as *mut Rect;
            if (*c).w == 0i32 as f32 || (*c).h == 0i32 as f32
                || ((*c).x > r.x + r.w
                    || (*c).x + (*c).w < r.x
                    || (*c).y > r.y + r.h
                    || (*c).y + (*c).h < r.y)
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(b, NK_COMMAND_IMAGE, mem::size_of::<CommandImage>() as Ulong)
            as *mut CommandImage;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).x = r.x as Short;
            (*cmd).y = r.y as Short;
            (*cmd).w = (if (0i32 as f32) < r.w {
                r.w
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).h = (if (0i32 as f32) < r.h {
                r.h
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).img = *img;
            (*cmd).col = col;
            return;
        }
    };
}
unsafe fn nk_command_buffer_push(
    mut b: *mut CommandBuffer,
    mut t: CommandType,
    mut size: Size,
) -> *mut Void {
    const align: Size = mem::align_of::<Command>() as Size;
    let mut cmd: *mut Command = 0 as *mut Command;
    let mut alignment: Size = 0;
    let mut unaligned: *mut Void = 0 as *mut Void;
    let mut memory: *mut Void = 0 as *mut Void;
    if b.is_null() {
        return 0 as *mut Void;
    } else {
        cmd = nk_buffer_alloc((*b).base, NK_BUFFER_FRONT, size, align) as *mut Command;
        if cmd.is_null() {
            return 0 as *mut Void;
        } else {
            /* make sure the offset to the next command is aligned */
            (*b).last = ((*(*b).base).memory.ptr as *mut u8)
                .ptr_offset_to(cmd as *mut u8)
                .expect("bad offset_to") as Long as Size;
            unaligned = (cmd as *mut u8).offset(size as isize) as *mut Void;
            memory = ((unaligned as *mut u8).offset(align.wrapping_sub(1i32 as Ulong) as isize)
                as Long as Size & !align.wrapping_sub(1i32 as Ulong)) as Long
                as *mut Void;
            alignment = (unaligned as *mut u8)
                .ptr_offset_to(memory as *mut u8)
                .expect("bad offset_to") as Long as Size;
            nk_memset(cmd as *mut Void, 0i32, size.wrapping_add(alignment));
            (*cmd).type_0 = t;
            (*cmd).next = (*(*b).base).allocated.wrapping_add(alignment);
            (*cmd).userdata = (*b).userdata;
            (*b).end = (*cmd).next;
            return cmd as *mut Void;
        }
    };
}

unsafe fn nk_buffer_alloc(
    mut b: *mut Buffer,
    mut type_0: BufferAllocationType,
    mut size: Size,
    mut align: Size,
) -> *mut Void {
    let mut full: Int = 0;
    let mut alignment: Size = 0;
    let mut unaligned: *mut Void = 0 as *mut Void;
    let mut memory: *mut Void = 0 as *mut Void;
    if b.is_null() || 0 == size {
        return 0 as *mut Void;
    } else {
        (*b).needed = ((*b).needed as Ulong).wrapping_add(size) as Size as Size;
        /* calculate total size with needed alignment + size */
        if type_0 as Uint == NK_BUFFER_FRONT as Int as Uint {
            unaligned = ((*b).memory.ptr as *mut u8).offset((*b).allocated as isize) as *mut Void
        } else {
            unaligned = ((*b).memory.ptr as *mut u8).offset((*b).size.wrapping_sub(size) as isize)
                as *mut Void
        }
        memory = nk_buffer_align(unaligned, align, &mut alignment, type_0);
        /* check if buffer has enough memory*/
        if type_0 as Uint == NK_BUFFER_FRONT as Int as Uint {
            full = ((*b).allocated.wrapping_add(size).wrapping_add(alignment) > (*b).size) as Int
        } else {
            full = ((*b)
                .size
                .wrapping_sub(if (*b).size < size.wrapping_add(alignment) {
                    (*b).size
                } else {
                    size.wrapping_add(alignment)
                }) <= (*b).allocated) as Int
        }
        if 0 != full {
            let mut capacity: Size = 0;
            if (*b).type_0 as Uint != NK_BUFFER_DYNAMIC as Int as Uint {
                return 0 as *mut Void;
            } else if (*b).type_0 as Uint != NK_BUFFER_DYNAMIC as Int as Uint
                || (*b).pool.alloc.is_none()
                || (*b).pool.free.is_none()
            {
                return 0 as *mut Void;
            } else {
                /* buffer is full so allocate bigger buffer if dynamic */
                capacity = ((*b).memory.size as f32 * (*b).grow_factor) as Size;
                capacity = if capacity
                    < nk_round_up_pow2((*b).allocated.wrapping_add(size) as u32) as Ulong
                {
                    nk_round_up_pow2((*b).allocated.wrapping_add(size) as u32) as Ulong
                } else {
                    capacity
                };
                (*b).memory.ptr = nk_buffer_realloc(b, capacity, &mut (*b).memory.size);
                if (*b).memory.ptr.is_null() {
                    return 0 as *mut Void;
                } else {
                    /* align newly allocated pointer */
                    if type_0 as Uint == NK_BUFFER_FRONT as Int as Uint {
                        unaligned = ((*b).memory.ptr as *mut u8).offset((*b).allocated as isize)
                            as *mut Void
                    } else {
                        unaligned = ((*b).memory.ptr as *mut u8)
                            .offset((*b).size.wrapping_sub(size) as isize)
                            as *mut Void
                    }
                    memory = nk_buffer_align(unaligned, align, &mut alignment, type_0)
                }
            }
        }
        if type_0 as Uint == NK_BUFFER_FRONT as Int as Uint {
            (*b).allocated =
                ((*b).allocated as Ulong).wrapping_add(size.wrapping_add(alignment)) as Size as Size
        } else {
            (*b).size =
                ((*b).size as Ulong).wrapping_sub(size.wrapping_add(alignment)) as Size as Size
        }
        (*b).needed = ((*b).needed as Ulong).wrapping_add(alignment) as Size as Size;
        (*b).calls = (*b).calls.wrapping_add(1);
        return memory;
    };
}

unsafe fn nk_buffer_align(
    mut unaligned: *mut Void,
    mut align: Size,
    mut alignment: *mut Size,
    mut type_0: BufferAllocationType,
) -> *mut Void {
    let mut memory: *mut Void = 0 as *mut Void;
    match type_0 as Uint {
        1 => {
            if 0 != align {
                memory = (unaligned as *mut u8 as Long as Size & !align.wrapping_sub(1i32 as Ulong))
                    as Long as *mut Void;
                *alignment = (memory as *mut u8)
                    .ptr_offset_to(unaligned as *mut u8)
                    .expect("bad offset_to") as Long as Size
            } else {
                memory = unaligned;
                *alignment = 0i32 as Size
            }
        }
        2 | 0 | _ => {
            if 0 != align {
                memory = ((unaligned as *mut u8).offset(align.wrapping_sub(1i32 as Ulong) as isize)
                    as Long as Size & !align.wrapping_sub(1i32 as Ulong))
                    as Long as *mut Void;
                *alignment = (unaligned as *mut u8)
                    .ptr_offset_to(memory as *mut u8)
                    .expect("bad offset_to") as Long as Size
            } else {
                memory = unaligned;
                *alignment = 0i32 as Size
            }
        }
    }
    return memory;
}

unsafe fn nk_buffer_realloc(
    mut b: *mut Buffer,
    mut capacity: Size,
    mut size: *mut Size,
) -> *mut Void {
    let mut temp: *mut Void = 0 as *mut Void;
    let mut buffer_size: Size = 0;
    if b.is_null() || size.is_null() || (*b).pool.alloc.is_none() || (*b).pool.free.is_none() {
        return 0 as *mut Void;
    } else {
        buffer_size = (*b).memory.size;
        temp = (*b).pool.alloc.expect("non-null function pointer")(
            (*b).pool.userdata,
            (*b).memory.ptr,
            capacity,
        );
        if temp.is_null() {
            return 0 as *mut Void;
        } else {
            *size = capacity;
            if temp != (*b).memory.ptr {
                nk_memcopy(temp, (*b).memory.ptr, buffer_size);
                (*b).pool.free.expect("non-null function pointer")(
                    (*b).pool.userdata,
                    (*b).memory.ptr,
                );
            }
            if (*b).size == buffer_size {
                /* no back buffer so just set correct size */
                (*b).size = capacity;
                return temp;
            } else {
                let mut dst: *mut Void = 0 as *mut Void;
                /* copy back buffer to the end of the new buffer */
                let mut src: *mut Void = 0 as *mut Void;
                let mut back_size: Size = 0;
                back_size = buffer_size.wrapping_sub((*b).size);
                dst = (temp as *mut u8).offset(capacity.wrapping_sub(back_size) as isize)
                    as *mut Void;
                src = (temp as *mut u8).offset((*b).size as isize) as *mut Void;
                nk_memcopy(dst, src, back_size);
                (*b).size = capacity.wrapping_sub(back_size);
                return temp;
            }
        }
    };
}

unsafe fn nk_memcopy(mut dst0: *mut Void, mut src0: *const Void, mut length: Size) -> *mut Void {
    let mut t: Ptr = 0;
    let mut dst: *mut Char = dst0 as *mut Char;
    let mut src: *const Char = src0 as *const Char;
    if !(length == 0i32 as Ulong || dst == src as *mut Char) {
        if dst < src as *mut Char {
            /* only need low bits */
            t = src as Ptr;
            if 0 != (t | dst as Ptr) & (mem::size_of::<Int>() as Ulong).wrapping_sub(1i32 as Ulong)
            {
                if 0 != (t ^ dst as Ptr)
                    & (mem::size_of::<Int>() as Ulong).wrapping_sub(1i32 as Ulong)
                    || length < mem::size_of::<Int>() as Ulong
                {
                    t = length
                } else {
                    t = (mem::size_of::<Int>() as Ulong).wrapping_sub(
                        t & (mem::size_of::<Int>() as Ulong).wrapping_sub(1i32 as Ulong),
                    )
                }
                length = (length as Ulong).wrapping_sub(t) as Size as Size;
                loop {
                    let fresh5 = dst;
                    dst = dst.offset(1);
                    let fresh4 = src;
                    src = src.offset(1);
                    *fresh5 = *fresh4;
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
            t = length.wrapping_div(mem::size_of::<Int>() as Ulong);
            if 0 != t {
                loop {
                    *(dst as *mut Void as *mut Int) = *(src as *const Void as *const Int);
                    src = src.offset(mem::size_of::<Int>() as Ulong as isize);
                    dst = dst.offset(mem::size_of::<Int>() as Ulong as isize);
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
            t = length & (mem::size_of::<Int>() as Ulong).wrapping_sub(1i32 as Ulong);
            if 0 != t {
                loop {
                    let fresh7 = dst;
                    dst = dst.offset(1);
                    let fresh6 = src;
                    src = src.offset(1);
                    *fresh7 = *fresh6;
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
        } else {
            src = src.offset(length as isize);
            dst = dst.offset(length as isize);
            t = src as Ptr;
            if 0 != (t | dst as Ptr) & (mem::size_of::<Int>() as Ulong).wrapping_sub(1i32 as Ulong)
            {
                if 0 != (t ^ dst as Ptr)
                    & (mem::size_of::<Int>() as Ulong).wrapping_sub(1i32 as Ulong)
                    || length <= mem::size_of::<Int>() as Ulong
                {
                    t = length
                } else {
                    t &= (mem::size_of::<Int>() as Ulong).wrapping_sub(1i32 as Ulong)
                }
                length = (length as Ulong).wrapping_sub(t) as Size as Size;
                loop {
                    dst = dst.offset(-1isize);
                    src = src.offset(-1isize);
                    *dst = *src;
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
            t = length.wrapping_div(mem::size_of::<Int>() as Ulong);
            if 0 != t {
                loop {
                    src = src.offset(-(mem::size_of::<Int>() as Ulong as isize));
                    dst = dst.offset(-(mem::size_of::<Int>() as Ulong as isize));
                    *(dst as *mut Void as *mut Int) = *(src as *const Void as *const Int);
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
            t = length & (mem::size_of::<Int>() as Ulong).wrapping_sub(1i32 as Ulong);
            if 0 != t {
                loop {
                    dst = dst.offset(-1isize);
                    src = src.offset(-1isize);
                    *dst = *src;
                    t = t.wrapping_sub(1);
                    if !(0 != t) {
                        break;
                    }
                }
            }
        }
    }
    return dst0;
}

unsafe fn nk_round_up_pow2(mut v: u32) -> u32 {
    v = v.wrapping_sub(1);
    v |= v >> 1i32;
    v |= v >> 2i32;
    v |= v >> 4i32;
    v |= v >> 8i32;
    v |= v >> 16i32;
    v = v.wrapping_add(1);
    return v;
}

unsafe fn nk_start_buffer(mut ctx: *mut Context, mut buffer: *mut CommandBuffer) -> () {
    if ctx.is_null() || buffer.is_null() {
        return;
    } else {
        (*buffer).begin = (*ctx).memory.allocated;
        (*buffer).end = (*buffer).begin;
        (*buffer).last = (*buffer).begin;
        (*buffer).clip = nk_null_rect;
        return;
    };
}

const nk_null_rect: Rect = Rect {
    x: -8192.0,
    y: -8192.0,
    w: 16384.0,
    h: 16384.0,
};

unsafe fn nk_command_buffer_init(
    mut cb: *mut CommandBuffer,
    mut b: *mut Buffer,
    mut clip: CommandClipping,
) -> () {
    if cb.is_null() || b.is_null() {
        return;
    } else {
        (*cb).base = b;
        (*cb).use_clipping = clip as Int;
        (*cb).begin = (*b).allocated;
        (*cb).end = (*b).allocated;
        (*cb).last = (*b).allocated;
        return;
    };
}

pub unsafe fn nk__next(mut ctx: *mut Context, mut cmd: *const Command) -> *const Command {
    let mut buffer: *mut u8 = 0 as *mut u8;
    let mut next: *const Command = 0 as *const Command;
    if ctx.is_null() || cmd.is_null() || 0 == (*ctx).count {
        return 0 as *const Command;
    } else if (*cmd).next >= (*ctx).memory.allocated {
        return 0 as *const Command;
    } else {
        buffer = (*ctx).memory.memory.ptr as *mut u8;
        next = (buffer as *const u8).offset((*cmd).next as isize) as *const Void as *const Command;
        return next;
    };
}

pub unsafe fn nk_convert(
    mut ctx: *mut Context,
    mut cmds: *mut Buffer,
    mut vertices: *mut Buffer,
    mut elements: *mut Buffer,
    mut config: *const ConvertConfig,
) -> Flags {
    let mut t_1: *const CommandText = 0 as *const CommandText;
    let mut i_2: *const CommandImage = 0 as *const CommandImage;
    let mut t_0: *const CommandTriangleFilled = 0 as *const CommandTriangleFilled;
    let mut s: *const CommandScissor = 0 as *const CommandScissor;
    let mut c_2: *const CommandArcFilled = 0 as *const CommandArcFilled;
    let mut r: *const CommandRect = 0 as *const CommandRect;
    let mut r_1: *const CommandRectMultiColor = 0 as *const CommandRectMultiColor;
    let mut c_1: *const CommandArc = 0 as *const CommandArc;
    let mut c: *const CommandCircle = 0 as *const CommandCircle;
    let mut q: *const CommandCurve = 0 as *const CommandCurve;
    let mut r_0: *const CommandRectFilled = 0 as *const CommandRectFilled;
    let mut c_0: *const CommandCircleFilled = 0 as *const CommandCircleFilled;
    let mut t: *const CommandTriangle = 0 as *const CommandTriangle;
    let mut l: *const CommandLine = 0 as *const CommandLine;
    let mut res: Flags = NK_CONVERT_SUCCESS as Int as Flags;
    let mut cmd: *const Command = 0 as *const Command;
    if ctx.is_null()
        || cmds.is_null()
        || vertices.is_null()
        || elements.is_null()
        || config.is_null()
        || (*config).vertex_layout.is_null()
    {
        return NK_CONVERT_INVALID_PARAM as Int as Flags;
    } else {
        nk_draw_list_setup(
            &mut (*ctx).draw_list,
            config,
            cmds,
            vertices,
            elements,
            (*config).line_AA,
            (*config).shape_AA,
        );
        cmd = nk__begin(ctx);
        while !cmd.is_null() {
            (*ctx).draw_list.userdata = (*cmd).userdata;
            match (*cmd).type_0 as Uint {
                1 => {
                    s = cmd as *const CommandScissor;
                    nk_draw_list_add_clip(
                        &mut (*ctx).draw_list,
                        Rect::new((*s).x as f32, (*s).y as f32, (*s).w as f32, (*s).h as f32),
                    );
                }
                2 => {
                    l = cmd as *const CommandLine;
                    nk_draw_list_stroke_line(
                        &mut (*ctx).draw_list,
                        Point::new((*l).begin.x as f32, (*l).begin.y as f32),
                        Point::new((*l).end.x as f32, (*l).end.y as f32),
                        (*l).color,
                        (*l).line_thickness as f32,
                    );
                }
                3 => {
                    q = cmd as *const CommandCurve;
                    nk_draw_list_stroke_curve(
                        &mut (*ctx).draw_list,
                        Point::new((*q).begin.x as f32, (*q).begin.y as f32),
                        Point::new((*q).ctrl[0usize].x as f32, (*q).ctrl[0usize].y as f32),
                        Point::new((*q).ctrl[1usize].x as f32, (*q).ctrl[1usize].y as f32),
                        Point::new((*q).end.x as f32, (*q).end.y as f32),
                        (*q).color,
                        (*config).curve_segment_count,
                        (*q).line_thickness as f32,
                    );
                }
                4 => {
                    r = cmd as *const CommandRect;
                    nk_draw_list_stroke_rect(
                        &mut (*ctx).draw_list,
                        Rect::new((*r).x as f32, (*r).y as f32, (*r).w as f32, (*r).h as f32),
                        (*r).color,
                        (*r).rounding as f32,
                        (*r).line_thickness as f32,
                    );
                }
                5 => {
                    r_0 = cmd as *const CommandRectFilled;
                    nk_draw_list_fill_rect(
                        &mut (*ctx).draw_list,
                        Rect::new(
                            (*r_0).x as f32,
                            (*r_0).y as f32,
                            (*r_0).w as f32,
                            (*r_0).h as f32,
                        ),
                        (*r_0).color,
                        (*r_0).rounding as f32,
                    );
                }
                6 => {
                    r_1 = cmd as *const CommandRectMultiColor;
                    nk_draw_list_fill_rect_multi_color(
                        &mut (*ctx).draw_list,
                        Rect::new(
                            (*r_1).x as f32,
                            (*r_1).y as f32,
                            (*r_1).w as f32,
                            (*r_1).h as f32,
                        ),
                        (*r_1).left,
                        (*r_1).top,
                        (*r_1).right,
                        (*r_1).bottom,
                    );
                }
                7 => {
                    c = cmd as *const CommandCircle;
                    nk_draw_list_stroke_circle(
                        &mut (*ctx).draw_list,
                        Point::new(
                            (*c).x as f32 + (*c).w as f32 / 2i32 as f32,
                            (*c).y as f32 + (*c).h as f32 / 2i32 as f32,
                        ),
                        (*c).w as f32 / 2i32 as f32,
                        (*c).color,
                        (*config).circle_segment_count,
                        (*c).line_thickness as f32,
                    );
                }
                8 => {
                    c_0 = cmd as *const CommandCircleFilled;
                    nk_draw_list_fill_circle(
                        &mut (*ctx).draw_list,
                        Point::new(
                            (*c_0).x as f32 + (*c_0).w as f32 / 2i32 as f32,
                            (*c_0).y as f32 + (*c_0).h as f32 / 2i32 as f32,
                        ),
                        (*c_0).w as f32 / 2i32 as f32,
                        (*c_0).color,
                        (*config).circle_segment_count,
                    );
                }
                9 => {
                    c_1 = cmd as *const CommandArc;
                    nk_draw_list_path_line_to(
                        &mut (*ctx).draw_list,
                        Point::new((*c_1).cx as f32, (*c_1).cy as f32),
                    );
                    nk_draw_list_path_arc_to(
                        &mut (*ctx).draw_list,
                        Point::new((*c_1).cx as f32, (*c_1).cy as f32),
                        (*c_1).r as f32,
                        (*c_1).a[0usize],
                        (*c_1).a[1usize],
                        (*config).arc_segment_count,
                    );
                    nk_draw_list_path_stroke(
                        &mut (*ctx).draw_list,
                        (*c_1).color,
                        NK_STROKE_CLOSED,
                        (*c_1).line_thickness as f32,
                    );
                }
                10 => {
                    c_2 = cmd as *const CommandArcFilled;
                    nk_draw_list_path_line_to(
                        &mut (*ctx).draw_list,
                        Point::new((*c_2).cx as f32, (*c_2).cy as f32),
                    );
                    nk_draw_list_path_arc_to(
                        &mut (*ctx).draw_list,
                        Point::new((*c_2).cx as f32, (*c_2).cy as f32),
                        (*c_2).r as f32,
                        (*c_2).a[0usize],
                        (*c_2).a[1usize],
                        (*config).arc_segment_count,
                    );
                    nk_draw_list_path_fill(&mut (*ctx).draw_list, (*c_2).color);
                }
                11 => {
                    t = cmd as *const CommandTriangle;
                    nk_draw_list_stroke_triangle(
                        &mut (*ctx).draw_list,
                        Point::new((*t).a.x as f32, (*t).a.y as f32),
                        Point::new((*t).b.x as f32, (*t).b.y as f32),
                        Point::new((*t).c.x as f32, (*t).c.y as f32),
                        (*t).color,
                        (*t).line_thickness as f32,
                    );
                }
                12 => {
                    t_0 = cmd as *const CommandTriangleFilled;
                    nk_draw_list_fill_triangle(
                        &mut (*ctx).draw_list,
                        Point::new((*t_0).a.x as f32, (*t_0).a.y as f32),
                        Point::new((*t_0).b.x as f32, (*t_0).b.y as f32),
                        Point::new((*t_0).c.x as f32, (*t_0).c.y as f32),
                        (*t_0).color,
                    );
                }
                13 => {
                    let mut i: Int = 0;
                    let mut p: *const CommandPolygon = cmd as *const CommandPolygon;
                    i = 0i32;
                    while i < (*p).point_count as Int {
                        let mut pnt: Point = Point::new(
                            (*p).points[i as usize].x as f32,
                            (*p).points[i as usize].y as f32,
                        );
                        nk_draw_list_path_line_to(&mut (*ctx).draw_list, pnt);
                        i += 1
                    }
                    nk_draw_list_path_stroke(
                        &mut (*ctx).draw_list,
                        (*p).color,
                        NK_STROKE_CLOSED,
                        (*p).line_thickness as f32,
                    );
                }
                14 => {
                    let mut i_0: Int = 0;
                    let mut p_0: *const CommandPolygonFilled = cmd as *const CommandPolygonFilled;
                    i_0 = 0i32;
                    while i_0 < (*p_0).point_count as Int {
                        let mut pnt_0: Point = Point::new(
                            (*p_0).points[i_0 as usize].x as f32,
                            (*p_0).points[i_0 as usize].y as f32,
                        );
                        nk_draw_list_path_line_to(&mut (*ctx).draw_list, pnt_0);
                        i_0 += 1
                    }
                    nk_draw_list_path_fill(&mut (*ctx).draw_list, (*p_0).color);
                }
                15 => {
                    let mut i_1: Int = 0;
                    let mut p_1: *const CommandPolyline = cmd as *const CommandPolyline;
                    i_1 = 0i32;
                    while i_1 < (*p_1).point_count as Int {
                        let mut pnt_1: Point = Point::new(
                            (*p_1).points[i_1 as usize].x as f32,
                            (*p_1).points[i_1 as usize].y as f32,
                        );
                        nk_draw_list_path_line_to(&mut (*ctx).draw_list, pnt_1);
                        i_1 += 1
                    }
                    nk_draw_list_path_stroke(
                        &mut (*ctx).draw_list,
                        (*p_1).color,
                        NK_STROKE_OPEN,
                        (*p_1).line_thickness as f32,
                    );
                }
                16 => {
                    t_1 = cmd as *const CommandText;
                    nk_draw_list_add_text(
                        &mut (*ctx).draw_list,
                        (*t_1).font,
                        Rect::new(
                            (*t_1).x as f32,
                            (*t_1).y as f32,
                            (*t_1).w as f32,
                            (*t_1).h as f32,
                        ),
                        (*t_1).string.as_ptr(),
                        (*t_1).length,
                        (*t_1).height,
                        (*t_1).foreground,
                    );
                }
                17 => {
                    i_2 = cmd as *const CommandImage;
                    nk_draw_list_add_image(
                        &mut (*ctx).draw_list,
                        (*i_2).img,
                        Rect::new(
                            (*i_2).x as f32,
                            (*i_2).y as f32,
                            (*i_2).w as f32,
                            (*i_2).h as f32,
                        ),
                        (*i_2).col,
                    );
                }
                18 => {
                    let mut c_3: *const CommandCustom = cmd as *const CommandCustom;
                    (*c_3).callback.expect("non-null function pointer")(
                        &mut (*ctx).draw_list as *mut DrawList as *mut Void,
                        (*c_3).x,
                        (*c_3).y,
                        (*c_3).w,
                        (*c_3).h,
                        (*c_3).callback_data,
                    );
                }
                0 | _ => {}
            }
            cmd = nk__next(ctx, cmd)
        }
        res |= (if (*cmds).needed
            > (*cmds)
                .allocated
                .wrapping_add((*cmds).memory.size.wrapping_sub((*cmds).size))
        {
            NK_CONVERT_COMMAND_BUFFER_FULL as Int
        } else {
            0i32
        }) as Uint;
        res |= (if (*vertices).needed > (*vertices).allocated {
            NK_CONVERT_VERTEX_BUFFER_FULL as Int
        } else {
            0i32
        }) as Uint;
        res |= (if (*elements).needed > (*elements).allocated {
            NK_CONVERT_ELEMENT_BUFFER_FULL as Int
        } else {
            0i32
        }) as Uint;
        return res;
    };
}

pub unsafe fn nk_draw_list_add_image(
    mut list: *mut DrawList,
    mut texture: Image,
    mut rect: Rect,
    mut color: Color,
) -> () {
    let mut uv: [Point; 2] = [Point { x: 0., y: 0. }; 2];
    if list.is_null() {
        return;
    } else {
        /* push new command with given texture */
        nk_draw_list_push_image(list, texture.handle);
        if 0 != nk_image_is_subimage(&mut texture) {
            /* add region inside of the texture  */
            uv = [Point { x: 0., y: 0. }; 2];
            uv[0usize].x = texture.region[0usize] as f32 / texture.w as f32;
            uv[0usize].y = texture.region[1usize] as f32 / texture.h as f32;
            uv[1usize].x = (texture.region[0usize] as Int + texture.region[2usize] as Int) as f32
                / texture.w as f32;
            uv[1usize].y = (texture.region[1usize] as Int + texture.region[3usize] as Int) as f32
                / texture.h as f32;
            nk_draw_list_push_rect_uv(
                list,
                Point::new(rect.x, rect.y),
                Point::new(rect.x + rect.w, rect.y + rect.h),
                uv[0usize],
                uv[1usize],
                color,
            );
        } else {
            nk_draw_list_push_rect_uv(
                list,
                Point::new(rect.x, rect.y),
                Point::new(rect.x + rect.w, rect.y + rect.h),
                Point::new(0.0f32, 0.0f32),
                Point::new(1.0f32, 1.0f32),
                color,
            );
        }
        return;
    };
}
unsafe fn nk_draw_list_push_rect_uv(
    mut list: *mut DrawList,
    mut a: Point,
    mut c: Point,
    mut uva: Point,
    mut uvc: Point,
    mut color: Color,
) -> () {
    let mut vtx: *mut Void = 0 as *mut Void;
    let mut uvb: Point = Point { x: 0., y: 0. };
    let mut uvd: Point = Point { x: 0., y: 0. };
    let mut b: Point = Point { x: 0., y: 0. };
    let mut d: Point = Point { x: 0., y: 0. };
    let mut col: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut idx: *mut DrawIndex = 0 as *mut DrawIndex;
    let mut index: DrawIndex = 0;
    if list.is_null() {
        return;
    } else {
        nk_color_fv(&mut col.r, color);
        uvb = Point::new(uvc.x, uva.y);
        uvd = Point::new(uva.x, uvc.y);
        b = Point::new(c.x, a.y);
        d = Point::new(a.x, c.y);
        index = (*list).vertex_count as DrawIndex;
        vtx = nk_draw_list_alloc_vertices(list, 4i32 as Size);
        idx = nk_draw_list_alloc_elements(list, 6i32 as Size);
        if vtx.is_null() || idx.is_null() {
            return;
        } else {
            *idx.offset(0isize) = (index as Int + 0i32) as DrawIndex;
            *idx.offset(1isize) = (index as Int + 1i32) as DrawIndex;
            *idx.offset(2isize) = (index as Int + 2i32) as DrawIndex;
            *idx.offset(3isize) = (index as Int + 0i32) as DrawIndex;
            *idx.offset(4isize) = (index as Int + 2i32) as DrawIndex;
            *idx.offset(5isize) = (index as Int + 3i32) as DrawIndex;
            vtx = nk_draw_vertex(vtx, &mut (*list).config, a, uva, col);
            vtx = nk_draw_vertex(vtx, &mut (*list).config, b, uvb, col);
            vtx = nk_draw_vertex(vtx, &mut (*list).config, c, uvc, col);
            vtx = nk_draw_vertex(vtx, &mut (*list).config, d, uvd, col);
            return;
        }
    };
}

unsafe fn nk_draw_vertex(
    mut dst: *mut Void,
    mut config: *const ConvertConfig,
    mut pos: Point,
    mut uv: Point,
    mut color: ColorF,
) -> *mut Void {
    let mut result: *mut Void =
        (dst as *mut Char).offset((*config).vertex_size as isize) as *mut Void;
    let mut elem_iter: *const DrawVertexLayoutElement = (*config).vertex_layout;
    while 0 == nk_draw_vertex_layout_element_is_end_of_layout(elem_iter) {
        let mut address: *mut Void =
            (dst as *mut Char).offset((*elem_iter).offset as isize) as *mut Void;
        match (*elem_iter).attribute as Uint {
            0 => {
                nk_draw_vertex_element(address, &mut pos.x, 2i32, (*elem_iter).format);
            }
            2 => {
                nk_draw_vertex_element(address, &mut uv.x, 2i32, (*elem_iter).format);
            }
            1 => {
                nk_draw_vertex_color(address, &mut color.r, (*elem_iter).format);
            }
            3 | _ => {}
        }
        elem_iter = elem_iter.offset(1isize)
    }
    return result;
}

unsafe fn nk_draw_vertex_color(
    mut attr: *mut Void,
    mut vals: *const f32,
    mut format: DrawVertexLayoutFormat,
) -> () {
    let mut col_5: [f64; 4] = [0.; 4];
    let mut col: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut col_3: [u32; 3] = [0; 3];
    let mut col_2: [u16; 4] = [0; 4];
    let mut col_0: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut col_4: [u32; 4] = [0; 4];
    let mut bgra: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut col_1: [u16; 3] = [0; 3];
    /* if this triggers you tried to provide a value format for a color */
    let mut val: [f32; 4] = [0.; 4];
    if (format as Uint) < NK_FORMAT_COLOR_BEGIN as Int as Uint
        || format as Uint > NK_FORMAT_COLOR_END as Int as Uint
    {
        return;
    } else {
        val[0usize] = if (0i32 as f32) < if 1.0f32 < *vals.offset(0isize) {
            1.0f32
        } else {
            *vals.offset(0isize)
        } {
            if 1.0f32 < *vals.offset(0isize) {
                1.0f32
            } else {
                *vals.offset(0isize)
            }
        } else {
            0i32 as f32
        };
        val[1usize] = if (0i32 as f32) < if 1.0f32 < *vals.offset(1isize) {
            1.0f32
        } else {
            *vals.offset(1isize)
        } {
            if 1.0f32 < *vals.offset(1isize) {
                1.0f32
            } else {
                *vals.offset(1isize)
            }
        } else {
            0i32 as f32
        };
        val[2usize] = if (0i32 as f32) < if 1.0f32 < *vals.offset(2isize) {
            1.0f32
        } else {
            *vals.offset(2isize)
        } {
            if 1.0f32 < *vals.offset(2isize) {
                1.0f32
            } else {
                *vals.offset(2isize)
            }
        } else {
            0i32 as f32
        };
        val[3usize] = if (0i32 as f32) < if 1.0f32 < *vals.offset(3isize) {
            1.0f32
        } else {
            *vals.offset(3isize)
        } {
            if 1.0f32 < *vals.offset(3isize) {
                1.0f32
            } else {
                *vals.offset(3isize)
            }
        } else {
            0i32 as f32
        };
        match format as Uint {
            11 | 8 => {
                col = nk_rgba_fv(val.as_mut_ptr());
                nk_memcopy(
                    attr,
                    &mut col.r as *mut u8 as *const Void,
                    mem::size_of::<Color>() as Ulong,
                );
            }
            12 => {
                col_0 = nk_rgba_fv(val.as_mut_ptr());
                bgra = nk_rgba(
                    col_0.b as Int,
                    col_0.g as Int,
                    col_0.r as Int,
                    col_0.a as Int,
                );
                nk_memcopy(
                    attr,
                    &mut bgra as *mut Color as *const Void,
                    mem::size_of::<Color>() as Ulong,
                );
            }
            9 => {
                col_1 = [0; 3];
                col_1[0usize] = (val[0usize] * 65535i32 as f32) as u16;
                col_1[1usize] = (val[1usize] * 65535i32 as f32) as u16;
                col_1[2usize] = (val[2usize] * 65535i32 as f32) as u16;
                nk_memcopy(
                    attr,
                    col_1.as_mut_ptr() as *const Void,
                    mem::size_of::<[u16; 3]>() as Ulong,
                );
            }
            13 => {
                col_2 = [0; 4];
                col_2[0usize] = (val[0usize] * 65535i32 as f32) as u16;
                col_2[1usize] = (val[1usize] * 65535i32 as f32) as u16;
                col_2[2usize] = (val[2usize] * 65535i32 as f32) as u16;
                col_2[3usize] = (val[3usize] * 65535i32 as f32) as u16;
                nk_memcopy(
                    attr,
                    col_2.as_mut_ptr() as *const Void,
                    mem::size_of::<[u16; 4]>() as Ulong,
                );
            }
            10 => {
                col_3 = [0; 3];
                col_3[0usize] = (val[0usize] * 4294967295u32 as f32) as u32;
                col_3[1usize] = (val[1usize] * 4294967295u32 as f32) as u32;
                col_3[2usize] = (val[2usize] * 4294967295u32 as f32) as u32;
                nk_memcopy(
                    attr,
                    col_3.as_mut_ptr() as *const Void,
                    mem::size_of::<[u32; 3]>() as Ulong,
                );
            }
            14 => {
                col_4 = [0; 4];
                col_4[0usize] = (val[0usize] * 4294967295u32 as f32) as u32;
                col_4[1usize] = (val[1usize] * 4294967295u32 as f32) as u32;
                col_4[2usize] = (val[2usize] * 4294967295u32 as f32) as u32;
                col_4[3usize] = (val[3usize] * 4294967295u32 as f32) as u32;
                nk_memcopy(
                    attr,
                    col_4.as_mut_ptr() as *const Void,
                    mem::size_of::<[u32; 4]>() as Ulong,
                );
            }
            15 => {
                nk_memcopy(
                    attr,
                    val.as_mut_ptr() as *const Void,
                    (mem::size_of::<f32>() as Ulong).wrapping_mul(4i32 as Ulong),
                );
            }
            16 => {
                col_5 = [0.; 4];
                col_5[0usize] = val[0usize] as f64;
                col_5[1usize] = val[1usize] as f64;
                col_5[2usize] = val[2usize] as f64;
                col_5[3usize] = val[3usize] as f64;
                nk_memcopy(
                    attr,
                    col_5.as_mut_ptr() as *const Void,
                    mem::size_of::<[f64; 4]>() as Ulong,
                );
            }
            17 | 18 => {
                let mut col_6: Color = nk_rgba_fv(val.as_mut_ptr());
                let mut color: u32 = nk_color_u32(col_6);
                nk_memcopy(
                    attr,
                    &mut color as *mut u32 as *const Void,
                    mem::size_of::<u32>() as Ulong,
                );
            }
            _ => {}
        }
        return;
    };
}

pub unsafe fn nk_rgba_fv(mut c: *const f32) -> Color {
    return nk_rgba_f(
        *c.offset(0isize),
        *c.offset(1isize),
        *c.offset(2isize),
        *c.offset(3isize),
    );
}

pub unsafe fn nk_rgba_f(mut r: f32, mut g: f32, mut b: f32, mut a: f32) -> Color {
    let mut ret: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    ret.r = (if (0i32 as f32) < if 1.0f32 < r { 1.0f32 } else { r } {
        if 1.0f32 < r {
            1.0f32
        } else {
            r
        }
    } else {
        0i32 as f32
    } * 255.0f32) as u8;
    ret.g = (if (0i32 as f32) < if 1.0f32 < g { 1.0f32 } else { g } {
        if 1.0f32 < g {
            1.0f32
        } else {
            g
        }
    } else {
        0i32 as f32
    } * 255.0f32) as u8;
    ret.b = (if (0i32 as f32) < if 1.0f32 < b { 1.0f32 } else { b } {
        if 1.0f32 < b {
            1.0f32
        } else {
            b
        }
    } else {
        0i32 as f32
    } * 255.0f32) as u8;
    ret.a = (if (0i32 as f32) < if 1.0f32 < a { 1.0f32 } else { a } {
        if 1.0f32 < a {
            1.0f32
        } else {
            a
        }
    } else {
        0i32 as f32
    } * 255.0f32) as u8;
    return ret;
}

pub unsafe fn nk_color_u32(mut in_0: Color) -> u32 {
    let mut out: u32 = in_0.r as u32;
    out |= (in_0.g as u32) << 8i32;
    out |= (in_0.b as u32) << 16i32;
    out |= (in_0.a as u32) << 24i32;
    return out;
}
unsafe fn nk_draw_vertex_element(
    mut dst: *mut Void,
    mut values: *const f32,
    mut value_count: Int,
    mut format: DrawVertexLayoutFormat,
) -> () {
    let mut value_4: u32 = 0;
    let mut value: Char = 0;
    let mut value_3: u16 = 0;
    let mut value_1: i32 = 0;
    let mut value_2: Uchar = 0;
    let mut value_0: i16 = 0;
    let mut value_index: Int = 0;
    let mut attribute: *mut Void = dst;
    /* if this triggers you tried to provide a color format for a value */
    if format as Uint >= NK_FORMAT_COLOR_BEGIN as Int as Uint
        && format as Uint <= NK_FORMAT_COLOR_END as Int as Uint
    {
        return;
    } else {
        value_index = 0i32;
        while value_index < value_count {
            match format as Uint {
                0 => {
                    value = (if if *values.offset(value_index as isize) < 127i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        127i32 as f32
                    } < -127i32 as f32
                    {
                        -127i32 as f32
                    } else if *values.offset(value_index as isize) < 127i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        127i32 as f32
                    }) as Char;
                    nk_memcopy(
                        attribute,
                        &mut value as *mut Char as *const Void,
                        mem::size_of::<Char>() as Ulong,
                    );
                    attribute = (attribute as *mut Char)
                        .offset(mem::size_of::<Char>() as Ulong as isize)
                        as *mut Void
                }
                1 => {
                    value_0 = (if if *values.offset(value_index as isize) < 32767i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        32767i32 as f32
                    } < -32767i32 as f32
                    {
                        -32767i32 as f32
                    } else if *values.offset(value_index as isize) < 32767i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        32767i32 as f32
                    }) as i16;
                    nk_memcopy(
                        attribute,
                        &mut value_0 as *mut i16 as *const Void,
                        mem::size_of::<i16>() as Ulong,
                    );
                    attribute = (attribute as *mut Char)
                        .offset(mem::size_of::<i16>() as Ulong as isize)
                        as *mut Void
                }
                2 => {
                    value_1 = (if if *values.offset(value_index as isize) < 2147483647i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        2147483647i32 as f32
                    } < -2147483647i32 as f32
                    {
                        -2147483647i32 as f32
                    } else if *values.offset(value_index as isize) < 2147483647i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        2147483647i32 as f32
                    }) as i32;
                    nk_memcopy(
                        attribute,
                        &mut value_1 as *mut i32 as *const Void,
                        mem::size_of::<i32>() as Ulong,
                    );
                    attribute = (attribute as *mut Char)
                        .offset(mem::size_of::<i32>() as Ulong as isize)
                        as *mut Void
                }
                3 => {
                    value_2 = (if if *values.offset(value_index as isize) < 256i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        256i32 as f32
                    } < 0i32 as f32
                    {
                        0i32 as f32
                    } else if *values.offset(value_index as isize) < 256i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        256i32 as f32
                    }) as Uchar;
                    nk_memcopy(
                        attribute,
                        &mut value_2 as *mut Uchar as *const Void,
                        mem::size_of::<Uchar>() as Ulong,
                    );
                    attribute = (attribute as *mut Char)
                        .offset(mem::size_of::<Uchar>() as Ulong as isize)
                        as *mut Void
                }
                4 => {
                    value_3 = (if if *values.offset(value_index as isize) < 65535i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        65535i32 as f32
                    } < 0i32 as f32
                    {
                        0i32 as f32
                    } else if *values.offset(value_index as isize) < 65535i32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        65535i32 as f32
                    }) as u16;
                    nk_memcopy(
                        attribute,
                        &mut value_3 as *mut u16 as *const Void,
                        mem::size_of::<u16>() as Ulong,
                    );
                    attribute = (attribute as *mut Char)
                        .offset(mem::size_of::<u16>() as Ulong as isize)
                        as *mut Void
                }
                5 => {
                    value_4 = (if if *values.offset(value_index as isize) < 4294967295u32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        4294967295u32 as f32
                    } < 0i32 as f32
                    {
                        0i32 as f32
                    } else if *values.offset(value_index as isize) < 4294967295u32 as f32 {
                        *values.offset(value_index as isize)
                    } else {
                        4294967295u32 as f32
                    }) as u32;
                    nk_memcopy(
                        attribute,
                        &mut value_4 as *mut u32 as *const Void,
                        mem::size_of::<u32>() as Ulong,
                    );
                    attribute = (attribute as *mut Char)
                        .offset(mem::size_of::<u32>() as Ulong as isize)
                        as *mut Void
                }
                6 => {
                    nk_memcopy(
                        attribute,
                        &*values.offset(value_index as isize) as *const f32 as *const Void,
                        mem::size_of::<f32>() as Ulong,
                    );
                    attribute = (attribute as *mut Char)
                        .offset(mem::size_of::<f32>() as Ulong as isize)
                        as *mut Void
                }
                7 => {
                    let mut value_5: f64 = *values.offset(value_index as isize) as f64;
                    nk_memcopy(
                        attribute,
                        &mut value_5 as *mut f64 as *const Void,
                        mem::size_of::<f64>() as Ulong,
                    );
                    attribute = (attribute as *mut Char)
                        .offset(mem::size_of::<f64>() as Ulong as isize)
                        as *mut Void
                }
                _ => {}
            }
            value_index += 1
        }
        return;
    };
}
unsafe fn nk_draw_vertex_layout_element_is_end_of_layout(
    mut element: *const DrawVertexLayoutElement,
) -> Int {
    return ((*element).attribute as Uint == NK_VERTEX_ATTRIBUTE_COUNT as Int as Uint
        || (*element).format as Uint == NK_FORMAT_COUNT as Int as Uint) as Int;
}
unsafe fn nk_draw_list_alloc_elements(mut list: *mut DrawList, mut count: Size) -> *mut DrawIndex {
    let mut ids: *mut DrawIndex = 0 as *mut DrawIndex;
    let mut cmd: *mut DrawCommand = 0 as *mut DrawCommand;
    const elem_align: Size = mem::align_of::<DrawIndex>() as Size;
    const elem_size: Size = mem::size_of::<DrawIndex>() as Size;
    if list.is_null() {
        return 0 as *mut DrawIndex;
    } else {
        ids = nk_buffer_alloc(
            (*list).elements,
            NK_BUFFER_FRONT,
            elem_size.wrapping_mul(count),
            elem_align,
        ) as *mut DrawIndex;
        if ids.is_null() {
            return 0 as *mut DrawIndex;
        } else {
            cmd = nk_draw_list_command_last(list);
            (*list).element_count = (*list).element_count.wrapping_add(count as Uint);
            (*cmd).elem_count = (*cmd).elem_count.wrapping_add(count as Uint);
            return ids;
        }
    };
}
unsafe fn nk_draw_list_command_last(mut list: *mut DrawList) -> *mut DrawCommand {
    let mut memory: *mut Void = 0 as *mut Void;
    let mut size: Size = 0;
    let mut cmd: *mut DrawCommand = 0 as *mut DrawCommand;
    memory = nk_buffer_memory((*list).buffer);
    size = nk_buffer_total((*list).buffer);
    cmd = (memory as *mut u8).offset(size.wrapping_sub((*list).cmd_offset) as isize) as *mut Void
        as *mut DrawCommand;
    return cmd.offset(-((*list).cmd_count.wrapping_sub(1i32 as Uint) as isize));
}

pub unsafe fn nk_buffer_total(mut buffer: *mut Buffer) -> Size {
    if buffer.is_null() {
        return 0i32 as Size;
    } else {
        return (*buffer).memory.size;
    };
}

pub unsafe fn nk_buffer_memory(mut buffer: *mut Buffer) -> *mut Void {
    if buffer.is_null() {
        return 0 as *mut Void;
    } else {
        return (*buffer).memory.ptr;
    };
}

unsafe fn nk_draw_list_alloc_vertices(mut list: *mut DrawList, mut count: Size) -> *mut Void {
    let mut vtx: *mut Void = 0 as *mut Void;
    if list.is_null() {
        return 0 as *mut Void;
    } else {
        vtx = nk_buffer_alloc(
            (*list).vertices,
            NK_BUFFER_FRONT,
            (*list).config.vertex_size.wrapping_mul(count),
            (*list).config.vertex_alignment,
        );
        if vtx.is_null() {
            return 0 as *mut Void;
        } else {
            (*list).vertex_count = (*list).vertex_count.wrapping_add(count as Uint);
            /* This assert triggers because your are drawing a lot of stuff and nuklear
             * defined `DrawIndex` as `u16` to safe space be default.
             *
             * So you reached the maximum number of indicies or rather vertexes.
             * To solve this issue please change typdef `DrawIndex` to `u32`
             * and don't forget to specify the new element size in your drawing
             * backend (OpenGL, DirectX, ...). For example in OpenGL for `glDrawElements`
             * instead of specifing `GL_UNSIGNED_SHORT` you have to define `GL_UNSIGNED_INT`.
             * Sorry for the inconvenience. */
            assert_eq!(2, mem::size_of::<DrawIndex>());
            return vtx;
        }
    };
}

pub unsafe fn nk_color_fv(mut c: *mut f32, mut in_0: Color) -> () {
    nk_color_f(
        &mut *c.offset(0isize),
        &mut *c.offset(1isize),
        &mut *c.offset(2isize),
        &mut *c.offset(3isize),
        in_0,
    );
}

pub unsafe fn nk_color_f(
    mut r: *mut f32,
    mut g: *mut f32,
    mut b: *mut f32,
    mut a: *mut f32,
    mut in_0: Color,
) -> () {
    static mut s: f32 = unsafe { 1.0f32 / 255.0f32 };
    *r = in_0.r as f32 * s;
    *g = in_0.g as f32 * s;
    *b = in_0.b as f32 * s;
    *a = in_0.a as f32 * s;
}

pub unsafe fn nk_image_is_subimage(mut img: *const Image) -> Int {
    return !((*img).w as Int == 0i32 && (*img).h as Int == 0i32) as Int;
}

unsafe fn nk_draw_list_push_image(mut list: *mut DrawList, mut texture: Handle) -> () {
    if list.is_null() {
        return;
    } else {
        if 0 == (*list).cmd_count {
            nk_draw_list_push_command(list, nk_null_rect, texture);
        } else {
            let mut prev: *mut DrawCommand = nk_draw_list_command_last(list);
            if (*prev).elem_count == 0i32 as Uint {
                (*prev).texture = texture;
                (*prev).userdata = (*list).userdata
            } else if (*prev).texture.id != texture.id || (*prev).userdata.id != (*list).userdata.id
            {
                nk_draw_list_push_command(list, (*prev).clip_rect, texture);
            }
        }
        return;
    };
}

unsafe fn nk_draw_list_push_command(
    mut list: *mut DrawList,
    mut clip: Rect,
    mut texture: Handle,
) -> *mut DrawCommand {
    let mut total: Size = 0;
    let mut memory: *mut u8 = 0 as *mut u8;
    const cmd_align: Size = mem::align_of::<DrawCommand>() as Size;
    const cmd_size: Size = mem::size_of::<DrawCommand>() as Size;
    let mut cmd: *mut DrawCommand = 0 as *mut DrawCommand;
    cmd = nk_buffer_alloc((*list).buffer, NK_BUFFER_BACK, cmd_size, cmd_align) as *mut DrawCommand;
    if cmd.is_null() {
        return 0 as *mut DrawCommand;
    } else {
        if 0 == (*list).cmd_count {
            memory = nk_buffer_memory((*list).buffer) as *mut u8;
            total = nk_buffer_total((*list).buffer);
            memory = memory.offset(total as isize) as *mut Void as *mut u8;
            (*list).cmd_offset = (cmd as *mut u8)
                .ptr_offset_to(memory)
                .expect("bad offset_to") as Long as Size
        }
        (*cmd).elem_count = 0i32 as Uint;
        (*cmd).clip_rect = clip;
        (*cmd).texture = texture;
        (*cmd).userdata = (*list).userdata;
        (*list).cmd_count = (*list).cmd_count.wrapping_add(1);
        (*list).clip_rect = clip;
        return cmd;
    };
}

pub unsafe fn nk_draw_list_add_text(
    mut list: *mut DrawList,
    mut font: *const UserFont,
    mut rect: Rect,
    mut text: *const Char,
    mut len: Int,
    mut font_height: f32,
    mut fg: Color,
) -> () {
    let mut x: f32 = 0i32 as f32;
    let mut text_len: Int = 0i32;
    let mut unicode: Rune = 0i32 as Rune;
    let mut next: Rune = 0i32 as Rune;
    let mut glyph_len: Int = 0i32;
    let mut next_glyph_len: Int = 0i32;
    let mut g: UserFontGlyph = UserFontGlyph {
        uv: [Point { x: 0., y: 0. }; 2],
        offset: Point { x: 0., y: 0. },
        width: 0.,
        height: 0.,
        xadvance: 0.,
    };
    if list.is_null() || 0 == len || text.is_null() {
        return;
    } else if (*list).clip_rect.x > rect.x + rect.w
        || (*list).clip_rect.x + (*list).clip_rect.w < rect.x
        || (*list).clip_rect.y > rect.y + rect.h
        || (*list).clip_rect.y + (*list).clip_rect.h < rect.y
    {
        return;
    } else {
        nk_draw_list_push_image(list, (*font).texture);
        x = rect.x;
        glyph_len = nk_utf_decode(text, &mut unicode, len);
        if 0 == glyph_len {
            return;
        } else {
            /* draw every glyph image */
            fg.a = (fg.a as f32 * (*list).config.global_alpha) as u8;
            while text_len < len && 0 != glyph_len {
                let mut gx: f32 = 0.;
                let mut gy: f32 = 0.;
                let mut gh: f32 = 0.;
                let mut gw: f32 = 0.;
                let mut char_width: f32 = 0i32 as f32;
                if unicode == 65533i32 as Uint {
                    break;
                }
                /* query currently drawn glyph information */
                next_glyph_len = nk_utf_decode(
                    text.offset(text_len as isize).offset(glyph_len as isize),
                    &mut next,
                    len - text_len,
                );
                (*font).query.expect("non-null function pointer")(
                    (*font).userdata,
                    font_height,
                    &mut g,
                    unicode,
                    if next == 65533i32 as Uint {
                        '\u{0}' as i32 as Uint
                    } else {
                        next
                    },
                );
                /* calculate and draw glyph drawing rectangle and image */
                gx = x + g.offset.x;
                gy = rect.y + g.offset.y;
                gw = g.width;
                gh = g.height;
                char_width = g.xadvance;
                nk_draw_list_push_rect_uv(
                    list,
                    Point::new(gx, gy),
                    Point::new(gx + gw, gy + gh),
                    g.uv[0usize],
                    g.uv[1usize],
                    fg,
                );
                /* offset next glyph */
                text_len += glyph_len;
                x += char_width;
                glyph_len = next_glyph_len;
                unicode = next
            }
            return;
        }
    };
}

pub unsafe fn nk_draw_list_path_stroke(
    mut list: *mut DrawList,
    mut color: Color,
    mut closed: DrawListStroke,
    mut thickness: f32,
) -> () {
    let mut points: *mut Point = 0 as *mut Point;
    if list.is_null() {
        return;
    } else {
        points = nk_buffer_memory((*list).buffer) as *mut Point;
        nk_draw_list_stroke_poly_line(
            list,
            points,
            (*list).path_count,
            color,
            closed,
            thickness,
            (*list).config.line_AA,
        );
        nk_draw_list_path_clear(list);
        return;
    };
}

pub unsafe fn nk_draw_list_path_clear(mut list: *mut DrawList) -> () {
    if list.is_null() {
        return;
    } else {
        nk_buffer_reset((*list).buffer, NK_BUFFER_FRONT);
        (*list).path_count = 0i32 as Uint;
        (*list).path_offset = 0i32 as Uint;
        return;
    };
}

pub unsafe fn nk_draw_list_stroke_poly_line(
    mut list: *mut DrawList,
    mut points: *const Point,
    points_count: Uint,
    mut color: Color,
    mut closed: DrawListStroke,
    mut thickness: f32,
    mut aliasing: AntiAliasing,
) -> () {
    let mut d: Point = Point { x: 0., y: 0. };
    let mut d1: Point = Point { x: 0., y: 0. };
    let mut scale: f32 = 0.;
    let mut d2: Point = Point { x: 0., y: 0. };
    let mut scale_0: f32 = 0.;
    let mut count: Size = 0;
    let mut thick_line: Int = 0;
    let mut col: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut col_trans: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    if list.is_null() || points_count < 2i32 as Uint {
        return;
    } else {
        color.a = (color.a as f32 * (*list).config.global_alpha) as u8;
        count = points_count as Size;
        if 0 == closed as u64 {
            count = points_count.wrapping_sub(1i32 as Uint) as Size
        }
        thick_line = (thickness > 1.0f32) as Int;
        nk_draw_list_push_userdata(list, (*list).userdata);
        color.a = (color.a as f32 * (*list).config.global_alpha) as u8;
        nk_color_fv(&mut col.r, color);
        col_trans = col;
        col_trans.a = 0i32 as f32;
        if aliasing as Uint == NK_ANTI_ALIASING_ON as Int as Uint {
            /* ANTI-ALIASED STROKE */
            let AA_SIZE: f32 = 1.0f32;
            const pnt_align: Size = mem::align_of::<Point>() as Size;
            const pnt_size: Size = mem::size_of::<Point>() as Size;
            /* allocate vertices and elements  */
            let mut i1: Size = 0i32 as Size;
            let mut vertex_offset: Size = 0;
            let mut index: Size = (*list).vertex_count as Size;
            let idx_count: Size = if 0 != thick_line {
                count.wrapping_mul(18i32 as Ulong)
            } else {
                count.wrapping_mul(12i32 as Ulong)
            };
            let vtx_count: Size = (if 0 != thick_line {
                points_count.wrapping_mul(4i32 as Uint)
            } else {
                points_count.wrapping_mul(3i32 as Uint)
            }) as Size;
            let mut vtx: *mut Void = nk_draw_list_alloc_vertices(list, vtx_count);
            let mut ids: *mut DrawIndex = nk_draw_list_alloc_elements(list, idx_count);
            let mut size: Size = 0;
            let mut normals: *mut Point = 0 as *mut Point;
            let mut temp: *mut Point = 0 as *mut Point;
            if vtx.is_null() || ids.is_null() {
                return;
            } else {
                /* temporary allocate normals + points */
                vertex_offset = ((*(*list).vertices).memory.ptr as *mut u8)
                    .ptr_offset_to(vtx as *mut u8)
                    .expect("bad offset_to") as Long as Size;
                nk_buffer_mark((*list).vertices, NK_BUFFER_FRONT);
                size = pnt_size
                    .wrapping_mul((if 0 != thick_line { 5i32 } else { 3i32 }) as Ulong)
                    .wrapping_mul(points_count as Ulong);
                normals = nk_buffer_alloc((*list).vertices, NK_BUFFER_FRONT, size, pnt_align)
                    as *mut Point;
                if normals.is_null() {
                    return;
                } else {
                    temp = normals.offset(points_count as isize);
                    /* make sure vertex pointer is still correct */
                    vtx = ((*(*list).vertices).memory.ptr as *mut u8).offset(vertex_offset as isize)
                        as *mut Void;
                    /* calculate normals */
                    i1 = 0i32 as Size;
                    while i1 < count {
                        let i2: Size = if i1.wrapping_add(1i32 as Ulong) == points_count as Ulong {
                            0i32 as Ulong
                        } else {
                            i1.wrapping_add(1i32 as Ulong)
                        };
                        let mut diff: Point = Point::new(
                            (*points.offset(i2 as isize)).x - (*points.offset(i1 as isize)).x,
                            (*points.offset(i2 as isize)).y - (*points.offset(i1 as isize)).y,
                        );
                        let mut len: f32 = 0.;
                        /* point inverted length  */
                        len = diff.x * diff.x + diff.y * diff.y;
                        if len != 0.0f32 {
                            len = nk_inv_sqrt(len)
                        } else {
                            len = 1.0f32
                        }
                        diff = Point::new(diff.x * len, diff.y * len);
                        (*normals.offset(i1 as isize)).x = diff.y;
                        (*normals.offset(i1 as isize)).y = -diff.x;
                        i1 = i1.wrapping_add(1)
                    }
                    if 0 == closed as u64 {
                        *normals.offset(points_count.wrapping_sub(1i32 as Uint) as isize) =
                            *normals.offset(points_count.wrapping_sub(2i32 as Uint) as isize)
                    }
                    if 0 == thick_line {
                        let mut idx1: Size = 0;
                        let mut i: Size = 0;
                        if 0 == closed as u64 {
                            d = Point { x: 0., y: 0. };
                            *temp.offset(0isize) = Point::new(
                                (*points.offset(0isize)).x
                                    + Point::new(
                                        (*normals.offset(0isize)).x * AA_SIZE,
                                        (*normals.offset(0isize)).y * AA_SIZE,
                                    ).x,
                                (*points.offset(0isize)).y
                                    + Point::new(
                                        (*normals.offset(0isize)).x * AA_SIZE,
                                        (*normals.offset(0isize)).y * AA_SIZE,
                                    ).y,
                            );
                            *temp.offset(1isize) = Point::new(
                                (*points.offset(0isize)).x
                                    - Point::new(
                                        (*normals.offset(0isize)).x * AA_SIZE,
                                        (*normals.offset(0isize)).y * AA_SIZE,
                                    ).x,
                                (*points.offset(0isize)).y
                                    - Point::new(
                                        (*normals.offset(0isize)).x * AA_SIZE,
                                        (*normals.offset(0isize)).y * AA_SIZE,
                                    ).y,
                            );
                            d = Point::new(
                                (*normals.offset(points_count.wrapping_sub(1i32 as Uint) as isize))
                                    .x * AA_SIZE,
                                (*normals.offset(points_count.wrapping_sub(1i32 as Uint) as isize))
                                    .y * AA_SIZE,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as Uint)
                                    .wrapping_mul(2i32 as Uint)
                                    .wrapping_add(0i32 as Uint)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).x
                                    + d.x,
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).y
                                    + d.y,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as Uint)
                                    .wrapping_mul(2i32 as Uint)
                                    .wrapping_add(1i32 as Uint)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).x
                                    - d.x,
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).y
                                    - d.y,
                            )
                        }
                        /* fill elements */
                        idx1 = index;
                        i1 = 0i32 as Size;
                        while i1 < count {
                            let mut dm: Point = Point { x: 0., y: 0. };
                            let mut dmr2: f32 = 0.;
                            let mut i2_0: Size =
                                if i1.wrapping_add(1i32 as Ulong) == points_count as Ulong {
                                    0i32 as Ulong
                                } else {
                                    i1.wrapping_add(1i32 as Ulong)
                                };
                            let mut idx2: Size =
                                if i1.wrapping_add(1i32 as Ulong) == points_count as Ulong {
                                    index
                                } else {
                                    idx1.wrapping_add(3i32 as Ulong)
                                };
                            /* average normals */
                            dm = Point::new(
                                Point::new(
                                    (*normals.offset(i1 as isize)).x
                                        + (*normals.offset(i2_0 as isize)).x,
                                    (*normals.offset(i1 as isize)).y
                                        + (*normals.offset(i2_0 as isize)).y,
                                ).x * 0.5f32,
                                Point::new(
                                    (*normals.offset(i1 as isize)).x
                                        + (*normals.offset(i2_0 as isize)).x,
                                    (*normals.offset(i1 as isize)).y
                                        + (*normals.offset(i2_0 as isize)).y,
                                ).y * 0.5f32,
                            );
                            dmr2 = dm.x * dm.x + dm.y * dm.y;
                            if dmr2 > 9.999999974752428e-7f32 {
                                scale = 1.0f32 / dmr2;
                                scale = if 100.0f32 < scale { 100.0f32 } else { scale };
                                dm = Point::new(dm.x * scale, dm.y * scale)
                            }
                            dm = Point::new(dm.x * AA_SIZE, dm.y * AA_SIZE);
                            *temp.offset(
                                i2_0.wrapping_mul(2i32 as Ulong).wrapping_add(0i32 as Ulong)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(i2_0 as isize)).x + dm.x,
                                (*points.offset(i2_0 as isize)).y + dm.y,
                            );
                            *temp.offset(
                                i2_0.wrapping_mul(2i32 as Ulong).wrapping_add(1i32 as Ulong)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(i2_0 as isize)).x - dm.x,
                                (*points.offset(i2_0 as isize)).y - dm.y,
                            );
                            *ids.offset(0isize) = idx2.wrapping_add(0i32 as Ulong) as DrawIndex;
                            *ids.offset(1isize) = idx1.wrapping_add(0i32 as Ulong) as DrawIndex;
                            *ids.offset(2isize) = idx1.wrapping_add(2i32 as Ulong) as DrawIndex;
                            *ids.offset(3isize) = idx1.wrapping_add(2i32 as Ulong) as DrawIndex;
                            *ids.offset(4isize) = idx2.wrapping_add(2i32 as Ulong) as DrawIndex;
                            *ids.offset(5isize) = idx2.wrapping_add(0i32 as Ulong) as DrawIndex;
                            *ids.offset(6isize) = idx2.wrapping_add(1i32 as Ulong) as DrawIndex;
                            *ids.offset(7isize) = idx1.wrapping_add(1i32 as Ulong) as DrawIndex;
                            *ids.offset(8isize) = idx1.wrapping_add(0i32 as Ulong) as DrawIndex;
                            *ids.offset(9isize) = idx1.wrapping_add(0i32 as Ulong) as DrawIndex;
                            *ids.offset(10isize) = idx2.wrapping_add(0i32 as Ulong) as DrawIndex;
                            *ids.offset(11isize) = idx2.wrapping_add(1i32 as Ulong) as DrawIndex;
                            ids = ids.offset(12isize);
                            idx1 = idx2;
                            i1 = i1.wrapping_add(1)
                        }
                        /* fill vertices */
                        i = 0i32 as Size;
                        while i < points_count as Ulong {
                            let uv: Point = (*list).config.null.uv;
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *points.offset(i as isize),
                                uv,
                                col,
                            );
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i.wrapping_mul(2i32 as Ulong).wrapping_add(0i32 as Ulong)
                                        as isize,
                                ),
                                uv,
                                col_trans,
                            );
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i.wrapping_mul(2i32 as Ulong).wrapping_add(1i32 as Ulong)
                                        as isize,
                                ),
                                uv,
                                col_trans,
                            );
                            i = i.wrapping_add(1)
                        }
                    } else {
                        let mut idx1_0: Size = 0;
                        let mut i_0: Size = 0;
                        let half_inner_thickness: f32 = (thickness - AA_SIZE) * 0.5f32;
                        if 0 == closed as u64 {
                            d1 = Point::new(
                                (*normals.offset(0isize)).x * (half_inner_thickness + AA_SIZE),
                                (*normals.offset(0isize)).y * (half_inner_thickness + AA_SIZE),
                            );
                            d2 = Point::new(
                                (*normals.offset(0isize)).x * half_inner_thickness,
                                (*normals.offset(0isize)).y * half_inner_thickness,
                            );
                            *temp.offset(0isize) = Point::new(
                                (*points.offset(0isize)).x + d1.x,
                                (*points.offset(0isize)).y + d1.y,
                            );
                            *temp.offset(1isize) = Point::new(
                                (*points.offset(0isize)).x + d2.x,
                                (*points.offset(0isize)).y + d2.y,
                            );
                            *temp.offset(2isize) = Point::new(
                                (*points.offset(0isize)).x - d2.x,
                                (*points.offset(0isize)).y - d2.y,
                            );
                            *temp.offset(3isize) = Point::new(
                                (*points.offset(0isize)).x - d1.x,
                                (*points.offset(0isize)).y - d1.y,
                            );
                            d1 = Point::new(
                                (*normals.offset(points_count.wrapping_sub(1i32 as Uint) as isize))
                                    .x
                                    * (half_inner_thickness + AA_SIZE),
                                (*normals.offset(points_count.wrapping_sub(1i32 as Uint) as isize))
                                    .y
                                    * (half_inner_thickness + AA_SIZE),
                            );
                            d2 = Point::new(
                                (*normals.offset(points_count.wrapping_sub(1i32 as Uint) as isize))
                                    .x * half_inner_thickness,
                                (*normals.offset(points_count.wrapping_sub(1i32 as Uint) as isize))
                                    .y * half_inner_thickness,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as Uint)
                                    .wrapping_mul(4i32 as Uint)
                                    .wrapping_add(0i32 as Uint)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).x
                                    + d1.x,
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).y
                                    + d1.y,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as Uint)
                                    .wrapping_mul(4i32 as Uint)
                                    .wrapping_add(1i32 as Uint)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).x
                                    + d2.x,
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).y
                                    + d2.y,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as Uint)
                                    .wrapping_mul(4i32 as Uint)
                                    .wrapping_add(2i32 as Uint)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).x
                                    - d2.x,
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).y
                                    - d2.y,
                            );
                            *temp.offset(
                                points_count
                                    .wrapping_sub(1i32 as Uint)
                                    .wrapping_mul(4i32 as Uint)
                                    .wrapping_add(3i32 as Uint)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).x
                                    - d1.x,
                                (*points.offset(points_count.wrapping_sub(1i32 as Uint) as isize)).y
                                    - d1.y,
                            )
                        }
                        /* add all elements */
                        idx1_0 = index;
                        i1 = 0i32 as Size;
                        while i1 < count {
                            let mut dm_out: Point = Point { x: 0., y: 0. };
                            let mut dm_in: Point = Point { x: 0., y: 0. };
                            let i2_1: Size =
                                if i1.wrapping_add(1i32 as Ulong) == points_count as Ulong {
                                    0i32 as Ulong
                                } else {
                                    i1.wrapping_add(1i32 as Ulong)
                                };
                            let mut idx2_0: Size =
                                if i1.wrapping_add(1i32 as Ulong) == points_count as Ulong {
                                    index
                                } else {
                                    idx1_0.wrapping_add(4i32 as Ulong)
                                };
                            /* average normals */
                            let mut dm_0: Point = Point::new(
                                Point::new(
                                    (*normals.offset(i1 as isize)).x
                                        + (*normals.offset(i2_1 as isize)).x,
                                    (*normals.offset(i1 as isize)).y
                                        + (*normals.offset(i2_1 as isize)).y,
                                ).x * 0.5f32,
                                Point::new(
                                    (*normals.offset(i1 as isize)).x
                                        + (*normals.offset(i2_1 as isize)).x,
                                    (*normals.offset(i1 as isize)).y
                                        + (*normals.offset(i2_1 as isize)).y,
                                ).y * 0.5f32,
                            );
                            let mut dmr2_0: f32 = dm_0.x * dm_0.x + dm_0.y * dm_0.y;
                            if dmr2_0 > 9.999999974752428e-7f32 {
                                scale_0 = 1.0f32 / dmr2_0;
                                scale_0 = if 100.0f32 < scale_0 {
                                    100.0f32
                                } else {
                                    scale_0
                                };
                                dm_0 = Point::new(dm_0.x * scale_0, dm_0.y * scale_0)
                            }
                            dm_out = Point::new(
                                dm_0.x * (half_inner_thickness + AA_SIZE),
                                dm_0.y * (half_inner_thickness + AA_SIZE),
                            );
                            dm_in = Point::new(
                                dm_0.x * half_inner_thickness,
                                dm_0.y * half_inner_thickness,
                            );
                            *temp.offset(
                                i2_1.wrapping_mul(4i32 as Ulong).wrapping_add(0i32 as Ulong)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(i2_1 as isize)).x + dm_out.x,
                                (*points.offset(i2_1 as isize)).y + dm_out.y,
                            );
                            *temp.offset(
                                i2_1.wrapping_mul(4i32 as Ulong).wrapping_add(1i32 as Ulong)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(i2_1 as isize)).x + dm_in.x,
                                (*points.offset(i2_1 as isize)).y + dm_in.y,
                            );
                            *temp.offset(
                                i2_1.wrapping_mul(4i32 as Ulong).wrapping_add(2i32 as Ulong)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(i2_1 as isize)).x - dm_in.x,
                                (*points.offset(i2_1 as isize)).y - dm_in.y,
                            );
                            *temp.offset(
                                i2_1.wrapping_mul(4i32 as Ulong).wrapping_add(3i32 as Ulong)
                                    as isize,
                            ) = Point::new(
                                (*points.offset(i2_1 as isize)).x - dm_out.x,
                                (*points.offset(i2_1 as isize)).y - dm_out.y,
                            );
                            /* add indexes */
                            *ids.offset(0isize) = idx2_0.wrapping_add(1i32 as Ulong) as DrawIndex;
                            *ids.offset(1isize) = idx1_0.wrapping_add(1i32 as Ulong) as DrawIndex;
                            *ids.offset(2isize) = idx1_0.wrapping_add(2i32 as Ulong) as DrawIndex;
                            *ids.offset(3isize) = idx1_0.wrapping_add(2i32 as Ulong) as DrawIndex;
                            *ids.offset(4isize) = idx2_0.wrapping_add(2i32 as Ulong) as DrawIndex;
                            *ids.offset(5isize) = idx2_0.wrapping_add(1i32 as Ulong) as DrawIndex;
                            *ids.offset(6isize) = idx2_0.wrapping_add(1i32 as Ulong) as DrawIndex;
                            *ids.offset(7isize) = idx1_0.wrapping_add(1i32 as Ulong) as DrawIndex;
                            *ids.offset(8isize) = idx1_0.wrapping_add(0i32 as Ulong) as DrawIndex;
                            *ids.offset(9isize) = idx1_0.wrapping_add(0i32 as Ulong) as DrawIndex;
                            *ids.offset(10isize) = idx2_0.wrapping_add(0i32 as Ulong) as DrawIndex;
                            *ids.offset(11isize) = idx2_0.wrapping_add(1i32 as Ulong) as DrawIndex;
                            *ids.offset(12isize) = idx2_0.wrapping_add(2i32 as Ulong) as DrawIndex;
                            *ids.offset(13isize) = idx1_0.wrapping_add(2i32 as Ulong) as DrawIndex;
                            *ids.offset(14isize) = idx1_0.wrapping_add(3i32 as Ulong) as DrawIndex;
                            *ids.offset(15isize) = idx1_0.wrapping_add(3i32 as Ulong) as DrawIndex;
                            *ids.offset(16isize) = idx2_0.wrapping_add(3i32 as Ulong) as DrawIndex;
                            *ids.offset(17isize) = idx2_0.wrapping_add(2i32 as Ulong) as DrawIndex;
                            ids = ids.offset(18isize);
                            idx1_0 = idx2_0;
                            i1 = i1.wrapping_add(1)
                        }
                        /* add vertices */
                        i_0 = 0i32 as Size;
                        while i_0 < points_count as Ulong {
                            let uv_0: Point = (*list).config.null.uv;
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i_0.wrapping_mul(4i32 as Ulong).wrapping_add(0i32 as Ulong)
                                        as isize,
                                ),
                                uv_0,
                                col_trans,
                            );
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i_0.wrapping_mul(4i32 as Ulong).wrapping_add(1i32 as Ulong)
                                        as isize,
                                ),
                                uv_0,
                                col,
                            );
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i_0.wrapping_mul(4i32 as Ulong).wrapping_add(2i32 as Ulong)
                                        as isize,
                                ),
                                uv_0,
                                col,
                            );
                            vtx = nk_draw_vertex(
                                vtx,
                                &mut (*list).config,
                                *temp.offset(
                                    i_0.wrapping_mul(4i32 as Ulong).wrapping_add(3i32 as Ulong)
                                        as isize,
                                ),
                                uv_0,
                                col_trans,
                            );
                            i_0 = i_0.wrapping_add(1)
                        }
                    }
                    /* free temporary normals + points */
                    nk_buffer_reset((*list).vertices, NK_BUFFER_FRONT);
                }
            }
        } else {
            /* NON ANTI-ALIASED STROKE */
            let mut i1_0: Size = 0i32 as Size;
            let mut idx: Size = (*list).vertex_count as Size;
            let idx_count_0: Size = count.wrapping_mul(6i32 as Ulong);
            let vtx_count_0: Size = count.wrapping_mul(4i32 as Ulong);
            let mut vtx_0: *mut Void = nk_draw_list_alloc_vertices(list, vtx_count_0);
            let mut ids_0: *mut DrawIndex = nk_draw_list_alloc_elements(list, idx_count_0);
            if vtx_0.is_null() || ids_0.is_null() {
                return;
            } else {
                i1_0 = 0i32 as Size;
                while i1_0 < count {
                    let mut dx: f32 = 0.;
                    let mut dy: f32 = 0.;
                    let uv_1: Point = (*list).config.null.uv;
                    let i2_2: Size = if i1_0.wrapping_add(1i32 as Ulong) == points_count as Ulong {
                        0i32 as Ulong
                    } else {
                        i1_0.wrapping_add(1i32 as Ulong)
                    };
                    let p1: Point = *points.offset(i1_0 as isize);
                    let p2: Point = *points.offset(i2_2 as isize);
                    let mut diff_0: Point = Point::new(p2.x - p1.x, p2.y - p1.y);
                    let mut len_0: f32 = 0.;
                    /* point inverted length  */
                    len_0 = diff_0.x * diff_0.x + diff_0.y * diff_0.y;
                    if len_0 != 0.0f32 {
                        len_0 = nk_inv_sqrt(len_0)
                    } else {
                        len_0 = 1.0f32
                    }
                    diff_0 = Point::new(diff_0.x * len_0, diff_0.y * len_0);
                    /* add vertices */
                    dx = diff_0.x * (thickness * 0.5f32);
                    dy = diff_0.y * (thickness * 0.5f32);
                    vtx_0 = nk_draw_vertex(
                        vtx_0,
                        &mut (*list).config,
                        Point::new(p1.x + dy, p1.y - dx),
                        uv_1,
                        col,
                    );
                    vtx_0 = nk_draw_vertex(
                        vtx_0,
                        &mut (*list).config,
                        Point::new(p2.x + dy, p2.y - dx),
                        uv_1,
                        col,
                    );
                    vtx_0 = nk_draw_vertex(
                        vtx_0,
                        &mut (*list).config,
                        Point::new(p2.x - dy, p2.y + dx),
                        uv_1,
                        col,
                    );
                    vtx_0 = nk_draw_vertex(
                        vtx_0,
                        &mut (*list).config,
                        Point::new(p1.x - dy, p1.y + dx),
                        uv_1,
                        col,
                    );
                    *ids_0.offset(0isize) = idx.wrapping_add(0i32 as Ulong) as DrawIndex;
                    *ids_0.offset(1isize) = idx.wrapping_add(1i32 as Ulong) as DrawIndex;
                    *ids_0.offset(2isize) = idx.wrapping_add(2i32 as Ulong) as DrawIndex;
                    *ids_0.offset(3isize) = idx.wrapping_add(0i32 as Ulong) as DrawIndex;
                    *ids_0.offset(4isize) = idx.wrapping_add(2i32 as Ulong) as DrawIndex;
                    *ids_0.offset(5isize) = idx.wrapping_add(3i32 as Ulong) as DrawIndex;
                    ids_0 = ids_0.offset(6isize);
                    idx = (idx as Ulong).wrapping_add(4i32 as Ulong) as Size as Size;
                    i1_0 = i1_0.wrapping_add(1)
                }
            }
        }
        return;
    };
}
unsafe fn nk_inv_sqrt(mut n: f32) -> f32 {
    let mut x2: f32 = 0.;
    let threehalfs: f32 = 1.5f32;
    let mut conv: unnamed_3 = unnamed_3 { i: 0i32 as u32 };
    conv.f = n;
    x2 = n * 0.5f32;
    conv.i = (1597463172i32 as Uint).wrapping_sub(conv.i >> 1i32);
    conv.f = conv.f * (threehalfs - x2 * conv.f * conv.f);
    return conv.f;
}

pub unsafe fn nk_buffer_mark(mut buffer: *mut Buffer, mut type_0: BufferAllocationType) -> () {
    if buffer.is_null() {
        return;
    } else {
        (*buffer).marker[type_0 as usize].active = nk_true as Int;
        if type_0 as Uint == NK_BUFFER_BACK as Int as Uint {
            (*buffer).marker[type_0 as usize].offset = (*buffer).size
        } else {
            (*buffer).marker[type_0 as usize].offset = (*buffer).allocated
        }
        return;
    };
}

pub unsafe fn nk_draw_list_push_userdata(mut list: *mut DrawList, mut userdata: Handle) -> () {
    (*list).userdata = userdata;
}

pub unsafe fn nk_draw_list_path_line_to(mut list: *mut DrawList, mut pos: Point) -> () {
    let mut points: *mut Point = 0 as *mut Point;
    let mut cmd: *mut DrawCommand = 0 as *mut DrawCommand;
    if list.is_null() {
        return;
    } else {
        if 0 == (*list).cmd_count {
            nk_draw_list_add_clip(list, nk_null_rect);
        }
        cmd = nk_draw_list_command_last(list);
        if !cmd.is_null() && (*cmd).texture.ptr != (*list).config.null.texture.ptr {
            nk_draw_list_push_image(list, (*list).config.null.texture);
        }
        points = nk_draw_list_alloc_path(list, 1i32);
        if points.is_null() {
            return;
        } else {
            *points.offset(0isize) = pos;
            return;
        }
    };
}
unsafe fn nk_draw_list_alloc_path(mut list: *mut DrawList, mut count: Int) -> *mut Point {
    let mut memory: *mut Void = 0 as *mut Void;
    let mut points: *mut Point = 0 as *mut Point;
    const point_align: Size = mem::align_of::<Point>() as Size;
    const point_size: Size = mem::size_of::<Point>() as Size;
    points = nk_buffer_alloc(
        (*list).buffer,
        NK_BUFFER_FRONT,
        point_size.wrapping_mul(count as Size),
        point_align,
    ) as *mut Point;
    if points.is_null() {
        return 0 as *mut Point;
    } else {
        if 0 == (*list).path_offset {
            memory = nk_buffer_memory((*list).buffer);
            (*list).path_offset = (memory as *mut u8)
                .ptr_offset_to(points as *mut u8)
                .expect("bad offset_to") as Long as Uint
        }
        (*list).path_count = (*list).path_count.wrapping_add(count as Uint);
        return points;
    };
}
unsafe fn nk_draw_list_add_clip(mut list: *mut DrawList, mut rect: Rect) -> () {
    if list.is_null() {
        return;
    } else {
        if 0 == (*list).cmd_count {
            nk_draw_list_push_command(list, rect, (*list).config.null.texture);
        } else {
            let mut prev: *mut DrawCommand = nk_draw_list_command_last(list);
            if (*prev).elem_count == 0i32 as Uint {
                (*prev).clip_rect = rect
            }
            nk_draw_list_push_command(list, rect, (*prev).texture);
        }
        return;
    };
}

pub unsafe fn nk_draw_list_path_fill(mut list: *mut DrawList, mut color: Color) -> () {
    let mut points: *mut Point = 0 as *mut Point;
    if list.is_null() {
        return;
    } else {
        points = nk_buffer_memory((*list).buffer) as *mut Point;
        nk_draw_list_fill_poly_convex(
            list,
            points,
            (*list).path_count,
            color,
            (*list).config.shape_AA,
        );
        nk_draw_list_path_clear(list);
        return;
    };
}

pub unsafe fn nk_draw_list_fill_poly_convex(
    mut list: *mut DrawList,
    mut points: *const Point,
    points_count: Uint,
    mut color: Color,
    mut aliasing: AntiAliasing,
) -> () {
    let mut scale: f32 = 0.;
    let mut col: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut col_trans: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    const pnt_align: Size = mem::align_of::<Point>() as Size;
    const pnt_size: Size = mem::size_of::<Point>() as Size;
    if list.is_null() || points_count < 3i32 as Uint {
        return;
    } else {
        nk_draw_list_push_userdata(list, (*list).userdata);
        color.a = (color.a as f32 * (*list).config.global_alpha) as u8;
        nk_color_fv(&mut col.r, color);
        col_trans = col;
        col_trans.a = 0i32 as f32;
        if aliasing as Uint == NK_ANTI_ALIASING_ON as Int as Uint {
            let mut i: Size = 0i32 as Size;
            let mut i0: Size = 0i32 as Size;
            let mut i1: Size = 0i32 as Size;
            let AA_SIZE: f32 = 1.0f32;
            let mut vertex_offset: Size = 0i32 as Size;
            let mut index: Size = (*list).vertex_count as Size;
            let idx_count: Size = points_count
                .wrapping_sub(2i32 as Uint)
                .wrapping_mul(3i32 as Uint)
                .wrapping_add(points_count.wrapping_mul(6i32 as Uint))
                as Size;
            let vtx_count: Size = points_count.wrapping_mul(2i32 as Uint) as Size;
            let mut vtx: *mut Void = nk_draw_list_alloc_vertices(list, vtx_count);
            let mut ids: *mut DrawIndex = nk_draw_list_alloc_elements(list, idx_count);
            let mut size: Size = 0i32 as Size;
            let mut normals: *mut Point = 0 as *mut Point;
            let mut vtx_inner_idx: Uint = index.wrapping_add(0i32 as Ulong) as Uint;
            let mut vtx_outer_idx: Uint = index.wrapping_add(1i32 as Ulong) as Uint;
            if vtx.is_null() || ids.is_null() {
                return;
            } else {
                /* temporary allocate normals */
                vertex_offset = ((*(*list).vertices).memory.ptr as *mut u8)
                    .ptr_offset_to(vtx as *mut u8)
                    .expect("bad offset_to") as Long as Size;
                nk_buffer_mark((*list).vertices, NK_BUFFER_FRONT);
                size = pnt_size.wrapping_mul(points_count as Ulong);
                normals = nk_buffer_alloc((*list).vertices, NK_BUFFER_FRONT, size, pnt_align)
                    as *mut Point;
                if normals.is_null() {
                    return;
                } else {
                    vtx = ((*(*list).vertices).memory.ptr as *mut u8).offset(vertex_offset as isize)
                        as *mut Void;
                    /* add elements */
                    i = 2i32 as Size;
                    while i < points_count as Ulong {
                        *ids.offset(0isize) = vtx_inner_idx as DrawIndex;
                        *ids.offset(1isize) = (vtx_inner_idx as Ulong)
                            .wrapping_add(i.wrapping_sub(1i32 as Ulong) << 1i32)
                            as DrawIndex;
                        *ids.offset(2isize) =
                            (vtx_inner_idx as Ulong).wrapping_add(i << 1i32) as DrawIndex;
                        ids = ids.offset(3isize);
                        i = i.wrapping_add(1)
                    }
                    /* compute normals */
                    i0 = points_count.wrapping_sub(1i32 as Uint) as Size;
                    i1 = 0i32 as Size;
                    while i1 < points_count as Ulong {
                        let mut p0: Point = *points.offset(i0 as isize);
                        let mut p1: Point = *points.offset(i1 as isize);
                        let mut diff: Point = Point::new(p1.x - p0.x, p1.y - p0.y);
                        /* point inverted length  */
                        let mut len: f32 = diff.x * diff.x + diff.y * diff.y;
                        if len != 0.0f32 {
                            len = nk_inv_sqrt(len)
                        } else {
                            len = 1.0f32
                        }
                        diff = Point::new(diff.x * len, diff.y * len);
                        (*normals.offset(i0 as isize)).x = diff.y;
                        (*normals.offset(i0 as isize)).y = -diff.x;
                        let fresh8 = i1;
                        i1 = i1.wrapping_add(1);
                        i0 = fresh8
                    }
                    /* add vertices + indexes */
                    i0 = points_count.wrapping_sub(1i32 as Uint) as Size;
                    i1 = 0i32 as Size;
                    while i1 < points_count as Ulong {
                        let uv: Point = (*list).config.null.uv;
                        let mut n0: Point = *normals.offset(i0 as isize);
                        let mut n1: Point = *normals.offset(i1 as isize);
                        let mut dm: Point = Point::new(
                            Point::new(n0.x + n1.x, n0.y + n1.y).x * 0.5f32,
                            Point::new(n0.x + n1.x, n0.y + n1.y).y * 0.5f32,
                        );
                        let mut dmr2: f32 = dm.x * dm.x + dm.y * dm.y;
                        if dmr2 > 9.999999974752428e-7f32 {
                            scale = 1.0f32 / dmr2;
                            scale = if scale < 100.0f32 { scale } else { 100.0f32 };
                            dm = Point::new(dm.x * scale, dm.y * scale)
                        }
                        dm = Point::new(dm.x * (AA_SIZE * 0.5f32), dm.y * (AA_SIZE * 0.5f32));
                        /* add vertices */
                        vtx = nk_draw_vertex(
                            vtx,
                            &mut (*list).config,
                            Point::new(
                                (*points.offset(i1 as isize)).x - dm.x,
                                (*points.offset(i1 as isize)).y - dm.y,
                            ),
                            uv,
                            col,
                        );
                        vtx = nk_draw_vertex(
                            vtx,
                            &mut (*list).config,
                            Point::new(
                                (*points.offset(i1 as isize)).x + dm.x,
                                (*points.offset(i1 as isize)).y + dm.y,
                            ),
                            uv,
                            col_trans,
                        );
                        /* add indexes */
                        *ids.offset(0isize) =
                            (vtx_inner_idx as Ulong).wrapping_add(i1 << 1i32) as DrawIndex;
                        *ids.offset(1isize) =
                            (vtx_inner_idx as Ulong).wrapping_add(i0 << 1i32) as DrawIndex;
                        *ids.offset(2isize) =
                            (vtx_outer_idx as Ulong).wrapping_add(i0 << 1i32) as DrawIndex;
                        *ids.offset(3isize) =
                            (vtx_outer_idx as Ulong).wrapping_add(i0 << 1i32) as DrawIndex;
                        *ids.offset(4isize) =
                            (vtx_outer_idx as Ulong).wrapping_add(i1 << 1i32) as DrawIndex;
                        *ids.offset(5isize) =
                            (vtx_inner_idx as Ulong).wrapping_add(i1 << 1i32) as DrawIndex;
                        ids = ids.offset(6isize);
                        let fresh9 = i1;
                        i1 = i1.wrapping_add(1);
                        i0 = fresh9
                    }
                    /* free temporary normals + points */
                    nk_buffer_reset((*list).vertices, NK_BUFFER_FRONT);
                }
            }
        } else {
            let mut i_0: Size = 0i32 as Size;
            let mut index_0: Size = (*list).vertex_count as Size;
            let idx_count_0: Size = points_count
                .wrapping_sub(2i32 as Uint)
                .wrapping_mul(3i32 as Uint) as Size;
            let vtx_count_0: Size = points_count as Size;
            let mut vtx_0: *mut Void = nk_draw_list_alloc_vertices(list, vtx_count_0);
            let mut ids_0: *mut DrawIndex = nk_draw_list_alloc_elements(list, idx_count_0);
            if vtx_0.is_null() || ids_0.is_null() {
                return;
            } else {
                i_0 = 0i32 as Size;
                while i_0 < vtx_count_0 {
                    vtx_0 = nk_draw_vertex(
                        vtx_0,
                        &mut (*list).config,
                        *points.offset(i_0 as isize),
                        (*list).config.null.uv,
                        col,
                    );
                    i_0 = i_0.wrapping_add(1)
                }
                i_0 = 2i32 as Size;
                while i_0 < points_count as Ulong {
                    *ids_0.offset(0isize) = index_0 as DrawIndex;
                    *ids_0.offset(1isize) =
                        index_0.wrapping_add(i_0).wrapping_sub(1i32 as Ulong) as DrawIndex;
                    *ids_0.offset(2isize) = index_0.wrapping_add(i_0) as DrawIndex;
                    ids_0 = ids_0.offset(3isize);
                    i_0 = i_0.wrapping_add(1)
                }
            }
        }
        return;
    };
}

pub unsafe fn nk_draw_list_fill_triangle(
    mut list: *mut DrawList,
    mut a: Point,
    mut b: Point,
    mut c: Point,
    mut col: Color,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        nk_draw_list_path_line_to(list, a);
        nk_draw_list_path_line_to(list, b);
        nk_draw_list_path_line_to(list, c);
        nk_draw_list_path_fill(list, col);
        return;
    };
}

pub unsafe fn nk_draw_list_stroke_triangle(
    mut list: *mut DrawList,
    mut a: Point,
    mut b: Point,
    mut c: Point,
    mut col: Color,
    mut thickness: f32,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        nk_draw_list_path_line_to(list, a);
        nk_draw_list_path_line_to(list, b);
        nk_draw_list_path_line_to(list, c);
        nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
        return;
    };
}

pub unsafe fn nk_draw_list_path_arc_to(
    mut list: *mut DrawList,
    mut center: Point,
    mut radius: f32,
    mut a_min: f32,
    mut a_max: f32,
    mut segments: Uint,
) -> () {
    let mut i: Uint = 0i32 as Uint;
    if list.is_null() {
        return;
    } else if radius == 0.0f32 {
        return;
    } else {
        /*  This algorithm for arc drawing relies on these two trigonometric identities[1]:
            sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)
            cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b)

        Two coordinates (x, y) of a point on a circle centered on
        the origin can be written in polar form as:
            x = r * cos(a)
            y = r * sin(a)
        where r is the radius of the circle,
            a is the angle between (x, y) and the origin.

        This allows us to rotate the coordinates around the
        origin by an angle b using the following transformation:
            x' = r * cos(a + b) = x * cos(b) - y * sin(b)
            y' = r * sin(a + b) = y * cos(b) + x * sin(b)

        [1] https://en.wikipedia.org/wiki/List_of_trigonometric_identities#Angle_sum_and_difference_identities
    */
        let d_angle: f32 = (a_max - a_min) / segments as f32;
        let sin_d: f32 = nk_sin(d_angle);
        let cos_d: f32 = nk_cos(d_angle);
        let mut cx: f32 = nk_cos(a_min) * radius;
        let mut cy: f32 = nk_sin(a_min) * radius;
        i = 0i32 as Uint;
        while i <= segments {
            let mut new_cx: f32 = 0.;
            let mut new_cy: f32 = 0.;
            let x: f32 = center.x + cx;
            let y: f32 = center.y + cy;
            nk_draw_list_path_line_to(list, Point::new(x, y));
            new_cx = cx * cos_d - cy * sin_d;
            new_cy = cy * cos_d + cx * sin_d;
            cx = new_cx;
            cy = new_cy;
            i = i.wrapping_add(1)
        }
        return;
    };
}

pub unsafe fn nk_draw_list_fill_circle(
    mut list: *mut DrawList,
    mut center: Point,
    mut radius: f32,
    mut col: Color,
    mut segs: Uint,
) -> () {
    let mut a_max: f32 = 0.;
    if list.is_null() || 0 == col.a {
        return;
    } else {
        a_max = 3.1415927410125734f32 * 2.0f32 * (segs as f32 - 1.0f32) / segs as f32;
        nk_draw_list_path_arc_to(list, center, radius, 0.0f32, a_max, segs);
        nk_draw_list_path_fill(list, col);
        return;
    };
}

pub unsafe fn nk_draw_list_stroke_circle(
    mut list: *mut DrawList,
    mut center: Point,
    mut radius: f32,
    mut col: Color,
    mut segs: Uint,
    mut thickness: f32,
) -> () {
    let mut a_max: f32 = 0.;
    if list.is_null() || 0 == col.a {
        return;
    } else {
        a_max = 3.1415927410125734f32 * 2.0f32 * (segs as f32 - 1.0f32) / segs as f32;
        nk_draw_list_path_arc_to(list, center, radius, 0.0f32, a_max, segs);
        nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
        return;
    };
}

pub unsafe fn nk_draw_list_fill_rect_multi_color(
    mut list: *mut DrawList,
    mut rect: Rect,
    mut left: Color,
    mut top: Color,
    mut right: Color,
    mut bottom: Color,
) -> () {
    let mut vtx: *mut Void = 0 as *mut Void;
    let mut col_left: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut col_top: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut col_right: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut col_bottom: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    let mut idx: *mut DrawIndex = 0 as *mut DrawIndex;
    let mut index: DrawIndex = 0;
    nk_color_fv(&mut col_left.r, left);
    nk_color_fv(&mut col_right.r, right);
    nk_color_fv(&mut col_top.r, top);
    nk_color_fv(&mut col_bottom.r, bottom);
    if list.is_null() {
        return;
    } else {
        nk_draw_list_push_image(list, (*list).config.null.texture);
        index = (*list).vertex_count as DrawIndex;
        vtx = nk_draw_list_alloc_vertices(list, 4i32 as Size);
        idx = nk_draw_list_alloc_elements(list, 6i32 as Size);
        if vtx.is_null() || idx.is_null() {
            return;
        } else {
            *idx.offset(0isize) = (index as Int + 0i32) as DrawIndex;
            *idx.offset(1isize) = (index as Int + 1i32) as DrawIndex;
            *idx.offset(2isize) = (index as Int + 2i32) as DrawIndex;
            *idx.offset(3isize) = (index as Int + 0i32) as DrawIndex;
            *idx.offset(4isize) = (index as Int + 2i32) as DrawIndex;
            *idx.offset(5isize) = (index as Int + 3i32) as DrawIndex;
            vtx = nk_draw_vertex(
                vtx,
                &mut (*list).config,
                Point::new(rect.x, rect.y),
                (*list).config.null.uv,
                col_left,
            );
            vtx = nk_draw_vertex(
                vtx,
                &mut (*list).config,
                Point::new(rect.x + rect.w, rect.y),
                (*list).config.null.uv,
                col_top,
            );
            vtx = nk_draw_vertex(
                vtx,
                &mut (*list).config,
                Point::new(rect.x + rect.w, rect.y + rect.h),
                (*list).config.null.uv,
                col_right,
            );
            vtx = nk_draw_vertex(
                vtx,
                &mut (*list).config,
                Point::new(rect.x, rect.y + rect.h),
                (*list).config.null.uv,
                col_bottom,
            );
            return;
        }
    };
}

pub unsafe fn nk_draw_list_fill_rect(
    mut list: *mut DrawList,
    mut rect: Rect,
    mut col: Color,
    mut rounding: f32,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        if (*list).line_AA as Uint == NK_ANTI_ALIASING_ON as Int as Uint {
            nk_draw_list_path_rect_to(
                list,
                Point::new(rect.x, rect.y),
                Point::new(rect.x + rect.w, rect.y + rect.h),
                rounding,
            );
        } else {
            nk_draw_list_path_rect_to(
                list,
                Point::new(rect.x - 0.5f32, rect.y - 0.5f32),
                Point::new(rect.x + rect.w, rect.y + rect.h),
                rounding,
            );
        }
        nk_draw_list_path_fill(list, col);
        return;
    };
}

pub unsafe fn nk_draw_list_path_rect_to(
    mut list: *mut DrawList,
    mut a: Point,
    mut b: Point,
    mut rounding: f32,
) -> () {
    let mut r: f32 = 0.;
    if list.is_null() {
        return;
    } else {
        r = rounding;
        r = if r < if b.x - a.x < 0i32 as f32 {
            -(b.x - a.x)
        } else {
            b.x - a.x
        } {
            r
        } else if b.x - a.x < 0i32 as f32 {
            -(b.x - a.x)
        } else {
            b.x - a.x
        };
        r = if r < if b.y - a.y < 0i32 as f32 {
            -(b.y - a.y)
        } else {
            b.y - a.y
        } {
            r
        } else if b.y - a.y < 0i32 as f32 {
            -(b.y - a.y)
        } else {
            b.y - a.y
        };
        if r == 0.0f32 {
            nk_draw_list_path_line_to(list, a);
            nk_draw_list_path_line_to(list, Point::new(b.x, a.y));
            nk_draw_list_path_line_to(list, b);
            nk_draw_list_path_line_to(list, Point::new(a.x, b.y));
        } else {
            nk_draw_list_path_arc_to_fast(list, Point::new(a.x + r, a.y + r), r, 6i32, 9i32);
            nk_draw_list_path_arc_to_fast(list, Point::new(b.x - r, a.y + r), r, 9i32, 12i32);
            nk_draw_list_path_arc_to_fast(list, Point::new(b.x - r, b.y - r), r, 0i32, 3i32);
            nk_draw_list_path_arc_to_fast(list, Point::new(a.x + r, b.y - r), r, 3i32, 6i32);
        }
        return;
    };
}

pub unsafe fn nk_draw_list_path_arc_to_fast(
    mut list: *mut DrawList,
    mut center: Point,
    mut radius: f32,
    mut a_min: Int,
    mut a_max: Int,
) -> () {
    let mut a: Int = 0i32;
    if list.is_null() {
        return;
    } else {
        if a_min <= a_max {
            a = a_min;
            while a <= a_max {
                let c: Point = (*list).circle_vtx[(a as Size).wrapping_rem(
                    (mem::size_of::<[Point; 12]>() as Ulong)
                        .wrapping_div(mem::size_of::<Point>() as Ulong),
                ) as usize];
                let x: f32 = center.x + c.x * radius;
                let y: f32 = center.y + c.y * radius;
                nk_draw_list_path_line_to(list, Point::new(x, y));
                a += 1
            }
        }
        return;
    };
}

pub unsafe fn nk_draw_list_stroke_rect(
    mut list: *mut DrawList,
    mut rect: Rect,
    mut col: Color,
    mut rounding: f32,
    mut thickness: f32,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        if (*list).line_AA as Uint == NK_ANTI_ALIASING_ON as Int as Uint {
            nk_draw_list_path_rect_to(
                list,
                Point::new(rect.x, rect.y),
                Point::new(rect.x + rect.w, rect.y + rect.h),
                rounding,
            );
        } else {
            nk_draw_list_path_rect_to(
                list,
                Point::new(rect.x - 0.5f32, rect.y - 0.5f32),
                Point::new(rect.x + rect.w, rect.y + rect.h),
                rounding,
            );
        }
        nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
        return;
    };
}

pub unsafe fn nk_draw_list_stroke_curve(
    mut list: *mut DrawList,
    mut p0: Point,
    mut cp0: Point,
    mut cp1: Point,
    mut p1: Point,
    mut col: Color,
    mut segments: Uint,
    mut thickness: f32,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        nk_draw_list_path_line_to(list, p0);
        nk_draw_list_path_curve_to(list, cp0, cp1, p1, segments);
        nk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness);
        return;
    };
}

pub unsafe fn nk_draw_list_path_curve_to(
    mut list: *mut DrawList,
    mut p2: Point,
    mut p3: Point,
    mut p4: Point,
    mut num_segments: Uint,
) -> () {
    let mut t_step: f32 = 0.;
    let mut i_step: Uint = 0;
    let mut p1: Point = Point { x: 0., y: 0. };
    if list.is_null() || 0 == (*list).path_count {
        return;
    } else {
        num_segments = if num_segments < 1i32 as Uint {
            1i32 as Uint
        } else {
            num_segments
        };
        p1 = nk_draw_list_path_last(list);
        t_step = 1.0f32 / num_segments as f32;
        i_step = 1i32 as Uint;
        while i_step <= num_segments {
            let mut t: f32 = t_step * i_step as f32;
            let mut u: f32 = 1.0f32 - t;
            let mut w1: f32 = u * u * u;
            let mut w2: f32 = 3i32 as f32 * u * u * t;
            let mut w3: f32 = 3i32 as f32 * u * t * t;
            let mut w4: f32 = t * t * t;
            let mut x: f32 = w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x;
            let mut y: f32 = w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y;
            nk_draw_list_path_line_to(list, Point::new(x, y));
            i_step = i_step.wrapping_add(1)
        }
        return;
    };
}
unsafe fn nk_draw_list_path_last(mut list: *mut DrawList) -> Point {
    let mut memory: *mut Void = 0 as *mut Void;
    let mut point: *mut Point = 0 as *mut Point;
    memory = nk_buffer_memory((*list).buffer);
    point = (memory as *mut u8).offset((*list).path_offset as isize) as *mut Void as *mut Point;
    point = point.offset((*list).path_count.wrapping_sub(1i32 as Uint) as isize);
    return *point;
}

pub unsafe fn nk_draw_list_stroke_line(
    mut list: *mut DrawList,
    mut a: Point,
    mut b: Point,
    mut col: Color,
    mut thickness: f32,
) -> () {
    if list.is_null() || 0 == col.a {
        return;
    } else {
        if (*list).line_AA as Uint == NK_ANTI_ALIASING_ON as Int as Uint {
            nk_draw_list_path_line_to(list, a);
            nk_draw_list_path_line_to(list, b);
        } else {
            nk_draw_list_path_line_to(
                list,
                Point::new(
                    a.x - Point::new(0.5f32, 0.5f32).x,
                    a.y - Point::new(0.5f32, 0.5f32).y,
                ),
            );
            nk_draw_list_path_line_to(
                list,
                Point::new(
                    b.x - Point::new(0.5f32, 0.5f32).x,
                    b.y - Point::new(0.5f32, 0.5f32).y,
                ),
            );
        }
        nk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness);
        return;
    };
}

pub unsafe fn nk_draw_list_setup(
    mut canvas: *mut DrawList,
    mut config: *const ConvertConfig,
    mut cmds: *mut Buffer,
    mut vertices: *mut Buffer,
    mut elements: *mut Buffer,
    mut line_aa: AntiAliasing,
    mut shape_aa: AntiAliasing,
) -> () {
    if canvas.is_null()
        || config.is_null()
        || cmds.is_null()
        || vertices.is_null()
        || elements.is_null()
    {
        return;
    } else {
        (*canvas).buffer = cmds;
        (*canvas).config = *config;
        (*canvas).elements = elements;
        (*canvas).vertices = vertices;
        (*canvas).line_AA = line_aa;
        (*canvas).shape_AA = shape_aa;
        (*canvas).clip_rect = nk_null_rect;
        (*canvas).cmd_offset = 0i32 as Size;
        (*canvas).element_count = 0i32 as Uint;
        (*canvas).vertex_count = 0i32 as Uint;
        (*canvas).cmd_offset = 0i32 as Size;
        (*canvas).cmd_count = 0i32 as Uint;
        (*canvas).path_count = 0i32 as Uint;
        return;
    };
}

pub unsafe fn nk__draw_begin(
    mut ctx: *const Context,
    mut buffer: *const Buffer,
) -> *const DrawCommand {
    return nk__draw_list_begin(&(*ctx).draw_list, buffer);
}

pub unsafe fn nk__draw_list_begin(
    mut canvas: *const DrawList,
    mut buffer: *const Buffer,
) -> *const DrawCommand {
    let mut memory: *mut u8 = 0 as *mut u8;
    let mut offset: Size = 0;
    let mut cmd: *const DrawCommand = 0 as *const DrawCommand;
    if buffer.is_null() || 0 == (*buffer).size || 0 == (*canvas).cmd_count {
        return 0 as *const DrawCommand;
    } else {
        memory = (*buffer).memory.ptr as *mut u8;
        offset = (*buffer).memory.size.wrapping_sub((*canvas).cmd_offset);
        cmd = memory.offset(offset as isize) as *mut Void as *const DrawCommand;
        return cmd;
    };
}

pub unsafe fn nk__draw_end(
    mut ctx: *const Context,
    mut buffer: *const Buffer,
) -> *const DrawCommand {
    return nk__draw_list_end(&(*ctx).draw_list, buffer);
}

pub unsafe fn nk__draw_list_end(
    mut canvas: *const DrawList,
    mut buffer: *const Buffer,
) -> *const DrawCommand {
    let mut size: Size = 0;
    let mut offset: Size = 0;
    let mut memory: *mut u8 = 0 as *mut u8;
    let mut end: *const DrawCommand = 0 as *const DrawCommand;
    if buffer.is_null() || canvas.is_null() {
        return 0 as *const DrawCommand;
    } else {
        memory = (*buffer).memory.ptr as *mut u8;
        size = (*buffer).memory.size;
        offset = size.wrapping_sub((*canvas).cmd_offset);
        end = memory.offset(offset as isize) as *mut Void as *const DrawCommand;
        end = end.offset(-((*canvas).cmd_count.wrapping_sub(1i32 as Uint) as isize));
        return end;
    };
}

pub unsafe fn nk__draw_next(
    mut cmd: *const DrawCommand,
    mut buffer: *const Buffer,
    mut ctx: *const Context,
) -> *const DrawCommand {
    return nk__draw_list_next(cmd, buffer, &(*ctx).draw_list);
}

pub unsafe fn nk__draw_list_next(
    mut cmd: *const DrawCommand,
    mut buffer: *const Buffer,
    mut canvas: *const DrawList,
) -> *const DrawCommand {
    let mut end: *const DrawCommand = 0 as *const DrawCommand;
    if cmd.is_null() || buffer.is_null() || canvas.is_null() {
        return 0 as *const DrawCommand;
    } else {
        end = nk__draw_list_end(canvas, buffer);
        if cmd <= end {
            return 0 as *const DrawCommand;
        } else {
            return cmd.offset(-1isize);
        }
    };
}

pub unsafe fn nk_begin(
    mut ctx: *mut Context,
    mut title: *const Char,
    mut bounds: Rect,
    mut flags: Flags,
) -> Int {
    return nk_begin_titled(ctx, title, title, bounds, flags);
}

pub unsafe fn nk_begin_titled(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut title: *const Char,
    mut bounds: Rect,
    mut flags: Flags,
) -> Int {
    let mut name_hash: Hash = 0;
    let mut name_len: Int = 0;
    let mut ret: Int = 0;
    if ctx.is_null() || !(*ctx).current.is_null() || title.is_null() || name.is_null() {
        return 0;
    } else {
        /* find or create window */
        let mut style = &mut (*ctx).style as *mut Style;
        name_len = nk_strlen(name);
        name_hash = nk_murmur_hash(name as *const Void, name_len, NK_WINDOW_TITLE as Hash);
        let mut win = nk_find_window(ctx, name_hash, name);
        if win.is_null() {
            /* create new window */
            let mut name_length = name_len as Size;
            win = nk_create_window(ctx) as *mut Window;
            if win.is_null() {
                return 0;
            } else {
                if 0 != flags & NK_WINDOW_BACKGROUND as Uint {
                    nk_insert_window(ctx, win, NK_INSERT_FRONT);
                } else {
                    nk_insert_window(ctx, win, NK_INSERT_BACK);
                }
                nk_command_buffer_init(&mut (*win).buffer, &mut (*ctx).memory, NK_CLIPPING_ON);
                (*win).flags = flags;
                (*win).bounds = bounds;
                (*win).name = name_hash;
                name_length = name_length.min(64 - 1);
                nk_memcopy(
                    (*win).name_string.as_mut_ptr() as *mut Void,
                    name as *const Void,
                    name_length,
                );
                (*win).name_string[name_length as usize] = 0;
                (*win).popup.win = ptr::null_mut();
                if (*ctx).active.is_null() {
                    (*ctx).active = win
                }
            }
        } else {
            /* update window */
            (*win).flags &= !((NK_WINDOW_PRIVATE as Int - 1) as Flags);
            (*win).flags |= flags;
            if 0 == (*win).flags & (NK_WINDOW_MOVABLE as Int | NK_WINDOW_SCALABLE as Int) as Uint {
                (*win).bounds = bounds
            }
            /* If this assert triggers you either:
             *
             * I.) Have more than one window with the same name or
             * II.) You forgot to actually draw the window.
             *      More specific you did not call `nk_clear` (nk_clear will be
             *      automatically called for you if you are using one of the
             *      provided demo backends). */
            (*win).seq = (*ctx).seq;
            if (*ctx).active.is_null() && 0 == (*win).flags & NK_WINDOW_HIDDEN as Uint {
                (*ctx).active = win;
                (*ctx).end = win
            }
        }
        if 0 != (*win).flags & NK_WINDOW_HIDDEN as Uint {
            (*ctx).current = win;
            (*win).layout = ptr::null_mut();
            return 0;
        } else {
            nk_start(ctx, win);
            /* window overlapping */
            if 0 == (*win).flags & NK_WINDOW_HIDDEN as Uint
                && 0 == (*win).flags & NK_WINDOW_NO_INPUT as Uint
            {
                let mut inpanel = 0;
                let mut ishovered = 0;
                let mut iter = win;
                let mut h = (*(*ctx).style.font).height
                    + 2.0 * (*style).window.header.padding.y
                    + 2.0 * (*style).window.header.label_padding.y;
                let mut win_bounds: Rect = if 0 == (*win).flags & NK_WINDOW_MINIMIZED as Int as Uint
                {
                    (*win).bounds
                } else {
                    Rect::new((*win).bounds.x, (*win).bounds.y, (*win).bounds.w, h)
                };
                /* activate window if hovered and no other window is overlapping this window */
                inpanel = nk_input_has_mouse_click_down_in_rect(
                    &mut (*ctx).input,
                    NK_BUTTON_LEFT,
                    win_bounds,
                    nk_true as Int,
                );
                inpanel = (0 != inpanel
                    && 0 != (*ctx).input.mouse.buttons[NK_BUTTON_LEFT as Int as usize].clicked)
                    as Int;
                ishovered = nk_input_is_mouse_hovering_rect(&mut (*ctx).input, win_bounds);
                if win != (*ctx).active
                    && 0 != ishovered
                    && 0 == (*ctx).input.mouse.buttons[NK_BUTTON_LEFT as Int as usize].down
                {
                    iter = (*win).next;
                    while !iter.is_null() {
                        let mut iter_bounds: Rect =
                            if 0 == (*iter).flags & NK_WINDOW_MINIMIZED as Int as Uint {
                                (*iter).bounds
                            } else {
                                Rect::new((*iter).bounds.x, (*iter).bounds.y, (*iter).bounds.w, h)
                            };
                        if !(iter_bounds.x > win_bounds.x + win_bounds.w
                            || iter_bounds.x + iter_bounds.w < win_bounds.x
                            || iter_bounds.y > win_bounds.y + win_bounds.h
                            || iter_bounds.y + iter_bounds.h < win_bounds.y)
                            && 0 == (*iter).flags & NK_WINDOW_HIDDEN as Int as Uint
                        {
                            break;
                        }
                        if !(*iter).popup.win.is_null()
                            && 0 != (*iter).popup.active
                            && 0 == (*iter).flags & NK_WINDOW_HIDDEN as Int as Uint
                            && !((*(*iter).popup.win).bounds.x > (*win).bounds.x + win_bounds.w
                                || (*(*iter).popup.win).bounds.x + (*(*iter).popup.win).bounds.w
                                    < (*win).bounds.x
                                || (*(*iter).popup.win).bounds.y > win_bounds.y + win_bounds.h
                                || (*(*iter).popup.win).bounds.y + (*(*iter).popup.win).bounds.h
                                    < win_bounds.y)
                        {
                            break;
                        }
                        iter = (*iter).next
                    }
                }
                /* activate window if clicked */
                if !iter.is_null() && 0 != inpanel && win != (*ctx).end {
                    iter = (*win).next;
                    while !iter.is_null() {
                        /* try to find a panel with higher priority in the same position */
                        let mut iter_bounds_0: Rect =
                            if 0 == (*iter).flags & NK_WINDOW_MINIMIZED as Int as Uint {
                                (*iter).bounds
                            } else {
                                Rect::new((*iter).bounds.x, (*iter).bounds.y, (*iter).bounds.w, h)
                            };
                        if iter_bounds_0.x <= (*ctx).input.mouse.pos.x
                            && (*ctx).input.mouse.pos.x < iter_bounds_0.x + iter_bounds_0.w
                            && (iter_bounds_0.y <= (*ctx).input.mouse.pos.y
                                && (*ctx).input.mouse.pos.y < iter_bounds_0.y + iter_bounds_0.h)
                            && 0 == (*iter).flags & NK_WINDOW_HIDDEN as Int as Uint
                        {
                            break;
                        }
                        if !(*iter).popup.win.is_null()
                            && 0 != (*iter).popup.active
                            && 0 == (*iter).flags & NK_WINDOW_HIDDEN as Int as Uint
                            && !((*(*iter).popup.win).bounds.x > win_bounds.x + win_bounds.w
                                || (*(*iter).popup.win).bounds.x + (*(*iter).popup.win).bounds.w
                                    < win_bounds.x
                                || (*(*iter).popup.win).bounds.y > win_bounds.y + win_bounds.h
                                || (*(*iter).popup.win).bounds.y + (*(*iter).popup.win).bounds.h
                                    < win_bounds.y)
                        {
                            break;
                        }
                        iter = (*iter).next
                    }
                }
                if !iter.is_null()
                    && 0 == (*win).flags & NK_WINDOW_ROM as Int as Uint
                    && 0 != (*win).flags & NK_WINDOW_BACKGROUND as Int as Uint
                {
                    (*win).flags |= NK_WINDOW_ROM as Int as Flags;
                    (*iter).flags &= !(NK_WINDOW_ROM as Int as Flags);
                    (*ctx).active = iter;
                    if 0 == (*iter).flags & NK_WINDOW_BACKGROUND as Int as Uint {
                        /* current window is active in that position so transfer to top
                         * at the highest priority in stack */
                        nk_remove_window(ctx, iter);
                        nk_insert_window(ctx, iter, NK_INSERT_BACK);
                    }
                } else {
                    if iter.is_null() && (*ctx).end != win {
                        if 0 == (*win).flags & NK_WINDOW_BACKGROUND as Int as Uint {
                            /* current window is active in that position so transfer to top
                             * at the highest priority in stack */
                            nk_remove_window(ctx, win);
                            nk_insert_window(ctx, win, NK_INSERT_BACK);
                        }
                        (*win).flags &= !(NK_WINDOW_ROM as Int as Flags);
                        (*ctx).active = win
                    }
                    if (*ctx).end != win && 0 == (*win).flags & NK_WINDOW_BACKGROUND as Int as Uint
                    {
                        (*win).flags |= NK_WINDOW_ROM as Int as Uint
                    }
                }
            }
            (*win).layout = nk_create_panel(ctx) as *mut Panel;
            (*ctx).current = win;
            ret = nk_panel_begin(ctx, title, NK_PANEL_WINDOW);
            (*(*win).layout).offset_x = &mut (*win).scrollbar.x as *mut u32;
            (*(*win).layout).offset_y = &mut (*win).scrollbar.y as *mut u32;
            return ret;
        }
    };
}
unsafe fn nk_panel_begin(
    mut ctx: *mut Context,
    mut title: *const Char,
    mut panel_type: PanelType,
) -> Int {
    let mut in_0: *mut Input = 0 as *mut Input;
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut out: *mut CommandBuffer = 0 as *mut CommandBuffer;
    let mut style: *const Style = 0 as *const Style;
    let mut font: *const UserFont = 0 as *const UserFont;
    let mut scrollbar_size: Point = Point { x: 0., y: 0. };
    let mut panel_padding: Point = Point { x: 0., y: 0. };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        nk_zero(
            (*(*ctx).current).layout as *mut Void,
            mem::size_of::<Panel>() as Ulong,
        );
        if 0 != (*(*ctx).current).flags & NK_WINDOW_HIDDEN as Int as Uint
            || 0 != (*(*ctx).current).flags & NK_WINDOW_CLOSED as Int as Uint
        {
            nk_zero(
                (*(*ctx).current).layout as *mut Void,
                mem::size_of::<Panel>() as Ulong,
            );
            (*(*(*ctx).current).layout).type_0 = panel_type;
            return 0i32;
        } else {
            /* pull state into local stack */
            style = &mut (*ctx).style as *mut Style;
            font = (*style).font;
            win = (*ctx).current;
            layout = (*win).layout;
            out = &mut (*win).buffer as *mut CommandBuffer;
            in_0 = if 0 != (*win).flags & NK_WINDOW_NO_INPUT as Int as Uint {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            (*win).buffer.userdata = (*ctx).userdata;
            /* pull style configuration into local stack */
            scrollbar_size = (*style).window.scrollbar_size;
            panel_padding = nk_panel_get_padding(style, panel_type);
            /* window movement */
            if 0 != (*win).flags & NK_WINDOW_MOVABLE as Int as Uint
                && 0 == (*win).flags & NK_WINDOW_ROM as Int as Uint
            {
                let mut left_mouse_down: Int = 0;
                let mut left_mouse_clicked: Int = 0;
                let mut left_mouse_click_in_cursor: Int = 0;
                /* calculate draggable window space */
                let mut header: Rect = Rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                header.x = (*win).bounds.x;
                header.y = (*win).bounds.y;
                header.w = (*win).bounds.w;
                if 0 != nk_panel_has_header((*win).flags, title) {
                    header.h = (*font).height + 2.0f32 * (*style).window.header.padding.y;
                    header.h += 2.0f32 * (*style).window.header.label_padding.y
                } else {
                    header.h = panel_padding.y
                }
                /* window movement by dragging */
                left_mouse_down = (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down;
                left_mouse_clicked =
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].clicked as Int;
                left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(
                    in_0,
                    NK_BUTTON_LEFT,
                    header,
                    nk_true as Int,
                );
                if 0 != left_mouse_down
                    && 0 != left_mouse_click_in_cursor
                    && 0 == left_mouse_clicked
                {
                    (*win).bounds.x = (*win).bounds.x + (*in_0).mouse.delta.x;
                    (*win).bounds.y = (*win).bounds.y + (*in_0).mouse.delta.y;
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize]
                        .clicked_pos
                        .x += (*in_0).mouse.delta.x;
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize]
                        .clicked_pos
                        .y += (*in_0).mouse.delta.y;
                    (*ctx).style.cursor_active =
                        (*ctx).style.cursors[NK_CURSOR_MOVE as Int as usize]
                }
            }
            /* setup panel */
            (*layout).type_0 = panel_type;
            (*layout).flags = (*win).flags;
            (*layout).bounds = (*win).bounds;
            (*layout).bounds.x += panel_padding.x;
            (*layout).bounds.w -= 2i32 as f32 * panel_padding.x;
            if 0 != (*win).flags & NK_WINDOW_BORDER as Int as Uint {
                (*layout).border = nk_panel_get_border(style, (*win).flags, panel_type);
                (*layout).bounds = nk_shrink_rect((*layout).bounds, (*layout).border)
            } else {
                (*layout).border = 0i32 as f32
            }
            (*layout).at_y = (*layout).bounds.y;
            (*layout).at_x = (*layout).bounds.x;
            (*layout).max_x = 0i32 as f32;
            (*layout).header_height = 0i32 as f32;
            (*layout).footer_height = 0i32 as f32;
            nk_layout_reset_min_row_height(ctx);
            (*layout).row.index = 0i32;
            (*layout).row.columns = 0i32;
            (*layout).row.ratio = 0 as *const f32;
            (*layout).row.item_width = 0i32 as f32;
            (*layout).row.tree_depth = 0i32;
            (*layout).row.height = panel_padding.y;
            (*layout).has_scrolling = nk_true as Int as Uint;
            if 0 == (*win).flags & NK_WINDOW_NO_SCROLLBAR as Int as Uint {
                (*layout).bounds.w -= scrollbar_size.x
            }
            if 0 == nk_panel_is_nonblock(panel_type) {
                (*layout).footer_height = 0i32 as f32;
                if 0 == (*win).flags & NK_WINDOW_NO_SCROLLBAR as Int as Uint
                    || 0 != (*win).flags & NK_WINDOW_SCALABLE as Int as Uint
                {
                    (*layout).footer_height = scrollbar_size.y
                }
                (*layout).bounds.h -= (*layout).footer_height
            }
            /* panel header */
            if 0 != nk_panel_has_header((*win).flags, title) {
                let mut text: Text = Text {
                    padding: Point { x: 0., y: 0. },
                    background: Color {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0,
                    },
                    text: Color {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0,
                    },
                };
                let mut header_0: Rect = Rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                let mut background: *const StyleItem = 0 as *const StyleItem;
                /* calculate header bounds */
                header_0.x = (*win).bounds.x;
                header_0.y = (*win).bounds.y;
                header_0.w = (*win).bounds.w;
                header_0.h = (*font).height + 2.0f32 * (*style).window.header.padding.y;
                header_0.h += 2.0f32 * (*style).window.header.label_padding.y;
                /* shrink panel by header */
                (*layout).header_height = header_0.h;
                (*layout).bounds.y += header_0.h;
                (*layout).bounds.h -= header_0.h;
                (*layout).at_y += header_0.h;
                /* select correct header background and text color */
                if (*ctx).active == win {
                    background = &(*style).window.header.active as *const StyleItem;
                    text.text = (*style).window.header.label_active
                } else if 0 != nk_input_is_mouse_hovering_rect(&mut (*ctx).input, header_0) {
                    background = &(*style).window.header.hover as *const StyleItem;
                    text.text = (*style).window.header.label_hover
                } else {
                    background = &(*style).window.header.normal as *const StyleItem;
                    text.text = (*style).window.header.label_normal
                }
                /* draw header background */
                header_0.h += 1.0f32;
                if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                    text.background = nk_rgba(0i32, 0i32, 0i32, 0i32);
                    nk_draw_image(
                        &mut (*win).buffer,
                        header_0,
                        &(*background).data.image,
                        nk_white,
                    );
                } else {
                    text.background = (*background).data.color;
                    nk_fill_rect(out, header_0, 0i32 as f32, (*background).data.color);
                }
                /* window close button */
                let mut button: Rect = Rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                button.y = header_0.y + (*style).window.header.padding.y;
                button.h = header_0.h - 2i32 as f32 * (*style).window.header.padding.y;
                button.w = button.h;
                if 0 != (*win).flags & NK_WINDOW_CLOSABLE as Int as Uint {
                    let mut ws: Flags = 0i32 as Flags;
                    if (*style).window.header.align as Uint == NK_HEADER_RIGHT as Int as Uint {
                        button.x =
                            header_0.w + header_0.x - (button.w + (*style).window.header.padding.x);
                        header_0.w -= button.w
                            + (*style).window.header.spacing.x
                            + (*style).window.header.padding.x
                    } else {
                        button.x = header_0.x + (*style).window.header.padding.x;
                        header_0.x += button.w
                            + (*style).window.header.spacing.x
                            + (*style).window.header.padding.x
                    }
                    if 0 != nk_do_button_symbol(
                        &mut ws,
                        &mut (*win).buffer,
                        button,
                        (*style).window.header.close_symbol,
                        NK_BUTTON_DEFAULT,
                        &(*style).window.header.close_button,
                        in_0,
                        (*style).font,
                    ) && 0 == (*win).flags & NK_WINDOW_ROM as Int as Uint
                    {
                        (*layout).flags |= NK_WINDOW_HIDDEN as Int as Uint;
                        (*layout).flags &= !(NK_WINDOW_MINIMIZED as Int) as Flags
                    }
                }
                /* window minimize button */
                if 0 != (*win).flags & NK_WINDOW_MINIMIZABLE as Int as Uint {
                    let mut ws_0: Flags = 0i32 as Flags;
                    if (*style).window.header.align as Uint == NK_HEADER_RIGHT as Int as Uint {
                        button.x = header_0.w + header_0.x - button.w;
                        if 0 == (*win).flags & NK_WINDOW_CLOSABLE as Int as Uint {
                            button.x -= (*style).window.header.padding.x;
                            header_0.w -= (*style).window.header.padding.x
                        }
                        header_0.w -= button.w + (*style).window.header.spacing.x
                    } else {
                        button.x = header_0.x;
                        header_0.x += button.w
                            + (*style).window.header.spacing.x
                            + (*style).window.header.padding.x
                    }
                    if 0 != nk_do_button_symbol(
                        &mut ws_0,
                        &mut (*win).buffer,
                        button,
                        (if 0 != (*layout).flags & NK_WINDOW_MINIMIZED as Int as Uint {
                            (*style).window.header.maximize_symbol as Uint
                        } else {
                            (*style).window.header.minimize_symbol as Uint
                        }) as SymbolType,
                        NK_BUTTON_DEFAULT,
                        &(*style).window.header.minimize_button,
                        in_0,
                        (*style).font,
                    ) && 0 == (*win).flags & NK_WINDOW_ROM as Int as Uint
                    {
                        (*layout).flags =
                            if 0 != (*layout).flags & NK_WINDOW_MINIMIZED as Int as Uint {
                                (*layout).flags & !(NK_WINDOW_MINIMIZED as Int) as Flags
                            } else {
                                (*layout).flags | NK_WINDOW_MINIMIZED as Int as Uint
                            }
                    }
                }
                /* window header title */
                let mut text_len: Int = nk_strlen(title);
                let mut label: Rect = Rect {
                    x: 0i32 as f32,
                    y: 0i32 as f32,
                    w: 0i32 as f32,
                    h: 0i32 as f32,
                };
                let mut t: f32 = (*font).width.expect("non-null function pointer")(
                    (*font).userdata,
                    (*font).height,
                    title,
                    text_len,
                );
                text.padding = Point::new(0i32 as f32, 0i32 as f32);
                label.x = header_0.x + (*style).window.header.padding.x;
                label.x += (*style).window.header.label_padding.x;
                label.y = header_0.y + (*style).window.header.label_padding.y;
                label.h = (*font).height + 2i32 as f32 * (*style).window.header.label_padding.y;
                label.w = t + 2i32 as f32 * (*style).window.header.spacing.x;
                label.w = if if label.w < header_0.x + header_0.w - label.x {
                    label.w
                } else {
                    header_0.x + header_0.w - label.x
                } < 0i32 as f32
                {
                    0i32 as f32
                } else if label.w < header_0.x + header_0.w - label.x {
                    label.w
                } else {
                    header_0.x + header_0.w - label.x
                };
                nk_widget_text(
                    out,
                    label,
                    title,
                    text_len,
                    &mut text,
                    NK_TEXT_LEFT as Int as Flags,
                    font,
                );
            }
            /* draw window background */
            if 0 == (*layout).flags & NK_WINDOW_MINIMIZED as Int as Uint
                && 0 == (*layout).flags & NK_WINDOW_DYNAMIC as Int as Uint
            {
                let mut body: Rect = Rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                body.x = (*win).bounds.x;
                body.w = (*win).bounds.w;
                body.y = (*win).bounds.y + (*layout).header_height;
                body.h = (*win).bounds.h - (*layout).header_height;
                if (*style).window.fixed_background.type_0 as Uint
                    == NK_STYLE_ITEM_IMAGE as Int as Uint
                {
                    nk_draw_image(
                        out,
                        body,
                        &(*style).window.fixed_background.data.image,
                        nk_white,
                    );
                } else {
                    nk_fill_rect(
                        out,
                        body,
                        0i32 as f32,
                        (*style).window.fixed_background.data.color,
                    );
                }
            }
            /* set clipping rectangle */
            let mut clip: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            (*layout).clip = (*layout).bounds;
            nk_unify(
                &mut clip,
                &mut (*win).buffer.clip,
                (*layout).clip.x,
                (*layout).clip.y,
                (*layout).clip.x + (*layout).clip.w,
                (*layout).clip.y + (*layout).clip.h,
            );
            nk_push_scissor(out, clip);
            (*layout).clip = clip;
            return (0 == (*layout).flags & NK_WINDOW_HIDDEN as Int as Uint
                && 0 == (*layout).flags & NK_WINDOW_MINIMIZED as Int as Uint)
                as Int;
        }
    };
}

pub unsafe fn nk_push_scissor(mut b: *mut CommandBuffer, mut r: Rect) -> () {
    let mut cmd: *mut CommandScissor = 0 as *mut CommandScissor;
    if b.is_null() {
        return;
    } else {
        (*b).clip.x = r.x;
        (*b).clip.y = r.y;
        (*b).clip.w = r.w;
        (*b).clip.h = r.h;
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_SCISSOR,
            mem::size_of::<CommandScissor>() as Ulong,
        ) as *mut CommandScissor;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).x = r.x as Short;
            (*cmd).y = r.y as Short;
            (*cmd).w = (if (0i32 as f32) < r.w {
                r.w
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).h = (if (0i32 as f32) < r.h {
                r.h
            } else {
                0i32 as f32
            }) as Ushort;
            return;
        }
    };
}
unsafe fn nk_unify(
    mut clip: *mut Rect,
    mut a: *const Rect,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
) -> () {
    (*clip).x = if (*a).x < x0 { x0 } else { (*a).x };
    (*clip).y = if (*a).y < y0 { y0 } else { (*a).y };
    (*clip).w = if (*a).x + (*a).w < x1 {
        (*a).x + (*a).w
    } else {
        x1
    } - (*clip).x;
    (*clip).h = if (*a).y + (*a).h < y1 {
        (*a).y + (*a).h
    } else {
        y1
    } - (*clip).y;
    (*clip).w = if (0i32 as f32) < (*clip).w {
        (*clip).w
    } else {
        0i32 as f32
    };
    (*clip).h = if (0i32 as f32) < (*clip).h {
        (*clip).h
    } else {
        0i32 as f32
    };
}

pub unsafe fn nk_fill_rect(
    mut b: *mut CommandBuffer,
    mut rect: Rect,
    mut rounding: f32,
    mut c: Color,
) -> () {
    let mut cmd: *mut CommandRectFilled = 0 as *mut CommandRectFilled;
    if b.is_null() || c.a as Int == 0i32 || rect.w == 0i32 as f32 || rect.h == 0i32 as f32 {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const Rect = &mut (*b).clip as *mut Rect;
            if (*clip).x > rect.x + rect.w
                || (*clip).x + (*clip).w < rect.x
                || (*clip).y > rect.y + rect.h
                || (*clip).y + (*clip).h < rect.y
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_RECT_FILLED,
            mem::size_of::<CommandRectFilled>() as Ulong,
        ) as *mut CommandRectFilled;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).rounding = rounding as Ushort;
            (*cmd).x = rect.x as Short;
            (*cmd).y = rect.y as Short;
            (*cmd).w = (if (0i32 as f32) < rect.w {
                rect.w
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).h = (if (0i32 as f32) < rect.h {
                rect.h
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).color = c;
            return;
        }
    };
}

pub unsafe fn nk_strlen(mut str: *const Char) -> Int {
    let mut siz: Int = 0i32;
    while !str.is_null() && {
        let fresh10 = str;
        str = str.offset(1);
        *fresh10 as Int != '\u{0}' as i32
    } {
        siz += 1
    }
    return siz;
}
unsafe fn nk_widget_text(
    mut o: *mut CommandBuffer,
    mut b: Rect,
    mut string: *const Char,
    mut len: Int,
    mut t: *const Text,
    mut a: Flags,
    mut f: *const UserFont,
) -> () {
    let mut label: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut text_width: f32 = 0.;
    if o.is_null() || t.is_null() {
        return;
    } else {
        b.h = if b.h < 2i32 as f32 * (*t).padding.y {
            2i32 as f32 * (*t).padding.y
        } else {
            b.h
        };
        label.x = 0i32 as f32;
        label.w = 0i32 as f32;
        label.y = b.y + (*t).padding.y;
        label.h = if (*f).height < b.h - 2i32 as f32 * (*t).padding.y {
            (*f).height
        } else {
            b.h - 2i32 as f32 * (*t).padding.y
        };
        text_width =
            (*f).width.expect("non-null function pointer")((*f).userdata, (*f).height, string, len);
        text_width += 2.0f32 * (*t).padding.x;
        /* align in x-axis */
        if 0 != a & NK_TEXT_ALIGN_LEFT as Int as Uint {
            label.x = b.x + (*t).padding.x;
            label.w = if (0i32 as f32) < b.w - 2i32 as f32 * (*t).padding.x {
                b.w - 2i32 as f32 * (*t).padding.x
            } else {
                0i32 as f32
            }
        } else if 0 != a & NK_TEXT_ALIGN_CENTERED as Int as Uint {
            label.w = if (1i32 as f32) < 2i32 as f32 * (*t).padding.x + text_width {
                2i32 as f32 * (*t).padding.x + text_width
            } else {
                1i32 as f32
            };
            label.x =
                b.x + (*t).padding.x + (b.w - 2i32 as f32 * (*t).padding.x - label.w) / 2i32 as f32;
            label.x = if b.x + (*t).padding.x < label.x {
                label.x
            } else {
                b.x + (*t).padding.x
            };
            label.w = if b.x + b.w < label.x + label.w {
                b.x + b.w
            } else {
                label.x + label.w
            };
            if label.w >= label.x {
                label.w -= label.x
            }
        } else if 0 != a & NK_TEXT_ALIGN_RIGHT as Int as Uint {
            label.x =
                if b.x + (*t).padding.x < b.x + b.w - (2i32 as f32 * (*t).padding.x + text_width) {
                    b.x + b.w - (2i32 as f32 * (*t).padding.x + text_width)
                } else {
                    b.x + (*t).padding.x
                };
            label.w = text_width + 2i32 as f32 * (*t).padding.x
        } else {
            return;
        }
        /* align in y-axis */
        if 0 != a & NK_TEXT_ALIGN_MIDDLE as Int as Uint {
            label.y = b.y + b.h / 2.0f32 - (*f).height / 2.0f32;
            label.h = if b.h / 2.0f32 < b.h - (b.h / 2.0f32 + (*f).height / 2.0f32) {
                b.h - (b.h / 2.0f32 + (*f).height / 2.0f32)
            } else {
                b.h / 2.0f32
            }
        } else if 0 != a & NK_TEXT_ALIGN_BOTTOM as Int as Uint {
            label.y = b.y + b.h - (*f).height;
            label.h = (*f).height
        }
        nk_draw_text(o, label, string, len, f, (*t).background, (*t).text);
        return;
    };
}

pub unsafe fn nk_draw_text(
    mut b: *mut CommandBuffer,
    mut r: Rect,
    mut string: *const Char,
    mut length: Int,
    mut font: *const UserFont,
    mut bg: Color,
    mut fg: Color,
) -> () {
    let mut glyphs: Int = 0;
    let mut txt_width: f32 = 0.;
    let mut text_width: f32 = 0i32 as f32;
    let mut cmd: *mut CommandText = 0 as *mut CommandText;
    if b.is_null() || string.is_null() || 0 == length || bg.a as Int == 0i32 && fg.a as Int == 0i32
    {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut c: *const Rect = &mut (*b).clip as *mut Rect;
            if (*c).w == 0i32 as f32 || (*c).h == 0i32 as f32
                || ((*c).x > r.x + r.w
                    || (*c).x + (*c).w < r.x
                    || (*c).y > r.y + r.h
                    || (*c).y + (*c).h < r.y)
            {
                return;
            }
        }
        /* make sure text fits inside bounds */
        text_width = (*font).width.expect("non-null function pointer")(
            (*font).userdata,
            (*font).height,
            string,
            length,
        );
        if text_width > r.w {
            glyphs = 0i32;
            txt_width = text_width;
            length = nk_text_clamp(
                font,
                string,
                length,
                r.w,
                &mut glyphs,
                &mut txt_width,
                0 as *mut Rune,
                0i32,
            )
        }
        if 0 == length {
            return;
        } else {
            cmd = nk_command_buffer_push(
                b,
                NK_COMMAND_TEXT,
                (mem::size_of::<CommandText>() as Ulong).wrapping_add((length + 1i32) as Size),
            ) as *mut CommandText;
            if cmd.is_null() {
                return;
            } else {
                (*cmd).x = r.x as Short;
                (*cmd).y = r.y as Short;
                (*cmd).w = r.w as Ushort;
                (*cmd).h = r.h as Ushort;
                (*cmd).background = bg;
                (*cmd).foreground = fg;
                (*cmd).font = font;
                (*cmd).length = length;
                (*cmd).height = (*font).height;
                nk_memcopy(
                    (*cmd).string.as_mut_ptr() as *mut Void,
                    string as *const Void,
                    length as Size,
                );
                let string_ptr: *mut Char = (*cmd).string.as_ptr() as _;
                *string_ptr.offset(length as isize) = '\u{0}' as i32 as Char;
                return;
            }
        }
    };
}
unsafe fn nk_text_clamp(
    mut font: *const UserFont,
    mut text: *const Char,
    mut text_len: Int,
    mut space: f32,
    mut glyphs: *mut Int,
    mut text_width: *mut f32,
    mut sep_list: *mut Rune,
    mut sep_count: Int,
) -> Int {
    let mut i: Int = 0i32;
    let mut glyph_len: Int = 0i32;
    let mut last_width: f32 = 0i32 as f32;
    let mut unicode: Rune = 0i32 as Rune;
    let mut width: f32 = 0i32 as f32;
    let mut len: Int = 0i32;
    let mut g: Int = 0i32;
    let mut s: f32 = 0.;
    let mut sep_len: Int = 0i32;
    let mut sep_g: Int = 0i32;
    let mut sep_width: f32 = 0i32 as f32;
    sep_count = if sep_count < 0i32 { 0i32 } else { sep_count };
    glyph_len = nk_utf_decode(text, &mut unicode, text_len);
    while 0 != glyph_len && width < space && len < text_len {
        len += glyph_len;
        s = (*font).width.expect("non-null function pointer")(
            (*font).userdata,
            (*font).height,
            text,
            len,
        );
        i = 0i32;
        while i < sep_count {
            if unicode != *sep_list.offset(i as isize) {
                i += 1
            } else {
                last_width = width;
                sep_width = last_width;
                sep_g = g + 1i32;
                sep_len = len;
                break;
            }
        }
        if i == sep_count {
            sep_width = width;
            last_width = sep_width;
            sep_g = g + 1i32
        }
        width = s;
        glyph_len = nk_utf_decode(&*text.offset(len as isize), &mut unicode, text_len - len);
        g += 1
    }
    if len >= text_len {
        *glyphs = g;
        *text_width = last_width;
        return len;
    } else {
        *glyphs = sep_g;
        *text_width = sep_width;
        return if 0 == sep_len { len } else { sep_len };
    };
}
unsafe fn nk_do_button_symbol(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut symbol: SymbolType,
    mut behavior: ButtonBehavior,
    mut style: *const StyleButton,
    mut in_0: *const Input,
    mut font: *const UserFont,
) -> Int {
    let mut ret: Int = 0;
    let mut content: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() || font.is_null() || state.is_null() {
        return nk_false as Int;
    } else {
        ret = nk_do_button(state, out, bounds, style, in_0, behavior, &mut content);
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_button_symbol(out, &mut bounds, &mut content, *state, style, symbol, font);
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return ret;
    };
}
unsafe fn nk_draw_button_symbol(
    mut out: *mut CommandBuffer,
    mut bounds: *const Rect,
    mut content: *const Rect,
    mut state: Flags,
    mut style: *const StyleButton,
    mut type_0: SymbolType,
    mut font: *const UserFont,
) -> () {
    let mut sym: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut bg: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut background: *const StyleItem = 0 as *const StyleItem;
    /* select correct colors/images */
    background = nk_draw_button(out, bounds, state, style);
    if (*background).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
        bg = (*background).data.color
    } else {
        bg = (*style).text_background
    }
    if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        sym = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        sym = (*style).text_active
    } else {
        sym = (*style).text_normal
    }
    nk_draw_symbol(out, type_0, *content, bg, sym, 1i32 as f32, font);
}
unsafe fn nk_draw_symbol(
    mut out: *mut CommandBuffer,
    mut type_0: SymbolType,
    mut content: Rect,
    mut background: Color,
    mut foreground: Color,
    mut border_width: f32,
    mut font: *const UserFont,
) -> () {
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut X: *const Char = 0 as *const Char;
    match type_0 as Uint {
        1 | 2 | 11 | 12 => {
            /* single character text symbol */
            X = if type_0 as Uint == NK_SYMBOL_X as Int as Uint {
                b"x\x00" as *const u8 as *const Char
            } else if type_0 as Uint == NK_SYMBOL_UNDERSCORE as Int as Uint {
                b"_\x00" as *const u8 as *const Char
            } else if type_0 as Uint == NK_SYMBOL_PLUS as Int as Uint {
                b"+\x00" as *const u8 as *const Char
            } else {
                b"-\x00" as *const u8 as *const Char
            };
            text = Text {
                padding: Point { x: 0., y: 0. },
                background: Color {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                },
                text: Color {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                },
            };
            text.padding = Point::new(0i32 as f32, 0i32 as f32);
            text.background = background;
            text.text = foreground;
            nk_widget_text(
                out,
                content,
                X,
                1i32,
                &mut text,
                NK_TEXT_CENTERED as Int as Flags,
                font,
            );
        }
        3 | 4 | 5 | 6 => {
            /* simple empty/filled shapes */
            if type_0 as Uint == NK_SYMBOL_RECT_SOLID as Int as Uint
                || type_0 as Uint == NK_SYMBOL_RECT_OUTLINE as Int as Uint
            {
                nk_fill_rect(out, content, 0i32 as f32, foreground);
                if type_0 as Uint == NK_SYMBOL_RECT_OUTLINE as Int as Uint {
                    nk_fill_rect(
                        out,
                        nk_shrink_rect(content, border_width),
                        0i32 as f32,
                        background,
                    );
                }
            } else {
                nk_fill_circle(out, content, foreground);
                if type_0 as Uint == NK_SYMBOL_CIRCLE_OUTLINE as Int as Uint {
                    nk_fill_circle(out, nk_shrink_rect(content, 1i32 as f32), background);
                }
            }
        }
        7 | 8 | 9 | 10 => {
            let mut heading: Heading = NK_UP;
            let mut points: [Point; 3] = [Point { x: 0., y: 0. }; 3];
            heading = (if type_0 as Uint == NK_SYMBOL_TRIANGLE_RIGHT as Int as Uint {
                NK_RIGHT as Int
            } else if type_0 as Uint == NK_SYMBOL_TRIANGLE_LEFT as Int as Uint {
                NK_LEFT as Int
            } else if type_0 as Uint == NK_SYMBOL_TRIANGLE_UP as Int as Uint {
                NK_UP as Int
            } else {
                NK_DOWN as Int
            }) as Heading;
            nk_triangle_from_direction(
                points.as_mut_ptr(),
                content,
                0i32 as f32,
                0i32 as f32,
                heading,
            );
            nk_fill_triangle(
                out,
                points[0usize].x,
                points[0usize].y,
                points[1usize].x,
                points[1usize].y,
                points[2usize].x,
                points[2usize].y,
                foreground,
            );
        }
        0 | 13 | _ => {}
    };
}

pub unsafe fn nk_fill_triangle(
    mut b: *mut CommandBuffer,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
    mut x2: f32,
    mut y2: f32,
    mut c: Color,
) -> () {
    let mut cmd: *mut CommandTriangleFilled = 0 as *mut CommandTriangleFilled;
    if b.is_null() || c.a as Int == 0i32 {
        return;
    } else if b.is_null() {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const Rect = &mut (*b).clip as *mut Rect;
            if !((*clip).x <= x0
                && x0 < (*clip).x + (*clip).w
                && ((*clip).y <= y0 && y0 < (*clip).y + (*clip).h))
                && !((*clip).x <= x1
                    && x1 < (*clip).x + (*clip).w
                    && ((*clip).y <= y1 && y1 < (*clip).y + (*clip).h))
                && !((*clip).x <= x2
                    && x2 < (*clip).x + (*clip).w
                    && ((*clip).y <= y2 && y2 < (*clip).y + (*clip).h))
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_TRIANGLE_FILLED,
            mem::size_of::<CommandTriangleFilled>() as Ulong,
        ) as *mut CommandTriangleFilled;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).a.x = x0 as Short;
            (*cmd).a.y = y0 as Short;
            (*cmd).b.x = x1 as Short;
            (*cmd).b.y = y1 as Short;
            (*cmd).c.x = x2 as Short;
            (*cmd).c.y = y2 as Short;
            (*cmd).color = c;
            return;
        }
    };
}

pub unsafe fn nk_triangle_from_direction(
    mut result: *mut Point,
    mut r: Rect,
    mut pad_x: f32,
    mut pad_y: f32,
    mut direction: Heading,
) -> () {
    let mut w_half: f32 = 0.;
    let mut h_half: f32 = 0.;
    r.w = if 2i32 as f32 * pad_x < r.w {
        r.w
    } else {
        2i32 as f32 * pad_x
    };
    r.h = if 2i32 as f32 * pad_y < r.h {
        r.h
    } else {
        2i32 as f32 * pad_y
    };
    r.w = r.w - 2i32 as f32 * pad_x;
    r.h = r.h - 2i32 as f32 * pad_y;
    r.x = r.x + pad_x;
    r.y = r.y + pad_y;
    w_half = r.w / 2.0f32;
    h_half = r.h / 2.0f32;
    if direction as Uint == NK_UP as Int as Uint {
        *result.offset(0isize) = Point::new(r.x + w_half, r.y);
        *result.offset(1isize) = Point::new(r.x + r.w, r.y + r.h);
        *result.offset(2isize) = Point::new(r.x, r.y + r.h)
    } else if direction as Uint == NK_RIGHT as Int as Uint {
        *result.offset(0isize) = Point::new(r.x, r.y);
        *result.offset(1isize) = Point::new(r.x + r.w, r.y + h_half);
        *result.offset(2isize) = Point::new(r.x, r.y + r.h)
    } else if direction as Uint == NK_DOWN as Int as Uint {
        *result.offset(0isize) = Point::new(r.x, r.y);
        *result.offset(1isize) = Point::new(r.x + r.w, r.y);
        *result.offset(2isize) = Point::new(r.x + w_half, r.y + r.h)
    } else {
        *result.offset(0isize) = Point::new(r.x, r.y + h_half);
        *result.offset(1isize) = Point::new(r.x + r.w, r.y);
        *result.offset(2isize) = Point::new(r.x + r.w, r.y + r.h)
    };
}
unsafe fn nk_shrink_rect(mut r: Rect, mut amount: f32) -> Rect {
    let mut res: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    r.w = if r.w < 2i32 as f32 * amount {
        2i32 as f32 * amount
    } else {
        r.w
    };
    r.h = if r.h < 2i32 as f32 * amount {
        2i32 as f32 * amount
    } else {
        r.h
    };
    res.x = r.x + amount;
    res.y = r.y + amount;
    res.w = r.w - 2i32 as f32 * amount;
    res.h = r.h - 2i32 as f32 * amount;
    return res;
}

pub unsafe fn nk_fill_circle(mut b: *mut CommandBuffer, mut r: Rect, mut c: Color) -> () {
    let mut cmd: *mut CommandCircleFilled = 0 as *mut CommandCircleFilled;
    if b.is_null() || c.a as Int == 0i32 || r.w == 0i32 as f32 || r.h == 0i32 as f32 {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const Rect = &mut (*b).clip as *mut Rect;
            if (*clip).x > r.x + r.w
                || (*clip).x + (*clip).w < r.x
                || (*clip).y > r.y + r.h
                || (*clip).y + (*clip).h < r.y
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_CIRCLE_FILLED,
            mem::size_of::<CommandCircleFilled>() as Ulong,
        ) as *mut CommandCircleFilled;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).x = r.x as Short;
            (*cmd).y = r.y as Short;
            (*cmd).w = (if r.w < 0i32 as f32 {
                0i32 as f32
            } else {
                r.w
            }) as Ushort;
            (*cmd).h = (if r.h < 0i32 as f32 {
                0i32 as f32
            } else {
                r.h
            }) as Ushort;
            (*cmd).color = c;
            return;
        }
    };
}

unsafe fn nk_draw_button(
    mut out: *mut CommandBuffer,
    mut bounds: *const Rect,
    mut state: Flags,
    mut style: *const StyleButton,
) -> *const StyleItem {
    let mut background: *const StyleItem = 0 as *const StyleItem;
    if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        background = &(*style).hover as *const StyleItem
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        background = &(*style).active as *const StyleItem
    } else {
        background = &(*style).normal as *const StyleItem
    }
    if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
    } else {
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        nk_stroke_rect(
            out,
            *bounds,
            (*style).rounding,
            (*style).border,
            (*style).border_color,
        );
    }
    return background;
}

pub unsafe fn nk_stroke_rect(
    mut b: *mut CommandBuffer,
    mut rect: Rect,
    mut rounding: f32,
    mut line_thickness: f32,
    mut c: Color,
) -> () {
    let mut cmd: *mut CommandRect = 0 as *mut CommandRect;
    if b.is_null()
        || c.a as Int == 0i32
        || rect.w == 0i32 as f32
        || rect.h == 0i32 as f32
        || line_thickness <= 0i32 as f32
    {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const Rect = &mut (*b).clip as *mut Rect;
            if (*clip).x > rect.x + rect.w
                || (*clip).x + (*clip).w < rect.x
                || (*clip).y > rect.y + rect.h
                || (*clip).y + (*clip).h < rect.y
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(b, NK_COMMAND_RECT, mem::size_of::<CommandRect>() as Ulong)
            as *mut CommandRect;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).rounding = rounding as Ushort;
            (*cmd).line_thickness = line_thickness as Ushort;
            (*cmd).x = rect.x as Short;
            (*cmd).y = rect.y as Short;
            (*cmd).w = (if (0i32 as f32) < rect.w {
                rect.w
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).h = (if (0i32 as f32) < rect.h {
                rect.h
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).color = c;
            return;
        }
    };
}

unsafe fn nk_do_button(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut r: Rect,
    mut style: *const StyleButton,
    mut in_0: *const Input,
    mut behavior: ButtonBehavior,
    mut content: *mut Rect,
) -> Int {
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() {
        return nk_false as Int;
    } else {
        /* calculate button content space */
        (*content).x = r.x + (*style).padding.x + (*style).border + (*style).rounding;
        (*content).y = r.y + (*style).padding.y + (*style).border + (*style).rounding;
        (*content).w = r.w - (2i32 as f32 * (*style).padding.x
            + (*style).border
            + (*style).rounding * 2i32 as f32);
        (*content).h = r.h - (2i32 as f32 * (*style).padding.y
            + (*style).border
            + (*style).rounding * 2i32 as f32);
        /* execute button behavior */
        bounds.x = r.x - (*style).touch_padding.x;
        bounds.y = r.y - (*style).touch_padding.y;
        bounds.w = r.w + 2i32 as f32 * (*style).touch_padding.x;
        bounds.h = r.h + 2i32 as f32 * (*style).touch_padding.y;
        return ButtonBehavior(state, bounds, in_0, behavior);
    };
}

unsafe fn ButtonBehavior(
    mut state: *mut Flags,
    mut r: Rect,
    mut i: *const Input,
    mut behavior: ButtonBehavior,
) -> Int {
    let mut ret: Int = 0i32;
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as Int as Uint {
        *state = (NK_WIDGET_STATE_INACTIVE as Int | NK_WIDGET_STATE_MODIFIED as Int) as Flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as Int as Flags
    }
    if i.is_null() {
        return 0i32;
    } else {
        if 0 != nk_input_is_mouse_hovering_rect(i, r) {
            *state = NK_WIDGET_STATE_HOVERED as Int as Flags;
            if 0 != nk_input_is_mouse_down(i, NK_BUTTON_LEFT) {
                *state = NK_WIDGET_STATE_ACTIVE as Int as Flags
            }
            if 0 != nk_input_has_mouse_click_in_rect(i, NK_BUTTON_LEFT, r) {
                ret = if behavior as Uint != NK_BUTTON_DEFAULT as Int as Uint {
                    nk_input_is_mouse_down(i, NK_BUTTON_LEFT)
                } else {
                    nk_input_is_mouse_pressed(i, NK_BUTTON_LEFT)
                }
            }
        }
        if 0 != *state & NK_WIDGET_STATE_HOVER as Int as Uint
            && 0 == nk_input_is_mouse_prev_hovering_rect(i, r)
        {
            *state |= NK_WIDGET_STATE_ENTERED as Int as Uint
        } else if 0 != nk_input_is_mouse_prev_hovering_rect(i, r) {
            *state |= NK_WIDGET_STATE_LEFT as Int as Uint
        }
        return ret;
    };
}

unsafe fn nk_panel_has_header(mut flags: Flags, mut title: *const Char) -> Int {
    let mut active: Int = 0i32;
    active = (flags & (NK_WINDOW_CLOSABLE as Int | NK_WINDOW_MINIMIZABLE as Int) as Uint) as Int;
    active = (0 != active || 0 != flags & NK_WINDOW_TITLE as Int as Uint) as Int;
    active =
        (0 != active && 0 == flags & NK_WINDOW_HIDDEN as Int as Uint && !title.is_null()) as Int;
    return active;
}
unsafe fn nk_panel_is_nonblock(mut type_0: PanelType) -> Int {
    return if 0 != type_0 as Uint & NK_PANEL_SET_NONBLOCK as Int as Uint {
        1i32
    } else {
        0i32
    };
}

pub unsafe fn nk_layout_reset_min_row_height(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).row.min_height = (*(*ctx).style.font).height;
        (*layout).row.min_height += (*ctx).style.text.padding.y * 2i32 as f32;
        (*layout).row.min_height += (*ctx).style.window.min_row_height_padding * 2i32 as f32;
        return;
    };
}
unsafe fn nk_panel_get_border(
    mut style: *const Style,
    mut flags: Flags,
    mut type_0: PanelType,
) -> f32 {
    if 0 != flags & NK_WINDOW_BORDER as Int as Uint {
        match type_0 as Uint {
            2 => return (*style).window.group_border,
            4 => return (*style).window.popup_border,
            16 => return (*style).window.contextual_border,
            32 => return (*style).window.combo_border,
            64 => return (*style).window.menu_border,
            128 => return (*style).window.menu_border,
            1 | _ => return (*style).window.border,
        }
    } else {
        return 0i32 as f32;
    };
}

unsafe fn nk_panel_get_padding(mut style: *const Style, mut type_0: PanelType) -> Point {
    match type_0 as Uint {
        2 => return (*style).window.group_padding,
        4 => return (*style).window.popup_padding,
        16 => return (*style).window.contextual_padding,
        32 => return (*style).window.combo_padding,
        64 => return (*style).window.menu_padding,
        128 => return (*style).window.menu_padding,
        1 | _ => return (*style).window.padding,
    };
}
unsafe fn nk_create_panel(mut ctx: *mut Context) -> *mut Void {
    let mut elem: *mut PageElement = 0 as *mut PageElement;
    elem = nk_create_page_element(ctx);
    if elem.is_null() {
        return 0 as *mut Void;
    } else {
        nk_zero(elem as *mut Void, mem::size_of::<PageElement>() as Ulong);
        return &mut (*elem).data.pan as *mut Panel as *mut Void;
    };
}
unsafe fn nk_create_page_element(mut ctx: *mut Context) -> *mut PageElement {
    let mut elem: *mut PageElement = 0 as *mut PageElement;
    if !(*ctx).freelist.is_null() {
        /* unlink page element from free list */
        elem = (*ctx).freelist;
        (*ctx).freelist = (*elem).next
    } else if 0 != (*ctx).use_pool {
        /* allocate page element from memory pool */
        elem = nk_pool_alloc(&mut (*ctx).pool);
        if elem.is_null() {
            return 0 as *mut PageElement;
        }
    } else {
        const size: Size = mem::size_of::<PageElement>() as Size;
        const align: Size = mem::size_of::<PageElement>() as Size;
        /* allocate new page element from back of fixed size memory buffer */
        elem = nk_buffer_alloc(&mut (*ctx).memory, NK_BUFFER_BACK, size, align) as *mut PageElement;
        if elem.is_null() {
            return 0 as *mut PageElement;
        }
    }
    nk_zero(elem as *mut Void, mem::size_of::<PageElement>() as Ulong);
    (*elem).next = 0 as *mut PageElement;
    (*elem).prev = 0 as *mut PageElement;
    return elem;
}
unsafe fn nk_pool_alloc(mut pool: *mut Pool) -> *mut PageElement {
    if (*pool).pages.is_null() || (*(*pool).pages).size >= (*pool).capacity {
        /* allocate new page */
        let mut page: *mut Page = 0 as *mut Page;
        if (*pool).type_0 as Uint == NK_BUFFER_FIXED as Int as Uint {
            if (*pool).pages.is_null() {
                return 0 as *mut PageElement;
            } else {
                return 0 as *mut PageElement;
            }
        } else {
            let mut size: Size = mem::size_of::<Page>() as Ulong;
            size = (size as Ulong).wrapping_add(
                (16i32 as Ulong).wrapping_mul(mem::size_of::<nk_page_data>() as Ulong),
            ) as Size as Size;
            page = (*pool).alloc.alloc.expect("non-null function pointer")(
                (*pool).alloc.userdata,
                0 as *mut Void,
                size,
            ) as *mut Page;
            (*page).next = (*pool).pages;
            (*pool).pages = page;
            (*page).size = 0i32 as Uint
        }
    }
    let fresh11 = (*(*pool).pages).size;
    (*(*pool).pages).size = (*(*pool).pages).size.wrapping_add(1);
    let win_ptr: *mut PageElement = (*(*pool).pages).win.as_ptr() as _;
    return win_ptr.offset(fresh11 as isize);
}
unsafe fn nk_insert_window(
    mut ctx: *mut Context,
    mut win: *mut Window,
    mut loc: WindowInsertLocation,
) -> () {
    let mut end: *mut Window = 0 as *mut Window;
    let mut iter: *const Window = 0 as *const Window;
    if win.is_null() || ctx.is_null() {
        return;
    } else {
        iter = (*ctx).begin;
        while !iter.is_null() {
            if iter == win {
                return;
            } else {
                iter = (*iter).next
            }
        }
        if (*ctx).begin.is_null() {
            (*win).next = 0 as *mut Window;
            (*win).prev = 0 as *mut Window;
            (*ctx).begin = win;
            (*ctx).end = win;
            (*ctx).count = 1i32 as Uint;
            return;
        } else {
            if loc as Uint == NK_INSERT_BACK as Int as Uint {
                end = 0 as *mut Window;
                end = (*ctx).end;
                (*end).flags |= NK_WINDOW_ROM as Int as Uint;
                (*end).next = win;
                (*win).prev = (*ctx).end;
                (*win).next = 0 as *mut Window;
                (*ctx).end = win;
                (*ctx).active = (*ctx).end;
                (*(*ctx).end).flags &= !(NK_WINDOW_ROM as Int as Flags)
            } else {
                /*ctx->end->flags |= NK_WINDOW_ROM;*/
                (*(*ctx).begin).prev = win;
                (*win).next = (*ctx).begin;
                (*win).prev = 0 as *mut Window;
                (*ctx).begin = win;
                (*(*ctx).begin).flags &= !(NK_WINDOW_ROM as Int as Flags)
            }
            (*ctx).count = (*ctx).count.wrapping_add(1);
            return;
        }
    };
}
unsafe fn nk_start(mut ctx: *mut Context, mut win: *mut Window) -> () {
    nk_start_buffer(ctx, &mut (*win).buffer);
}
unsafe fn nk_create_window(mut ctx: *mut Context) -> *mut Void {
    let mut elem: *mut PageElement = 0 as *mut PageElement;
    elem = nk_create_page_element(ctx);
    if elem.is_null() {
        return 0 as *mut Void;
    } else {
        (*elem).data.win.seq = (*ctx).seq;
        return &mut (*elem).data.win as *mut Window as *mut Void;
    };
}
unsafe fn nk_find_window(
    mut ctx: *mut Context,
    mut hash: Hash,
    mut name: *const Char,
) -> *mut Window {
    let mut iter: *mut Window = 0 as *mut Window;
    iter = (*ctx).begin;
    while !iter.is_null() {
        if (*iter).name == hash {
            let mut max_len: Int = nk_strlen((*iter).name_string.as_mut_ptr());
            if 0 == nk_stricmpn((*iter).name_string.as_mut_ptr(), name, max_len) {
                return iter;
            }
        }
        iter = (*iter).next
    }
    return 0 as *mut Window;
}

pub unsafe fn nk_stricmpn(mut s1: *const Char, mut s2: *const Char, mut n: Int) -> Int {
    let mut current_block: u64;
    let mut c1: Int = 0;
    let mut c2: Int = 0;
    let mut d: Int = 0;
    loop {
        let fresh12 = s1;
        s1 = s1.offset(1);
        c1 = *fresh12 as Int;
        let fresh13 = s2;
        s2 = s2.offset(1);
        c2 = *fresh13 as Int;
        let fresh14 = n;
        n = n - 1;
        if 0 == fresh14 {
            return 0i32;
        } else {
            d = c1 - c2;
            if 0 != d {
                if c1 <= 'Z' as i32 && c1 >= 'A' as i32 {
                    d += 'a' as i32 - 'A' as i32;
                    if 0 == d {
                        current_block = 11174649648027449784;
                    } else {
                        current_block = 17778012151635330486;
                    }
                } else {
                    current_block = 17778012151635330486;
                }
                match current_block {
                    11174649648027449784 => {}
                    _ => {
                        if c2 <= 'Z' as i32 && c2 >= 'A' as i32 {
                            d -= 'a' as i32 - 'A' as i32;
                            if 0 == d {
                                current_block = 11174649648027449784;
                            } else {
                                current_block = 6873731126896040597;
                            }
                        } else {
                            current_block = 6873731126896040597;
                        }
                        match current_block {
                            11174649648027449784 => {}
                            _ => return (((d >= 0i32) as Int) << 1i32) - 1i32,
                        }
                    }
                }
            }
            if !(0 != c1) {
                break;
            }
        }
    }
    return 0i32;
}

pub unsafe fn nk_murmur_hash(mut key: *const Void, mut len: Int, mut seed: Hash) -> Hash {
    let mut current_block: u64;
    /* 32-Bit MurmurHash3: https://code.google.com/p/smhasher/wiki/MurmurHash3*/
    let mut conv: unnamed_8 = unnamed_8 { i: 0 as *const u32 };
    let mut data: *const u8 = key as *const u8;
    let nblocks: Int = len / 4i32;
    let mut h1: u32 = seed;
    let c1: u32 = 3432918353u32;
    let c2: u32 = 461845907i32 as u32;
    let mut tail: *const u8 = 0 as *const u8;
    let mut blocks: *const u32 = 0 as *const u32;
    let mut k1: u32 = 0;
    let mut i: Int = 0;
    /* body */
    if key.is_null() {
        return 0i32 as Hash;
    } else {
        conv.b = data.offset((nblocks * 4i32) as isize);
        blocks = conv.i;
        i = -nblocks;
        while 0 != i {
            k1 = *blocks.offset(i as isize);
            k1 = (k1 as Uint).wrapping_mul(c1) as u32 as u32;
            k1 = k1 << 15i32 | k1 >> 32i32 - 15i32;
            k1 = (k1 as Uint).wrapping_mul(c2) as u32 as u32;
            h1 ^= k1;
            h1 = h1 << 13i32 | h1 >> 32i32 - 13i32;
            h1 = h1.wrapping_mul(5i32 as Uint).wrapping_add(3864292196u32);
            i += 1
        }
        /* tail */
        tail = data.offset((nblocks * 4i32) as isize);
        k1 = 0i32 as u32;
        match len & 3i32 {
            3 => {
                /* fallthrough */
                k1 ^= ((*tail.offset(2isize) as Int) << 16i32) as u32;
                current_block = 12401332213780770671;
            }
            2 => {
                current_block = 12401332213780770671;
            }
            1 => {
                current_block = 9641644719232025533;
            }
            _ => {
                current_block = 4906268039856690917;
            }
        }
        match current_block {
            12401332213780770671 => {
                /* fallthrough */
                k1 ^= ((*tail.offset(1isize) as Int) << 8u32) as u32;
                current_block = 9641644719232025533;
            }
            _ => {}
        }
        match current_block {
            9641644719232025533 => {
                k1 ^= *tail.offset(0isize) as Uint;
                k1 = (k1 as Uint).wrapping_mul(c1) as u32 as u32;
                k1 = k1 << 15i32 | k1 >> 32i32 - 15i32;
                k1 = (k1 as Uint).wrapping_mul(c2) as u32 as u32;
                h1 ^= k1
            }
            _ => {}
        }
        /* finalization */
        h1 ^= len as u32;
        /* fmix32 */
        h1 ^= h1 >> 16i32;
        h1 = (h1 as Uint).wrapping_mul(2246822507u32) as u32 as u32;
        h1 ^= h1 >> 13i32;
        h1 = (h1 as Uint).wrapping_mul(3266489909u32) as u32 as u32;
        h1 ^= h1 >> 16i32;
        return h1;
    };
}

pub unsafe fn nk_end(mut ctx: *mut Context) -> () {
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        layout = (*(*ctx).current).layout;
        if layout.is_null()
            || (*layout).type_0 as Uint == NK_PANEL_WINDOW as Int as Uint
                && 0 != (*(*ctx).current).flags & NK_WINDOW_HIDDEN as Int as Uint
        {
            (*ctx).current = 0 as *mut Window;
            return;
        } else {
            nk_panel_end(ctx);
            nk_free_panel(ctx, (*(*ctx).current).layout);
            (*ctx).current = 0 as *mut Window;
            return;
        }
    };
}
unsafe fn nk_free_panel(mut ctx: *mut Context, mut pan: *mut Panel) -> () {
    let mut pd: *mut nk_page_data = ((if 0 != 1i32 {
        pan
    } else {
        &mut (*(0 as *mut nk_page_data)).pan as *mut Panel
    }) as *mut Char)
        .offset(-(&mut (*(0 as *mut nk_page_data)).pan as *mut Panel as Ptr as isize))
        as *mut Void as *mut nk_page_data;
    let mut pe: *mut PageElement = ((if 0 != 1i32 {
        pd
    } else {
        &mut (*(0 as *mut PageElement)).data as *mut nk_page_data
    }) as *mut Char)
        .offset(-(&mut (*(0 as *mut PageElement)).data as *mut nk_page_data as Ptr as isize))
        as *mut Void as *mut PageElement;
    nk_free_page_element(ctx, pe);
}
unsafe fn nk_panel_end(mut ctx: *mut Context) -> () {
    let mut padding_y: f32 = 0.;
    let mut border_color: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut b: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut in_0: *mut Input = 0 as *mut Input;
    let mut window: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut style: *const Style = 0 as *const Style;
    let mut out: *mut CommandBuffer = 0 as *mut CommandBuffer;
    let mut scrollbar_size: Point = Point { x: 0., y: 0. };
    let mut panel_padding: Point = Point { x: 0., y: 0. };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        window = (*ctx).current;
        layout = (*window).layout;
        style = &mut (*ctx).style as *mut Style;
        out = &mut (*window).buffer as *mut CommandBuffer;
        in_0 = if 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            || 0 != (*layout).flags & NK_WINDOW_NO_INPUT as Int as Uint
        {
            0 as *mut Input
        } else {
            &mut (*ctx).input as *mut Input
        };
        if 0 == nk_panel_is_sub((*layout).type_0) {
            nk_push_scissor(out, nk_null_rect);
        }
        /* cache configuration data */
        scrollbar_size = (*style).window.scrollbar_size;
        panel_padding = nk_panel_get_padding(style, (*layout).type_0);
        /* update the current cursor Y-position to point over the last added widget */
        (*layout).at_y += (*layout).row.height;
        /* dynamic panels */
        if 0 != (*layout).flags & NK_WINDOW_DYNAMIC as Int as Uint
            && 0 == (*layout).flags & NK_WINDOW_MINIMIZED as Int as Uint
        {
            /* update panel height to fit dynamic growth */
            let mut empty_space: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            if (*layout).at_y < (*layout).bounds.y + (*layout).bounds.h {
                (*layout).bounds.h = (*layout).at_y - (*layout).bounds.y
            }
            /* fill top empty space */
            empty_space.x = (*window).bounds.x;
            empty_space.y = (*layout).bounds.y;
            empty_space.h = panel_padding.y;
            empty_space.w = (*window).bounds.w;
            nk_fill_rect(out, empty_space, 0i32 as f32, (*style).window.background);
            /* fill left empty space */
            empty_space.x = (*window).bounds.x;
            empty_space.y = (*layout).bounds.y;
            empty_space.w = panel_padding.x + (*layout).border;
            empty_space.h = (*layout).bounds.h;
            nk_fill_rect(out, empty_space, 0i32 as f32, (*style).window.background);
            /* fill right empty space */
            empty_space.x = (*layout).bounds.x + (*layout).bounds.w - (*layout).border;
            empty_space.y = (*layout).bounds.y;
            empty_space.w = panel_padding.x + (*layout).border;
            empty_space.h = (*layout).bounds.h;
            if *(*layout).offset_y == 0i32 as Uint
                && 0 == (*layout).flags & NK_WINDOW_NO_SCROLLBAR as Int as Uint
            {
                empty_space.w += scrollbar_size.x
            }
            nk_fill_rect(out, empty_space, 0i32 as f32, (*style).window.background);
            /* fill bottom empty space */
            if (*layout).footer_height > 0i32 as f32 {
                empty_space.x = (*window).bounds.x;
                empty_space.y = (*layout).bounds.y + (*layout).bounds.h;
                empty_space.w = (*window).bounds.w;
                empty_space.h = (*layout).footer_height;
                nk_fill_rect(out, empty_space, 0i32 as f32, (*style).window.background);
            }
        }
        /* scrollbars */
        if 0 == (*layout).flags & NK_WINDOW_NO_SCROLLBAR as Int as Uint
            && 0 == (*layout).flags & NK_WINDOW_MINIMIZED as Int as Uint
            && (*window).scrollbar_hiding_timer < 4.0f32
        {
            let mut scroll: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut scroll_has_scrolling: Int = 0;
            let mut scroll_target: f32 = 0.;
            let mut scroll_offset: f32 = 0.;
            let mut scroll_step: f32 = 0.;
            let mut scroll_inc: f32 = 0.;
            /* mouse wheel scrolling */
            if 0 != nk_panel_is_sub((*layout).type_0) {
                /* sub-window mouse wheel scrolling */
                let mut root_window: *mut Window = window;
                let mut root_panel: *mut Panel = (*window).layout;
                while !(*root_panel).parent.is_null() {
                    root_panel = (*root_panel).parent
                }
                while !(*root_window).parent.is_null() {
                    root_window = (*root_window).parent
                }
                /* only allow scrolling if parent window is active */
                scroll_has_scrolling = 0i32;
                if root_window == (*ctx).active && 0 != (*layout).has_scrolling {
                    /* and panel is being hovered and inside clip rect*/
                    if 0 != nk_input_is_mouse_hovering_rect(in_0, (*layout).bounds)
                        && !((*root_panel).clip.x > (*layout).bounds.x + (*layout).bounds.w
                            || (*root_panel).clip.x + (*root_panel).clip.w < (*layout).bounds.x
                            || (*root_panel).clip.y > (*layout).bounds.y + (*layout).bounds.h
                            || (*root_panel).clip.y + (*root_panel).clip.h < (*layout).bounds.y)
                    {
                        /* deactivate all parent scrolling */
                        root_panel = (*window).layout;
                        while !(*root_panel).parent.is_null() {
                            (*root_panel).has_scrolling = nk_false as Int as Uint;
                            root_panel = (*root_panel).parent
                        }
                        (*root_panel).has_scrolling = nk_false as Int as Uint;
                        scroll_has_scrolling = nk_true as Int
                    }
                }
            } else if 0 == nk_panel_is_sub((*layout).type_0) {
                /* window mouse wheel scrolling */
                scroll_has_scrolling =
                    (window == (*ctx).active && 0 != (*layout).has_scrolling) as Int;
                if !in_0.is_null()
                    && ((*in_0).mouse.scroll_delta.y > 0i32 as f32
                        || (*in_0).mouse.scroll_delta.x > 0i32 as f32)
                    && 0 != scroll_has_scrolling
                {
                    (*window).scrolled = nk_true as Int as Uint
                } else {
                    (*window).scrolled = nk_false as Int as Uint
                }
            } else {
                scroll_has_scrolling = nk_false as Int
            }
            /* vertical scrollbar */
            let mut state: Flags = 0i32 as Flags;
            scroll.x = (*layout).bounds.x + (*layout).bounds.w + panel_padding.x;
            scroll.y = (*layout).bounds.y;
            scroll.w = scrollbar_size.x;
            scroll.h = (*layout).bounds.h;
            scroll_offset = *(*layout).offset_y as f32;
            scroll_step = scroll.h * 0.10000000149011612f32;
            scroll_inc = scroll.h * 0.009999999776482582f32;
            scroll_target = ((*layout).at_y - scroll.y) as Int as f32;
            scroll_offset = nk_do_scrollbarv(
                &mut state,
                out,
                scroll,
                scroll_has_scrolling,
                scroll_offset,
                scroll_target,
                scroll_step,
                scroll_inc,
                &mut (*ctx).style.scrollv,
                in_0,
                (*style).font,
            );
            *(*layout).offset_y = scroll_offset as u32;
            if !in_0.is_null() && 0 != scroll_has_scrolling {
                (*in_0).mouse.scroll_delta.y = 0i32 as f32
            }
            /* horizontal scrollbar */
            let mut state_0: Flags = 0i32 as Flags;
            scroll.x = (*layout).bounds.x;
            scroll.y = (*layout).bounds.y + (*layout).bounds.h;
            scroll.w = (*layout).bounds.w;
            scroll.h = scrollbar_size.y;
            scroll_offset = *(*layout).offset_x as f32;
            scroll_target = ((*layout).max_x - scroll.x) as Int as f32;
            scroll_step = (*layout).max_x * 0.05000000074505806f32;
            scroll_inc = (*layout).max_x * 0.004999999888241291f32;
            scroll_offset = nk_do_scrollbarh(
                &mut state_0,
                out,
                scroll,
                scroll_has_scrolling,
                scroll_offset,
                scroll_target,
                scroll_step,
                scroll_inc,
                &mut (*ctx).style.scrollh,
                in_0,
                (*style).font,
            );
            *(*layout).offset_x = scroll_offset as u32
        }
        /* hide scroll if no user input */
        if 0 != (*window).flags & NK_WINDOW_SCROLL_AUTO_HIDE as Int as Uint {
            let mut has_input: Int = ((*ctx).input.mouse.delta.x != 0i32 as f32
                || (*ctx).input.mouse.delta.y != 0i32 as f32
                || (*ctx).input.mouse.scroll_delta.y != 0i32 as f32)
                as Int;
            let mut is_window_hovered: Int = nk_window_is_hovered(ctx);
            let mut any_item_active: Int =
                ((*ctx).last_widget_state & NK_WIDGET_STATE_MODIFIED as Int as Uint) as Int;
            if 0 == has_input && 0 != is_window_hovered
                || 0 == is_window_hovered && 0 == any_item_active
            {
                (*window).scrollbar_hiding_timer += (*ctx).delta_time_seconds
            } else {
                (*window).scrollbar_hiding_timer = 0i32 as f32
            }
        } else {
            (*window).scrollbar_hiding_timer = 0i32 as f32
        }
        /* window border */
        if 0 != (*layout).flags & NK_WINDOW_BORDER as Int as Uint {
            border_color = nk_panel_get_border_color(style, (*layout).type_0);
            padding_y = if 0 != (*layout).flags & NK_WINDOW_MINIMIZED as Int as Uint {
                (*style).window.border + (*window).bounds.y + (*layout).header_height
            } else if 0 != (*layout).flags & NK_WINDOW_DYNAMIC as Int as Uint {
                (*layout).bounds.y + (*layout).bounds.h + (*layout).footer_height
            } else {
                (*window).bounds.y + (*window).bounds.h
            };
            b = (*window).bounds;
            b.h = padding_y - (*window).bounds.y;
            nk_stroke_rect(out, b, 0i32 as f32, (*layout).border, border_color);
        }
        /* scaler */
        if 0 != (*layout).flags & NK_WINDOW_SCALABLE as Int as Uint
            && !in_0.is_null()
            && 0 == (*layout).flags & NK_WINDOW_MINIMIZED as Int as Uint
        {
            /* calculate scaler bounds */
            let mut scaler: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            scaler.w = scrollbar_size.x;
            scaler.h = scrollbar_size.y;
            scaler.y = (*layout).bounds.y + (*layout).bounds.h;
            if 0 != (*layout).flags & NK_WINDOW_SCALE_LEFT as Int as Uint {
                scaler.x = (*layout).bounds.x - panel_padding.x * 0.5f32
            } else {
                scaler.x = (*layout).bounds.x + (*layout).bounds.w + panel_padding.x
            }
            if 0 != (*layout).flags & NK_WINDOW_NO_SCROLLBAR as Int as Uint {
                scaler.x -= scaler.w
            }
            /* draw scaler */
            let mut item: *const StyleItem = &(*style).window.scaler as *const StyleItem;
            if (*item).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                nk_draw_image(out, scaler, &(*item).data.image, nk_white);
            } else if 0 != (*layout).flags & NK_WINDOW_SCALE_LEFT as Int as Uint {
                nk_fill_triangle(
                    out,
                    scaler.x,
                    scaler.y,
                    scaler.x,
                    scaler.y + scaler.h,
                    scaler.x + scaler.w,
                    scaler.y + scaler.h,
                    (*item).data.color,
                );
            } else {
                nk_fill_triangle(
                    out,
                    scaler.x + scaler.w,
                    scaler.y,
                    scaler.x + scaler.w,
                    scaler.y + scaler.h,
                    scaler.x,
                    scaler.y + scaler.h,
                    (*item).data.color,
                );
            }
            /* do window scaling */
            if 0 == (*window).flags & NK_WINDOW_ROM as Int as Uint {
                let mut window_size: Point = (*style).window.min_size;
                let mut left_mouse_down: Int =
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down;
                let mut left_mouse_click_in_scaler: Int = nk_input_has_mouse_click_down_in_rect(
                    in_0,
                    NK_BUTTON_LEFT,
                    scaler,
                    nk_true as Int,
                );
                if 0 != left_mouse_down && 0 != left_mouse_click_in_scaler {
                    let mut delta_x: f32 = (*in_0).mouse.delta.x;
                    if 0 != (*layout).flags & NK_WINDOW_SCALE_LEFT as Int as Uint {
                        delta_x = -delta_x;
                        (*window).bounds.x += (*in_0).mouse.delta.x
                    }
                    /* dragging in x-direction  */
                    if (*window).bounds.w + delta_x >= window_size.x {
                        if delta_x < 0i32 as f32
                            || delta_x > 0i32 as f32 && (*in_0).mouse.pos.x >= scaler.x
                        {
                            (*window).bounds.w = (*window).bounds.w + delta_x;
                            scaler.x += (*in_0).mouse.delta.x
                        }
                    }
                    /* dragging in y-direction (only possible if static window) */
                    if 0 == (*layout).flags & NK_WINDOW_DYNAMIC as Int as Uint {
                        if window_size.y < (*window).bounds.h + (*in_0).mouse.delta.y {
                            if (*in_0).mouse.delta.y < 0i32 as f32
                                || (*in_0).mouse.delta.y > 0i32 as f32
                                    && (*in_0).mouse.pos.y >= scaler.y
                            {
                                (*window).bounds.h = (*window).bounds.h + (*in_0).mouse.delta.y;
                                scaler.y += (*in_0).mouse.delta.y
                            }
                        }
                    }
                    (*ctx).style.cursor_active =
                        (*ctx).style.cursors[NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT as Int as usize];
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize]
                        .clicked_pos
                        .x = scaler.x + scaler.w / 2.0f32;
                    (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize]
                        .clicked_pos
                        .y = scaler.y + scaler.h / 2.0f32
                }
            }
        }
        if 0 == nk_panel_is_sub((*layout).type_0) {
            /* window is hidden so clear command buffer  */
            if 0 != (*layout).flags & NK_WINDOW_HIDDEN as Int as Uint {
                nk_command_buffer_reset(&mut (*window).buffer);
            } else {
                /* window is visible and not tab */
                nk_finish(ctx, window);
            }
        }
        /* NK_WINDOW_REMOVE_ROM flag was set so remove NK_WINDOW_ROM */
        if 0 != (*layout).flags & NK_WINDOW_REMOVE_ROM as Int as Uint {
            (*layout).flags &= !(NK_WINDOW_ROM as Int as Flags);
            (*layout).flags &= !(NK_WINDOW_REMOVE_ROM as Int as Flags)
        }
        (*window).flags = (*layout).flags;
        /* property garbage collector */
        if 0 != (*window).property.active
            && (*window).property.old != (*window).property.seq
            && (*window).property.active == (*window).property.prev
        {
            nk_zero(
                &mut (*window).property as *mut PropertyState as *mut Void,
                mem::size_of::<PropertyState>() as Ulong,
            );
        } else {
            (*window).property.old = (*window).property.seq;
            (*window).property.prev = (*window).property.active;
            (*window).property.seq = 0i32 as Uint
        }
        /* edit garbage collector */
        if 0 != (*window).edit.active
            && (*window).edit.old != (*window).edit.seq
            && (*window).edit.active == (*window).edit.prev
        {
            nk_zero(
                &mut (*window).edit as *mut EditState as *mut Void,
                mem::size_of::<EditState>() as Ulong,
            );
        } else {
            (*window).edit.old = (*window).edit.seq;
            (*window).edit.prev = (*window).edit.active;
            (*window).edit.seq = 0i32 as Uint
        }
        /* contextual garbage collector */
        if 0 != (*window).popup.active_con && (*window).popup.con_old != (*window).popup.con_count {
            (*window).popup.con_count = 0i32 as Uint;
            (*window).popup.con_old = 0i32 as Uint;
            (*window).popup.active_con = 0i32 as Uint
        } else {
            (*window).popup.con_old = (*window).popup.con_count;
            (*window).popup.con_count = 0i32 as Uint
        }
        (*window).popup.combo_count = 0i32 as Uint;
        return;
    };
}
unsafe fn nk_finish(mut ctx: *mut Context, mut win: *mut Window) -> () {
    let mut buf: *mut PopupBuffer = 0 as *mut PopupBuffer;
    let mut parent_last: *mut Command = 0 as *mut Command;
    let mut memory: *mut Void = 0 as *mut Void;
    if ctx.is_null() || win.is_null() {
        return;
    } else {
        nk_finish_buffer(ctx, &mut (*win).buffer);
        if 0 == (*win).popup.buf.active {
            return;
        } else {
            buf = &mut (*win).popup.buf as *mut PopupBuffer;
            memory = (*ctx).memory.memory.ptr;
            parent_last =
                (memory as *mut u8).offset((*buf).parent as isize) as *mut Void as *mut Command;
            (*parent_last).next = (*buf).end;
            return;
        }
    };
}
unsafe fn nk_command_buffer_reset(mut b: *mut CommandBuffer) -> () {
    if b.is_null() {
        return;
    } else {
        (*b).begin = 0i32 as Size;
        (*b).end = 0i32 as Size;
        (*b).last = 0i32 as Size;
        (*b).clip = nk_null_rect;
        (*b).userdata.ptr = 0 as *mut Void;
        return;
    };
}
unsafe fn nk_panel_is_sub(mut type_0: PanelType) -> Int {
    return if 0 != type_0 as Uint & NK_PANEL_SET_SUB as Int as Uint {
        1i32
    } else {
        0i32
    };
}
unsafe fn nk_panel_get_border_color(mut style: *const Style, mut type_0: PanelType) -> Color {
    match type_0 as Uint {
        2 => return (*style).window.group_border_color,
        4 => return (*style).window.popup_border_color,
        16 => return (*style).window.contextual_border_color,
        32 => return (*style).window.combo_border_color,
        64 => return (*style).window.menu_border_color,
        128 => return (*style).window.menu_border_color,
        1 | _ => return (*style).window.border_color,
    };
}

pub unsafe fn nk_window_is_hovered(mut ctx: *mut Context) -> Int {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32;
    } else if 0 != (*(*ctx).current).flags & NK_WINDOW_HIDDEN as Int as Uint {
        return 0i32;
    } else {
        return nk_input_is_mouse_hovering_rect(&mut (*ctx).input, (*(*ctx).current).bounds);
    };
}
unsafe fn nk_do_scrollbarh(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut scroll: Rect,
    mut has_scrolling: Int,
    mut offset: f32,
    mut target: f32,
    mut step: f32,
    mut button_pixel_inc: f32,
    mut style: *const StyleScrollbar,
    mut in_0: *mut Input,
    mut font: *const UserFont,
) -> f32 {
    let mut cursor: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut empty_west: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut empty_east: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut scroll_step: f32 = 0.;
    let mut scroll_offset: f32 = 0.;
    let mut scroll_off: f32 = 0.;
    let mut scroll_ratio: f32 = 0.;
    if out.is_null() || style.is_null() {
        return 0i32 as f32;
    } else {
        /* scrollbar background */
        scroll.h = if scroll.h < 1i32 as f32 {
            1i32 as f32
        } else {
            scroll.h
        };
        scroll.w = if scroll.w < 2i32 as f32 * scroll.h {
            2i32 as f32 * scroll.h
        } else {
            scroll.w
        };
        if target <= scroll.w {
            return 0i32 as f32;
        } else {
            /* optional scrollbar buttons */
            if 0 != (*style).show_buttons {
                let mut ws: Flags = 0;
                let mut scroll_w: f32 = 0.;
                let mut button: Rect = Rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                button.y = scroll.y;
                button.w = scroll.h;
                button.h = scroll.h;
                scroll_w = scroll.w - 2i32 as f32 * button.w;
                scroll_step = if step < button_pixel_inc {
                    step
                } else {
                    button_pixel_inc
                };
                /* decrement button */
                button.x = scroll.x;
                if 0 != nk_do_button_symbol(
                    &mut ws,
                    out,
                    button,
                    (*style).dec_symbol,
                    NK_BUTTON_REPEATER,
                    &(*style).dec_button,
                    in_0,
                    font,
                ) {
                    offset = offset - scroll_step
                }
                /* increment button */
                button.x = scroll.x + scroll.w - button.w;
                if 0 != nk_do_button_symbol(
                    &mut ws,
                    out,
                    button,
                    (*style).inc_symbol,
                    NK_BUTTON_REPEATER,
                    &(*style).inc_button,
                    in_0,
                    font,
                ) {
                    offset = offset + scroll_step
                }
                scroll.x = scroll.x + button.w;
                scroll.w = scroll_w
            }
            /* calculate scrollbar constants */
            scroll_step = if step < scroll.w { step } else { scroll.w };
            scroll_offset = if if offset < target - scroll.w {
                offset
            } else {
                target - scroll.w
            } < 0i32 as f32
            {
                0i32 as f32
            } else if offset < target - scroll.w {
                offset
            } else {
                target - scroll.w
            };
            scroll_ratio = scroll.w / target;
            scroll_off = scroll_offset / target;
            /* calculate cursor bounds */
            cursor.w = scroll_ratio * scroll.w
                - (2i32 as f32 * (*style).border + 2i32 as f32 * (*style).padding.x);
            cursor.x = scroll.x + scroll_off * scroll.w + (*style).border + (*style).padding.x;
            cursor.h =
                scroll.h - (2i32 as f32 * (*style).border + 2i32 as f32 * (*style).padding.y);
            cursor.y = scroll.y + (*style).border + (*style).padding.y;
            /* calculate empty space around cursor */
            empty_west.x = scroll.x;
            empty_west.y = scroll.y;
            empty_west.w = cursor.x - scroll.x;
            empty_west.h = scroll.h;
            empty_east.x = cursor.x + cursor.w;
            empty_east.y = scroll.y;
            empty_east.w = scroll.x + scroll.w - (cursor.x + cursor.w);
            empty_east.h = scroll.h;
            /* update scrollbar */
            scroll_offset = nk_scrollbar_behavior(
                state,
                in_0,
                has_scrolling,
                &mut scroll,
                &mut cursor,
                &mut empty_west,
                &mut empty_east,
                scroll_offset,
                target,
                scroll_step,
                NK_HORIZONTAL,
            );
            scroll_off = scroll_offset / target;
            cursor.x = scroll.x + scroll_off * scroll.w;
            /* draw scrollbar */
            if (*style).draw_begin.is_some() {
                (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
            }
            nk_draw_scrollbar(out, *state, style, &mut scroll, &mut cursor);
            if (*style).draw_end.is_some() {
                (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
            }
            return scroll_offset;
        }
    };
}
unsafe fn nk_draw_scrollbar(
    mut out: *mut CommandBuffer,
    mut state: Flags,
    mut style: *const StyleScrollbar,
    mut bounds: *const Rect,
    mut scroll: *const Rect,
) -> () {
    let mut background: *const StyleItem = 0 as *const StyleItem;
    let mut cursor: *const StyleItem = 0 as *const StyleItem;
    /* select correct colors/images to draw */
    if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        background = &(*style).active as *const StyleItem;
        cursor = &(*style).cursor_active as *const StyleItem
    } else if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        background = &(*style).hover as *const StyleItem;
        cursor = &(*style).cursor_hover as *const StyleItem
    } else {
        background = &(*style).normal as *const StyleItem;
        cursor = &(*style).cursor_normal as *const StyleItem
    }
    /* draw background */
    if (*background).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        nk_stroke_rect(
            out,
            *bounds,
            (*style).rounding,
            (*style).border,
            (*style).border_color,
        );
    } else {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
    }
    /* draw cursor */
    if (*cursor).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
        nk_fill_rect(out, *scroll, (*style).rounding_cursor, (*cursor).data.color);
        nk_stroke_rect(
            out,
            *scroll,
            (*style).rounding_cursor,
            (*style).border_cursor,
            (*style).cursor_border_color,
        );
    } else {
        nk_draw_image(out, *scroll, &(*cursor).data.image, nk_white);
    };
}
unsafe fn nk_scrollbar_behavior(
    mut state: *mut Flags,
    mut in_0: *mut Input,
    mut has_scrolling: Int,
    mut scroll: *const Rect,
    mut cursor: *const Rect,
    mut empty0: *const Rect,
    mut empty1: *const Rect,
    mut scroll_offset: f32,
    mut target: f32,
    mut scroll_step: f32,
    mut o: Orientation,
) -> f32 {
    let mut cursor_y: f32 = 0.;
    let mut ws: Flags = 0i32 as Flags;
    let mut left_mouse_down: Int = 0;
    let mut left_mouse_clicked: Int = 0;
    let mut left_mouse_click_in_cursor: Int = 0;
    let mut scroll_delta: f32 = 0.;
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as Int as Uint {
        *state = (NK_WIDGET_STATE_INACTIVE as Int | NK_WIDGET_STATE_MODIFIED as Int) as Flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as Int as Flags
    }
    if in_0.is_null() {
        return scroll_offset;
    } else {
        left_mouse_down = (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down;
        left_mouse_clicked = (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].clicked as Int;
        left_mouse_click_in_cursor =
            nk_input_has_mouse_click_down_in_rect(in_0, NK_BUTTON_LEFT, *cursor, nk_true as Int);
        if 0 != nk_input_is_mouse_hovering_rect(in_0, *scroll) {
            *state = NK_WIDGET_STATE_HOVERED as Int as Flags
        }
        scroll_delta = if o as Uint == NK_VERTICAL as Int as Uint {
            (*in_0).mouse.scroll_delta.y
        } else {
            (*in_0).mouse.scroll_delta.x
        };
        if 0 != left_mouse_down && 0 != left_mouse_click_in_cursor && 0 == left_mouse_clicked {
            let mut pixel: f32 = 0.;
            /* update cursor by mouse dragging */
            let mut delta: f32 = 0.;
            *state = NK_WIDGET_STATE_ACTIVE as Int as Flags;
            if o as Uint == NK_VERTICAL as Int as Uint {
                cursor_y = 0.;
                pixel = (*in_0).mouse.delta.y;
                delta = pixel / (*scroll).h * target;
                scroll_offset = if if scroll_offset + delta < target - (*scroll).h {
                    scroll_offset + delta
                } else {
                    target - (*scroll).h
                } < 0i32 as f32
                {
                    0i32 as f32
                } else if scroll_offset + delta < target - (*scroll).h {
                    scroll_offset + delta
                } else {
                    target - (*scroll).h
                };
                cursor_y = (*scroll).y + scroll_offset / target * (*scroll).h;
                (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize]
                    .clicked_pos
                    .y = cursor_y + (*cursor).h / 2.0f32
            } else {
                let mut cursor_x: f32 = 0.;
                pixel = (*in_0).mouse.delta.x;
                delta = pixel / (*scroll).w * target;
                scroll_offset = if if scroll_offset + delta < target - (*scroll).w {
                    scroll_offset + delta
                } else {
                    target - (*scroll).w
                } < 0i32 as f32
                {
                    0i32 as f32
                } else if scroll_offset + delta < target - (*scroll).w {
                    scroll_offset + delta
                } else {
                    target - (*scroll).w
                };
                cursor_x = (*scroll).x + scroll_offset / target * (*scroll).w;
                (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize]
                    .clicked_pos
                    .x = cursor_x + (*cursor).w / 2.0f32
            }
        } else if 0 != nk_input_is_key_pressed(in_0, NK_KEY_SCROLL_UP)
            && o as Uint == NK_VERTICAL as Int as Uint
            && 0 != has_scrolling
            || 0 != ButtonBehavior(&mut ws, *empty0, in_0, NK_BUTTON_DEFAULT)
        {
            /* scroll page up by click on empty space or shortcut */
            if o as Uint == NK_VERTICAL as Int as Uint {
                scroll_offset = if (0i32 as f32) < scroll_offset - (*scroll).h {
                    scroll_offset - (*scroll).h
                } else {
                    0i32 as f32
                }
            } else {
                scroll_offset = if (0i32 as f32) < scroll_offset - (*scroll).w {
                    scroll_offset - (*scroll).w
                } else {
                    0i32 as f32
                }
            }
        } else if 0 != nk_input_is_key_pressed(in_0, NK_KEY_SCROLL_DOWN)
            && o as Uint == NK_VERTICAL as Int as Uint
            && 0 != has_scrolling
            || 0 != ButtonBehavior(&mut ws, *empty1, in_0, NK_BUTTON_DEFAULT)
        {
            /* scroll page down by click on empty space or shortcut */
            if o as Uint == NK_VERTICAL as Int as Uint {
                scroll_offset = if scroll_offset + (*scroll).h < target - (*scroll).h {
                    scroll_offset + (*scroll).h
                } else {
                    target - (*scroll).h
                }
            } else {
                scroll_offset = if scroll_offset + (*scroll).w < target - (*scroll).w {
                    scroll_offset + (*scroll).w
                } else {
                    target - (*scroll).w
                }
            }
        } else if 0 != has_scrolling {
            if scroll_delta < 0i32 as f32 || scroll_delta > 0i32 as f32 {
                /* update cursor by mouse scrolling */
                scroll_offset = scroll_offset + scroll_step * -scroll_delta;
                if o as Uint == NK_VERTICAL as Int as Uint {
                    scroll_offset = if if scroll_offset < target - (*scroll).h {
                        scroll_offset
                    } else {
                        target - (*scroll).h
                    } < 0i32 as f32
                    {
                        0i32 as f32
                    } else if scroll_offset < target - (*scroll).h {
                        scroll_offset
                    } else {
                        target - (*scroll).h
                    }
                } else {
                    scroll_offset = if if scroll_offset < target - (*scroll).w {
                        scroll_offset
                    } else {
                        target - (*scroll).w
                    } < 0i32 as f32
                    {
                        0i32 as f32
                    } else if scroll_offset < target - (*scroll).w {
                        scroll_offset
                    } else {
                        target - (*scroll).w
                    }
                }
            } else if 0 != nk_input_is_key_pressed(in_0, NK_KEY_SCROLL_START) {
                /* update cursor to the beginning  */
                if o as Uint == NK_VERTICAL as Int as Uint {
                    scroll_offset = 0i32 as f32
                }
            } else if 0 != nk_input_is_key_pressed(in_0, NK_KEY_SCROLL_END) {
                /* update cursor to the end */
                if o as Uint == NK_VERTICAL as Int as Uint {
                    scroll_offset = target - (*scroll).h
                }
            }
        }
        if 0 != *state & NK_WIDGET_STATE_HOVER as Int as Uint
            && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, *scroll)
        {
            *state |= NK_WIDGET_STATE_ENTERED as Int as Uint
        } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, *scroll) {
            *state |= NK_WIDGET_STATE_LEFT as Int as Uint
        }
        return scroll_offset;
    };
}

unsafe fn nk_do_scrollbarv(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut scroll: Rect,
    mut has_scrolling: Int,
    mut offset: f32,
    mut target: f32,
    mut step: f32,
    mut button_pixel_inc: f32,
    mut style: *const StyleScrollbar,
    mut in_0: *mut Input,
    mut font: *const UserFont,
) -> f32 {
    let mut empty_north: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut empty_south: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut cursor: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut scroll_step: f32 = 0.;
    let mut scroll_offset: f32 = 0.;
    let mut scroll_off: f32 = 0.;
    let mut scroll_ratio: f32 = 0.;
    if out.is_null() || style.is_null() {
        return 0i32 as f32;
    } else {
        scroll.w = if scroll.w < 1i32 as f32 {
            1i32 as f32
        } else {
            scroll.w
        };
        scroll.h = if scroll.h < 0i32 as f32 {
            0i32 as f32
        } else {
            scroll.h
        };
        if target <= scroll.h {
            return 0i32 as f32;
        } else {
            /* optional scrollbar buttons */
            if 0 != (*style).show_buttons {
                let mut ws: Flags = 0;
                let mut scroll_h: f32 = 0.;
                let mut button: Rect = Rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                button.x = scroll.x;
                button.w = scroll.w;
                button.h = scroll.w;
                scroll_h = if scroll.h - 2i32 as f32 * button.h < 0i32 as f32 {
                    0i32 as f32
                } else {
                    scroll.h - 2i32 as f32 * button.h
                };
                scroll_step = if step < button_pixel_inc {
                    step
                } else {
                    button_pixel_inc
                };
                /* decrement button */
                button.y = scroll.y;
                if 0 != nk_do_button_symbol(
                    &mut ws,
                    out,
                    button,
                    (*style).dec_symbol,
                    NK_BUTTON_REPEATER,
                    &(*style).dec_button,
                    in_0,
                    font,
                ) {
                    offset = offset - scroll_step
                }
                /* increment button */
                button.y = scroll.y + scroll.h - button.h;
                if 0 != nk_do_button_symbol(
                    &mut ws,
                    out,
                    button,
                    (*style).inc_symbol,
                    NK_BUTTON_REPEATER,
                    &(*style).inc_button,
                    in_0,
                    font,
                ) {
                    offset = offset + scroll_step
                }
                scroll.y = scroll.y + button.h;
                scroll.h = scroll_h
            }
            /* calculate scrollbar constants */
            scroll_step = if step < scroll.h { step } else { scroll.h };
            scroll_offset = if if offset < target - scroll.h {
                offset
            } else {
                target - scroll.h
            } < 0i32 as f32
            {
                0i32 as f32
            } else if offset < target - scroll.h {
                offset
            } else {
                target - scroll.h
            };
            scroll_ratio = scroll.h / target;
            scroll_off = scroll_offset / target;
            /* calculate scrollbar cursor bounds */
            cursor.h = if scroll_ratio * scroll.h
                - (2i32 as f32 * (*style).border + 2i32 as f32 * (*style).padding.y)
                < 0i32 as f32
            {
                0i32 as f32
            } else {
                scroll_ratio * scroll.h
                    - (2i32 as f32 * (*style).border + 2i32 as f32 * (*style).padding.y)
            };
            cursor.y = scroll.y + scroll_off * scroll.h + (*style).border + (*style).padding.y;
            cursor.w =
                scroll.w - (2i32 as f32 * (*style).border + 2i32 as f32 * (*style).padding.x);
            cursor.x = scroll.x + (*style).border + (*style).padding.x;
            /* calculate empty space around cursor */
            empty_north.x = scroll.x;
            empty_north.y = scroll.y;
            empty_north.w = scroll.w;
            empty_north.h = if cursor.y - scroll.y < 0i32 as f32 {
                0i32 as f32
            } else {
                cursor.y - scroll.y
            };
            empty_south.x = scroll.x;
            empty_south.y = cursor.y + cursor.h;
            empty_south.w = scroll.w;
            empty_south.h = if scroll.y + scroll.h - (cursor.y + cursor.h) < 0i32 as f32 {
                0i32 as f32
            } else {
                scroll.y + scroll.h - (cursor.y + cursor.h)
            };
            /* update scrollbar */
            scroll_offset = nk_scrollbar_behavior(
                state,
                in_0,
                has_scrolling,
                &mut scroll,
                &mut cursor,
                &mut empty_north,
                &mut empty_south,
                scroll_offset,
                target,
                scroll_step,
                NK_VERTICAL,
            );
            scroll_off = scroll_offset / target;
            cursor.y =
                scroll.y + scroll_off * scroll.h + (*style).border_cursor + (*style).padding.y;
            /* draw scrollbar */
            if (*style).draw_begin.is_some() {
                (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
            }
            nk_draw_scrollbar(out, *state, style, &mut scroll, &mut cursor);
            if (*style).draw_end.is_some() {
                (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
            }
            return scroll_offset;
        }
    };
}

pub unsafe fn nk_window_find(mut ctx: *mut Context, mut name: *const Char) -> *mut Window {
    let mut title_len: Int = 0;
    let mut title_hash: Hash = 0;
    title_len = nk_strlen(name);
    title_hash = nk_murmur_hash(
        name as *const Void,
        title_len,
        NK_WINDOW_TITLE as Int as Hash,
    );
    return nk_find_window(ctx, title_hash, name);
}

pub unsafe fn nk_window_get_bounds(mut ctx: *const Context) -> Rect {
    if ctx.is_null() || (*ctx).current.is_null() {
        return Rect::new(0i32 as f32, 0i32 as f32, 0i32 as f32, 0i32 as f32);
    } else {
        return (*(*ctx).current).bounds;
    };
}

pub unsafe fn nk_window_get_position(mut ctx: *const Context) -> Point {
    if ctx.is_null() || (*ctx).current.is_null() {
        return Point::new(0i32 as f32, 0i32 as f32);
    } else {
        return Point::new((*(*ctx).current).bounds.x, (*(*ctx).current).bounds.y);
    };
}

pub unsafe fn nk_window_get_size(mut ctx: *const Context) -> Point {
    if ctx.is_null() || (*ctx).current.is_null() {
        return Point::new(0i32 as f32, 0i32 as f32);
    } else {
        return Point::new((*(*ctx).current).bounds.w, (*(*ctx).current).bounds.h);
    };
}

pub unsafe fn nk_window_get_width(mut ctx: *const Context) -> f32 {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32 as f32;
    } else {
        return (*(*ctx).current).bounds.w;
    };
}

pub unsafe fn nk_window_get_height(mut ctx: *const Context) -> f32 {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32 as f32;
    } else {
        return (*(*ctx).current).bounds.h;
    };
}

pub unsafe fn nk_window_get_panel(mut ctx: *mut Context) -> *mut Panel {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0 as *mut Panel;
    } else {
        return (*(*ctx).current).layout;
    };
}

pub unsafe fn nk_window_get_content_region(mut ctx: *mut Context) -> Rect {
    if ctx.is_null() || (*ctx).current.is_null() {
        return Rect::new(0i32 as f32, 0i32 as f32, 0i32 as f32, 0i32 as f32);
    } else {
        return (*(*(*ctx).current).layout).clip;
    };
}

pub unsafe fn nk_window_get_content_region_min(mut ctx: *mut Context) -> Point {
    if ctx.is_null() || (*ctx).current.is_null() {
        return Point::new(0i32 as f32, 0i32 as f32);
    } else {
        return Point::new(
            (*(*(*ctx).current).layout).clip.x,
            (*(*(*ctx).current).layout).clip.y,
        );
    };
}

pub unsafe fn nk_window_get_content_region_max(mut ctx: *mut Context) -> Point {
    if ctx.is_null() || (*ctx).current.is_null() {
        return Point::new(0i32 as f32, 0i32 as f32);
    } else {
        return Point::new(
            (*(*(*ctx).current).layout).clip.x + (*(*(*ctx).current).layout).clip.w,
            (*(*(*ctx).current).layout).clip.y + (*(*(*ctx).current).layout).clip.h,
        );
    };
}

pub unsafe fn nk_window_get_content_region_size(mut ctx: *mut Context) -> Point {
    if ctx.is_null() || (*ctx).current.is_null() {
        return Point::new(0i32 as f32, 0i32 as f32);
    } else {
        return Point::new(
            (*(*(*ctx).current).layout).clip.w,
            (*(*(*ctx).current).layout).clip.h,
        );
    };
}

pub unsafe fn nk_window_get_canvas(mut ctx: *mut Context) -> *mut CommandBuffer {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0 as *mut CommandBuffer;
    } else {
        return &mut (*(*ctx).current).buffer as *mut CommandBuffer;
    };
}

pub unsafe fn nk_window_has_focus(mut ctx: *const Context) -> Int {
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32;
    } else {
        return ((*ctx).current == (*ctx).active) as Int;
    };
}

pub unsafe fn nk_window_is_collapsed(mut ctx: *mut Context, mut name: *const Char) -> Int {
    let mut title_len: Int = 0;
    let mut title_hash: Hash = 0;
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return 0i32;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const Void,
            title_len,
            NK_WINDOW_TITLE as Int as Hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return 0i32;
        } else {
            return ((*win).flags & NK_WINDOW_MINIMIZED as Int as Uint) as Int;
        }
    };
}

pub unsafe fn nk_window_is_closed(mut ctx: *mut Context, mut name: *const Char) -> Int {
    let mut title_len: Int = 0;
    let mut title_hash: Hash = 0;
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return 1i32;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const Void,
            title_len,
            NK_WINDOW_TITLE as Int as Hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return 1i32;
        } else {
            return ((*win).flags & NK_WINDOW_CLOSED as Int as Uint) as Int;
        }
    };
}

pub unsafe fn nk_window_is_hidden(mut ctx: *mut Context, mut name: *const Char) -> Int {
    let mut title_len: Int = 0;
    let mut title_hash: Hash = 0;
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return 1i32;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const Void,
            title_len,
            NK_WINDOW_TITLE as Int as Hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return 1i32;
        } else {
            return ((*win).flags & NK_WINDOW_HIDDEN as Int as Uint) as Int;
        }
    };
}

pub unsafe fn nk_window_is_active(mut ctx: *mut Context, mut name: *const Char) -> Int {
    let mut title_len: Int = 0;
    let mut title_hash: Hash = 0;
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return 0i32;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const Void,
            title_len,
            NK_WINDOW_TITLE as Int as Hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return 0i32;
        } else {
            return (win == (*ctx).active) as Int;
        }
    };
}

pub unsafe fn nk_window_is_any_hovered(mut ctx: *mut Context) -> Int {
    let mut iter: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return 0i32;
    } else {
        iter = (*ctx).begin;
        while !iter.is_null() {
            /* check if window is being hovered */
            if 0 == (*iter).flags & NK_WINDOW_HIDDEN as Int as Uint {
                /* check if window popup is being hovered */
                if 0 != (*iter).popup.active && !(*iter).popup.win.is_null()
                    && 0 != nk_input_is_mouse_hovering_rect(
                        &mut (*ctx).input,
                        (*(*iter).popup.win).bounds,
                    ) {
                    return 1i32;
                } else if 0 != (*iter).flags & NK_WINDOW_MINIMIZED as Int as Uint {
                    let mut header: Rect = (*iter).bounds;
                    header.h = (*(*ctx).style.font).height
                        + 2i32 as f32 * (*ctx).style.window.header.padding.y;
                    if 0 != nk_input_is_mouse_hovering_rect(&mut (*ctx).input, header) {
                        return 1i32;
                    }
                } else if 0 != nk_input_is_mouse_hovering_rect(&mut (*ctx).input, (*iter).bounds) {
                    return 1i32;
                }
            }
            iter = (*iter).next
        }
        return 0i32;
    };
}

pub unsafe fn nk_item_is_any_active(mut ctx: *mut Context) -> Int {
    let mut any_hovered: Int = nk_window_is_any_hovered(ctx);
    let mut any_active: Int =
        ((*ctx).last_widget_state & NK_WIDGET_STATE_MODIFIED as Int as Uint) as Int;
    return (0 != any_hovered || 0 != any_active) as Int;
}

pub unsafe fn nk_window_set_bounds(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut bounds: Rect,
) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return;
    } else {
        win = nk_window_find(ctx, name);
        if win.is_null() {
            return;
        } else {
            (*win).bounds = bounds;
            return;
        }
    };
}

pub unsafe fn nk_window_set_position(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut pos: Point,
) -> () {
    let mut win: *mut Window = nk_window_find(ctx, name);
    if win.is_null() {
        return;
    } else {
        (*win).bounds.x = pos.x;
        (*win).bounds.y = pos.y;
        return;
    };
}

pub unsafe fn nk_window_set_size(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut size: Point,
) -> () {
    let mut win: *mut Window = nk_window_find(ctx, name);
    if win.is_null() {
        return;
    } else {
        (*win).bounds.w = size.x;
        (*win).bounds.h = size.y;
        return;
    };
}

pub unsafe fn nk_window_set_focus(mut ctx: *mut Context, mut name: *const Char) -> () {
    let mut title_len: Int = 0;
    let mut title_hash: Hash = 0;
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const Void,
            title_len,
            NK_WINDOW_TITLE as Int as Hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if !win.is_null() && (*ctx).end != win {
            nk_remove_window(ctx, win);
            nk_insert_window(ctx, win, NK_INSERT_BACK);
        }
        (*ctx).active = win;
        return;
    };
}

pub unsafe fn nk_window_close(mut ctx: *mut Context, mut name: *const Char) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return;
    } else {
        win = nk_window_find(ctx, name);
        if win.is_null() {
            return;
        } else if (*ctx).current == win {
            return;
        } else {
            (*win).flags |= NK_WINDOW_HIDDEN as Int as Uint;
            (*win).flags |= NK_WINDOW_CLOSED as Int as Uint;
            return;
        }
    };
}

pub unsafe fn nk_window_collapse(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut c: CollapseStates,
) -> () {
    let mut title_len: Int = 0;
    let mut title_hash: Hash = 0;
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const Void,
            title_len,
            NK_WINDOW_TITLE as Int as Hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return;
        } else {
            if c as Uint == NK_MINIMIZED as Int as Uint {
                (*win).flags |= NK_WINDOW_MINIMIZED as Int as Uint
            } else {
                (*win).flags &= !(NK_WINDOW_MINIMIZED as Int as Flags)
            }
            return;
        }
    };
}

pub unsafe fn nk_window_collapse_if(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut c: CollapseStates,
    mut cond: Int,
) -> () {
    if ctx.is_null() || 0 == cond {
        return;
    } else {
        nk_window_collapse(ctx, name, c);
        return;
    };
}

pub unsafe fn nk_window_show(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut s: ShowStates,
) -> () {
    let mut title_len: Int = 0;
    let mut title_hash: Hash = 0;
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() {
        return;
    } else {
        title_len = nk_strlen(name);
        title_hash = nk_murmur_hash(
            name as *const Void,
            title_len,
            NK_WINDOW_TITLE as Int as Hash,
        );
        win = nk_find_window(ctx, title_hash, name);
        if win.is_null() {
            return;
        } else {
            if s as Uint == NK_HIDDEN as Int as Uint {
                (*win).flags |= NK_WINDOW_HIDDEN as Int as Uint
            } else {
                (*win).flags &= !(NK_WINDOW_HIDDEN as Int as Flags)
            }
            return;
        }
    };
}

pub unsafe fn nk_window_show_if(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut s: ShowStates,
    mut cond: Int,
) -> () {
    if ctx.is_null() || 0 == cond {
        return;
    } else {
        nk_window_show(ctx, name, s);
        return;
    };
}

pub unsafe fn nk_layout_set_min_row_height(mut ctx: *mut Context, mut height: f32) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).row.min_height = height;
        return;
    };
}

pub unsafe fn nk_layout_widget_bounds(mut ctx: *mut Context) -> Rect {
    let mut ret: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x = (*layout).at_x;
    ret.y = (*layout).at_y;
    ret.w = (*layout).bounds.w - if (*layout).at_x - (*layout).bounds.x < 0i32 as f32 {
        0i32 as f32
    } else {
        (*layout).at_x - (*layout).bounds.x
    };
    ret.h = (*layout).row.height;
    return ret;
}

pub unsafe fn nk_layout_ratio_from_pixel(mut ctx: *mut Context, mut pixel_width: f32) -> f32 {
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32 as f32;
    } else {
        win = (*ctx).current;
        return if if pixel_width / (*win).bounds.x < 1.0f32 {
            pixel_width / (*win).bounds.x
        } else {
            1.0f32
        } < 0.0f32
        {
            0.0f32
        } else if pixel_width / (*win).bounds.x < 1.0f32 {
            pixel_width / (*win).bounds.x
        } else {
            1.0f32
        };
    };
}

pub unsafe fn nk_layout_row_dynamic(mut ctx: *mut Context, mut height: f32, mut cols: Int) -> () {
    RowLayout(ctx, NK_DYNAMIC, height, cols, 0i32);
}

unsafe fn RowLayout(
    mut ctx: *mut Context,
    mut fmt: LayoutFormat,
    mut height: f32,
    mut cols: Int,
    mut width: Int,
) -> () {
    /* update the current row and set the current row layout */
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        nk_panel_layout(ctx, win, height, cols);
        if fmt as Uint == NK_DYNAMIC as Int as Uint {
            (*(*win).layout).row.type_0 = NK_LAYOUT_DYNAMIC_FIXED
        } else {
            (*(*win).layout).row.type_0 = NK_LAYOUT_STATIC_FIXED
        }
        (*(*win).layout).row.ratio = 0 as *const f32;
        (*(*win).layout).row.filled = 0i32 as f32;
        (*(*win).layout).row.item_offset = 0i32 as f32;
        (*(*win).layout).row.item_width = width as f32;
        return;
    };
}

unsafe fn nk_panel_layout(
    mut ctx: *const Context,
    mut win: *mut Window,
    mut height: f32,
    mut cols: Int,
) -> () {
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut style: *const Style = 0 as *const Style;
    let mut out: *mut CommandBuffer = 0 as *mut CommandBuffer;
    let mut item_spacing: Point = Point { x: 0., y: 0. };
    let mut color: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        /* prefetch some configuration data */
        layout = (*win).layout;
        style = &(*ctx).style as *const Style;
        out = &mut (*win).buffer as *mut CommandBuffer;
        color = (*style).window.background;
        item_spacing = (*style).window.spacing;
        /*  if one of these triggers you forgot to add an `if` condition around either
        a window, group, popup, combobox or contextual menu `begin` and `end` block.
        Example:
            if (nk_begin(...) {...} nk_end(...); or
            if (nk_group_begin(...) { nk_group_end(...);} */
        /* update the current row and set the current row layout */
        (*layout).row.index = 0i32;
        (*layout).at_y += (*layout).row.height;
        (*layout).row.columns = cols;
        if height == 0.0f32 {
            (*layout).row.height = if height < (*layout).row.min_height {
                (*layout).row.min_height
            } else {
                height
            } + item_spacing.y
        } else {
            (*layout).row.height = height + item_spacing.y
        }
        (*layout).row.item_offset = 0i32 as f32;
        if 0 != (*layout).flags & NK_WINDOW_DYNAMIC as Int as Uint {
            /* draw background for dynamic panels */
            let mut background: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            background.x = (*win).bounds.x;
            background.w = (*win).bounds.w;
            background.y = (*layout).at_y - 1.0f32;
            background.h = (*layout).row.height + 1.0f32;
            nk_fill_rect(out, background, 0i32 as f32, color);
        }
        return;
    };
}

pub unsafe fn nk_layout_row_static(
    mut ctx: *mut Context,
    mut height: f32,
    mut item_width: Int,
    mut cols: Int,
) -> () {
    RowLayout(ctx, NK_STATIC, height, cols, item_width);
}

pub unsafe fn nk_layout_row_begin(
    mut ctx: *mut Context,
    mut fmt: LayoutFormat,
    mut row_height: f32,
    mut cols: Int,
) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        nk_panel_layout(ctx, win, row_height, cols);
        if fmt as Uint == NK_DYNAMIC as Int as Uint {
            (*layout).row.type_0 = NK_LAYOUT_DYNAMIC_ROW
        } else {
            (*layout).row.type_0 = NK_LAYOUT_STATIC_ROW
        }
        (*layout).row.ratio = 0 as *const f32;
        (*layout).row.filled = 0i32 as f32;
        (*layout).row.item_width = 0i32 as f32;
        (*layout).row.item_offset = 0i32 as f32;
        (*layout).row.columns = cols;
        return;
    };
}

pub unsafe fn nk_layout_row_push(mut ctx: *mut Context, mut ratio_or_width: f32) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as Uint != NK_LAYOUT_STATIC_ROW as Int as Uint
            && (*layout).row.type_0 as Uint != NK_LAYOUT_DYNAMIC_ROW as Int as Uint
        {
            return;
        } else {
            if (*layout).row.type_0 as Uint == NK_LAYOUT_DYNAMIC_ROW as Int as Uint {
                let mut ratio: f32 = ratio_or_width;
                if ratio + (*layout).row.filled > 1.0f32 {
                    return;
                } else if ratio > 0.0f32 {
                    (*layout).row.item_width =
                        if (0i32 as f32) < if 1.0f32 < ratio { 1.0f32 } else { ratio } {
                            if 1.0f32 < ratio {
                                1.0f32
                            } else {
                                ratio
                            }
                        } else {
                            0i32 as f32
                        }
                } else {
                    (*layout).row.item_width = 1.0f32 - (*layout).row.filled
                }
            } else {
                (*layout).row.item_width = ratio_or_width
            }
            return;
        }
    };
}

pub unsafe fn nk_layout_row_end(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as Uint != NK_LAYOUT_STATIC_ROW as Int as Uint
            && (*layout).row.type_0 as Uint != NK_LAYOUT_DYNAMIC_ROW as Int as Uint
        {
            return;
        } else {
            (*layout).row.item_width = 0i32 as f32;
            (*layout).row.item_offset = 0i32 as f32;
            return;
        }
    };
}

pub unsafe fn nk_layout_row(
    mut ctx: *mut Context,
    mut fmt: LayoutFormat,
    mut height: f32,
    mut cols: Int,
    mut ratio: *const f32,
) -> () {
    let mut i: Int = 0;
    let mut n_undef: Int = 0i32;
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        nk_panel_layout(ctx, win, height, cols);
        if fmt as Uint == NK_DYNAMIC as Int as Uint {
            /* calculate width of undefined widget ratios */
            let mut r: f32 = 0i32 as f32;
            (*layout).row.ratio = ratio;
            i = 0i32;
            while i < cols {
                if *ratio.offset(i as isize) < 0.0f32 {
                    n_undef += 1
                } else {
                    r += *ratio.offset(i as isize)
                }
                i += 1
            }
            r = if (0i32 as f32) < if 1.0f32 < 1.0f32 - r {
                1.0f32
            } else {
                1.0f32 - r
            } {
                if 1.0f32 < 1.0f32 - r {
                    1.0f32
                } else {
                    1.0f32 - r
                }
            } else {
                0i32 as f32
            };
            (*layout).row.type_0 = NK_LAYOUT_DYNAMIC;
            (*layout).row.item_width = if r > 0i32 as f32 && n_undef > 0i32 {
                r / n_undef as f32
            } else {
                0i32 as f32
            }
        } else {
            (*layout).row.ratio = ratio;
            (*layout).row.type_0 = NK_LAYOUT_STATIC;
            (*layout).row.item_width = 0i32 as f32;
            (*layout).row.item_offset = 0i32 as f32
        }
        (*layout).row.item_offset = 0i32 as f32;
        (*layout).row.filled = 0i32 as f32;
        return;
    };
}

pub unsafe fn nk_layout_row_template_begin(mut ctx: *mut Context, mut height: f32) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        nk_panel_layout(ctx, win, height, 1i32);
        (*layout).row.type_0 = NK_LAYOUT_TEMPLATE;
        (*layout).row.columns = 0i32;
        (*layout).row.ratio = 0 as *const f32;
        (*layout).row.item_width = 0i32 as f32;
        (*layout).row.item_height = 0i32 as f32;
        (*layout).row.item_offset = 0i32 as f32;
        (*layout).row.filled = 0i32 as f32;
        (*layout).row.item.x = 0i32 as f32;
        (*layout).row.item.y = 0i32 as f32;
        (*layout).row.item.w = 0i32 as f32;
        (*layout).row.item.h = 0i32 as f32;
        return;
    };
}

pub unsafe fn nk_layout_row_template_push_dynamic(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as Uint != NK_LAYOUT_TEMPLATE as Int as Uint {
            return;
        } else if (*layout).row.columns >= 16i32 {
            return;
        } else {
            let fresh15 = (*layout).row.columns;
            (*layout).row.columns = (*layout).row.columns + 1;
            (*layout).row.templates[fresh15 as usize] = -1.0f32;
            return;
        }
    };
}

pub unsafe fn nk_layout_row_template_push_variable(
    mut ctx: *mut Context,
    mut min_width: f32,
) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as Uint != NK_LAYOUT_TEMPLATE as Int as Uint {
            return;
        } else if (*layout).row.columns >= 16i32 {
            return;
        } else {
            let fresh16 = (*layout).row.columns;
            (*layout).row.columns = (*layout).row.columns + 1;
            (*layout).row.templates[fresh16 as usize] = -min_width;
            return;
        }
    };
}

pub unsafe fn nk_layout_row_template_push_static(mut ctx: *mut Context, mut width: f32) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as Uint != NK_LAYOUT_TEMPLATE as Int as Uint {
            return;
        } else if (*layout).row.columns >= 16i32 {
            return;
        } else {
            let fresh17 = (*layout).row.columns;
            (*layout).row.columns = (*layout).row.columns + 1;
            (*layout).row.templates[fresh17 as usize] = width;
            return;
        }
    };
}

pub unsafe fn nk_layout_row_template_end(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut i: Int = 0i32;
    let mut variable_count: Int = 0i32;
    let mut min_variable_count: Int = 0i32;
    let mut min_fixed_width: f32 = 0.0f32;
    let mut total_fixed_width: f32 = 0.0f32;
    let mut max_variable_width: f32 = 0.0f32;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.type_0 as Uint != NK_LAYOUT_TEMPLATE as Int as Uint {
            return;
        } else {
            i = 0i32;
            while i < (*layout).row.columns {
                let mut width: f32 = (*layout).row.templates[i as usize];
                if width >= 0.0f32 {
                    total_fixed_width += width;
                    min_fixed_width += width
                } else if width < -1.0f32 {
                    width = -width;
                    total_fixed_width += width;
                    max_variable_width = if max_variable_width < width {
                        width
                    } else {
                        max_variable_width
                    };
                    variable_count += 1
                } else {
                    min_variable_count += 1;
                    variable_count += 1
                }
                i += 1
            }
            if 0 != variable_count {
                let mut space: f32 = nk_layout_row_calculate_usable_space(
                    &mut (*ctx).style,
                    (*layout).type_0,
                    (*layout).bounds.w,
                    (*layout).row.columns,
                );
                let mut var_width: f32 = if space - min_fixed_width < 0.0f32 {
                    0.0f32
                } else {
                    space - min_fixed_width
                } / variable_count as f32;
                let mut enough_space: Int = (var_width >= max_variable_width) as Int;
                if 0 == enough_space {
                    var_width = if space - total_fixed_width < 0i32 as f32 {
                        0i32 as f32
                    } else {
                        space - total_fixed_width
                    } / min_variable_count as f32
                }
                i = 0i32;
                while i < (*layout).row.columns {
                    let mut width_0: *mut f32 =
                        &mut (*layout).row.templates[i as usize] as *mut f32;
                    *width_0 = if *width_0 >= 0.0f32 {
                        *width_0
                    } else if *width_0 < -1.0f32 && 0 == enough_space {
                        -*width_0
                    } else {
                        var_width
                    };
                    i += 1
                }
            }
            return;
        }
    };
}
unsafe fn nk_layout_row_calculate_usable_space(
    mut style: *const Style,
    mut type_0: PanelType,
    mut total_space: f32,
    mut columns: Int,
) -> f32 {
    let mut panel_padding: f32 = 0.;
    let mut panel_spacing: f32 = 0.;
    let mut panel_space: f32 = 0.;
    let mut spacing: Point = Point { x: 0., y: 0. };
    let mut padding: Point = Point { x: 0., y: 0. };
    spacing = (*style).window.spacing;
    padding = nk_panel_get_padding(style, type_0);
    /* calculate the usable panel space */
    panel_padding = 2i32 as f32 * padding.x;
    panel_spacing = (if columns - 1i32 < 0i32 {
        0i32
    } else {
        columns - 1i32
    }) as f32 * spacing.x;
    panel_space = total_space - panel_padding - panel_spacing;
    return panel_space;
}

pub unsafe fn nk_layout_space_begin(
    mut ctx: *mut Context,
    mut fmt: LayoutFormat,
    mut height: f32,
    mut widget_count: Int,
) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        nk_panel_layout(ctx, win, height, widget_count);
        if fmt as Uint == NK_STATIC as Int as Uint {
            (*layout).row.type_0 = NK_LAYOUT_STATIC_FREE
        } else {
            (*layout).row.type_0 = NK_LAYOUT_DYNAMIC_FREE
        }
        (*layout).row.ratio = 0 as *const f32;
        (*layout).row.filled = 0i32 as f32;
        (*layout).row.item_width = 0i32 as f32;
        (*layout).row.item_offset = 0i32 as f32;
        return;
    };
}

pub unsafe fn nk_layout_space_push(mut ctx: *mut Context, mut rect: Rect) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).row.item = rect;
        return;
    };
}

pub unsafe fn nk_layout_space_end(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).row.item_width = 0i32 as f32;
        (*layout).row.item_height = 0i32 as f32;
        (*layout).row.item_offset = 0i32 as f32;
        nk_zero(
            &mut (*layout).row.item as *mut Rect as *mut Void,
            mem::size_of::<Rect>() as Ulong,
        );
        return;
    };
}

pub unsafe fn nk_layout_space_bounds(mut ctx: *mut Context) -> Rect {
    let mut ret: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x = (*layout).clip.x;
    ret.y = (*layout).clip.y;
    ret.w = (*layout).clip.w;
    ret.h = (*layout).row.height;
    return ret;
}

pub unsafe fn nk_layout_space_to_screen(mut ctx: *mut Context, mut ret: Point) -> Point {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x += (*layout).at_x - *(*layout).offset_x as f32;
    ret.y += (*layout).at_y - *(*layout).offset_y as f32;
    return ret;
}

pub unsafe fn nk_layout_space_to_local(mut ctx: *mut Context, mut ret: Point) -> Point {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x += -(*layout).at_x + *(*layout).offset_x as f32;
    ret.y += -(*layout).at_y + *(*layout).offset_y as f32;
    return ret;
}

pub unsafe fn nk_layout_space_rect_to_screen(mut ctx: *mut Context, mut ret: Rect) -> Rect {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x += (*layout).at_x - *(*layout).offset_x as f32;
    ret.y += (*layout).at_y - *(*layout).offset_y as f32;
    return ret;
}

pub unsafe fn nk_layout_space_rect_to_local(mut ctx: *mut Context, mut ret: Rect) -> Rect {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    win = (*ctx).current;
    layout = (*win).layout;
    ret.x += -(*layout).at_x + *(*layout).offset_x as f32;
    ret.y += -(*layout).at_y + *(*layout).offset_y as f32;
    return ret;
}

pub unsafe fn nk_group_begin(
    mut ctx: *mut Context,
    mut title: *const Char,
    mut flags: Flags,
) -> Int {
    return nk_group_begin_titled(ctx, title, title, flags);
}

pub unsafe fn nk_group_begin_titled(
    mut ctx: *mut Context,
    mut id: *const Char,
    mut title: *const Char,
    mut flags: Flags,
) -> Int {
    let mut id_len: Int = 0;
    let mut id_hash: Hash = 0;
    let mut win: *mut Window = 0 as *mut Window;
    let mut x_offset: *mut u32 = 0 as *mut u32;
    let mut y_offset: *mut u32 = 0 as *mut u32;
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || id.is_null()
    {
        return 0i32;
    } else {
        /* find persistent group scrollbar value */
        win = (*ctx).current;
        id_len = nk_strlen(id);
        id_hash = nk_murmur_hash(id as *const Void, id_len, NK_PANEL_GROUP as Int as Hash);
        x_offset = nk_find_value(win, id_hash);
        if x_offset.is_null() {
            x_offset = nk_add_value(ctx, win, id_hash, 0i32 as u32);
            y_offset = nk_add_value(ctx, win, id_hash.wrapping_add(1i32 as Uint), 0i32 as u32);
            if x_offset.is_null() || y_offset.is_null() {
                return 0i32;
            } else {
                *y_offset = 0i32 as u32;
                *x_offset = *y_offset
            }
        } else {
            y_offset = nk_find_value(win, id_hash.wrapping_add(1i32 as Uint))
        }
        return nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);
    };
}

pub unsafe fn nk_group_scrolled_offset_begin(
    mut ctx: *mut Context,
    mut x_offset: *mut u32,
    mut y_offset: *mut u32,
    mut title: *const Char,
    mut flags: Flags,
) -> Int {
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut panel: Window = Window {
        seq: 0,
        name: 0,
        name_string: [0; 64],
        flags: 0,
        bounds: Rect {
            x: 0.,
            y: 0.,
            w: 0.,
            h: 0.,
        },
        scrollbar: Scroll { x: 0, y: 0 },
        buffer: CommandBuffer {
            base: 0 as *mut Buffer,
            clip: Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            },
            use_clipping: 0,
            userdata: Handle {
                ptr: 0 as *mut Void,
            },
            begin: 0,
            end: 0,
            last: 0,
        },
        layout: 0 as *mut Panel,
        scrollbar_hiding_timer: 0.,
        property: PropertyState {
            active: 0,
            prev: 0,
            buffer: [0; 64],
            length: 0,
            cursor: 0,
            select_start: 0,
            select_end: 0,
            name: 0,
            seq: 0,
            old: 0,
            state: 0,
        },
        popup: PopupState {
            win: 0 as *mut Window,
            type_0: NK_PANEL_NONE,
            buf: PopupBuffer {
                begin: 0,
                parent: 0,
                last: 0,
                end: 0,
                active: 0,
            },
            name: 0,
            active: 0,
            combo_count: 0,
            con_count: 0,
            con_old: 0,
            active_con: 0,
            header: Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            },
        },
        edit: EditState {
            name: 0,
            seq: 0,
            old: 0,
            active: 0,
            prev: 0,
            cursor: 0,
            sel_start: 0,
            sel_end: 0,
            scrollbar: Scroll { x: 0, y: 0 },
            mode: 0,
            single_line: 0,
        },
        scrolled: 0,
        tables: 0 as *mut Table,
        table_count: 0,
        next: 0 as *mut Window,
        prev: 0 as *mut Window,
        parent: 0 as *mut Window,
    };
    let mut win: *mut Window = 0 as *mut Window;
    win = (*ctx).current;
    nk_panel_alloc_space(&mut bounds, ctx);
    let mut c: *const Rect = &mut (*(*win).layout).clip as *mut Rect;
    if (bounds.x > (*c).x + (*c).w
        || bounds.x + bounds.w < (*c).x
        || bounds.y > (*c).y + (*c).h
        || bounds.y + bounds.h < (*c).y) && 0 == flags & NK_WINDOW_MOVABLE as Int as Uint
    {
        return 0i32;
    } else {
        if 0 != (*win).flags & NK_WINDOW_ROM as Int as Uint {
            flags |= NK_WINDOW_ROM as Int as Uint
        }
        /* initialize a fake window to create the panel from */
        nk_zero(
            &mut panel as *mut Window as *mut Void,
            mem::size_of::<Window>() as Ulong,
        );
        panel.bounds = bounds;
        panel.flags = flags;
        panel.scrollbar.x = *x_offset;
        panel.scrollbar.y = *y_offset;
        panel.buffer = (*win).buffer;
        panel.layout = nk_create_panel(ctx) as *mut Panel;
        (*ctx).current = &mut panel;
        nk_panel_begin(
            ctx,
            if 0 != flags & NK_WINDOW_TITLE as Int as Uint {
                title
            } else {
                0 as *const Char
            },
            NK_PANEL_GROUP,
        );
        (*win).buffer = panel.buffer;
        (*win).buffer.clip = (*panel.layout).clip;
        (*panel.layout).offset_x = x_offset;
        (*panel.layout).offset_y = y_offset;
        (*panel.layout).parent = (*win).layout;
        (*win).layout = panel.layout;
        (*ctx).current = win;
        if 0 != (*panel.layout).flags & NK_WINDOW_CLOSED as Int as Uint
            || 0 != (*panel.layout).flags & NK_WINDOW_MINIMIZED as Int as Uint
        {
            let mut f: Flags = (*panel.layout).flags;
            nk_group_scrolled_end(ctx);
            if 0 != f & NK_WINDOW_CLOSED as Int as Uint {
                return NK_WINDOW_CLOSED as Int;
            } else if 0 != f & NK_WINDOW_MINIMIZED as Int as Uint {
                return NK_WINDOW_MINIMIZED as Int;
            }
        }
        return 1i32;
    };
}

pub unsafe fn nk_group_scrolled_end(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut parent: *mut Panel = 0 as *mut Panel;
    let mut g: *mut Panel = 0 as *mut Panel;
    let mut clip: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut pan: Window = Window {
        seq: 0,
        name: 0,
        name_string: [0; 64],
        flags: 0,
        bounds: Rect {
            x: 0.,
            y: 0.,
            w: 0.,
            h: 0.,
        },
        scrollbar: Scroll { x: 0, y: 0 },
        buffer: CommandBuffer {
            base: 0 as *mut Buffer,
            clip: Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            },
            use_clipping: 0,
            userdata: Handle {
                ptr: 0 as *mut Void,
            },
            begin: 0,
            end: 0,
            last: 0,
        },
        layout: 0 as *mut Panel,
        scrollbar_hiding_timer: 0.,
        property: PropertyState {
            active: 0,
            prev: 0,
            buffer: [0; 64],
            length: 0,
            cursor: 0,
            select_start: 0,
            select_end: 0,
            name: 0,
            seq: 0,
            old: 0,
            state: 0,
        },
        popup: PopupState {
            win: 0 as *mut Window,
            type_0: NK_PANEL_NONE,
            buf: PopupBuffer {
                begin: 0,
                parent: 0,
                last: 0,
                end: 0,
                active: 0,
            },
            name: 0,
            active: 0,
            combo_count: 0,
            con_count: 0,
            con_old: 0,
            active_con: 0,
            header: Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            },
        },
        edit: EditState {
            name: 0,
            seq: 0,
            old: 0,
            active: 0,
            prev: 0,
            cursor: 0,
            sel_start: 0,
            sel_end: 0,
            scrollbar: Scroll { x: 0, y: 0 },
            mode: 0,
            single_line: 0,
        },
        scrolled: 0,
        tables: 0 as *mut Table,
        table_count: 0,
        next: 0 as *mut Window,
        prev: 0 as *mut Window,
        parent: 0 as *mut Window,
    };
    let mut panel_padding: Point = Point { x: 0., y: 0. };
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        /* make sure nk_group_begin was called correctly */
        win = (*ctx).current;
        g = (*win).layout;
        parent = (*g).parent;
        nk_zero(
            &mut pan as *mut Window as *mut Void,
            mem::size_of::<Window>() as Ulong,
        );
        /* dummy window */
        panel_padding = nk_panel_get_padding(&mut (*ctx).style, NK_PANEL_GROUP);
        pan.bounds.y = (*g).bounds.y - ((*g).header_height + (*g).menu.h);
        pan.bounds.x = (*g).bounds.x - panel_padding.x;
        pan.bounds.w = (*g).bounds.w + 2i32 as f32 * panel_padding.x;
        pan.bounds.h = (*g).bounds.h + (*g).header_height + (*g).menu.h;
        if 0 != (*g).flags & NK_WINDOW_BORDER as Int as Uint {
            pan.bounds.x -= (*g).border;
            pan.bounds.y -= (*g).border;
            pan.bounds.w += 2i32 as f32 * (*g).border;
            pan.bounds.h += 2i32 as f32 * (*g).border
        }
        if 0 == (*g).flags & NK_WINDOW_NO_SCROLLBAR as Int as Uint {
            pan.bounds.w += (*ctx).style.window.scrollbar_size.x;
            pan.bounds.h += (*ctx).style.window.scrollbar_size.y
        }
        pan.scrollbar.x = *(*g).offset_x;
        pan.scrollbar.y = *(*g).offset_y;
        pan.flags = (*g).flags;
        pan.buffer = (*win).buffer;
        pan.layout = g;
        pan.parent = win;
        (*ctx).current = &mut pan;
        /* make sure group has correct clipping rectangle */
        nk_unify(
            &mut clip,
            &mut (*parent).clip,
            pan.bounds.x,
            pan.bounds.y,
            pan.bounds.x + pan.bounds.w,
            pan.bounds.y + pan.bounds.h + panel_padding.x,
        );
        nk_push_scissor(&mut pan.buffer, clip);
        nk_end(ctx);
        (*win).buffer = pan.buffer;
        nk_push_scissor(&mut (*win).buffer, (*parent).clip);
        (*ctx).current = win;
        (*win).layout = parent;
        (*g).bounds = pan.bounds;
        return;
    };
}
unsafe fn nk_panel_alloc_space(mut bounds: *mut Rect, mut ctx: *const Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        /* check if the end of the row has been hit and begin new row if so */
        win = (*ctx).current;
        layout = (*win).layout;
        if (*layout).row.index >= (*layout).row.columns {
            nk_panel_alloc_row(ctx, win);
        }
        /* calculate widget position and size */
        nk_layout_widget_space(bounds, ctx, win, nk_true as Int);
        (*layout).row.index += 1;
        return;
    };
}
unsafe fn nk_layout_widget_space(
    mut bounds: *mut Rect,
    mut ctx: *const Context,
    mut win: *mut Window,
    mut modify: Int,
) -> () {
    let mut w: f32 = 0.;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut style: *const Style = 0 as *const Style;
    let mut spacing: Point = Point { x: 0., y: 0. };
    let mut padding: Point = Point { x: 0., y: 0. };
    let mut item_offset: f32 = 0i32 as f32;
    let mut item_width: f32 = 0i32 as f32;
    let mut item_spacing: f32 = 0i32 as f32;
    let mut panel_space: f32 = 0i32 as f32;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        style = &(*ctx).style as *const Style;
        spacing = (*style).window.spacing;
        padding = nk_panel_get_padding(style, (*layout).type_0);
        panel_space = nk_layout_row_calculate_usable_space(
            &(*ctx).style,
            (*layout).type_0,
            (*layout).bounds.w,
            (*layout).row.columns,
        );
        /* will be used to remove fookin gaps */
        /* calculate the width of one item inside the current layout space */
        match (*layout).row.type_0 as Uint {
            0 => {
                /* scaling fixed size widgets item width */
                w = if 1.0f32 < panel_space {
                    panel_space
                } else {
                    1.0f32
                } / (*layout).row.columns as f32;
                item_offset = (*layout).row.index as f32 * w;
                item_width = w + (item_offset - item_offset as Int as f32);
                item_spacing = (*layout).row.index as f32 * spacing.x
            }
            1 => {
                /* scaling single ratio widget width */
                let mut w_0: f32 = (*layout).row.item_width * panel_space;
                item_offset = (*layout).row.item_offset;
                item_width = w_0 + (item_offset - item_offset as Int as f32);
                item_spacing = 0i32 as f32;
                if 0 != modify {
                    (*layout).row.item_offset += w_0 + spacing.x;
                    (*layout).row.filled += (*layout).row.item_width;
                    (*layout).row.index = 0i32
                }
            }
            2 => {
                /* panel width depended free widget placing */
                (*bounds).x = (*layout).at_x + (*layout).bounds.w * (*layout).row.item.x;
                (*bounds).x -= *(*layout).offset_x as f32;
                (*bounds).y = (*layout).at_y + (*layout).row.height * (*layout).row.item.y;
                (*bounds).y -= *(*layout).offset_y as f32;
                (*bounds).w = (*layout).bounds.w * (*layout).row.item.w
                    + ((*bounds).x - (*bounds).x as Int as f32);
                (*bounds).h = (*layout).row.height * (*layout).row.item.h
                    + ((*bounds).y - (*bounds).y as Int as f32);
                return;
            }
            3 => {
                /* scaling arrays of panel width ratios for every widget */
                let mut ratio: f32 = 0.;
                let mut w_1: f32 = 0.;
                ratio = if *(*layout).row.ratio.offset((*layout).row.index as isize) < 0i32 as f32 {
                    (*layout).row.item_width
                } else {
                    *(*layout).row.ratio.offset((*layout).row.index as isize)
                };
                w_1 = ratio * panel_space;
                item_spacing = (*layout).row.index as f32 * spacing.x;
                item_offset = (*layout).row.item_offset;
                item_width = w_1 + (item_offset - item_offset as Int as f32);
                if 0 != modify {
                    (*layout).row.item_offset += w_1;
                    (*layout).row.filled += ratio
                }
            }
            4 => {
                /* non-scaling fixed widgets item width */
                item_width = (*layout).row.item_width;
                item_offset = (*layout).row.index as f32 * item_width;
                item_spacing = (*layout).row.index as f32 * spacing.x
            }
            5 => {
                /* scaling single ratio widget width */
                item_width = (*layout).row.item_width;
                item_offset = (*layout).row.item_offset;
                item_spacing = (*layout).row.index as f32 * spacing.x;
                if 0 != modify {
                    (*layout).row.item_offset += item_width
                }
            }
            6 => {
                /* free widget placing */
                (*bounds).x = (*layout).at_x + (*layout).row.item.x;
                (*bounds).w = (*layout).row.item.w;
                if (*bounds).x + (*bounds).w > (*layout).max_x && 0 != modify {
                    (*layout).max_x = (*bounds).x + (*bounds).w
                }
                (*bounds).x -= *(*layout).offset_x as f32;
                (*bounds).y = (*layout).at_y + (*layout).row.item.y;
                (*bounds).y -= *(*layout).offset_y as f32;
                (*bounds).h = (*layout).row.item.h;
                return;
            }
            7 => {
                /* non-scaling array of panel pixel width for every widget */
                item_spacing = (*layout).row.index as f32 * spacing.x;
                item_width = *(*layout).row.ratio.offset((*layout).row.index as isize);
                item_offset = (*layout).row.item_offset;
                if 0 != modify {
                    (*layout).row.item_offset += item_width
                }
            }
            8 => {
                /* stretchy row layout with combined dynamic/static widget width*/
                let mut w_2: f32 = 0.;
                w_2 = (*layout).row.templates[(*layout).row.index as usize];
                item_offset = (*layout).row.item_offset;
                item_width = w_2 + (item_offset - item_offset as Int as f32);
                item_spacing = (*layout).row.index as f32 * spacing.x;
                if 0 != modify {
                    (*layout).row.item_offset += w_2
                }
            }
            _ => {}
        }
        /* set the bounds of the newly allocated widget */
        (*bounds).w = item_width;
        (*bounds).h = (*layout).row.height - spacing.y;
        (*bounds).y = (*layout).at_y - *(*layout).offset_y as f32;
        (*bounds).x = (*layout).at_x + item_offset + item_spacing + padding.x;
        if (*bounds).x + (*bounds).w > (*layout).max_x && 0 != modify {
            (*layout).max_x = (*bounds).x + (*bounds).w
        }
        (*bounds).x -= *(*layout).offset_x as f32;
        return;
    };
}
unsafe fn nk_panel_alloc_row(mut ctx: *const Context, mut win: *mut Window) -> () {
    let mut layout: *mut Panel = (*win).layout;
    let mut spacing: Point = (*ctx).style.window.spacing;
    let row_height: f32 = (*layout).row.height - spacing.y;
    nk_panel_layout(ctx, win, row_height, (*layout).row.columns);
}
unsafe fn nk_find_value(mut win: *mut Window, mut name: Hash) -> *mut u32 {
    let mut iter: *mut Table = (*win).tables;
    while !iter.is_null() {
        let mut i: Uint = 0i32 as Uint;
        let mut size: Uint = (*iter).size;
        i = 0i32 as Uint;
        while i < size {
            if (*iter).keys[i as usize] == name {
                (*iter).seq = (*win).seq;
                return &mut (*iter).values[i as usize] as *mut u32;
            } else {
                i = i.wrapping_add(1)
            }
        }
        size = if (mem::size_of::<Window>() as Ulong) < mem::size_of::<Panel>() as Ulong {
            mem::size_of::<Panel>() as Ulong
        } else {
            mem::size_of::<Window>() as Ulong
        }.wrapping_div(mem::size_of::<u32>() as Ulong)
            .wrapping_div(2i32 as Ulong) as Uint;
        iter = (*iter).next
    }
    return 0 as *mut u32;
}
unsafe fn nk_add_value(
    mut ctx: *mut Context,
    mut win: *mut Window,
    mut name: Hash,
    mut value: u32,
) -> *mut u32 {
    if win.is_null() || ctx.is_null() {
        return 0 as *mut u32;
    } else {
        if (*win).tables.is_null()
            || (*(*win).tables).size as Ulong
                >= if (mem::size_of::<Window>() as Ulong) < mem::size_of::<Panel>() as Ulong {
                    mem::size_of::<Panel>() as Ulong
                } else {
                    mem::size_of::<Window>() as Ulong
                }.wrapping_div(mem::size_of::<u32>() as Ulong)
                    .wrapping_div(2i32 as Ulong)
        {
            let mut tbl: *mut Table = nk_create_table(ctx);
            if tbl.is_null() {
                return 0 as *mut u32;
            } else {
                nk_push_table(win, tbl);
            }
        }
        (*(*win).tables).seq = (*win).seq;
        (*(*win).tables).keys[(*(*win).tables).size as usize] = name;
        (*(*win).tables).values[(*(*win).tables).size as usize] = value;
        let fresh18 = (*(*win).tables).size;
        (*(*win).tables).size = (*(*win).tables).size.wrapping_add(1);
        return &mut (*(*win).tables).values[fresh18 as usize] as *mut u32;
    };
}
unsafe fn nk_create_table(mut ctx: *mut Context) -> *mut Table {
    let mut elem: *mut PageElement = 0 as *mut PageElement;
    elem = nk_create_page_element(ctx);
    if elem.is_null() {
        return 0 as *mut Table;
    } else {
        nk_zero(elem as *mut Void, mem::size_of::<PageElement>() as Ulong);
        return &mut (*elem).data.tbl as *mut Table;
    };
}
unsafe fn nk_push_table(mut win: *mut Window, mut tbl: *mut Table) -> () {
    if (*win).tables.is_null() {
        (*win).tables = tbl;
        (*tbl).next = 0 as *mut Table;
        (*tbl).prev = 0 as *mut Table;
        (*tbl).size = 0i32 as Uint;
        (*win).table_count = 1i32 as Uint;
        return;
    } else {
        (*(*win).tables).prev = tbl;
        (*tbl).next = (*win).tables;
        (*tbl).prev = 0 as *mut Table;
        (*tbl).size = 0i32 as Uint;
        (*win).tables = tbl;
        (*win).table_count = (*win).table_count.wrapping_add(1);
        return;
    };
}

pub unsafe fn nk_group_end(mut ctx: *mut Context) -> () {
    nk_group_scrolled_end(ctx);
}

pub unsafe fn nk_group_scrolled_begin(
    mut ctx: *mut Context,
    mut scroll: *mut Scroll,
    mut title: *const Char,
    mut flags: Flags,
) -> Int {
    return nk_group_scrolled_offset_begin(ctx, &mut (*scroll).x, &mut (*scroll).y, title, flags);
}

pub unsafe fn nk_tree_push_hashed(
    mut ctx: *mut Context,
    mut type_0: TreeType,
    mut title: *const Char,
    mut initial_state: CollapseStates,
    mut hash: *const Char,
    mut len: Int,
    mut line: Int,
) -> Int {
    return nk_tree_base(
        ctx,
        type_0,
        0 as *mut Image,
        title,
        initial_state,
        hash,
        len,
        line,
    );
}
unsafe fn nk_tree_base(
    mut ctx: *mut Context,
    mut type_0: TreeType,
    mut img: *mut Image,
    mut title: *const Char,
    mut initial_state: CollapseStates,
    mut hash: *const Char,
    mut len: Int,
    mut line: Int,
) -> Int {
    let mut win: *mut Window = (*ctx).current;
    let mut title_len: Int = 0i32;
    let mut tree_hash: Hash = 0i32 as Hash;
    let mut state: *mut u32 = 0 as *mut u32;
    /* retrieve tree state from internal widget state tables */
    if hash.is_null() {
        title_len = nk_strlen(title);
        tree_hash = nk_murmur_hash(title as *const Void, title_len, line as Hash)
    } else {
        tree_hash = nk_murmur_hash(hash as *const Void, len, line as Hash)
    }
    state = nk_find_value(win, tree_hash);
    if state.is_null() {
        state = nk_add_value(ctx, win, tree_hash, 0i32 as u32);
        *state = initial_state as u32
    }
    return nk_tree_state_base(ctx, type_0, img, title, state as *mut CollapseStates);
}
unsafe fn nk_tree_state_base(
    mut ctx: *mut Context,
    mut type_0: TreeType,
    mut img: *mut Image,
    mut title: *const Char,
    mut state: *mut CollapseStates,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut style: *const Style = 0 as *const Style;
    let mut out: *mut CommandBuffer = 0 as *mut CommandBuffer;
    let mut in_0: *const Input = 0 as *const Input;
    let mut button: *const StyleButton = 0 as *const StyleButton;
    let mut symbol: SymbolType = NK_SYMBOL_NONE;
    let mut row_height: f32 = 0.;
    let mut item_spacing: Point = Point { x: 0., y: 0. };
    let mut header: Rect = Rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    let mut sym: Rect = Rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut ws: Flags = 0i32 as Flags;
    let mut widget_state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        /* cache some data */
        win = (*ctx).current;
        layout = (*win).layout;
        out = &mut (*win).buffer as *mut CommandBuffer;
        style = &mut (*ctx).style as *mut Style;
        item_spacing = (*style).window.spacing;
        /* calculate header bounds and draw background */
        row_height = (*(*style).font).height + 2i32 as f32 * (*style).tab.padding.y;
        nk_layout_set_min_row_height(ctx, row_height);
        nk_layout_row_dynamic(ctx, row_height, 1i32);
        nk_layout_reset_min_row_height(ctx);
        widget_state = nk_widget(&mut header, ctx);
        if type_0 as Uint == NK_TREE_TAB as Int as Uint {
            let mut background: *const StyleItem = &(*style).tab.background as *const StyleItem;
            if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                nk_draw_image(out, header, &(*background).data.image, nk_white);
                text.background = nk_rgba(0i32, 0i32, 0i32, 0i32)
            } else {
                text.background = (*background).data.color;
                nk_fill_rect(out, header, 0i32 as f32, (*style).tab.border_color);
                nk_fill_rect(
                    out,
                    nk_shrink_rect(header, (*style).tab.border),
                    (*style).tab.rounding,
                    (*background).data.color,
                );
            }
        } else {
            text.background = (*style).window.background
        }
        /* update node state */
        in_0 = if 0 == (*layout).flags & NK_WINDOW_ROM as Int as Uint {
            &mut (*ctx).input as *mut Input
        } else {
            0 as *mut Input
        };
        in_0 = if !in_0.is_null() && widget_state as Uint == NK_WIDGET_VALID as Int as Uint {
            &mut (*ctx).input as *mut Input
        } else {
            0 as *mut Input
        };
        if 0 != ButtonBehavior(&mut ws, header, in_0, NK_BUTTON_DEFAULT) {
            *state = (if *state as Uint == NK_MAXIMIZED as Int as Uint {
                NK_MINIMIZED as Int
            } else {
                NK_MAXIMIZED as Int
            }) as CollapseStates
        }
        /* select correct button style */
        if *state as Uint == NK_MAXIMIZED as Int as Uint {
            symbol = (*style).tab.sym_maximize;
            if type_0 as Uint == NK_TREE_TAB as Int as Uint {
                button = &(*style).tab.tab_maximize_button as *const StyleButton
            } else {
                button = &(*style).tab.node_maximize_button as *const StyleButton
            }
        } else {
            symbol = (*style).tab.sym_minimize;
            if type_0 as Uint == NK_TREE_TAB as Int as Uint {
                button = &(*style).tab.tab_minimize_button as *const StyleButton
            } else {
                button = &(*style).tab.node_minimize_button as *const StyleButton
            }
        }
        /* draw triangle button */
        sym.h = (*(*style).font).height;
        sym.w = sym.h;
        sym.y = header.y + (*style).tab.padding.y;
        sym.x = header.x + (*style).tab.padding.x;
        nk_do_button_symbol(
            &mut ws,
            &mut (*win).buffer,
            sym,
            symbol,
            NK_BUTTON_DEFAULT,
            button,
            0 as *const Input,
            (*style).font,
        );
        if !img.is_null() {
            /* draw optional image icon */
            sym.x = sym.x + sym.w + 4i32 as f32 * item_spacing.x;
            nk_draw_image(&mut (*win).buffer, sym, img, nk_white);
            sym.w = (*(*style).font).height + (*style).tab.spacing.x
        }
        /* draw label */
        let mut label: Rect = Rect {
            x: 0.,
            y: 0.,
            w: 0.,
            h: 0.,
        };
        header.w = if header.w < sym.w + item_spacing.x {
            sym.w + item_spacing.x
        } else {
            header.w
        };
        label.x = sym.x + sym.w + item_spacing.x;
        label.y = sym.y;
        label.w = header.w - (sym.w + item_spacing.y + (*style).tab.indent);
        label.h = (*(*style).font).height;
        text.text = (*style).tab.text;
        text.padding = Point::new(0i32 as f32, 0i32 as f32);
        nk_widget_text(
            out,
            label,
            title,
            nk_strlen(title),
            &mut text,
            NK_TEXT_LEFT as Int as Flags,
            (*style).font,
        );
        /* increase x-axis cursor widget position pointer */
        if *state as Uint == NK_MAXIMIZED as Int as Uint {
            (*layout).at_x = header.x + *(*layout).offset_x as f32 + (*style).tab.indent;
            (*layout).bounds.w = if (*layout).bounds.w < (*style).tab.indent {
                (*style).tab.indent
            } else {
                (*layout).bounds.w
            };
            (*layout).bounds.w -= (*style).tab.indent + (*style).window.padding.x;
            (*layout).row.tree_depth += 1;
            return nk_true as Int;
        } else {
            return nk_false as Int;
        }
    };
}

pub unsafe fn nk_widget(mut bounds: *mut Rect, mut ctx: *const Context) -> WidgetLayoutStates {
    let mut c: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut v: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return NK_WIDGET_INVALID;
    } else {
        /* allocate space and check if the widget needs to be updated and drawn */
        nk_panel_alloc_space(bounds, ctx);
        win = (*ctx).current;
        layout = (*win).layout;
        in_0 = &(*ctx).input as *const Input;
        c = (*layout).clip;
        /*  if one of these triggers you forgot to add an `if` condition around either
        a window, group, popup, combobox or contextual menu `begin` and `end` block.
        Example:
            if (nk_begin(...) {...} nk_end(...); or
            if (nk_group_begin(...) { nk_group_end(...);} */
        /* need to convert to int here to remove floating point errors */
        (*bounds).x = (*bounds).x as Int as f32;
        (*bounds).y = (*bounds).y as Int as f32;
        (*bounds).w = (*bounds).w as Int as f32;
        (*bounds).h = (*bounds).h as Int as f32;
        c.x = c.x as Int as f32;
        c.y = c.y as Int as f32;
        c.w = c.w as Int as f32;
        c.h = c.h as Int as f32;
        nk_unify(
            &mut v,
            &mut c,
            (*bounds).x,
            (*bounds).y,
            (*bounds).x + (*bounds).w,
            (*bounds).y + (*bounds).h,
        );
        if (*bounds).x > c.x + c.w
            || (*bounds).x + (*bounds).w < c.x
            || (*bounds).y > c.y + c.h
            || (*bounds).y + (*bounds).h < c.y
        {
            return NK_WIDGET_INVALID;
        } else if !(v.x <= (*in_0).mouse.pos.x
            && (*in_0).mouse.pos.x < v.x + v.w
            && (v.y <= (*in_0).mouse.pos.y && (*in_0).mouse.pos.y < v.y + v.h))
        {
            return NK_WIDGET_ROM;
        } else {
            return NK_WIDGET_VALID;
        }
    };
}

pub unsafe fn nk_tree_image_push_hashed(
    mut ctx: *mut Context,
    mut type_0: TreeType,
    mut img: Image,
    mut title: *const Char,
    mut initial_state: CollapseStates,
    mut hash: *const Char,
    mut len: Int,
    mut seed: Int,
) -> Int {
    return nk_tree_base(ctx, type_0, &mut img, title, initial_state, hash, len, seed);
}

pub unsafe fn nk_tree_pop(mut ctx: *mut Context) -> () {
    nk_tree_state_pop(ctx);
}

pub unsafe fn nk_tree_state_pop(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).at_x -= (*ctx).style.tab.indent + (*ctx).style.window.padding.x;
        (*layout).bounds.w += (*ctx).style.tab.indent + (*ctx).style.window.padding.x;
        (*layout).row.tree_depth -= 1;
        return;
    };
}

pub unsafe fn nk_tree_state_push(
    mut ctx: *mut Context,
    mut type_0: TreeType,
    mut title: *const Char,
    mut state: *mut CollapseStates,
) -> Int {
    return nk_tree_state_base(ctx, type_0, 0 as *mut Image, title, state);
}

pub unsafe fn nk_tree_state_image_push(
    mut ctx: *mut Context,
    mut type_0: TreeType,
    mut img: Image,
    mut title: *const Char,
    mut state: *mut CollapseStates,
) -> Int {
    return nk_tree_state_base(ctx, type_0, &mut img, title, state);
}

pub unsafe fn nk_tree_element_push_hashed(
    mut ctx: *mut Context,
    mut type_0: TreeType,
    mut title: *const Char,
    mut initial_state: CollapseStates,
    mut selected: *mut Int,
    mut hash: *const Char,
    mut len: Int,
    mut seed: Int,
) -> Int {
    return nk_tree_element_base(
        ctx,
        type_0,
        0 as *mut Image,
        title,
        initial_state,
        selected,
        hash,
        len,
        seed,
    );
}

unsafe fn nk_tree_element_base(
    mut ctx: *mut Context,
    mut type_0: TreeType,
    mut img: *mut Image,
    mut title: *const Char,
    mut initial_state: CollapseStates,
    mut selected: *mut Int,
    mut hash: *const Char,
    mut len: Int,
    mut line: Int,
) -> Int {
    let mut win: *mut Window = (*ctx).current;
    let mut title_len: Int = 0i32;
    let mut tree_hash: Hash = 0i32 as Hash;
    let mut state: *mut u32 = 0 as *mut u32;
    /* retrieve tree state from internal widget state tables */
    if hash.is_null() {
        title_len = nk_strlen(title);
        tree_hash = nk_murmur_hash(title as *const Void, title_len, line as Hash)
    } else {
        tree_hash = nk_murmur_hash(hash as *const Void, len, line as Hash)
    }
    state = nk_find_value(win, tree_hash);
    if state.is_null() {
        state = nk_add_value(ctx, win, tree_hash, 0i32 as u32);
        *state = initial_state as u32
    }
    return nk_tree_element_image_push_hashed_base(
        ctx,
        type_0,
        img,
        title,
        nk_strlen(title),
        state as *mut CollapseStates,
        selected,
    );
}

unsafe fn nk_tree_element_image_push_hashed_base(
    mut ctx: *mut Context,
    mut type_0: TreeType,
    mut img: *mut Image,
    mut title: *const Char,
    mut title_len: Int,
    mut state: *mut CollapseStates,
    mut selected: *mut Int,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut style: *const Style = 0 as *const Style;
    let mut out: *mut CommandBuffer = 0 as *mut CommandBuffer;
    let mut in_0: *const Input = 0 as *const Input;
    let mut button: *const StyleButton = 0 as *const StyleButton;
    let mut symbol: SymbolType = NK_SYMBOL_NONE;
    let mut row_height: f32 = 0.;
    let mut padding: Point = Point { x: 0., y: 0. };
    let mut text_len: Int = 0;
    let mut text_width: f32 = 0.;
    let mut item_spacing: Point = Point { x: 0., y: 0. };
    let mut header: Rect = Rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    let mut sym: Rect = Rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut ws: Flags = 0i32 as Flags;
    let mut widget_state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        /* cache some data */
        win = (*ctx).current;
        layout = (*win).layout;
        out = &mut (*win).buffer as *mut CommandBuffer;
        style = &mut (*ctx).style as *mut Style;
        item_spacing = (*style).window.spacing;
        padding = (*style).selectable.padding;
        /* calculate header bounds and draw background */
        row_height = (*(*style).font).height + 2i32 as f32 * (*style).tab.padding.y;
        nk_layout_set_min_row_height(ctx, row_height);
        nk_layout_row_dynamic(ctx, row_height, 1i32);
        nk_layout_reset_min_row_height(ctx);
        widget_state = nk_widget(&mut header, ctx);
        if type_0 as Uint == NK_TREE_TAB as Int as Uint {
            let mut background: *const StyleItem = &(*style).tab.background as *const StyleItem;
            if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                nk_draw_image(out, header, &(*background).data.image, nk_white);
                text.background = nk_rgba(0i32, 0i32, 0i32, 0i32)
            } else {
                text.background = (*background).data.color;
                nk_fill_rect(out, header, 0i32 as f32, (*style).tab.border_color);
                nk_fill_rect(
                    out,
                    nk_shrink_rect(header, (*style).tab.border),
                    (*style).tab.rounding,
                    (*background).data.color,
                );
            }
        } else {
            text.background = (*style).window.background
        }
        in_0 = if 0 == (*layout).flags & NK_WINDOW_ROM as Int as Uint {
            &mut (*ctx).input as *mut Input
        } else {
            0 as *mut Input
        };
        in_0 = if !in_0.is_null() && widget_state as Uint == NK_WIDGET_VALID as Int as Uint {
            &mut (*ctx).input as *mut Input
        } else {
            0 as *mut Input
        };
        /* select correct button style */
        if *state as Uint == NK_MAXIMIZED as Int as Uint {
            symbol = (*style).tab.sym_maximize;
            if type_0 as Uint == NK_TREE_TAB as Int as Uint {
                button = &(*style).tab.tab_maximize_button as *const StyleButton
            } else {
                button = &(*style).tab.node_maximize_button as *const StyleButton
            }
        } else {
            symbol = (*style).tab.sym_minimize;
            if type_0 as Uint == NK_TREE_TAB as Int as Uint {
                button = &(*style).tab.tab_minimize_button as *const StyleButton
            } else {
                button = &(*style).tab.node_minimize_button as *const StyleButton
            }
        }
        /* draw triangle button */
        sym.h = (*(*style).font).height;
        sym.w = sym.h;
        sym.y = header.y + (*style).tab.padding.y;
        sym.x = header.x + (*style).tab.padding.x;
        if 0 != nk_do_button_symbol(
            &mut ws,
            &mut (*win).buffer,
            sym,
            symbol,
            NK_BUTTON_DEFAULT,
            button,
            in_0,
            (*style).font,
        ) {
            *state = (if *state as Uint == NK_MAXIMIZED as Int as Uint {
                NK_MINIMIZED as Int
            } else {
                NK_MAXIMIZED as Int
            }) as CollapseStates
        }
        /* draw label */
        let mut dummy: Flags = 0i32 as Flags;
        let mut label: Rect = Rect {
            x: 0.,
            y: 0.,
            w: 0.,
            h: 0.,
        };
        /* calculate size of the text and tooltip */
        text_len = nk_strlen(title);
        text_width = (*(*style).font).width.expect("non-null function pointer")(
            (*(*style).font).userdata,
            (*(*style).font).height,
            title,
            text_len,
        );
        text_width += 4i32 as f32 * padding.x;
        header.w = if header.w < sym.w + item_spacing.x {
            sym.w + item_spacing.x
        } else {
            header.w
        };
        label.x = sym.x + sym.w + item_spacing.x;
        label.y = sym.y;
        label.w = if header.w - (sym.w + item_spacing.y + (*style).tab.indent) < text_width {
            header.w - (sym.w + item_spacing.y + (*style).tab.indent)
        } else {
            text_width
        };
        label.h = (*(*style).font).height;
        if !img.is_null() {
            nk_do_selectable_image(
                &mut dummy,
                &mut (*win).buffer,
                label,
                title,
                title_len,
                NK_TEXT_LEFT as Int as Flags,
                selected,
                img,
                &(*style).selectable,
                in_0,
                (*style).font,
            );
        } else {
            nk_do_selectable(
                &mut dummy,
                &mut (*win).buffer,
                label,
                title,
                title_len,
                NK_TEXT_LEFT as Int as Flags,
                selected,
                &(*style).selectable,
                in_0,
                (*style).font,
            );
        }
        /* increase x-axis cursor widget position pointer */
        if *state as Uint == NK_MAXIMIZED as Int as Uint {
            (*layout).at_x = header.x + *(*layout).offset_x as f32 + (*style).tab.indent;
            (*layout).bounds.w = if (*layout).bounds.w < (*style).tab.indent {
                (*style).tab.indent
            } else {
                (*layout).bounds.w
            };
            (*layout).bounds.w -= (*style).tab.indent + (*style).window.padding.x;
            (*layout).row.tree_depth += 1;
            return nk_true as Int;
        } else {
            return nk_false as Int;
        }
    };
}

unsafe fn nk_do_selectable(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut str: *const Char,
    mut len: Int,
    mut align: Flags,
    mut value: *mut Int,
    mut style: *const StyleSelectable,
    mut in_0: *const Input,
    mut font: *const UserFont,
) -> Int {
    let mut old_value: Int = 0;
    let mut touch: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if state.is_null()
        || out.is_null()
        || str.is_null()
        || 0 == len
        || value.is_null()
        || style.is_null()
        || font.is_null()
    {
        return 0i32;
    } else {
        old_value = *value;
        /* remove padding */
        touch.x = bounds.x - (*style).touch_padding.x;
        touch.y = bounds.y - (*style).touch_padding.y;
        touch.w = bounds.w + (*style).touch_padding.x * 2i32 as f32;
        touch.h = bounds.h + (*style).touch_padding.y * 2i32 as f32;
        /* update button */
        if 0 != ButtonBehavior(state, touch, in_0, NK_BUTTON_DEFAULT) {
            *value = (0 == *value) as Int
        }
        /* draw selectable */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_selectable(
            out,
            *state,
            style,
            *value,
            &mut bounds,
            0 as *const Rect,
            0 as *const Image,
            NK_SYMBOL_NONE,
            str,
            len,
            align,
            font,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return (old_value != *value) as Int;
    };
}

unsafe fn nk_draw_selectable(
    mut out: *mut CommandBuffer,
    mut state: Flags,
    mut style: *const StyleSelectable,
    mut active: Int,
    mut bounds: *const Rect,
    mut icon: *const Rect,
    mut img: *const Image,
    mut sym: SymbolType,
    mut string: *const Char,
    mut len: Int,
    mut align: Flags,
    mut font: *const UserFont,
) -> () {
    let mut background: *const StyleItem = 0 as *const StyleItem;
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    text.padding = (*style).padding;
    /* select correct colors/images */
    if 0 == active {
        if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
            background = &(*style).pressed as *const StyleItem;
            text.text = (*style).text_pressed
        } else if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
            background = &(*style).hover as *const StyleItem;
            text.text = (*style).text_hover
        } else {
            background = &(*style).normal as *const StyleItem;
            text.text = (*style).text_normal
        }
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        background = &(*style).pressed_active as *const StyleItem;
        text.text = (*style).text_pressed_active
    } else if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        background = &(*style).hover_active as *const StyleItem;
        text.text = (*style).text_hover_active
    } else {
        background = &(*style).normal_active as *const StyleItem;
        text.text = (*style).text_normal_active
    }
    /* draw selectable background and text */
    if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
        text.background = nk_rgba(0i32, 0i32, 0i32, 0i32)
    } else {
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        text.background = (*background).data.color
    }
    if !icon.is_null() {
        if !img.is_null() {
            nk_draw_image(out, *icon, img, nk_white);
        } else {
            nk_draw_symbol(
                out,
                sym,
                *icon,
                text.background,
                text.text,
                1i32 as f32,
                font,
            );
        }
    }
    nk_widget_text(out, *bounds, string, len, &mut text, align, font);
}

unsafe fn nk_do_selectable_image(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut str: *const Char,
    mut len: Int,
    mut align: Flags,
    mut value: *mut Int,
    mut img: *const Image,
    mut style: *const StyleSelectable,
    mut in_0: *const Input,
    mut font: *const UserFont,
) -> Int {
    let mut old_value: Int = 0;
    let mut touch: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut icon: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if state.is_null()
        || out.is_null()
        || str.is_null()
        || 0 == len
        || value.is_null()
        || style.is_null()
        || font.is_null()
    {
        return 0i32;
    } else {
        old_value = *value;
        /* toggle behavior */
        touch.x = bounds.x - (*style).touch_padding.x;
        touch.y = bounds.y - (*style).touch_padding.y;
        touch.w = bounds.w + (*style).touch_padding.x * 2i32 as f32;
        touch.h = bounds.h + (*style).touch_padding.y * 2i32 as f32;
        if 0 != ButtonBehavior(state, touch, in_0, NK_BUTTON_DEFAULT) {
            *value = (0 == *value) as Int
        }
        icon.y = bounds.y + (*style).padding.y;
        icon.h = bounds.h - 2i32 as f32 * (*style).padding.y;
        icon.w = icon.h;
        if 0 != align & NK_TEXT_ALIGN_LEFT as Int as Uint {
            icon.x = bounds.x + bounds.w - (2i32 as f32 * (*style).padding.x + icon.w);
            icon.x = if icon.x < 0i32 as f32 {
                0i32 as f32
            } else {
                icon.x
            }
        } else {
            icon.x = bounds.x + 2i32 as f32 * (*style).padding.x
        }
        icon.x += (*style).image_padding.x;
        icon.y += (*style).image_padding.y;
        icon.w -= 2i32 as f32 * (*style).image_padding.x;
        icon.h -= 2i32 as f32 * (*style).image_padding.y;
        /* draw selectable */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_selectable(
            out,
            *state,
            style,
            *value,
            &mut bounds,
            &mut icon,
            img,
            NK_SYMBOL_NONE,
            str,
            len,
            align,
            font,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return (old_value != *value) as Int;
    };
}

pub unsafe fn nk_tree_element_image_push_hashed(
    mut ctx: *mut Context,
    mut type_0: TreeType,
    mut img: Image,
    mut title: *const Char,
    mut initial_state: CollapseStates,
    mut selected: *mut Int,
    mut hash: *const Char,
    mut len: Int,
    mut seed: Int,
) -> Int {
    return nk_tree_element_base(
        ctx,
        type_0,
        &mut img,
        title,
        initial_state,
        selected,
        hash,
        len,
        seed,
    );
}

pub unsafe fn nk_tree_element_pop(mut ctx: *mut Context) -> () {
    nk_tree_state_pop(ctx);
}

pub unsafe fn nk_list_view_begin(
    mut ctx: *mut Context,
    mut view: *mut ListView,
    mut title: *const Char,
    mut flags: Flags,
    mut row_height: Int,
    mut row_count: Int,
) -> Int {
    let mut title_len: Int = 0;
    let mut title_hash: Hash = 0;
    let mut x_offset: *mut u32 = 0 as *mut u32;
    let mut y_offset: *mut u32 = 0 as *mut u32;
    let mut result: Int = 0;
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut style: *const Style = 0 as *const Style;
    let mut item_spacing: Point = Point { x: 0., y: 0. };
    if ctx.is_null() || view.is_null() || title.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        item_spacing = (*style).window.spacing;
        row_height += if 0i32 < item_spacing.y as Int {
            item_spacing.y as Int
        } else {
            0i32
        };
        /* find persistent list view scrollbar offset */
        title_len = nk_strlen(title);
        title_hash = nk_murmur_hash(
            title as *const Void,
            title_len,
            NK_PANEL_GROUP as Int as Hash,
        );
        x_offset = nk_find_value(win, title_hash);
        if x_offset.is_null() {
            x_offset = nk_add_value(ctx, win, title_hash, 0i32 as u32);
            y_offset = nk_add_value(ctx, win, title_hash.wrapping_add(1i32 as Uint), 0i32 as u32);
            if x_offset.is_null() || y_offset.is_null() {
                return 0i32;
            } else {
                *y_offset = 0i32 as u32;
                *x_offset = *y_offset
            }
        } else {
            y_offset = nk_find_value(win, title_hash.wrapping_add(1i32 as Uint))
        }
        (*view).scroll_value = *y_offset;
        (*view).scroll_pointer = y_offset;
        *y_offset = 0i32 as u32;
        result = nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);
        win = (*ctx).current;
        layout = (*win).layout;
        (*view).total_height = row_height * if row_count < 1i32 { 1i32 } else { row_count };
        (*view).begin = (if ((*view).scroll_value as f32 / row_height as f32) < 0.0f32 {
            0.0f32
        } else {
            (*view).scroll_value as f32 / row_height as f32
        }) as Int;
        (*view).count = if nk_iceilf((*layout).clip.h / row_height as f32) < 0i32 {
            0i32
        } else {
            nk_iceilf((*layout).clip.h / row_height as f32)
        };
        (*view).count = if (*view).count < row_count - (*view).begin {
            (*view).count
        } else {
            row_count - (*view).begin
        };
        (*view).end = (*view).begin + (*view).count;
        (*view).ctx = ctx;
        return result;
    };
}
unsafe fn nk_iceilf(mut x: f32) -> Int {
    if x >= 0i32 as f32 {
        let mut i: Int = x as Int;
        return if x > i as f32 { i + 1i32 } else { i };
    } else {
        let mut t: Int = x as Int;
        let mut r: f32 = x - t as f32;
        return if r > 0.0f32 { t + 1i32 } else { t };
    };
}

pub unsafe fn nk_list_view_end(mut view: *mut ListView) -> () {
    let mut ctx: *mut Context = 0 as *mut Context;
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if view.is_null() || (*view).ctx.is_null() {
        return;
    } else {
        ctx = (*view).ctx;
        win = (*ctx).current;
        layout = (*win).layout;
        (*layout).at_y = (*layout).bounds.y + (*view).total_height as f32;
        *(*view).scroll_pointer = (*(*view).scroll_pointer).wrapping_add((*view).scroll_value);
        nk_group_end((*view).ctx);
        return;
    };
}

pub unsafe fn nk_widget_fitting(
    mut bounds: *mut Rect,
    mut ctx: *mut Context,
    mut item_padding: Point,
) -> WidgetLayoutStates {
    /* update the bounds to stand without padding  */
    let mut win: *mut Window = 0 as *mut Window;
    let mut style: *mut Style = 0 as *mut Style;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut panel_padding: Point = Point { x: 0., y: 0. };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return NK_WIDGET_INVALID;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        layout = (*win).layout;
        state = nk_widget(bounds, ctx);
        panel_padding = nk_panel_get_padding(style, (*layout).type_0);
        if (*layout).row.index == 1i32 {
            (*bounds).w += panel_padding.x;
            (*bounds).x -= panel_padding.x
        } else {
            (*bounds).x -= item_padding.x
        }
        if (*layout).row.index == (*layout).row.columns {
            (*bounds).w += panel_padding.x
        } else {
            (*bounds).w += item_padding.x
        }
        return state;
    };
}

pub unsafe fn nk_widget_bounds(mut ctx: *mut Context) -> Rect {
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() {
        return Rect::new(0i32 as f32, 0i32 as f32, 0i32 as f32, 0i32 as f32);
    } else {
        nk_layout_peek(&mut bounds, ctx);
        return bounds;
    };
}
unsafe fn nk_layout_peek(mut bounds: *mut Rect, mut ctx: *mut Context) -> () {
    let mut y: f32 = 0.;
    let mut index: Int = 0;
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        y = (*layout).at_y;
        index = (*layout).row.index;
        if (*layout).row.index >= (*layout).row.columns {
            (*layout).at_y += (*layout).row.height;
            (*layout).row.index = 0i32
        }
        nk_layout_widget_space(bounds, ctx, win, nk_false as Int);
        if 0 == (*layout).row.index {
            (*bounds).x -= (*layout).row.item_offset
        }
        (*layout).at_y = y;
        (*layout).row.index = index;
        return;
    };
}

pub unsafe fn nk_widget_position(mut ctx: *mut Context) -> Point {
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() {
        return Point::new(0i32 as f32, 0i32 as f32);
    } else {
        nk_layout_peek(&mut bounds, ctx);
        return Point::new(bounds.x, bounds.y);
    };
}

pub unsafe fn nk_widget_size(mut ctx: *mut Context) -> Point {
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() {
        return Point::new(0i32 as f32, 0i32 as f32);
    } else {
        nk_layout_peek(&mut bounds, ctx);
        return Point::new(bounds.w, bounds.h);
    };
}

pub unsafe fn nk_widget_width(mut ctx: *mut Context) -> f32 {
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32 as f32;
    } else {
        nk_layout_peek(&mut bounds, ctx);
        return bounds.w;
    };
}

pub unsafe fn nk_widget_height(mut ctx: *mut Context) -> f32 {
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() {
        return 0i32 as f32;
    } else {
        nk_layout_peek(&mut bounds, ctx);
        return bounds.h;
    };
}

pub unsafe fn nk_widget_is_hovered(mut ctx: *mut Context) -> Int {
    let mut c: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut v: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*ctx).active != (*ctx).current {
        return 0i32;
    } else {
        c = (*(*(*ctx).current).layout).clip;
        c.x = c.x as Int as f32;
        c.y = c.y as Int as f32;
        c.w = c.w as Int as f32;
        c.h = c.h as Int as f32;
        nk_layout_peek(&mut bounds, ctx);
        nk_unify(
            &mut v,
            &mut c,
            bounds.x,
            bounds.y,
            bounds.x + bounds.w,
            bounds.y + bounds.h,
        );
        if bounds.x > c.x + c.w
            || bounds.x + bounds.w < c.x
            || bounds.y > c.y + c.h
            || bounds.y + bounds.h < c.y
        {
            return 0i32;
        } else {
            return nk_input_is_mouse_hovering_rect(&mut (*ctx).input, bounds);
        }
    };
}

pub unsafe fn nk_widget_is_mouse_clicked(mut ctx: *mut Context, mut btn: Buttons) -> Int {
    let mut c: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut v: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*ctx).active != (*ctx).current {
        return 0i32;
    } else {
        c = (*(*(*ctx).current).layout).clip;
        c.x = c.x as Int as f32;
        c.y = c.y as Int as f32;
        c.w = c.w as Int as f32;
        c.h = c.h as Int as f32;
        nk_layout_peek(&mut bounds, ctx);
        nk_unify(
            &mut v,
            &mut c,
            bounds.x,
            bounds.y,
            bounds.x + bounds.w,
            bounds.y + bounds.h,
        );
        if bounds.x > c.x + c.w
            || bounds.x + bounds.w < c.x
            || bounds.y > c.y + c.h
            || bounds.y + bounds.h < c.y
        {
            return 0i32;
        } else {
            return nk_input_mouse_clicked(&mut (*ctx).input, btn, bounds);
        }
    };
}

pub unsafe fn nk_widget_has_mouse_click_down(
    mut ctx: *mut Context,
    mut btn: Buttons,
    mut down: Int,
) -> Int {
    let mut c: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut v: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*ctx).active != (*ctx).current {
        return 0i32;
    } else {
        c = (*(*(*ctx).current).layout).clip;
        c.x = c.x as Int as f32;
        c.y = c.y as Int as f32;
        c.w = c.w as Int as f32;
        c.h = c.h as Int as f32;
        nk_layout_peek(&mut bounds, ctx);
        nk_unify(
            &mut v,
            &mut c,
            bounds.x,
            bounds.y,
            bounds.x + bounds.w,
            bounds.y + bounds.h,
        );
        if bounds.x > c.x + c.w
            || bounds.x + bounds.w < c.x
            || bounds.y > c.y + c.h
            || bounds.y + bounds.h < c.y
        {
            return 0i32;
        } else {
            return nk_input_has_mouse_click_down_in_rect(&mut (*ctx).input, btn, bounds, down);
        }
    };
}

pub unsafe fn nk_spacing(mut ctx: *mut Context, mut cols: Int) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut none: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut i: Int = 0;
    let mut index: Int = 0;
    let mut rows: Int = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        /* spacing over row boundaries */
        win = (*ctx).current;
        layout = (*win).layout;
        index = ((*layout).row.index + cols) % (*layout).row.columns;
        rows = ((*layout).row.index + cols) / (*layout).row.columns;
        if 0 != rows {
            i = 0i32;
            while i < rows {
                nk_panel_alloc_row(ctx, win);
                i += 1
            }
            cols = index
        }
        /* non table layout need to allocate space */
        if (*layout).row.type_0 as Uint != NK_LAYOUT_DYNAMIC_FIXED as Int as Uint
            && (*layout).row.type_0 as Uint != NK_LAYOUT_STATIC_FIXED as Int as Uint
        {
            i = 0i32;
            while i < cols {
                nk_panel_alloc_space(&mut none, ctx);
                i += 1
            }
        }
        (*layout).row.index = index;
        return;
    };
}

pub unsafe fn Text(
    mut ctx: *mut Context,
    mut str: *const Char,
    mut len: Int,
    mut alignment: Flags,
) -> () {
    if ctx.is_null() {
        return;
    } else {
        nk_text_colored(ctx, str, len, alignment, (*ctx).style.text.color);
        return;
    };
}

pub unsafe fn nk_text_colored(
    mut ctx: *mut Context,
    mut str: *const Char,
    mut len: Int,
    mut alignment: Flags,
    mut color: Color,
) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut style: *const Style = 0 as *const Style;
    let mut item_padding: Point = Point { x: 0., y: 0. };
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        nk_panel_alloc_space(&mut bounds, ctx);
        item_padding = (*style).text.padding;
        text.padding.x = item_padding.x;
        text.padding.y = item_padding.y;
        text.background = (*style).window.background;
        text.text = color;
        nk_widget_text(
            &mut (*win).buffer,
            bounds,
            str,
            len,
            &mut text,
            alignment,
            (*style).font,
        );
        return;
    };
}

pub unsafe fn nk_text_wrap(mut ctx: *mut Context, mut str: *const Char, mut len: Int) -> () {
    if ctx.is_null() {
        return;
    } else {
        nk_text_wrap_colored(ctx, str, len, (*ctx).style.text.color);
        return;
    };
}

pub unsafe fn nk_text_wrap_colored(
    mut ctx: *mut Context,
    mut str: *const Char,
    mut len: Int,
    mut color: Color,
) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut style: *const Style = 0 as *const Style;
    let mut item_padding: Point = Point { x: 0., y: 0. };
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        nk_panel_alloc_space(&mut bounds, ctx);
        item_padding = (*style).text.padding;
        text.padding.x = item_padding.x;
        text.padding.y = item_padding.y;
        text.background = (*style).window.background;
        text.text = color;
        nk_widget_text_wrap(
            &mut (*win).buffer,
            bounds,
            str,
            len,
            &mut text,
            (*style).font,
        );
        return;
    };
}
unsafe fn nk_widget_text_wrap(
    mut o: *mut CommandBuffer,
    mut b: Rect,
    mut string: *const Char,
    mut len: Int,
    mut t: *const Text,
    mut f: *const UserFont,
) -> () {
    let mut width: f32 = 0.;
    let mut glyphs: Int = 0i32;
    let mut fitting: Int = 0i32;
    let mut done: Int = 0i32;
    let mut line: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    static mut seperator: [Rune; 1] = unsafe { [' ' as i32 as Rune] };
    if o.is_null() || t.is_null() {
        return;
    } else {
        text.padding = Point::new(0i32 as f32, 0i32 as f32);
        text.background = (*t).background;
        text.text = (*t).text;
        b.w = if b.w < 2i32 as f32 * (*t).padding.x {
            2i32 as f32 * (*t).padding.x
        } else {
            b.w
        };
        b.h = if b.h < 2i32 as f32 * (*t).padding.y {
            2i32 as f32 * (*t).padding.y
        } else {
            b.h
        };
        b.h = b.h - 2i32 as f32 * (*t).padding.y;
        line.x = b.x + (*t).padding.x;
        line.y = b.y + (*t).padding.y;
        line.w = b.w - 2i32 as f32 * (*t).padding.x;
        line.h = 2i32 as f32 * (*t).padding.y + (*f).height;
        fitting = nk_text_clamp(
            f,
            string,
            len,
            line.w,
            &mut glyphs,
            &mut width,
            seperator.as_mut_ptr(),
            (mem::size_of::<[Rune; 1]>() as Ulong).wrapping_div(mem::size_of::<Rune>() as Ulong)
                as Int,
        );
        while done < len {
            if 0 == fitting || line.y + line.h >= b.y + b.h {
                break;
            }
            nk_widget_text(
                o,
                line,
                &*string.offset(done as isize),
                fitting,
                &mut text,
                NK_TEXT_LEFT as Int as Flags,
                f,
            );
            done += fitting;
            line.y += (*f).height + 2i32 as f32 * (*t).padding.y;
            fitting = nk_text_clamp(
                f,
                &*string.offset(done as isize),
                len - done,
                line.w,
                &mut glyphs,
                &mut width,
                seperator.as_mut_ptr(),
                (mem::size_of::<[Rune; 1]>() as Ulong).wrapping_div(mem::size_of::<Rune>() as Ulong)
                    as Int,
            )
        }
        return;
    };
}

pub unsafe fn nk_label(mut ctx: *mut Context, mut str: *const Char, mut alignment: Flags) -> () {
    Text(ctx, str, nk_strlen(str), alignment);
}

pub unsafe fn nk_label_colored(
    mut ctx: *mut Context,
    mut str: *const Char,
    mut align: Flags,
    mut color: Color,
) -> () {
    nk_text_colored(ctx, str, nk_strlen(str), align, color);
}

pub unsafe fn nk_label_wrap(mut ctx: *mut Context, mut str: *const Char) -> () {
    nk_text_wrap(ctx, str, nk_strlen(str));
}

pub unsafe fn nk_label_colored_wrap(
    mut ctx: *mut Context,
    mut str: *const Char,
    mut color: Color,
) -> () {
    nk_text_wrap_colored(ctx, str, nk_strlen(str), color);
}

pub unsafe fn Image(mut ctx: *mut Context, mut img: Image) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        if 0 == nk_widget(&mut bounds, ctx) as u64 {
            return;
        } else {
            nk_draw_image(&mut (*win).buffer, bounds, &mut img, nk_white);
            return;
        }
    };
}

pub unsafe fn nk_image_color(mut ctx: *mut Context, mut img: Image, mut col: Color) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        if 0 == nk_widget(&mut bounds, ctx) as u64 {
            return;
        } else {
            nk_draw_image(&mut (*win).buffer, bounds, &mut img, col);
            return;
        }
    };
}

pub unsafe fn nk_button_text(mut ctx: *mut Context, mut title: *const Char, mut len: Int) -> Int {
    if ctx.is_null() {
        return 0i32;
    } else {
        return nk_button_text_styled(ctx, &mut (*ctx).style.button, title, len);
    };
}

pub unsafe fn nk_button_text_styled(
    mut ctx: *mut Context,
    mut style: *const StyleButton,
    mut title: *const Char,
    mut len: Int,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if style.is_null()
        || ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            return nk_do_button_text(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                title,
                len,
                (*style).text_alignment,
                (*ctx).button_behavior,
                style,
                in_0,
                (*ctx).style.font,
            );
        }
    };
}
unsafe fn nk_do_button_text(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut string: *const Char,
    mut len: Int,
    mut align: Flags,
    mut behavior: ButtonBehavior,
    mut style: *const StyleButton,
    mut in_0: *const Input,
    mut font: *const UserFont,
) -> Int {
    let mut content: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut ret: Int = nk_false as Int;
    if out.is_null() || style.is_null() || font.is_null() || string.is_null() {
        return nk_false as Int;
    } else {
        ret = nk_do_button(state, out, bounds, style, in_0, behavior, &mut content);
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_button_text(
            out,
            &mut bounds,
            &mut content,
            *state,
            style,
            string,
            len,
            align,
            font,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return ret;
    };
}
unsafe fn nk_draw_button_text(
    mut out: *mut CommandBuffer,
    mut bounds: *const Rect,
    mut content: *const Rect,
    mut state: Flags,
    mut style: *const StyleButton,
    mut txt: *const Char,
    mut len: Int,
    mut text_alignment: Flags,
    mut font: *const UserFont,
) -> () {
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut background: *const StyleItem = 0 as *const StyleItem;
    background = nk_draw_button(out, bounds, state, style);
    /* select correct colors/images */
    if (*background).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
        text.background = (*background).data.color
    } else {
        text.background = (*style).text_background
    }
    if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        text.text = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        text.text = (*style).text_active
    } else {
        text.text = (*style).text_normal
    }
    text.padding = Point::new(0i32 as f32, 0i32 as f32);
    nk_widget_text(out, *content, txt, len, &mut text, text_alignment, font);
}

pub unsafe fn nk_button_label(mut ctx: *mut Context, mut title: *const Char) -> Int {
    return nk_button_text(ctx, title, nk_strlen(title));
}

pub unsafe fn nk_button_color(mut ctx: *mut Context, mut color: Color) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut button: StyleButton = StyleButton {
        normal: StyleItem {
            type_0: NK_STYLE_ITEM_COLOR,
            data: nk_style_item_data {
                image: Image {
                    handle: Handle {
                        ptr: 0 as *mut Void,
                    },
                    w: 0,
                    h: 0,
                    region: [0; 4],
                },
            },
        },
        hover: StyleItem {
            type_0: NK_STYLE_ITEM_COLOR,
            data: nk_style_item_data {
                image: Image {
                    handle: Handle {
                        ptr: 0 as *mut Void,
                    },
                    w: 0,
                    h: 0,
                    region: [0; 4],
                },
            },
        },
        active: StyleItem {
            type_0: NK_STYLE_ITEM_COLOR,
            data: nk_style_item_data {
                image: Image {
                    handle: Handle {
                        ptr: 0 as *mut Void,
                    },
                    w: 0,
                    h: 0,
                    region: [0; 4],
                },
            },
        },
        border_color: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text_background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text_normal: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text_hover: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text_active: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text_alignment: 0,
        border: 0.,
        rounding: 0.,
        padding: Point { x: 0., y: 0. },
        image_padding: Point { x: 0., y: 0. },
        touch_padding: Point { x: 0., y: 0. },
        userdata: Handle {
            ptr: 0 as *mut Void,
        },
        draw_begin: None,
        draw_end: None,
    };
    let mut ret: Int = 0i32;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut content: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            button = (*ctx).style.button;
            button.normal = nk_style_item_color(color);
            button.hover = nk_style_item_color(color);
            button.active = nk_style_item_color(color);
            ret = nk_do_button(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                &mut button,
                in_0,
                (*ctx).button_behavior,
                &mut content,
            );
            nk_draw_button(
                &mut (*win).buffer,
                &mut bounds,
                (*ctx).last_widget_state,
                &mut button,
            );
            return ret;
        }
    };
}

pub unsafe fn nk_button_symbol(mut ctx: *mut Context, mut symbol: SymbolType) -> Int {
    if ctx.is_null() {
        return 0i32;
    } else {
        return nk_button_symbol_styled(ctx, &mut (*ctx).style.button, symbol);
    };
}

pub unsafe fn nk_button_symbol_styled(
    mut ctx: *mut Context,
    mut style: *const StyleButton,
    mut symbol: SymbolType,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            return nk_do_button_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                symbol,
                (*ctx).button_behavior,
                style,
                in_0,
                (*ctx).style.font,
            );
        }
    };
}

pub unsafe fn nk_button_image(mut ctx: *mut Context, mut img: Image) -> Int {
    if ctx.is_null() {
        return 0i32;
    } else {
        return nk_button_image_styled(ctx, &mut (*ctx).style.button, img);
    };
}

pub unsafe fn nk_button_image_styled(
    mut ctx: *mut Context,
    mut style: *const StyleButton,
    mut img: Image,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            return nk_do_button_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                img,
                (*ctx).button_behavior,
                style,
                in_0,
            );
        }
    };
}
unsafe fn nk_do_button_image(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut img: Image,
    mut b: ButtonBehavior,
    mut style: *const StyleButton,
    mut in_0: *const Input,
) -> Int {
    let mut ret: Int = 0;
    let mut content: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() || state.is_null() {
        return nk_false as Int;
    } else {
        ret = nk_do_button(state, out, bounds, style, in_0, b, &mut content);
        content.x += (*style).image_padding.x;
        content.y += (*style).image_padding.y;
        content.w -= 2i32 as f32 * (*style).image_padding.x;
        content.h -= 2i32 as f32 * (*style).image_padding.y;
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_button_image(out, &mut bounds, &mut content, *state, style, &mut img);
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return ret;
    };
}
unsafe fn nk_draw_button_image(
    mut out: *mut CommandBuffer,
    mut bounds: *const Rect,
    mut content: *const Rect,
    mut state: Flags,
    mut style: *const StyleButton,
    mut img: *const Image,
) -> () {
    nk_draw_button(out, bounds, state, style);
    nk_draw_image(out, *content, img, nk_white);
}

pub unsafe fn nk_button_symbol_label(
    mut ctx: *mut Context,
    mut symbol: SymbolType,
    mut label: *const Char,
    mut align: Flags,
) -> Int {
    return nk_button_symbol_text(ctx, symbol, label, nk_strlen(label), align);
}

pub unsafe fn nk_button_symbol_text(
    mut ctx: *mut Context,
    mut symbol: SymbolType,
    mut text: *const Char,
    mut len: Int,
    mut align: Flags,
) -> Int {
    if ctx.is_null() {
        return 0i32;
    } else {
        return nk_button_symbol_text_styled(
            ctx,
            &mut (*ctx).style.button,
            symbol,
            text,
            len,
            align,
        );
    };
}

pub unsafe fn nk_button_symbol_text_styled(
    mut ctx: *mut Context,
    mut style: *const StyleButton,
    mut symbol: SymbolType,
    mut text: *const Char,
    mut len: Int,
    mut align: Flags,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            return nk_do_button_text_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                symbol,
                text,
                len,
                align,
                (*ctx).button_behavior,
                style,
                (*ctx).style.font,
                in_0,
            );
        }
    };
}
unsafe fn nk_do_button_text_symbol(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut symbol: SymbolType,
    mut str: *const Char,
    mut len: Int,
    mut align: Flags,
    mut behavior: ButtonBehavior,
    mut style: *const StyleButton,
    mut font: *const UserFont,
    mut in_0: *const Input,
) -> Int {
    let mut ret: Int = 0;
    let mut tri: Rect = Rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    let mut content: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() || font.is_null() {
        return nk_false as Int;
    } else {
        ret = nk_do_button(state, out, bounds, style, in_0, behavior, &mut content);
        tri.y = content.y + content.h / 2i32 as f32 - (*font).height / 2i32 as f32;
        tri.w = (*font).height;
        tri.h = (*font).height;
        if 0 != align & NK_TEXT_ALIGN_LEFT as Int as Uint {
            tri.x = content.x + content.w - (2i32 as f32 * (*style).padding.x + tri.w);
            tri.x = if tri.x < 0i32 as f32 {
                0i32 as f32
            } else {
                tri.x
            }
        } else {
            tri.x = content.x + 2i32 as f32 * (*style).padding.x
        }
        /* draw button */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_button_text_symbol(
            out,
            &mut bounds,
            &mut content,
            &mut tri,
            *state,
            style,
            str,
            len,
            symbol,
            font,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return ret;
    };
}
unsafe fn nk_draw_button_text_symbol(
    mut out: *mut CommandBuffer,
    mut bounds: *const Rect,
    mut label: *const Rect,
    mut symbol: *const Rect,
    mut state: Flags,
    mut style: *const StyleButton,
    mut str: *const Char,
    mut len: Int,
    mut type_0: SymbolType,
    mut font: *const UserFont,
) -> () {
    let mut sym: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut background: *const StyleItem = 0 as *const StyleItem;
    /* select correct background colors/images */
    background = nk_draw_button(out, bounds, state, style);
    if (*background).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
        text.background = (*background).data.color
    } else {
        text.background = (*style).text_background
    }
    /* select correct text colors */
    if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        sym = (*style).text_hover;
        text.text = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        sym = (*style).text_active;
        text.text = (*style).text_active
    } else {
        sym = (*style).text_normal;
        text.text = (*style).text_normal
    }
    text.padding = Point::new(0i32 as f32, 0i32 as f32);
    nk_draw_symbol(
        out,
        type_0,
        *symbol,
        (*style).text_background,
        sym,
        0i32 as f32,
        font,
    );
    nk_widget_text(
        out,
        *label,
        str,
        len,
        &mut text,
        NK_TEXT_CENTERED as Int as Flags,
        font,
    );
}

pub unsafe fn nk_button_image_label(
    mut ctx: *mut Context,
    mut img: Image,
    mut label: *const Char,
    mut align: Flags,
) -> Int {
    return nk_button_image_text(ctx, img, label, nk_strlen(label), align);
}

pub unsafe fn nk_button_image_text(
    mut ctx: *mut Context,
    mut img: Image,
    mut text: *const Char,
    mut len: Int,
    mut align: Flags,
) -> Int {
    return nk_button_image_text_styled(ctx, &mut (*ctx).style.button, img, text, len, align);
}

pub unsafe fn nk_button_image_text_styled(
    mut ctx: *mut Context,
    mut style: *const StyleButton,
    mut img: Image,
    mut text: *const Char,
    mut len: Int,
    mut align: Flags,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            return nk_do_button_text_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                img,
                text,
                len,
                align,
                (*ctx).button_behavior,
                style,
                (*ctx).style.font,
                in_0,
            );
        }
    };
}
unsafe fn nk_do_button_text_image(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut img: Image,
    mut str: *const Char,
    mut len: Int,
    mut align: Flags,
    mut behavior: ButtonBehavior,
    mut style: *const StyleButton,
    mut font: *const UserFont,
    mut in_0: *const Input,
) -> Int {
    let mut ret: Int = 0;
    let mut icon: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut content: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || font.is_null() || style.is_null() || str.is_null() {
        return nk_false as Int;
    } else {
        ret = nk_do_button(state, out, bounds, style, in_0, behavior, &mut content);
        icon.y = bounds.y + (*style).padding.y;
        icon.h = bounds.h - 2i32 as f32 * (*style).padding.y;
        icon.w = icon.h;
        if 0 != align & NK_TEXT_ALIGN_LEFT as Int as Uint {
            icon.x = bounds.x + bounds.w - (2i32 as f32 * (*style).padding.x + icon.w);
            icon.x = if icon.x < 0i32 as f32 {
                0i32 as f32
            } else {
                icon.x
            }
        } else {
            icon.x = bounds.x + 2i32 as f32 * (*style).padding.x
        }
        icon.x += (*style).image_padding.x;
        icon.y += (*style).image_padding.y;
        icon.w -= 2i32 as f32 * (*style).image_padding.x;
        icon.h -= 2i32 as f32 * (*style).image_padding.y;
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_button_text_image(
            out,
            &mut bounds,
            &mut content,
            &mut icon,
            *state,
            style,
            str,
            len,
            font,
            &mut img,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return ret;
    };
}
unsafe fn nk_draw_button_text_image(
    mut out: *mut CommandBuffer,
    mut bounds: *const Rect,
    mut label: *const Rect,
    mut image: *const Rect,
    mut state: Flags,
    mut style: *const StyleButton,
    mut str: *const Char,
    mut len: Int,
    mut font: *const UserFont,
    mut img: *const Image,
) -> () {
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut background: *const StyleItem = 0 as *const StyleItem;
    background = nk_draw_button(out, bounds, state, style);
    /* select correct colors */
    if (*background).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
        text.background = (*background).data.color
    } else {
        text.background = (*style).text_background
    }
    if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        text.text = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        text.text = (*style).text_active
    } else {
        text.text = (*style).text_normal
    }
    text.padding = Point::new(0i32 as f32, 0i32 as f32);
    nk_widget_text(
        out,
        *label,
        str,
        len,
        &mut text,
        NK_TEXT_CENTERED as Int as Flags,
        font,
    );
    nk_draw_image(out, *image, img, nk_white);
}

pub unsafe fn nk_button_label_styled(
    mut ctx: *mut Context,
    mut style: *const StyleButton,
    mut title: *const Char,
) -> Int {
    return nk_button_text_styled(ctx, style, title, nk_strlen(title));
}

pub unsafe fn nk_button_symbol_label_styled(
    mut ctx: *mut Context,
    mut style: *const StyleButton,
    mut symbol: SymbolType,
    mut title: *const Char,
    mut align: Flags,
) -> Int {
    return nk_button_symbol_text_styled(ctx, style, symbol, title, nk_strlen(title), align);
}

pub unsafe fn nk_button_image_label_styled(
    mut ctx: *mut Context,
    mut style: *const StyleButton,
    mut img: Image,
    mut label: *const Char,
    mut text_alignment: Flags,
) -> Int {
    return nk_button_image_text_styled(ctx, style, img, label, nk_strlen(label), text_alignment);
}

pub unsafe fn nk_button_set_behavior(mut ctx: *mut Context, mut behavior: ButtonBehavior) -> () {
    if ctx.is_null() {
        return;
    } else {
        (*ctx).button_behavior = behavior;
        return;
    };
}

pub unsafe fn nk_button_push_behavior(mut ctx: *mut Context, mut behavior: ButtonBehavior) -> Int {
    let mut button_stack: *mut ConfigStackButtonBehavior = 0 as *mut ConfigStackButtonBehavior;
    let mut element: *mut ConfigStackButtonBehaviorElement =
        0 as *mut ConfigStackButtonBehaviorElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        button_stack = &mut (*ctx).stacks.button_behaviors as *mut ConfigStackButtonBehavior;
        if (*button_stack).head
            >= (mem::size_of::<[ConfigStackButtonBehaviorElement; 8]>() as Ulong)
                .wrapping_div(mem::size_of::<ConfigStackButtonBehaviorElement>() as Ulong)
                as Int
        {
            return 0i32;
        } else {
            let fresh19 = (*button_stack).head;
            (*button_stack).head = (*button_stack).head + 1;
            element = &mut (*button_stack).elements[fresh19 as usize]
                as *mut ConfigStackButtonBehaviorElement;
            (*element).address = &mut (*ctx).button_behavior as *mut ButtonBehavior;
            (*element).old_value = (*ctx).button_behavior;
            (*ctx).button_behavior = behavior;
            return 1i32;
        }
    };
}

pub unsafe fn nk_button_pop_behavior(mut ctx: *mut Context) -> Int {
    let mut button_stack: *mut ConfigStackButtonBehavior = 0 as *mut ConfigStackButtonBehavior;
    let mut element: *mut ConfigStackButtonBehaviorElement =
        0 as *mut ConfigStackButtonBehaviorElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        button_stack = &mut (*ctx).stacks.button_behaviors as *mut ConfigStackButtonBehavior;
        if (*button_stack).head < 1i32 {
            return 0i32;
        } else {
            (*button_stack).head -= 1;
            element = &mut (*button_stack).elements[(*button_stack).head as usize]
                as *mut ConfigStackButtonBehaviorElement;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_check_label(
    mut ctx: *mut Context,
    mut label: *const Char,
    mut active: Int,
) -> Int {
    return nk_check_text(ctx, label, nk_strlen(label), active);
}

pub unsafe fn nk_check_text(
    mut ctx: *mut Context,
    mut text: *const Char,
    mut len: Int,
    mut active: Int,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut style: *const Style = 0 as *const Style;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return active;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return active;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            nk_do_toggle(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                &mut active,
                text,
                len,
                NK_TOGGLE_CHECK,
                &(*style).checkbox,
                in_0,
                (*style).font,
            );
            return active;
        }
    };
}
unsafe fn nk_do_toggle(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut r: Rect,
    mut active: *mut Int,
    mut str: *const Char,
    mut len: Int,
    mut type_0: ToggleType,
    mut style: *const StyleToggle,
    mut in_0: *const Input,
    mut font: *const UserFont,
) -> Int {
    let mut was_active: Int = 0;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut select: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut cursor: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut label: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() || font.is_null() || active.is_null() {
        return 0i32;
    } else {
        r.w = if r.w < (*font).height + 2i32 as f32 * (*style).padding.x {
            (*font).height + 2i32 as f32 * (*style).padding.x
        } else {
            r.w
        };
        r.h = if r.h < (*font).height + 2i32 as f32 * (*style).padding.y {
            (*font).height + 2i32 as f32 * (*style).padding.y
        } else {
            r.h
        };
        /* add additional touch padding for touch screen devices */
        bounds.x = r.x - (*style).touch_padding.x;
        bounds.y = r.y - (*style).touch_padding.y;
        bounds.w = r.w + 2i32 as f32 * (*style).touch_padding.x;
        bounds.h = r.h + 2i32 as f32 * (*style).touch_padding.y;
        /* calculate the selector space */
        select.w = (*font).height;
        select.h = select.w;
        select.y = r.y + r.h / 2.0f32 - select.h / 2.0f32;
        select.x = r.x;
        /* calculate the bounds of the cursor inside the selector */
        cursor.x = select.x + (*style).padding.x + (*style).border;
        cursor.y = select.y + (*style).padding.y + (*style).border;
        cursor.w = select.w - (2i32 as f32 * (*style).padding.x + 2i32 as f32 * (*style).border);
        cursor.h = select.h - (2i32 as f32 * (*style).padding.y + 2i32 as f32 * (*style).border);
        /* label behind the selector */
        label.x = select.x + select.w + (*style).spacing;
        label.y = select.y;
        label.w = if r.x + r.w < label.x {
            label.x
        } else {
            r.x + r.w
        } - label.x;
        label.h = select.w;
        /* update selector */
        was_active = *active;
        *active = nk_toggle_behavior(in_0, bounds, state, *active);
        /* draw selector */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        if type_0 as Uint == NK_TOGGLE_CHECK as Int as Uint {
            nk_draw_checkbox(
                out,
                *state,
                style,
                *active,
                &mut label,
                &mut select,
                &mut cursor,
                str,
                len,
                font,
            );
        } else {
            nk_draw_option(
                out,
                *state,
                style,
                *active,
                &mut label,
                &mut select,
                &mut cursor,
                str,
                len,
                font,
            );
        }
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return (was_active != *active) as Int;
    };
}
unsafe fn nk_draw_option(
    mut out: *mut CommandBuffer,
    mut state: Flags,
    mut style: *const StyleToggle,
    mut active: Int,
    mut label: *const Rect,
    mut selector: *const Rect,
    mut cursors: *const Rect,
    mut string: *const Char,
    mut len: Int,
    mut font: *const UserFont,
) -> () {
    let mut background: *const StyleItem = 0 as *const StyleItem;
    let mut cursor: *const StyleItem = 0 as *const StyleItem;
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    /* select correct colors/images */
    if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        background = &(*style).hover as *const StyleItem;
        cursor = &(*style).cursor_hover as *const StyleItem;
        text.text = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        background = &(*style).hover as *const StyleItem;
        cursor = &(*style).cursor_hover as *const StyleItem;
        text.text = (*style).text_active
    } else {
        background = &(*style).normal as *const StyleItem;
        cursor = &(*style).cursor_normal as *const StyleItem;
        text.text = (*style).text_normal
    }
    /* draw background and cursor */
    if (*background).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
        nk_fill_circle(out, *selector, (*style).border_color);
        nk_fill_circle(
            out,
            nk_shrink_rect(*selector, (*style).border),
            (*background).data.color,
        );
    } else {
        nk_draw_image(out, *selector, &(*background).data.image, nk_white);
    }
    if 0 != active {
        if (*cursor).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
            nk_draw_image(out, *cursors, &(*cursor).data.image, nk_white);
        } else {
            nk_fill_circle(out, *cursors, (*cursor).data.color);
        }
    }
    text.padding.x = 0i32 as f32;
    text.padding.y = 0i32 as f32;
    text.background = (*style).text_background;
    nk_widget_text(
        out,
        *label,
        string,
        len,
        &mut text,
        NK_TEXT_LEFT as Int as Flags,
        font,
    );
}
unsafe fn nk_draw_checkbox(
    mut out: *mut CommandBuffer,
    mut state: Flags,
    mut style: *const StyleToggle,
    mut active: Int,
    mut label: *const Rect,
    mut selector: *const Rect,
    mut cursors: *const Rect,
    mut string: *const Char,
    mut len: Int,
    mut font: *const UserFont,
) -> () {
    let mut background: *const StyleItem = 0 as *const StyleItem;
    let mut cursor: *const StyleItem = 0 as *const StyleItem;
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    /* select correct colors/images */
    if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        background = &(*style).hover as *const StyleItem;
        cursor = &(*style).cursor_hover as *const StyleItem;
        text.text = (*style).text_hover
    } else if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        background = &(*style).hover as *const StyleItem;
        cursor = &(*style).cursor_hover as *const StyleItem;
        text.text = (*style).text_active
    } else {
        background = &(*style).normal as *const StyleItem;
        cursor = &(*style).cursor_normal as *const StyleItem;
        text.text = (*style).text_normal
    }
    /* draw background and cursor */
    if (*background).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
        nk_fill_rect(out, *selector, 0i32 as f32, (*style).border_color);
        nk_fill_rect(
            out,
            nk_shrink_rect(*selector, (*style).border),
            0i32 as f32,
            (*background).data.color,
        );
    } else {
        nk_draw_image(out, *selector, &(*background).data.image, nk_white);
    }
    if 0 != active {
        if (*cursor).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
            nk_draw_image(out, *cursors, &(*cursor).data.image, nk_white);
        } else {
            nk_fill_rect(out, *cursors, 0i32 as f32, (*cursor).data.color);
        }
    }
    text.padding.x = 0i32 as f32;
    text.padding.y = 0i32 as f32;
    text.background = (*style).text_background;
    nk_widget_text(
        out,
        *label,
        string,
        len,
        &mut text,
        NK_TEXT_LEFT as Int as Flags,
        font,
    );
}
unsafe fn nk_toggle_behavior(
    mut in_0: *const Input,
    mut select: Rect,
    mut state: *mut Flags,
    mut active: Int,
) -> Int {
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as Int as Uint {
        *state = (NK_WIDGET_STATE_INACTIVE as Int | NK_WIDGET_STATE_MODIFIED as Int) as Flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as Int as Flags
    }
    if 0 != ButtonBehavior(state, select, in_0, NK_BUTTON_DEFAULT) {
        *state = NK_WIDGET_STATE_ACTIVE as Int as Flags;
        active = (0 == active) as Int
    }
    if 0 != *state & NK_WIDGET_STATE_HOVER as Int as Uint
        && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, select)
    {
        *state |= NK_WIDGET_STATE_ENTERED as Int as Uint
    } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, select) {
        *state |= NK_WIDGET_STATE_LEFT as Int as Uint
    }
    return active;
}

pub unsafe fn nk_check_flags_label(
    mut ctx: *mut Context,
    mut label: *const Char,
    mut flags: Uint,
    mut value: Uint,
) -> Uint {
    return nk_check_flags_text(ctx, label, nk_strlen(label), flags, value);
}

pub unsafe fn nk_check_flags_text(
    mut ctx: *mut Context,
    mut text: *const Char,
    mut len: Int,
    mut flags: Uint,
    mut value: Uint,
) -> Uint {
    let mut old_active: Int = 0;
    if ctx.is_null() || text.is_null() {
        return flags;
    } else {
        old_active = (flags & value & value) as Int;
        if 0 != nk_check_text(ctx, text, len, old_active) {
            flags |= value
        } else {
            flags &= !value
        }
        return flags;
    };
}

pub unsafe fn nk_checkbox_label(
    mut ctx: *mut Context,
    mut label: *const Char,
    mut active: *mut Int,
) -> Int {
    return nk_checkbox_text(ctx, label, nk_strlen(label), active);
}

pub unsafe fn nk_checkbox_text(
    mut ctx: *mut Context,
    mut text: *const Char,
    mut len: Int,
    mut active: *mut Int,
) -> Int {
    let mut old_val: Int = 0;
    if ctx.is_null() || text.is_null() || active.is_null() {
        return 0i32;
    } else {
        old_val = *active;
        *active = nk_check_text(ctx, text, len, *active);
        return (old_val != *active) as Int;
    };
}

pub unsafe fn nk_checkbox_flags_label(
    mut ctx: *mut Context,
    mut label: *const Char,
    mut flags: *mut Uint,
    mut value: Uint,
) -> Int {
    return nk_checkbox_flags_text(ctx, label, nk_strlen(label), flags, value);
}

pub unsafe fn nk_checkbox_flags_text(
    mut ctx: *mut Context,
    mut text: *const Char,
    mut len: Int,
    mut flags: *mut Uint,
    mut value: Uint,
) -> Int {
    let mut active: Int = 0;
    if ctx.is_null() || text.is_null() || flags.is_null() {
        return 0i32;
    } else {
        active = (*flags & value & value) as Int;
        if 0 != nk_checkbox_text(ctx, text, len, &mut active) {
            if 0 != active {
                *flags |= value
            } else {
                *flags &= !value
            }
            return 1i32;
        } else {
            return 0i32;
        }
    };
}

pub unsafe fn nk_radio_label(
    mut ctx: *mut Context,
    mut label: *const Char,
    mut active: *mut Int,
) -> Int {
    return nk_radio_text(ctx, label, nk_strlen(label), active);
}

pub unsafe fn nk_radio_text(
    mut ctx: *mut Context,
    mut text: *const Char,
    mut len: Int,
    mut active: *mut Int,
) -> Int {
    let mut old_value: Int = 0;
    if ctx.is_null() || text.is_null() || active.is_null() {
        return 0i32;
    } else {
        old_value = *active;
        *active = nk_option_text(ctx, text, len, old_value);
        return (old_value != *active) as Int;
    };
}

pub unsafe fn nk_option_text(
    mut ctx: *mut Context,
    mut text: *const Char,
    mut len: Int,
    mut is_active: Int,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut style: *const Style = 0 as *const Style;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return is_active;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return state as Int;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            nk_do_toggle(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                &mut is_active,
                text,
                len,
                NK_TOGGLE_OPTION,
                &(*style).option,
                in_0,
                (*style).font,
            );
            return is_active;
        }
    };
}

pub unsafe fn nk_option_label(
    mut ctx: *mut Context,
    mut label: *const Char,
    mut active: Int,
) -> Int {
    return nk_option_text(ctx, label, nk_strlen(label), active);
}

pub unsafe fn nk_selectable_label(
    mut ctx: *mut Context,
    mut str: *const Char,
    mut align: Flags,
    mut value: *mut Int,
) -> Int {
    return nk_selectable_text(ctx, str, nk_strlen(str), align, value);
}

pub unsafe fn nk_selectable_text(
    mut ctx: *mut Context,
    mut str: *const Char,
    mut len: Int,
    mut align: Flags,
    mut value: *mut Int,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut style: *const Style = 0 as *const Style;
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || value.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        style = &mut (*ctx).style as *mut Style;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            return nk_do_selectable(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                str,
                len,
                align,
                value,
                &(*style).selectable,
                in_0,
                (*style).font,
            );
        }
    };
}

pub unsafe fn nk_selectable_image_label(
    mut ctx: *mut Context,
    mut img: Image,
    mut str: *const Char,
    mut align: Flags,
    mut value: *mut Int,
) -> Int {
    return nk_selectable_image_text(ctx, img, str, nk_strlen(str), align, value);
}

pub unsafe fn nk_selectable_image_text(
    mut ctx: *mut Context,
    mut img: Image,
    mut str: *const Char,
    mut len: Int,
    mut align: Flags,
    mut value: *mut Int,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut style: *const Style = 0 as *const Style;
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || value.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        style = &mut (*ctx).style as *mut Style;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            return nk_do_selectable_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                str,
                len,
                align,
                value,
                &mut img,
                &(*style).selectable,
                in_0,
                (*style).font,
            );
        }
    };
}

pub unsafe fn nk_selectable_symbol_label(
    mut ctx: *mut Context,
    mut sym: SymbolType,
    mut title: *const Char,
    mut align: Flags,
    mut value: *mut Int,
) -> Int {
    return nk_selectable_symbol_text(ctx, sym, title, nk_strlen(title), align, value);
}

pub unsafe fn nk_selectable_symbol_text(
    mut ctx: *mut Context,
    mut sym: SymbolType,
    mut str: *const Char,
    mut len: Int,
    mut align: Flags,
    mut value: *mut Int,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *const Input = 0 as *const Input;
    let mut style: *const Style = 0 as *const Style;
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || value.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        style = &mut (*ctx).style as *mut Style;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            return nk_do_selectable_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                str,
                len,
                align,
                value,
                sym,
                &(*style).selectable,
                in_0,
                (*style).font,
            );
        }
    };
}
unsafe fn nk_do_selectable_symbol(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut str: *const Char,
    mut len: Int,
    mut align: Flags,
    mut value: *mut Int,
    mut sym: SymbolType,
    mut style: *const StyleSelectable,
    mut in_0: *const Input,
    mut font: *const UserFont,
) -> Int {
    let mut old_value: Int = 0;
    let mut touch: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut icon: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if state.is_null()
        || out.is_null()
        || str.is_null()
        || 0 == len
        || value.is_null()
        || style.is_null()
        || font.is_null()
    {
        return 0i32;
    } else {
        old_value = *value;
        /* toggle behavior */
        touch.x = bounds.x - (*style).touch_padding.x;
        touch.y = bounds.y - (*style).touch_padding.y;
        touch.w = bounds.w + (*style).touch_padding.x * 2i32 as f32;
        touch.h = bounds.h + (*style).touch_padding.y * 2i32 as f32;
        if 0 != ButtonBehavior(state, touch, in_0, NK_BUTTON_DEFAULT) {
            *value = (0 == *value) as Int
        }
        icon.y = bounds.y + (*style).padding.y;
        icon.h = bounds.h - 2i32 as f32 * (*style).padding.y;
        icon.w = icon.h;
        if 0 != align & NK_TEXT_ALIGN_LEFT as Int as Uint {
            icon.x = bounds.x + bounds.w - (2i32 as f32 * (*style).padding.x + icon.w);
            icon.x = if icon.x < 0i32 as f32 {
                0i32 as f32
            } else {
                icon.x
            }
        } else {
            icon.x = bounds.x + 2i32 as f32 * (*style).padding.x
        }
        icon.x += (*style).image_padding.x;
        icon.y += (*style).image_padding.y;
        icon.w -= 2i32 as f32 * (*style).image_padding.x;
        icon.h -= 2i32 as f32 * (*style).image_padding.y;
        /* draw selectable */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_selectable(
            out,
            *state,
            style,
            *value,
            &mut bounds,
            &mut icon,
            0 as *const Image,
            sym,
            str,
            len,
            align,
            font,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return (old_value != *value) as Int;
    };
}

pub unsafe fn nk_select_label(
    mut ctx: *mut Context,
    mut str: *const Char,
    mut align: Flags,
    mut value: Int,
) -> Int {
    nk_selectable_text(ctx, str, nk_strlen(str), align, &mut value);
    return value;
}

pub unsafe fn nk_select_text(
    mut ctx: *mut Context,
    mut str: *const Char,
    mut len: Int,
    mut align: Flags,
    mut value: Int,
) -> Int {
    nk_selectable_text(ctx, str, len, align, &mut value);
    return value;
}

pub unsafe fn nk_select_image_label(
    mut ctx: *mut Context,
    mut img: Image,
    mut str: *const Char,
    mut align: Flags,
    mut value: Int,
) -> Int {
    nk_selectable_image_text(ctx, img, str, nk_strlen(str), align, &mut value);
    return value;
}

pub unsafe fn nk_select_image_text(
    mut ctx: *mut Context,
    mut img: Image,
    mut str: *const Char,
    mut len: Int,
    mut align: Flags,
    mut value: Int,
) -> Int {
    nk_selectable_image_text(ctx, img, str, len, align, &mut value);
    return value;
}

pub unsafe fn nk_select_symbol_label(
    mut ctx: *mut Context,
    mut sym: SymbolType,
    mut title: *const Char,
    mut align: Flags,
    mut value: Int,
) -> Int {
    return nk_select_symbol_text(ctx, sym, title, nk_strlen(title), align, value);
}

pub unsafe fn nk_select_symbol_text(
    mut ctx: *mut Context,
    mut sym: SymbolType,
    mut title: *const Char,
    mut title_len: Int,
    mut align: Flags,
    mut value: Int,
) -> Int {
    nk_selectable_symbol_text(ctx, sym, title, title_len, align, &mut value);
    return value;
}

pub unsafe fn nk_slide_float(
    mut ctx: *mut Context,
    mut min: f32,
    mut val: f32,
    mut max: f32,
    mut step: f32,
) -> f32 {
    nk_slider_float(ctx, min, &mut val, max, step);
    return val;
}

pub unsafe fn nk_slider_float(
    mut ctx: *mut Context,
    mut min_value: f32,
    mut value: *mut f32,
    mut max_value: f32,
    mut value_step: f32,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *mut Input = 0 as *mut Input;
    let mut style: *const Style = 0 as *const Style;
    let mut ret: Int = 0i32;
    let mut old_value: f32 = 0.;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || value.is_null()
    {
        return ret;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return ret;
        } else {
            /*state == NK_WIDGET_ROM || */
            in_0 = if 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            old_value = *value;
            *value = nk_do_slider(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                min_value,
                old_value,
                max_value,
                value_step,
                &(*style).slider,
                in_0,
                (*style).font,
            );
            return (old_value > *value || old_value < *value) as Int;
        }
    };
}
unsafe fn nk_do_slider(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut min: f32,
    mut val: f32,
    mut max: f32,
    mut step: f32,
    mut style: *const StyleSlider,
    mut in_0: *mut Input,
    mut font: *const UserFont,
) -> f32 {
    let mut slider_range: f32 = 0.;
    let mut slider_min: f32 = 0.;
    let mut slider_max: f32 = 0.;
    let mut slider_value: f32 = 0.;
    let mut slider_steps: f32 = 0.;
    let mut cursor_offset: f32 = 0.;
    let mut visual_cursor: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut logical_cursor: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() {
        return 0i32 as f32;
    } else {
        /* remove padding from slider bounds */
        bounds.x = bounds.x + (*style).padding.x;
        bounds.y = bounds.y + (*style).padding.y;
        bounds.h = if bounds.h < 2i32 as f32 * (*style).padding.y {
            2i32 as f32 * (*style).padding.y
        } else {
            bounds.h
        };
        bounds.w = if bounds.w < 2i32 as f32 * (*style).padding.x + (*style).cursor_size.x {
            2i32 as f32 * (*style).padding.x + (*style).cursor_size.x
        } else {
            bounds.w
        };
        bounds.w -= 2i32 as f32 * (*style).padding.x;
        bounds.h -= 2i32 as f32 * (*style).padding.y;
        /* optional buttons */
        if 0 != (*style).show_buttons {
            let mut ws: Flags = 0;
            let mut button: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            button.y = bounds.y;
            button.w = bounds.h;
            button.h = bounds.h;
            /* decrement button */
            button.x = bounds.x;
            if 0 != nk_do_button_symbol(
                &mut ws,
                out,
                button,
                (*style).dec_symbol,
                NK_BUTTON_DEFAULT,
                &(*style).dec_button,
                in_0,
                font,
            ) {
                val -= step
            }
            /* increment button */
            button.x = bounds.x + bounds.w - button.w;
            if 0 != nk_do_button_symbol(
                &mut ws,
                out,
                button,
                (*style).inc_symbol,
                NK_BUTTON_DEFAULT,
                &(*style).inc_button,
                in_0,
                font,
            ) {
                val += step
            }
            bounds.x = bounds.x + button.w + (*style).spacing.x;
            bounds.w = bounds.w - (2i32 as f32 * button.w + 2i32 as f32 * (*style).spacing.x)
        }
        /* remove one cursor size to support visual cursor */
        bounds.x += (*style).cursor_size.x * 0.5f32;
        bounds.w -= (*style).cursor_size.x;
        /* make sure the provided values are correct */
        slider_max = if min < max { max } else { min };
        slider_min = if min < max { min } else { max };
        slider_value = if if val < slider_max { val } else { slider_max } < slider_min {
            slider_min
        } else if val < slider_max {
            val
        } else {
            slider_max
        };
        slider_range = slider_max - slider_min;
        slider_steps = slider_range / step;
        cursor_offset = (slider_value - slider_min) / step;
        /* calculate cursor
    Basically you have two cursors. One for visual representation and interaction
    and one for updating the actual cursor value. */
        logical_cursor.h = bounds.h;
        logical_cursor.w = bounds.w / slider_steps;
        logical_cursor.x = bounds.x + logical_cursor.w * cursor_offset;
        logical_cursor.y = bounds.y;
        visual_cursor.h = (*style).cursor_size.y;
        visual_cursor.w = (*style).cursor_size.x;
        visual_cursor.y = bounds.y + bounds.h * 0.5f32 - visual_cursor.h * 0.5f32;
        visual_cursor.x = logical_cursor.x - visual_cursor.w * 0.5f32;
        slider_value = nk_slider_behavior(
            state,
            &mut logical_cursor,
            &mut visual_cursor,
            in_0,
            bounds,
            slider_min,
            slider_max,
            slider_value,
            step,
            slider_steps,
        );
        visual_cursor.x = logical_cursor.x - visual_cursor.w * 0.5f32;
        /* draw slider */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_slider(
            out,
            *state,
            style,
            &mut bounds,
            &mut visual_cursor,
            slider_min,
            slider_value,
            slider_max,
        );
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return slider_value;
    };
}
unsafe fn nk_draw_slider(
    mut out: *mut CommandBuffer,
    mut state: Flags,
    mut style: *const StyleSlider,
    mut bounds: *const Rect,
    mut visual_cursor: *const Rect,
    mut min: f32,
    mut value: f32,
    mut max: f32,
) -> () {
    let mut fill: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut bar: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut background: *const StyleItem = 0 as *const StyleItem;
    /* select correct slider images/colors */
    let mut bar_color: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut cursor: *const StyleItem = 0 as *const StyleItem;
    if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        background = &(*style).active as *const StyleItem;
        bar_color = (*style).bar_active;
        cursor = &(*style).cursor_active as *const StyleItem
    } else if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        background = &(*style).hover as *const StyleItem;
        bar_color = (*style).bar_hover;
        cursor = &(*style).cursor_hover as *const StyleItem
    } else {
        background = &(*style).normal as *const StyleItem;
        bar_color = (*style).bar_normal;
        cursor = &(*style).cursor_normal as *const StyleItem
    }
    /* calculate slider background bar */
    bar.x = (*bounds).x;
    bar.y = (*visual_cursor).y + (*visual_cursor).h / 2i32 as f32 - (*bounds).h / 12i32 as f32;
    bar.w = (*bounds).w;
    bar.h = (*bounds).h / 6i32 as f32;
    /* filled background bar style */
    fill.w = (*visual_cursor).x + (*visual_cursor).w / 2.0f32 - bar.x;
    fill.x = bar.x;
    fill.y = bar.y;
    fill.h = bar.h;
    /* draw background */
    if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
    } else {
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        nk_stroke_rect(
            out,
            *bounds,
            (*style).rounding,
            (*style).border,
            (*style).border_color,
        );
    }
    /* draw slider bar */
    nk_fill_rect(out, bar, (*style).rounding, bar_color);
    nk_fill_rect(out, fill, (*style).rounding, (*style).bar_filled);
    /* draw cursor */
    if (*cursor).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
        nk_draw_image(out, *visual_cursor, &(*cursor).data.image, nk_white);
    } else {
        nk_fill_circle(out, *visual_cursor, (*cursor).data.color);
    };
}
unsafe fn nk_slider_behavior(
    mut state: *mut Flags,
    mut logical_cursor: *mut Rect,
    mut visual_cursor: *mut Rect,
    mut in_0: *mut Input,
    mut bounds: Rect,
    mut slider_min: f32,
    mut slider_max: f32,
    mut slider_value: f32,
    mut slider_step: f32,
    mut slider_steps: f32,
) -> f32 {
    let mut left_mouse_down: Int = 0;
    let mut left_mouse_click_in_cursor: Int = 0;
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as Int as Uint {
        *state = (NK_WIDGET_STATE_INACTIVE as Int | NK_WIDGET_STATE_MODIFIED as Int) as Flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as Int as Flags
    }
    /* check if visual cursor is being dragged */
    left_mouse_down =
        (!in_0.is_null() && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down) as Int;
    left_mouse_click_in_cursor = (!in_0.is_null()
        && 0 != nk_input_has_mouse_click_down_in_rect(
            in_0,
            NK_BUTTON_LEFT,
            *visual_cursor,
            nk_true as Int,
        )) as Int;
    if 0 != left_mouse_down && 0 != left_mouse_click_in_cursor {
        let mut ratio: f32 = 0i32 as f32;
        let d: f32 = (*in_0).mouse.pos.x - ((*visual_cursor).x + (*visual_cursor).w * 0.5f32);
        let pxstep: f32 = bounds.w / slider_steps;
        /* only update value if the next slider step is reached */
        *state = NK_WIDGET_STATE_ACTIVE as Int as Flags;
        if if d < 0i32 as f32 { -d } else { d } >= pxstep {
            let steps: f32 = (if d < 0i32 as f32 { -d } else { d } / pxstep) as Int as f32;
            slider_value += if d > 0i32 as f32 {
                slider_step * steps
            } else {
                -(slider_step * steps)
            };
            slider_value = if if slider_value < slider_max {
                slider_value
            } else {
                slider_max
            } < slider_min
            {
                slider_min
            } else if slider_value < slider_max {
                slider_value
            } else {
                slider_max
            };
            ratio = (slider_value - slider_min) / slider_step;
            (*logical_cursor).x = bounds.x + (*logical_cursor).w * ratio;
            (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize]
                .clicked_pos
                .x = (*logical_cursor).x
        }
    }
    /* slider widget state */
    if 0 != nk_input_is_mouse_hovering_rect(in_0, bounds) {
        *state = NK_WIDGET_STATE_HOVERED as Int as Flags
    }
    if 0 != *state & NK_WIDGET_STATE_HOVER as Int as Uint
        && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, bounds)
    {
        *state |= NK_WIDGET_STATE_ENTERED as Int as Uint
    } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, bounds) {
        *state |= NK_WIDGET_STATE_LEFT as Int as Uint
    }
    return slider_value;
}

pub unsafe fn nk_slide_int(
    mut ctx: *mut Context,
    mut min: Int,
    mut val: Int,
    mut max: Int,
    mut step: Int,
) -> Int {
    let mut value: f32 = val as f32;
    nk_slider_float(ctx, min as f32, &mut value, max as f32, step as f32);
    return value as Int;
}

pub unsafe fn nk_slider_int(
    mut ctx: *mut Context,
    mut min: Int,
    mut val: *mut Int,
    mut max: Int,
    mut step: Int,
) -> Int {
    let mut ret: Int = 0;
    let mut value: f32 = *val as f32;
    ret = nk_slider_float(ctx, min as f32, &mut value, max as f32, step as f32);
    *val = value as Int;
    return ret;
}

pub unsafe fn nk_progress(
    mut ctx: *mut Context,
    mut cur: *mut Size,
    mut max: Size,
    mut is_modifyable: Int,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut style: *const Style = 0 as *const Style;
    let mut in_0: *mut Input = 0 as *mut Input;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut old_value: Size = 0;
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || cur.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            old_value = *cur;
            *cur = nk_do_progress(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                *cur,
                max,
                is_modifyable,
                &(*style).progress,
                in_0,
            );
            return (*cur != old_value) as Int;
        }
    };
}
unsafe fn nk_do_progress(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut value: Size,
    mut max: Size,
    mut modifiable: Int,
    mut style: *const StyleProgress,
    mut in_0: *mut Input,
) -> Size {
    let mut prog_scale: f32 = 0.;
    let mut prog_value: Size = 0;
    let mut cursor: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if out.is_null() || style.is_null() {
        return 0i32 as Size;
    } else {
        /* calculate progressbar cursor */
        cursor.w = if bounds.w < 2i32 as f32 * (*style).padding.x + 2i32 as f32 * (*style).border {
            2i32 as f32 * (*style).padding.x + 2i32 as f32 * (*style).border
        } else {
            bounds.w
        };
        cursor.h = if bounds.h < 2i32 as f32 * (*style).padding.y + 2i32 as f32 * (*style).border {
            2i32 as f32 * (*style).padding.y + 2i32 as f32 * (*style).border
        } else {
            bounds.h
        };
        cursor = nk_pad_rect(
            bounds,
            Point::new(
                (*style).padding.x + (*style).border,
                (*style).padding.y + (*style).border,
            ),
        );
        prog_scale = value as f32 / max as f32;
        /* update progressbar */
        prog_value = if value < max { value } else { max };
        prog_value = nk_progress_behavior(state, in_0, bounds, cursor, max, prog_value, modifiable);
        cursor.w = cursor.w * prog_scale;
        /* draw progressbar */
        if (*style).draw_begin.is_some() {
            (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
        }
        nk_draw_progress(out, *state, style, &mut bounds, &mut cursor, value, max);
        if (*style).draw_end.is_some() {
            (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
        }
        return prog_value;
    };
}
unsafe fn nk_draw_progress(
    mut out: *mut CommandBuffer,
    mut state: Flags,
    mut style: *const StyleProgress,
    mut bounds: *const Rect,
    mut scursor: *const Rect,
    mut value: Size,
    mut max: Size,
) -> () {
    let mut background: *const StyleItem = 0 as *const StyleItem;
    let mut cursor: *const StyleItem = 0 as *const StyleItem;
    /* select correct colors/images to draw */
    if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        background = &(*style).active as *const StyleItem;
        cursor = &(*style).cursor_active as *const StyleItem
    } else if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        background = &(*style).hover as *const StyleItem;
        cursor = &(*style).cursor_hover as *const StyleItem
    } else {
        background = &(*style).normal as *const StyleItem;
        cursor = &(*style).cursor_normal as *const StyleItem
    }
    /* draw background */
    if (*background).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        nk_stroke_rect(
            out,
            *bounds,
            (*style).rounding,
            (*style).border,
            (*style).border_color,
        );
    } else {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
    }
    /* draw cursor */
    if (*cursor).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
        nk_fill_rect(out, *scursor, (*style).rounding, (*cursor).data.color);
        nk_stroke_rect(
            out,
            *scursor,
            (*style).rounding,
            (*style).border,
            (*style).border_color,
        );
    } else {
        nk_draw_image(out, *scursor, &(*cursor).data.image, nk_white);
    };
}
unsafe fn nk_progress_behavior(
    mut state: *mut Flags,
    mut in_0: *mut Input,
    mut r: Rect,
    mut cursor: Rect,
    mut max: Size,
    mut value: Size,
    mut modifiable: Int,
) -> Size {
    let mut left_mouse_down: Int = 0i32;
    let mut left_mouse_click_in_cursor: Int = 0i32;
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as Int as Uint {
        *state = (NK_WIDGET_STATE_INACTIVE as Int | NK_WIDGET_STATE_MODIFIED as Int) as Flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as Int as Flags
    }
    if in_0.is_null() || 0 == modifiable {
        return value;
    } else {
        left_mouse_down = (!in_0.is_null()
            && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down)
            as Int;
        left_mouse_click_in_cursor = (!in_0.is_null()
            && 0 != nk_input_has_mouse_click_down_in_rect(
                in_0,
                NK_BUTTON_LEFT,
                cursor,
                nk_true as Int,
            )) as Int;
        if 0 != nk_input_is_mouse_hovering_rect(in_0, r) {
            *state = NK_WIDGET_STATE_HOVERED as Int as Flags
        }
        if !in_0.is_null() && 0 != left_mouse_down && 0 != left_mouse_click_in_cursor {
            if 0 != left_mouse_down && 0 != left_mouse_click_in_cursor {
                let mut ratio: f32 = if (0i32 as f32) < (*in_0).mouse.pos.x - cursor.x {
                    (*in_0).mouse.pos.x - cursor.x
                } else {
                    0i32 as f32
                } / cursor.w;
                value = (if if max as f32 * ratio < max as f32 {
                    max as f32 * ratio
                } else {
                    max as f32
                } < 0i32 as f32
                {
                    0i32 as f32
                } else if max as f32 * ratio < max as f32 {
                    max as f32 * ratio
                } else {
                    max as f32
                }) as Size;
                (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize]
                    .clicked_pos
                    .x = cursor.x + cursor.w / 2.0f32;
                *state |= NK_WIDGET_STATE_ACTIVE as Int as Uint
            }
        }
        /* set progressbar widget state */
        if 0 != *state & NK_WIDGET_STATE_HOVER as Int as Uint
            && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, r)
        {
            *state |= NK_WIDGET_STATE_ENTERED as Int as Uint
        } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, r) {
            *state |= NK_WIDGET_STATE_LEFT as Int as Uint
        }
        return value;
    };
}
unsafe fn nk_pad_rect(mut r: Rect, mut pad: Point) -> Rect {
    r.w = if r.w < 2i32 as f32 * pad.x {
        2i32 as f32 * pad.x
    } else {
        r.w
    };
    r.h = if r.h < 2i32 as f32 * pad.y {
        2i32 as f32 * pad.y
    } else {
        r.h
    };
    r.x += pad.x;
    r.y += pad.y;
    r.w -= 2i32 as f32 * pad.x;
    r.h -= 2i32 as f32 * pad.y;
    return r;
}

pub unsafe fn nk_prog(
    mut ctx: *mut Context,
    mut cur: Size,
    mut max: Size,
    mut modifyable: Int,
) -> Size {
    nk_progress(ctx, &mut cur, max, modifyable);
    return cur;
}

pub unsafe fn nk_color_picker(
    mut ctx: *mut Context,
    mut color: ColorF,
    mut fmt: ColorFormat,
) -> ColorF {
    nk_color_pick(ctx, &mut color, fmt);
    return color;
}

pub unsafe fn nk_color_pick(
    mut ctx: *mut Context,
    mut color: *mut ColorF,
    mut fmt: ColorFormat,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut config: *const Style = 0 as *const Style;
    let mut in_0: *const Input = 0 as *const Input;
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || color.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        config = &mut (*ctx).style as *mut Style;
        layout = (*win).layout;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return 0i32;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            return nk_do_color_picker(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                color,
                fmt,
                bounds,
                Point::new(0i32 as f32, 0i32 as f32),
                in_0,
                (*config).font,
            );
        }
    };
}
unsafe fn nk_do_color_picker(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut col: *mut ColorF,
    mut fmt: ColorFormat,
    mut bounds: Rect,
    mut padding: Point,
    mut in_0: *const Input,
    mut font: *const UserFont,
) -> Int {
    let mut ret: Int = 0i32;
    let mut matrix: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut hue_bar: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut alpha_bar: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut bar_w: f32 = 0.;
    if out.is_null() || col.is_null() || state.is_null() || font.is_null() {
        return ret;
    } else {
        bar_w = (*font).height;
        bounds.x += padding.x;
        bounds.y += padding.x;
        bounds.w -= 2i32 as f32 * padding.x;
        bounds.h -= 2i32 as f32 * padding.y;
        matrix.x = bounds.x;
        matrix.y = bounds.y;
        matrix.h = bounds.h;
        matrix.w = bounds.w - (3i32 as f32 * padding.x + 2i32 as f32 * bar_w);
        hue_bar.w = bar_w;
        hue_bar.y = bounds.y;
        hue_bar.h = matrix.h;
        hue_bar.x = matrix.x + matrix.w + padding.x;
        alpha_bar.x = hue_bar.x + hue_bar.w + padding.x;
        alpha_bar.y = bounds.y;
        alpha_bar.w = bar_w;
        alpha_bar.h = matrix.h;
        ret = nk_color_picker_behavior(
            state,
            &mut bounds,
            &mut matrix,
            &mut hue_bar,
            if fmt as Uint == NK_RGBA as Int as Uint {
                &mut alpha_bar
            } else {
                0 as *mut Rect
            },
            col,
            in_0,
        );
        nk_draw_color_picker(
            out,
            &mut matrix,
            &mut hue_bar,
            if fmt as Uint == NK_RGBA as Int as Uint {
                &mut alpha_bar
            } else {
                0 as *mut Rect
            },
            *col,
        );
        return ret;
    };
}
unsafe fn nk_draw_color_picker(
    mut o: *mut CommandBuffer,
    mut matrix: *const Rect,
    mut hue_bar: *const Rect,
    mut alpha_bar: *const Rect,
    mut col: ColorF,
) -> () {
    let mut alpha: f32 = 0.;
    static mut black: Color = unsafe {
        Color {
            r: 0i32 as u8,
            g: 0i32 as u8,
            b: 0i32 as u8,
            a: 255i32 as u8,
        }
    };
    static mut white: Color = unsafe {
        Color {
            r: 255i32 as u8,
            g: 255i32 as u8,
            b: 255i32 as u8,
            a: 255i32 as u8,
        }
    };
    static mut black_trans: Color = unsafe {
        Color {
            r: 0i32 as u8,
            g: 0i32 as u8,
            b: 0i32 as u8,
            a: 0i32 as u8,
        }
    };
    let crosshair_size: f32 = 7.0f32;
    let mut temp: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut hsva: [f32; 4] = [0.; 4];
    let mut line_y: f32 = 0.;
    let mut i: Int = 0;
    /* draw hue bar */
    nk_colorf_hsva_fv(hsva.as_mut_ptr(), col);
    i = 0i32;
    while i < 6i32 {
        static mut hue_colors: [Color; 7] = unsafe {
            [
                Color {
                    r: 255i32 as u8,
                    g: 0i32 as u8,
                    b: 0i32 as u8,
                    a: 255i32 as u8,
                },
                Color {
                    r: 255i32 as u8,
                    g: 255i32 as u8,
                    b: 0i32 as u8,
                    a: 255i32 as u8,
                },
                Color {
                    r: 0i32 as u8,
                    g: 255i32 as u8,
                    b: 0i32 as u8,
                    a: 255i32 as u8,
                },
                Color {
                    r: 0i32 as u8,
                    g: 255i32 as u8,
                    b: 255i32 as u8,
                    a: 255i32 as u8,
                },
                Color {
                    r: 0i32 as u8,
                    g: 0i32 as u8,
                    b: 255i32 as u8,
                    a: 255i32 as u8,
                },
                Color {
                    r: 255i32 as u8,
                    g: 0i32 as u8,
                    b: 255i32 as u8,
                    a: 255i32 as u8,
                },
                Color {
                    r: 255i32 as u8,
                    g: 0i32 as u8,
                    b: 0i32 as u8,
                    a: 255i32 as u8,
                },
            ]
        };
        nk_fill_rect_multi_color(
            o,
            Rect::new(
                (*hue_bar).x,
                (*hue_bar).y + i as f32 * ((*hue_bar).h / 6.0f32) + 0.5f32,
                (*hue_bar).w,
                (*hue_bar).h / 6.0f32 + 0.5f32,
            ),
            hue_colors[i as usize],
            hue_colors[i as usize],
            hue_colors[(i + 1i32) as usize],
            hue_colors[(i + 1i32) as usize],
        );
        i += 1
    }
    line_y = ((*hue_bar).y + hsva[0usize] * (*matrix).h + 0.5f32) as Int as f32;
    nk_stroke_line(
        o,
        (*hue_bar).x - 1i32 as f32,
        line_y,
        (*hue_bar).x + (*hue_bar).w + 2i32 as f32,
        line_y,
        1i32 as f32,
        nk_rgb(255i32, 255i32, 255i32),
    );
    /* draw alpha bar */
    if !alpha_bar.is_null() {
        alpha = if (0i32 as f32) < if 1.0f32 < col.a {
            1.0f32
        } else {
            col.a
        } {
            if 1.0f32 < col.a {
                1.0f32
            } else {
                col.a
            }
        } else {
            0i32 as f32
        };
        line_y = ((*alpha_bar).y + (1.0f32 - alpha) * (*matrix).h + 0.5f32) as Int as f32;
        nk_fill_rect_multi_color(o, *alpha_bar, white, white, black, black);
        nk_stroke_line(
            o,
            (*alpha_bar).x - 1i32 as f32,
            line_y,
            (*alpha_bar).x + (*alpha_bar).w + 2i32 as f32,
            line_y,
            1i32 as f32,
            nk_rgb(255i32, 255i32, 255i32),
        );
    }
    /* draw color matrix */
    temp = nk_hsv_f(hsva[0usize], 1.0f32, 1.0f32);
    nk_fill_rect_multi_color(o, *matrix, white, temp, temp, white);
    nk_fill_rect_multi_color(o, *matrix, black_trans, black_trans, black, black);
    /* draw cross-hair */
    let mut p: Point = Point { x: 0., y: 0. };
    let mut S: f32 = hsva[1usize];
    let mut V: f32 = hsva[2usize];
    p.x = ((*matrix).x + S * (*matrix).w) as Int as f32;
    p.y = ((*matrix).y + (1.0f32 - V) * (*matrix).h) as Int as f32;
    nk_stroke_line(
        o,
        p.x - crosshair_size,
        p.y,
        p.x - 2i32 as f32,
        p.y,
        1.0f32,
        white,
    );
    nk_stroke_line(
        o,
        p.x + crosshair_size + 1i32 as f32,
        p.y,
        p.x + 3i32 as f32,
        p.y,
        1.0f32,
        white,
    );
    nk_stroke_line(
        o,
        p.x,
        p.y + crosshair_size + 1i32 as f32,
        p.x,
        p.y + 3i32 as f32,
        1.0f32,
        white,
    );
    nk_stroke_line(
        o,
        p.x,
        p.y - crosshair_size,
        p.x,
        p.y - 2i32 as f32,
        1.0f32,
        white,
    );
}

pub unsafe fn nk_stroke_line(
    mut b: *mut CommandBuffer,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
    mut line_thickness: f32,
    mut c: Color,
) -> () {
    let mut cmd: *mut CommandLine = 0 as *mut CommandLine;
    if b.is_null() || line_thickness <= 0i32 as f32 {
        return;
    } else {
        cmd = nk_command_buffer_push(b, NK_COMMAND_LINE, mem::size_of::<CommandLine>() as Ulong)
            as *mut CommandLine;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).line_thickness = line_thickness as Ushort;
            (*cmd).begin.x = x0 as Short;
            (*cmd).begin.y = y0 as Short;
            (*cmd).end.x = x1 as Short;
            (*cmd).end.y = y1 as Short;
            (*cmd).color = c;
            return;
        }
    };
}

pub unsafe fn nk_fill_rect_multi_color(
    mut b: *mut CommandBuffer,
    mut rect: Rect,
    mut left: Color,
    mut top: Color,
    mut right: Color,
    mut bottom: Color,
) -> () {
    let mut cmd: *mut CommandRectMultiColor = 0 as *mut CommandRectMultiColor;
    if b.is_null() || rect.w == 0i32 as f32 || rect.h == 0i32 as f32 {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const Rect = &mut (*b).clip as *mut Rect;
            if (*clip).x > rect.x + rect.w
                || (*clip).x + (*clip).w < rect.x
                || (*clip).y > rect.y + rect.h
                || (*clip).y + (*clip).h < rect.y
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_RECT_MULTI_COLOR,
            mem::size_of::<CommandRectMultiColor>() as Ulong,
        ) as *mut CommandRectMultiColor;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).x = rect.x as Short;
            (*cmd).y = rect.y as Short;
            (*cmd).w = (if (0i32 as f32) < rect.w {
                rect.w
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).h = (if (0i32 as f32) < rect.h {
                rect.h
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).left = left;
            (*cmd).top = top;
            (*cmd).right = right;
            (*cmd).bottom = bottom;
            return;
        }
    };
}

pub unsafe fn nk_hsv_f(mut h: f32, mut s: f32, mut v: f32) -> Color {
    return nk_hsva_f(h, s, v, 1.0f32);
}

pub unsafe fn nk_hsva_f(mut h: f32, mut s: f32, mut v: f32, mut a: f32) -> Color {
    let mut c: ColorF = nk_hsva_colorf(h, s, v, a);
    return nk_rgba_f(c.r, c.g, c.b, c.a);
}

pub unsafe fn nk_hsva_colorf(mut h: f32, mut s: f32, mut v: f32, mut a: f32) -> ColorF {
    let mut i: Int = 0;
    let mut p: f32 = 0.;
    let mut q: f32 = 0.;
    let mut t: f32 = 0.;
    let mut f: f32 = 0.;
    let mut out: ColorF = ColorF {
        r: 0i32 as f32,
        g: 0i32 as f32,
        b: 0i32 as f32,
        a: 0i32 as f32,
    };
    if s <= 0.0f32 {
        out.r = v;
        out.g = v;
        out.b = v;
        out.a = a;
        return out;
    } else {
        h = h / (60.0f32 / 360.0f32);
        i = h as Int;
        f = h - i as f32;
        p = v * (1.0f32 - s);
        q = v * (1.0f32 - s * f);
        t = v * (1.0f32 - s * (1.0f32 - f));
        match i {
            1 => {
                out.r = q;
                out.g = v;
                out.b = p
            }
            2 => {
                out.r = p;
                out.g = v;
                out.b = t
            }
            3 => {
                out.r = p;
                out.g = q;
                out.b = v
            }
            4 => {
                out.r = t;
                out.g = p;
                out.b = v
            }
            5 => {
                out.r = v;
                out.g = p;
                out.b = q
            }
            0 | _ => {
                out.r = v;
                out.g = t;
                out.b = p
            }
        }
        out.a = a;
        return out;
    };
}

pub unsafe fn nk_colorf_hsva_fv(mut hsva: *mut f32, mut in_0: ColorF) -> () {
    nk_colorf_hsva_f(
        &mut *hsva.offset(0isize),
        &mut *hsva.offset(1isize),
        &mut *hsva.offset(2isize),
        &mut *hsva.offset(3isize),
        in_0,
    );
}

pub unsafe fn nk_colorf_hsva_f(
    mut out_h: *mut f32,
    mut out_s: *mut f32,
    mut out_v: *mut f32,
    mut out_a: *mut f32,
    mut in_0: ColorF,
) -> () {
    let mut t_0: f32 = 0.;
    let mut t: f32 = 0.;
    let mut chroma: f32 = 0.;
    let mut K: f32 = 0.0f32;
    if in_0.g < in_0.b {
        t = in_0.g;
        in_0.g = in_0.b;
        in_0.b = t;
        K = -1.0f32
    }
    if in_0.r < in_0.g {
        t_0 = in_0.r;
        in_0.r = in_0.g;
        in_0.g = t_0;
        K = -2.0f32 / 6.0f32 - K
    }
    chroma = in_0.r - if in_0.g < in_0.b {
        in_0.g
    } else {
        in_0.b
    };
    *out_h = if K + (in_0.g - in_0.b) / (6.0f32 * chroma + 9.999999682655225e-21f32) < 0i32 as f32 {
        -(K + (in_0.g - in_0.b) / (6.0f32 * chroma + 9.999999682655225e-21f32))
    } else {
        K + (in_0.g - in_0.b) / (6.0f32 * chroma + 9.999999682655225e-21f32)
    };
    *out_s = chroma / (in_0.r + 9.999999682655225e-21f32);
    *out_v = in_0.r;
    *out_a = in_0.a;
}
unsafe fn nk_color_picker_behavior(
    mut state: *mut Flags,
    mut bounds: *const Rect,
    mut matrix: *const Rect,
    mut hue_bar: *const Rect,
    mut alpha_bar: *const Rect,
    mut color: *mut ColorF,
    mut in_0: *const Input,
) -> Int {
    let mut hsva: [f32; 4] = [0.; 4];
    let mut value_changed: Int = 0i32;
    let mut hsv_changed: Int = 0i32;
    /* color matrix */
    nk_colorf_hsva_fv(hsva.as_mut_ptr(), *color);
    if 0 != ButtonBehavior(state, *matrix, in_0, NK_BUTTON_REPEATER) {
        hsva[1usize] = if (0i32 as f32)
            < if 1.0f32 < ((*in_0).mouse.pos.x - (*matrix).x) / ((*matrix).w - 1i32 as f32) {
                1.0f32
            } else {
                ((*in_0).mouse.pos.x - (*matrix).x) / ((*matrix).w - 1i32 as f32)
            } {
            if 1.0f32 < ((*in_0).mouse.pos.x - (*matrix).x) / ((*matrix).w - 1i32 as f32) {
                1.0f32
            } else {
                ((*in_0).mouse.pos.x - (*matrix).x) / ((*matrix).w - 1i32 as f32)
            }
        } else {
            0i32 as f32
        };
        hsva[2usize] = 1.0f32
            - if (0i32 as f32)
                < if 1.0f32 < ((*in_0).mouse.pos.y - (*matrix).y) / ((*matrix).h - 1i32 as f32) {
                    1.0f32
                } else {
                    ((*in_0).mouse.pos.y - (*matrix).y) / ((*matrix).h - 1i32 as f32)
                } {
                if 1.0f32 < ((*in_0).mouse.pos.y - (*matrix).y) / ((*matrix).h - 1i32 as f32) {
                    1.0f32
                } else {
                    ((*in_0).mouse.pos.y - (*matrix).y) / ((*matrix).h - 1i32 as f32)
                }
            } else {
                0i32 as f32
            };
        hsv_changed = 1i32;
        value_changed = hsv_changed
    }
    /* hue bar */
    if 0 != ButtonBehavior(state, *hue_bar, in_0, NK_BUTTON_REPEATER) {
        hsva[0usize] = if (0i32 as f32)
            < if 1.0f32 < ((*in_0).mouse.pos.y - (*hue_bar).y) / ((*hue_bar).h - 1i32 as f32) {
                1.0f32
            } else {
                ((*in_0).mouse.pos.y - (*hue_bar).y) / ((*hue_bar).h - 1i32 as f32)
            } {
            if 1.0f32 < ((*in_0).mouse.pos.y - (*hue_bar).y) / ((*hue_bar).h - 1i32 as f32) {
                1.0f32
            } else {
                ((*in_0).mouse.pos.y - (*hue_bar).y) / ((*hue_bar).h - 1i32 as f32)
            }
        } else {
            0i32 as f32
        };
        hsv_changed = 1i32;
        value_changed = hsv_changed
    }
    /* alpha bar */
    if !alpha_bar.is_null() {
        if 0 != ButtonBehavior(state, *alpha_bar, in_0, NK_BUTTON_REPEATER) {
            hsva[3usize] = 1.0f32
                - if (0i32 as f32)
                    < if 1.0f32
                        < ((*in_0).mouse.pos.y - (*alpha_bar).y) / ((*alpha_bar).h - 1i32 as f32)
                    {
                        1.0f32
                    } else {
                        ((*in_0).mouse.pos.y - (*alpha_bar).y) / ((*alpha_bar).h - 1i32 as f32)
                    } {
                    if 1.0f32
                        < ((*in_0).mouse.pos.y - (*alpha_bar).y) / ((*alpha_bar).h - 1i32 as f32)
                    {
                        1.0f32
                    } else {
                        ((*in_0).mouse.pos.y - (*alpha_bar).y) / ((*alpha_bar).h - 1i32 as f32)
                    }
                } else {
                    0i32 as f32
                };
            value_changed = 1i32
        }
    }
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as Int as Uint {
        *state = (NK_WIDGET_STATE_INACTIVE as Int | NK_WIDGET_STATE_MODIFIED as Int) as Flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as Int as Flags
    }
    if 0 != hsv_changed {
        *color = nk_hsva_colorfv(hsva.as_mut_ptr());
        *state = NK_WIDGET_STATE_ACTIVE as Int as Flags
    }
    if 0 != value_changed {
        (*color).a = hsva[3usize];
        *state = NK_WIDGET_STATE_ACTIVE as Int as Flags
    }
    /* set color picker widget state */
    if 0 != nk_input_is_mouse_hovering_rect(in_0, *bounds) {
        *state = NK_WIDGET_STATE_HOVERED as Int as Flags
    }
    if 0 != *state & NK_WIDGET_STATE_HOVER as Int as Uint
        && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, *bounds)
    {
        *state |= NK_WIDGET_STATE_ENTERED as Int as Uint
    } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, *bounds) {
        *state |= NK_WIDGET_STATE_LEFT as Int as Uint
    }
    return value_changed;
}

pub unsafe fn nk_hsva_colorfv(mut c: *mut f32) -> ColorF {
    return nk_hsva_colorf(
        *c.offset(0isize),
        *c.offset(1isize),
        *c.offset(2isize),
        *c.offset(3isize),
    );
}

pub unsafe fn nk_property_int(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut min: Int,
    mut val: *mut Int,
    mut max: Int,
    mut step: Int,
    mut inc_per_pixel: f32,
) -> () {
    let mut variant: PropertyVariant = PropertyVariant {
        kind: NK_PROPERTY_INT,
        value: Property { i: 0 },
        min_value: Property { i: 0 },
        max_value: Property { i: 0 },
        step: Property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() || val.is_null() {
        return;
    } else {
        variant = nk_property_variant_int(*val, min, max, step);
        Property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_INT);
        *val = variant.value.i;
        return;
    };
}
unsafe fn Property(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut variant: *mut PropertyVariant,
    mut inc_per_pixel: f32,
    filter: PropertyFilter,
) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut in_0: *mut Input = 0 as *mut Input;
    let mut style: *const Style = 0 as *const Style;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut s: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut state: *mut Int = 0 as *mut Int;
    let mut hash: Hash = 0i32 as Hash;
    let mut buffer: *mut Char = 0 as *mut Char;
    let mut len: *mut Int = 0 as *mut Int;
    let mut cursor: *mut Int = 0 as *mut Int;
    let mut select_begin: *mut Int = 0 as *mut Int;
    let mut select_end: *mut Int = 0 as *mut Int;
    let mut old_state: Int = 0;
    let mut dummy_buffer: [Char; 64] = [0; 64];
    let mut dummy_state: Int = NK_PROPERTY_DEFAULT as Int;
    let mut dummy_length: Int = 0i32;
    let mut dummy_cursor: Int = 0i32;
    let mut dummy_select_begin: Int = 0i32;
    let mut dummy_select_end: Int = 0i32;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        layout = (*win).layout;
        style = &mut (*ctx).style as *mut Style;
        s = nk_widget(&mut bounds, ctx);
        if 0 == s as u64 {
            return;
        } else {
            /* calculate hash from name */
            if *name.offset(0isize) as Int == '#' as i32 {
                let fresh20 = (*win).property.seq;
                (*win).property.seq = (*win).property.seq.wrapping_add(1);
                hash = nk_murmur_hash(name as *const Void, nk_strlen(name), fresh20);
                /* special number hash */
                name = name.offset(1isize)
            } else {
                hash = nk_murmur_hash(name as *const Void, nk_strlen(name), 42i32 as Hash)
            }
            /* check if property is currently hot item */
            if 0 != (*win).property.active && hash == (*win).property.name {
                buffer = (*win).property.buffer.as_mut_ptr();
                len = &mut (*win).property.length as *mut Int;
                cursor = &mut (*win).property.cursor as *mut Int;
                state = &mut (*win).property.state as *mut Int;
                select_begin = &mut (*win).property.select_start as *mut Int;
                select_end = &mut (*win).property.select_end as *mut Int
            } else {
                buffer = dummy_buffer.as_mut_ptr();
                len = &mut dummy_length;
                cursor = &mut dummy_cursor;
                state = &mut dummy_state;
                select_begin = &mut dummy_select_begin;
                select_end = &mut dummy_select_end
            }
            /* execute property widget */
            old_state = *state;
            (*ctx).text_edit.clip = (*ctx).clip;
            in_0 = if s as Uint == NK_WIDGET_ROM as Int as Uint && 0 == (*win).property.active
                || 0 != (*layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            nk_do_property(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                name,
                variant,
                inc_per_pixel,
                buffer,
                len,
                state,
                cursor,
                select_begin,
                select_end,
                &(*style).property,
                filter,
                in_0,
                (*style).font,
                &mut (*ctx).text_edit,
                (*ctx).button_behavior,
            );
            if !in_0.is_null()
                && *state != NK_PROPERTY_DEFAULT as Int
                && 0 == (*win).property.active
            {
                /* current property is now hot */
                (*win).property.active = 1i32;
                nk_memcopy(
                    (*win).property.buffer.as_mut_ptr() as *mut Void,
                    buffer as *const Void,
                    *len as Size,
                );
                (*win).property.length = *len;
                (*win).property.cursor = *cursor;
                (*win).property.state = *state;
                (*win).property.name = hash;
                (*win).property.select_start = *select_begin;
                (*win).property.select_end = *select_end;
                if *state == NK_PROPERTY_DRAG as Int {
                    (*ctx).input.mouse.grab = nk_true as Int as Uchar;
                    (*ctx).input.mouse.grabbed = nk_true as Int as Uchar
                }
            }
            /* check if previously active property is now inactive */
            if *state == NK_PROPERTY_DEFAULT as Int && old_state != NK_PROPERTY_DEFAULT as Int {
                if old_state == NK_PROPERTY_DRAG as Int {
                    (*ctx).input.mouse.grab = nk_false as Int as Uchar;
                    (*ctx).input.mouse.grabbed = nk_false as Int as Uchar;
                    (*ctx).input.mouse.ungrab = nk_true as Int as Uchar
                }
                (*win).property.select_start = 0i32;
                (*win).property.select_end = 0i32;
                (*win).property.active = 0i32
            }
            return;
        }
    };
}
unsafe fn nk_do_property(
    mut ws: *mut Flags,
    mut out: *mut CommandBuffer,
    mut property: Rect,
    mut name: *const Char,
    mut variant: *mut PropertyVariant,
    mut inc_per_pixel: f32,
    mut buffer: *mut Char,
    mut len: *mut Int,
    mut state: *mut Int,
    mut cursor: *mut Int,
    mut select_begin: *mut Int,
    mut select_end: *mut Int,
    mut style: *const StyleProperty,
    mut filter: PropertyFilter,
    mut in_0: *mut Input,
    mut font: *const UserFont,
    mut text_edit: *mut TextEdit,
    mut behavior: ButtonBehavior,
) -> () {
    let mut current_block: u64;
    let filters: [PluginFilter; 2] = [Some(nk_filter_decimal), Some(nk_filter_float)];
    let mut active: Int = 0;
    let mut old: Int = 0;
    let mut num_len: Int = 0;
    let mut name_len: Int = 0;
    let mut string: [Char; 64] = [0; 64];
    let mut size: f32 = 0.;
    let mut dst: *mut Char = 0 as *mut Char;
    let mut length: *mut Int = 0 as *mut Int;
    let mut left: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut right: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut label: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut edit: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut empty: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    /* left decrement button */
    left.h = (*font).height / 2i32 as f32;
    left.w = left.h;
    left.x = property.x + (*style).border + (*style).padding.x;
    left.y = property.y + (*style).border + property.h / 2.0f32 - left.h / 2i32 as f32;
    /* text label */
    name_len = nk_strlen(name);
    size = (*font).width.expect("non-null function pointer")(
        (*font).userdata,
        (*font).height,
        name,
        name_len,
    );
    label.x = left.x + left.w + (*style).padding.x;
    label.w = size + 2i32 as f32 * (*style).padding.x;
    label.y = property.y + (*style).border + (*style).padding.y;
    label.h = property.h - (2i32 as f32 * (*style).border + 2i32 as f32 * (*style).padding.y);
    /* right increment button */
    right.y = left.y;
    right.w = left.w;
    right.h = left.h;
    right.x = property.x + property.w - (right.w + (*style).padding.x);
    /* edit */
    if *state == NK_PROPERTY_EDIT as Int {
        size = (*font).width.expect("non-null function pointer")(
            (*font).userdata,
            (*font).height,
            buffer,
            *len,
        );
        size += (*style).edit.cursor_size;
        length = len;
        dst = buffer
    } else {
        match (*variant).kind as Uint {
            0 => {
                nk_itoa(string.as_mut_ptr(), (*variant).value.i as Long);
                num_len = nk_strlen(string.as_mut_ptr())
            }
            1 => {
                nk_dtoa(string.as_mut_ptr(), (*variant).value.f as f64);
                num_len = nk_string_float_limit(string.as_mut_ptr(), 2i32)
            }
            2 => {
                nk_dtoa(string.as_mut_ptr(), (*variant).value.d);
                num_len = nk_string_float_limit(string.as_mut_ptr(), 2i32)
            }
            _ => {}
        }
        size = (*font).width.expect("non-null function pointer")(
            (*font).userdata,
            (*font).height,
            string.as_mut_ptr(),
            num_len,
        );
        dst = string.as_mut_ptr();
        length = &mut num_len
    }
    edit.w = size + 2i32 as f32 * (*style).padding.x;
    edit.w = if edit.w < right.x - (label.x + label.w) {
        edit.w
    } else {
        right.x - (label.x + label.w)
    };
    edit.x = right.x - (edit.w + (*style).padding.x);
    edit.y = property.y + (*style).border;
    edit.h = property.h - 2i32 as f32 * (*style).border;
    /* empty left space activator */
    empty.w = edit.x - (label.x + label.w);
    empty.x = label.x + label.w;
    empty.y = property.y;
    empty.h = property.h;
    /* update property */
    old = (*state == NK_PROPERTY_EDIT as Int) as Int;
    nk_property_behavior(
        ws,
        in_0,
        property,
        label,
        edit,
        empty,
        state,
        variant,
        inc_per_pixel,
    );
    /* draw property */
    if (*style).draw_begin.is_some() {
        (*style).draw_begin.expect("non-null function pointer")(out, (*style).userdata);
    }
    nk_draw_property(
        out,
        style,
        &mut property,
        &mut label,
        *ws,
        name,
        name_len,
        font,
    );
    if (*style).draw_end.is_some() {
        (*style).draw_end.expect("non-null function pointer")(out, (*style).userdata);
    }
    /* execute right button  */
    if 0 != nk_do_button_symbol(
        ws,
        out,
        left,
        (*style).sym_left,
        behavior,
        &(*style).dec_button,
        in_0,
        font,
    ) {
        match (*variant).kind as Uint {
            0 => {
                current_block = 17608344827992466330;
                match current_block {
                    9289946841932024176 => {
                        (*variant).value.f = if if (*variant).value.f - (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f - (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    17608344827992466330 => {
                        (*variant).value.i = if if (*variant).value.i - (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i - (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    _ => {
                        (*variant).value.d = if if (*variant).value.d - (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d - (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                }
            }
            1 => {
                current_block = 9289946841932024176;
                match current_block {
                    9289946841932024176 => {
                        (*variant).value.f = if if (*variant).value.f - (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f - (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    17608344827992466330 => {
                        (*variant).value.i = if if (*variant).value.i - (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i - (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    _ => {
                        (*variant).value.d = if if (*variant).value.d - (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d - (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                }
            }
            2 => {
                current_block = 16190589082301463196;
                match current_block {
                    9289946841932024176 => {
                        (*variant).value.f = if if (*variant).value.f - (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f - (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f - (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    17608344827992466330 => {
                        (*variant).value.i = if if (*variant).value.i - (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i - (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i - (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    _ => {
                        (*variant).value.d = if if (*variant).value.d - (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d - (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d - (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                }
            }
            _ => {}
        }
    }
    /* execute left button  */
    if 0 != nk_do_button_symbol(
        ws,
        out,
        right,
        (*style).sym_right,
        behavior,
        &(*style).inc_button,
        in_0,
        font,
    ) {
        match (*variant).kind as Uint {
            0 => {
                current_block = 2124387292137129013;
                match current_block {
                    2124387292137129013 => {
                        (*variant).value.i = if if (*variant).value.i + (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i + (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    5316822834505342835 => {
                        (*variant).value.d = if if (*variant).value.d + (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d + (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    _ => {
                        (*variant).value.f = if if (*variant).value.f + (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f + (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                }
            }
            1 => {
                current_block = 16006929488343096132;
                match current_block {
                    2124387292137129013 => {
                        (*variant).value.i = if if (*variant).value.i + (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i + (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    5316822834505342835 => {
                        (*variant).value.d = if if (*variant).value.d + (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d + (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    _ => {
                        (*variant).value.f = if if (*variant).value.f + (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f + (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                }
            }
            2 => {
                current_block = 5316822834505342835;
                match current_block {
                    2124387292137129013 => {
                        (*variant).value.i = if if (*variant).value.i + (*variant).step.i
                            < (*variant).max_value.i
                        {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i + (*variant).step.i < (*variant).max_value.i {
                            (*variant).value.i + (*variant).step.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                    5316822834505342835 => {
                        (*variant).value.d = if if (*variant).value.d + (*variant).step.d
                            < (*variant).max_value.d
                        {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d + (*variant).step.d < (*variant).max_value.d {
                            (*variant).value.d + (*variant).step.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    _ => {
                        (*variant).value.f = if if (*variant).value.f + (*variant).step.f
                            < (*variant).max_value.f
                        {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f + (*variant).step.f < (*variant).max_value.f {
                            (*variant).value.f + (*variant).step.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                }
            }
            _ => {}
        }
    }
    if old != NK_PROPERTY_EDIT as Int && *state == NK_PROPERTY_EDIT as Int {
        nk_memcopy(buffer as *mut Void, dst as *const Void, *length as Size);
        /* property has been activated so setup buffer */
        *cursor = nk_utf_len(buffer, *length);
        *len = *length;
        length = len;
        dst = buffer;
        active = 0i32
    } else {
        active = (*state == NK_PROPERTY_EDIT as Int) as Int
    }
    /* execute and run text edit field */
    nk_textedit_clear_state(
        text_edit,
        NK_TEXT_EDIT_SINGLE_LINE,
        filters[filter as usize],
    );
    (*text_edit).active = active as Uchar;
    (*text_edit).string.len = *length;
    (*text_edit).cursor = if if *cursor < *length { *cursor } else { *length } < 0i32 {
        0i32
    } else if *cursor < *length {
        *cursor
    } else {
        *length
    };
    (*text_edit).select_start = if if *select_begin < *length {
        *select_begin
    } else {
        *length
    } < 0i32
    {
        0i32
    } else if *select_begin < *length {
        *select_begin
    } else {
        *length
    };
    (*text_edit).select_end = if if *select_end < *length {
        *select_end
    } else {
        *length
    } < 0i32
    {
        0i32
    } else if *select_end < *length {
        *select_end
    } else {
        *length
    };
    (*text_edit).string.buffer.allocated = *length as Size;
    (*text_edit).string.buffer.memory.size = 64i32 as Size;
    (*text_edit).string.buffer.memory.ptr = dst as *mut Void;
    (*text_edit).string.buffer.size = 64i32 as Size;
    (*text_edit).mode = NK_TEXT_EDIT_MODE_INSERT as Int as Uchar;
    nk_do_edit(
        ws,
        out,
        edit,
        (NK_EDIT_FIELD as Int | NK_EDIT_AUTO_SELECT as Int) as Flags,
        filters[filter as usize],
        text_edit,
        &(*style).edit,
        if *state == NK_PROPERTY_EDIT as Int {
            in_0
        } else {
            0 as *mut Input
        },
        font,
    );
    *length = (*text_edit).string.len;
    *cursor = (*text_edit).cursor;
    *select_begin = (*text_edit).select_start;
    *select_end = (*text_edit).select_end;
    if 0 != (*text_edit).active as Int && 0 != nk_input_is_key_pressed(in_0, NK_KEY_ENTER) {
        (*text_edit).active = nk_false as Int as Uchar
    }
    if 0 != active && 0 == (*text_edit).active {
        /* property is now not active so convert edit text to value*/
        *state = NK_PROPERTY_DEFAULT as Int;
        *buffer.offset(*len as isize) = '\u{0}' as i32 as Char;
        match (*variant).kind as Uint {
            0 => {
                current_block = 14176438224543909724;
                match current_block {
                    9505175611044265049 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.d = nk_strtod(buffer, 0 as *mut *const Char);
                        (*variant).value.d = if if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    11008709377727432485 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.f = nk_strtof(buffer, 0 as *mut *const Char);
                        (*variant).value.f = if if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    _ => {
                        (*variant).value.i = nk_strtoi(buffer, 0 as *mut *const Char);
                        (*variant).value.i = if if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                }
            }
            1 => {
                current_block = 11008709377727432485;
                match current_block {
                    9505175611044265049 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.d = nk_strtod(buffer, 0 as *mut *const Char);
                        (*variant).value.d = if if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    11008709377727432485 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.f = nk_strtof(buffer, 0 as *mut *const Char);
                        (*variant).value.f = if if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    _ => {
                        (*variant).value.i = nk_strtoi(buffer, 0 as *mut *const Char);
                        (*variant).value.i = if if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                }
            }
            2 => {
                current_block = 9505175611044265049;
                match current_block {
                    9505175611044265049 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.d = nk_strtod(buffer, 0 as *mut *const Char);
                        (*variant).value.d = if if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        } < (*variant).min_value.d
                        {
                            (*variant).min_value.d
                        } else if (*variant).value.d < (*variant).max_value.d {
                            (*variant).value.d
                        } else {
                            (*variant).max_value.d
                        }
                    }
                    11008709377727432485 => {
                        nk_string_float_limit(buffer, 2i32);
                        (*variant).value.f = nk_strtof(buffer, 0 as *mut *const Char);
                        (*variant).value.f = if if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        } < (*variant).min_value.f
                        {
                            (*variant).min_value.f
                        } else if (*variant).value.f < (*variant).max_value.f {
                            (*variant).value.f
                        } else {
                            (*variant).max_value.f
                        }
                    }
                    _ => {
                        (*variant).value.i = nk_strtoi(buffer, 0 as *mut *const Char);
                        (*variant).value.i = if if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        } < (*variant).min_value.i
                        {
                            (*variant).min_value.i
                        } else if (*variant).value.i < (*variant).max_value.i {
                            (*variant).value.i
                        } else {
                            (*variant).max_value.i
                        }
                    }
                }
            }
            _ => {}
        }
    };
}

pub unsafe fn nk_strtod(mut str: *const Char, mut endptr: *mut *const Char) -> f64 {
    let mut m: f64 = 0.;
    let mut neg: f64 = 1.0f64;
    let mut p: *const Char = str;
    let mut value: f64 = 0i32 as f64;
    let mut number: f64 = 0i32 as f64;
    if str.is_null() {
        return 0i32 as f64;
    } else {
        /* skip whitespace */
        while *p as Int == ' ' as i32 {
            p = p.offset(1isize)
        }
        if *p as Int == '-' as i32 {
            neg = -1.0f64;
            p = p.offset(1isize)
        }
        while 0 != *p as Int && *p as Int != '.' as i32 && *p as Int != 'e' as i32 {
            value = value * 10.0f64 + (*p as Int - '0' as i32) as f64;
            p = p.offset(1isize)
        }
        if *p as Int == '.' as i32 {
            p = p.offset(1isize);
            m = 0.1f64;
            while 0 != *p as Int && *p as Int != 'e' as i32 {
                value = value + (*p as Int - '0' as i32) as f64 * m;
                m *= 0.1f64;
                p = p.offset(1isize)
            }
        }
        if *p as Int == 'e' as i32 {
            let mut i: Int = 0;
            let mut pow: Int = 0;
            let mut div: Int = 0;
            p = p.offset(1isize);
            if *p as Int == '-' as i32 {
                div = nk_true as Int;
                p = p.offset(1isize)
            } else if *p as Int == '+' as i32 {
                div = nk_false as Int;
                p = p.offset(1isize)
            } else {
                div = nk_false as Int
            }
            pow = 0i32;
            while 0 != *p {
                pow = pow * 10i32 + (*p as Int - '0' as i32);
                p = p.offset(1isize)
            }
            m = 1.0f64;
            i = 0i32;
            while i < pow {
                m *= 10.0f64;
                i += 1
            }
            if 0 != div {
                value /= m
            } else {
                value *= m
            }
        }
        number = value * neg;
        if !endptr.is_null() {
            *endptr = p
        }
        return number;
    };
}
unsafe fn nk_string_float_limit(mut string: *mut Char, mut prec: Int) -> Int {
    let mut dot: Int = 0i32;
    let mut c: *mut Char = string;
    while 0 != *c {
        if *c as Int == '.' as i32 {
            dot = 1i32;
            c = c.offset(1isize)
        } else if dot == prec + 1i32 {
            *c = 0i32 as Char;
            break;
        } else {
            if dot > 0i32 {
                dot += 1
            }
            c = c.offset(1isize)
        }
    }
    return string.ptr_offset_to(c).expect("bad offset_to") as Long as Int;
}

pub unsafe fn nk_strtof(mut str: *const Char, mut endptr: *mut *const Char) -> f32 {
    let mut float_value: f32 = 0.;
    let mut double_value: f64 = 0.;
    double_value = nk_strtod(str, endptr);
    float_value = double_value as f32;
    return float_value;
}

pub unsafe fn nk_strtoi(mut str: *const Char, mut endptr: *mut *const Char) -> Int {
    let mut neg: Int = 1i32;
    let mut p: *const Char = str;
    let mut value: Int = 0i32;
    if str.is_null() {
        return 0i32;
    } else {
        /* skip whitespace */
        while *p as Int == ' ' as i32 {
            p = p.offset(1isize)
        }
        if *p as Int == '-' as i32 {
            neg = -1i32;
            p = p.offset(1isize)
        }
        while 0 != *p as Int && *p as Int >= '0' as i32 && *p as Int <= '9' as i32 {
            value = value * 10i32 + (*p as Int - '0' as i32);
            p = p.offset(1isize)
        }
        if !endptr.is_null() {
            *endptr = p
        }
        return neg * value;
    };
}

pub unsafe fn nk_filter_float(mut box_0: *const TextEdit, mut unicode: Rune) -> Int {
    if (unicode < '0' as i32 as Uint || unicode > '9' as i32 as Uint)
        && unicode != '.' as i32 as Uint
        && unicode != '-' as i32 as Uint
    {
        return nk_false as Int;
    } else {
        return nk_true as Int;
    };
}

pub unsafe fn nk_filter_decimal(mut box_0: *const TextEdit, mut unicode: Rune) -> Int {
    if (unicode < '0' as i32 as Uint || unicode > '9' as i32 as Uint)
        && unicode != '-' as i32 as Uint
    {
        return nk_false as Int;
    } else {
        return nk_true as Int;
    };
}
unsafe fn nk_do_edit(
    mut state: *mut Flags,
    mut out: *mut CommandBuffer,
    mut bounds: Rect,
    mut flags: Flags,
    mut filter: PluginFilter,
    mut edit: *mut TextEdit,
    mut style: *const StyleEdit,
    mut in_0: *mut Input,
    mut font: *const UserFont,
) -> Flags {
    let mut l: Int = 0;
    let mut remaining: *const Char = 0 as *const Char;
    let mut cursor: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut out_offset_1: Point = Point { x: 0., y: 0. };
    let mut glyph_offset_1: Int = 0;
    let mut glyph_offset: Int = 0;
    let mut row_size_0: Point = Point { x: 0., y: 0. };
    let mut remaining_0: *const Char = 0 as *const Char;
    let mut remaining_1: *const Char = 0 as *const Char;
    let mut begin_0: *const Char = 0 as *const Char;
    let mut out_offset: Point = Point { x: 0., y: 0. };
    let mut row_size: Point = Point { x: 0., y: 0. };
    let mut begin_2: *const Char = 0 as *const Char;
    let mut row_size_1: Point = Point { x: 0., y: 0. };
    let mut begin_1: *const Char = 0 as *const Char;
    let mut glyph_offset_0: Int = 0;
    let mut out_offset_0: Point = Point { x: 0., y: 0. };
    let mut area: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut ret: Flags = 0i32 as Flags;
    let mut row_height: f32 = 0.;
    let mut prev_state: Char = 0i32 as Char;
    let mut is_hovered: Char = 0i32 as Char;
    let mut select_all: Char = 0i32 as Char;
    let mut cursor_follow: Char = 0i32 as Char;
    let mut old_clip: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut clip: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    if state.is_null() || out.is_null() || style.is_null() {
        return ret;
    } else {
        /* visible text area calculation */
        area.x = bounds.x + (*style).padding.x + (*style).border;
        area.y = bounds.y + (*style).padding.y + (*style).border;
        area.w = bounds.w - (2.0f32 * (*style).padding.x + 2i32 as f32 * (*style).border);
        area.h = bounds.h - (2.0f32 * (*style).padding.y + 2i32 as f32 * (*style).border);
        if 0 != flags & NK_EDIT_MULTILINE as Int as Uint {
            area.w = if (0i32 as f32) < area.w - (*style).scrollbar_size.x {
                area.w - (*style).scrollbar_size.x
            } else {
                0i32 as f32
            }
        }
        row_height = if 0 != flags & NK_EDIT_MULTILINE as Int as Uint {
            (*font).height + (*style).row_padding
        } else {
            area.h
        };
        /* calculate clipping rectangle */
        old_clip = (*out).clip;
        nk_unify(
            &mut clip,
            &mut old_clip,
            area.x,
            area.y,
            area.x + area.w,
            area.y + area.h,
        );
        /* update edit state */
        prev_state = (*edit).active as Char;
        is_hovered = nk_input_is_mouse_hovering_rect(in_0, bounds) as Char;
        if !in_0.is_null()
            && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].clicked
            && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down
        {
            (*edit).active = (bounds.x <= (*in_0).mouse.pos.x
                && (*in_0).mouse.pos.x < bounds.x + bounds.w
                && (bounds.y <= (*in_0).mouse.pos.y && (*in_0).mouse.pos.y < bounds.y + bounds.h))
                as Int as Uchar
        }
        /* (de)activate text editor */
        if 0 == prev_state && 0 != (*edit).active as Int {
            let type_0: TextEditType = (if 0 != flags & NK_EDIT_MULTILINE as Int as Uint {
                NK_TEXT_EDIT_MULTI_LINE as Int
            } else {
                NK_TEXT_EDIT_SINGLE_LINE as Int
            }) as TextEditType;
            nk_textedit_clear_state(edit, type_0, filter);
            if 0 != flags & NK_EDIT_AUTO_SELECT as Int as Uint {
                select_all = nk_true as Int as Char
            }
            if 0 != flags & NK_EDIT_GOTO_END_ON_ACTIVATE as Int as Uint {
                (*edit).cursor = (*edit).string.len;
                in_0 = 0 as *mut Input
            }
        } else if 0 == (*edit).active {
            (*edit).mode = NK_TEXT_EDIT_MODE_VIEW as Int as Uchar
        }
        if 0 != flags & NK_EDIT_READ_ONLY as Int as Uint {
            (*edit).mode = NK_TEXT_EDIT_MODE_VIEW as Int as Uchar
        } else if 0 != flags & NK_EDIT_ALWAYS_INSERT_MODE as Int as Uint {
            (*edit).mode = NK_TEXT_EDIT_MODE_INSERT as Int as Uchar
        }
        ret = (if 0 != (*edit).active as Int {
            NK_EDIT_ACTIVE as Int
        } else {
            NK_EDIT_INACTIVE as Int
        }) as Flags;
        if prev_state as Int != (*edit).active as Int {
            ret |= (if 0 != (*edit).active as Int {
                NK_EDIT_ACTIVATED as Int
            } else {
                NK_EDIT_DEACTIVATED as Int
            }) as Uint
        }
        /* handle user input */
        if 0 != (*edit).active as Int && !in_0.is_null() {
            let mut shift_mod: Int = (*in_0).keyboard.keys[NK_KEY_SHIFT as Int as usize].down;
            let mouse_x: f32 = (*in_0).mouse.pos.x - area.x + (*edit).scrollbar.x;
            let mouse_y: f32 = (*in_0).mouse.pos.y - area.y + (*edit).scrollbar.y;
            /* mouse click handler */
            is_hovered = nk_input_is_mouse_hovering_rect(in_0, area) as Char;
            if 0 != select_all {
                nk_textedit_select_all(edit);
            } else if 0 != is_hovered as Int
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].clicked
            {
                nk_textedit_click(edit, mouse_x, mouse_y, font, row_height);
            } else if 0 != is_hovered as Int
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down
                && ((*in_0).mouse.delta.x != 0.0f32 || (*in_0).mouse.delta.y != 0.0f32)
            {
                nk_textedit_drag(edit, mouse_x, mouse_y, font, row_height);
                cursor_follow = nk_true as Int as Char
            } else if 0 != is_hovered as Int
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_RIGHT as Int as usize].clicked
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_RIGHT as Int as usize].down
            {
                nk_textedit_key(
                    edit,
                    NK_KEY_TEXT_WORD_LEFT,
                    nk_false as Int,
                    font,
                    row_height,
                );
                nk_textedit_key(
                    edit,
                    NK_KEY_TEXT_WORD_RIGHT,
                    nk_true as Int,
                    font,
                    row_height,
                );
                cursor_follow = nk_true as Int as Char
            }
            /* keyboard input */
            let mut i: Int = 0;
            let mut old_mode: Int = (*edit).mode as Int;
            i = 0i32;
            while i < NK_KEY_MAX as Int {
                if !(i == NK_KEY_ENTER as Int || i == NK_KEY_TAB as Int) {
                    /* special case */
                    if 0 != nk_input_is_key_pressed(in_0, i as Keys) {
                        nk_textedit_key(edit, i as Keys, shift_mod, font, row_height);
                        cursor_follow = nk_true as Int as Char
                    }
                }
                i += 1
            }
            if old_mode != (*edit).mode as Int {
                (*in_0).keyboard.text_len = 0i32
            }
            /* text input */
            (*edit).filter = filter;
            if 0 != (*in_0).keyboard.text_len {
                nk_textedit_text(
                    edit,
                    (*in_0).keyboard.text.as_mut_ptr(),
                    (*in_0).keyboard.text_len,
                );
                cursor_follow = nk_true as Int as Char;
                (*in_0).keyboard.text_len = 0i32
            }
            /* enter key handler */
            if 0 != nk_input_is_key_pressed(in_0, NK_KEY_ENTER) {
                cursor_follow = nk_true as Int as Char;
                if 0 != flags & NK_EDIT_CTRL_ENTER_NEWLINE as Int as Uint && 0 != shift_mod {
                    nk_textedit_text(edit, b"\n\x00" as *const u8 as *const Char, 1i32);
                } else if 0 != flags & NK_EDIT_SIG_ENTER as Int as Uint {
                    ret |= NK_EDIT_COMMITED as Int as Uint
                } else {
                    nk_textedit_text(edit, b"\n\x00" as *const u8 as *const Char, 1i32);
                }
            }
            /* cut & copy handler */
            let mut copy: Int = nk_input_is_key_pressed(in_0, NK_KEY_COPY);
            let mut cut: Int = nk_input_is_key_pressed(in_0, NK_KEY_CUT);
            if (0 != copy || 0 != cut) && 0 != flags & NK_EDIT_CLIPBOARD as Int as Uint {
                let mut glyph_len: Int = 0;
                let mut unicode: Rune = 0;
                let mut text: *const Char = 0 as *const Char;
                let mut b: Int = (*edit).select_start;
                let mut e: Int = (*edit).select_end;
                let mut begin: Int = if b < e { b } else { e };
                let mut end: Int = if b < e { e } else { b };
                text = nk_str_at_const(&mut (*edit).string, begin, &mut unicode, &mut glyph_len);
                if (*edit).clip.copy.is_some() {
                    (*edit).clip.copy.expect("non-null function pointer")(
                        (*edit).clip.userdata,
                        text,
                        end - begin,
                    );
                }
                if 0 != cut && 0 == flags & NK_EDIT_READ_ONLY as Int as Uint {
                    nk_textedit_cut(edit);
                    cursor_follow = nk_true as Int as Char
                }
            }
            /* paste handler */
            let mut paste: Int = nk_input_is_key_pressed(in_0, NK_KEY_PASTE);
            if 0 != paste
                && 0 != flags & NK_EDIT_CLIPBOARD as Int as Uint
                && (*edit).clip.paste.is_some()
            {
                (*edit).clip.paste.expect("non-null function pointer")((*edit).clip.userdata, edit);
                cursor_follow = nk_true as Int as Char
            }
            /* tab handler */
            let mut tab: Int = nk_input_is_key_pressed(in_0, NK_KEY_TAB);
            if 0 != tab && 0 != flags & NK_EDIT_ALLOW_TAB as Int as Uint {
                nk_textedit_text(edit, b"    \x00" as *const u8 as *const Char, 4i32);
                cursor_follow = nk_true as Int as Char
            }
        }
        /* set widget state */
        if 0 != (*edit).active {
            *state = NK_WIDGET_STATE_ACTIVE as Int as Flags
        } else if 0 != *state & NK_WIDGET_STATE_MODIFIED as Int as Uint {
            *state = (NK_WIDGET_STATE_INACTIVE as Int | NK_WIDGET_STATE_MODIFIED as Int) as Flags
        } else {
            *state = NK_WIDGET_STATE_INACTIVE as Int as Flags
        }
        if 0 != is_hovered {
            *state |= NK_WIDGET_STATE_HOVERED as Int as Uint
        }
        /* DRAW EDIT */
        let mut text_0: *const Char = nk_str_get_const(&mut (*edit).string);
        let mut len: Int = nk_str_len_char(&mut (*edit).string);
        /* select background colors/images  */
        let mut background: *const StyleItem = 0 as *const StyleItem;
        if 0 != *state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
            background = &(*style).active as *const StyleItem
        } else if 0 != *state & NK_WIDGET_STATE_HOVER as Int as Uint {
            background = &(*style).hover as *const StyleItem
        } else {
            background = &(*style).normal as *const StyleItem
        }
        /* draw background frame */
        if (*background).type_0 as Uint == NK_STYLE_ITEM_COLOR as Int as Uint {
            nk_stroke_rect(
                out,
                bounds,
                (*style).rounding,
                (*style).border,
                (*style).border_color,
            );
            nk_fill_rect(out, bounds, (*style).rounding, (*background).data.color);
        } else {
            nk_draw_image(out, bounds, &(*background).data.image, nk_white);
        }
        area.w = if (0i32 as f32) < area.w - (*style).cursor_size {
            area.w - (*style).cursor_size
        } else {
            0i32 as f32
        };
        if 0 != (*edit).active {
            let mut total_lines: Int = 1i32;
            let mut text_size: Point = Point::new(0i32 as f32, 0i32 as f32);
            /* text pointer positions */
            let mut cursor_ptr: *const Char = 0 as *const Char;
            let mut select_begin_ptr: *const Char = 0 as *const Char;
            let mut select_end_ptr: *const Char = 0 as *const Char;
            /* 2D pixel positions */
            let mut cursor_pos: Point = Point::new(0i32 as f32, 0i32 as f32);
            let mut selection_offset_start: Point = Point::new(0i32 as f32, 0i32 as f32);
            let mut selection_offset_end: Point = Point::new(0i32 as f32, 0i32 as f32);
            let mut selection_begin: Int = if (*edit).select_start < (*edit).select_end {
                (*edit).select_start
            } else {
                (*edit).select_end
            };
            let mut selection_end: Int = if (*edit).select_start < (*edit).select_end {
                (*edit).select_end
            } else {
                (*edit).select_start
            };
            /* calculate total line count + total space + cursor/selection position */
            let mut line_width: f32 = 0.0f32;
            if !text_0.is_null() && 0 != len {
                /* utf8 encoding */
                let mut glyph_width: f32 = 0.;
                let mut glyph_len_0: Int = 0i32;
                let mut unicode_0: Rune = 0i32 as Rune;
                let mut text_len: Int = 0i32;
                let mut glyphs: Int = 0i32;
                let mut row_begin: Int = 0i32;
                glyph_len_0 = nk_utf_decode(text_0, &mut unicode_0, len);
                glyph_width = (*font).width.expect("non-null function pointer")(
                    (*font).userdata,
                    (*font).height,
                    text_0,
                    glyph_len_0,
                );
                line_width = 0i32 as f32;
                /* iterate all lines */
                while text_len < len && 0 != glyph_len_0 {
                    /* set cursor 2D position and line */
                    if cursor_ptr.is_null() && glyphs == (*edit).cursor {
                        glyph_offset = 0;
                        out_offset = Point { x: 0., y: 0. };
                        row_size = Point { x: 0., y: 0. };
                        remaining = 0 as *const Char;
                        /* calculate 2d position */
                        cursor_pos.y = (total_lines - 1i32) as f32 * row_height;
                        row_size = nk_text_calculate_text_bounds(
                            font,
                            text_0.offset(row_begin as isize),
                            text_len - row_begin,
                            row_height,
                            &mut remaining,
                            &mut out_offset,
                            &mut glyph_offset,
                            NK_STOP_ON_NEW_LINE as Int,
                        );
                        cursor_pos.x = row_size.x;
                        cursor_ptr = text_0.offset(text_len as isize)
                    }
                    /* set start selection 2D position and line */
                    if select_begin_ptr.is_null()
                        && (*edit).select_start != (*edit).select_end
                        && glyphs == selection_begin
                    {
                        glyph_offset_0 = 0;
                        out_offset_0 = Point { x: 0., y: 0. };
                        row_size_0 = Point { x: 0., y: 0. };
                        remaining_0 = 0 as *const Char;
                        /* calculate 2d position */
                        selection_offset_start.y = (if total_lines - 1i32 < 0i32 {
                            0i32
                        } else {
                            total_lines - 1i32
                        }) as f32 * row_height;
                        row_size_0 = nk_text_calculate_text_bounds(
                            font,
                            text_0.offset(row_begin as isize),
                            text_len - row_begin,
                            row_height,
                            &mut remaining_0,
                            &mut out_offset_0,
                            &mut glyph_offset_0,
                            NK_STOP_ON_NEW_LINE as Int,
                        );
                        selection_offset_start.x = row_size_0.x;
                        select_begin_ptr = text_0.offset(text_len as isize)
                    }
                    /* set end selection 2D position and line */
                    if select_end_ptr.is_null()
                        && (*edit).select_start != (*edit).select_end
                        && glyphs == selection_end
                    {
                        glyph_offset_1 = 0;
                        out_offset_1 = Point { x: 0., y: 0. };
                        row_size_1 = Point { x: 0., y: 0. };
                        remaining_1 = 0 as *const Char;
                        /* calculate 2d position */
                        selection_offset_end.y = (total_lines - 1i32) as f32 * row_height;
                        row_size_1 = nk_text_calculate_text_bounds(
                            font,
                            text_0.offset(row_begin as isize),
                            text_len - row_begin,
                            row_height,
                            &mut remaining_1,
                            &mut out_offset_1,
                            &mut glyph_offset_1,
                            NK_STOP_ON_NEW_LINE as Int,
                        );
                        selection_offset_end.x = row_size_1.x;
                        select_end_ptr = text_0.offset(text_len as isize)
                    }
                    if unicode_0 == '\n' as i32 as Uint {
                        text_size.x = if text_size.x < line_width {
                            line_width
                        } else {
                            text_size.x
                        };
                        total_lines += 1;
                        line_width = 0i32 as f32;
                        text_len += 1;
                        glyphs += 1;
                        row_begin = text_len;
                        glyph_len_0 = nk_utf_decode(
                            text_0.offset(text_len as isize),
                            &mut unicode_0,
                            len - text_len,
                        );
                        glyph_width = (*font).width.expect("non-null function pointer")(
                            (*font).userdata,
                            (*font).height,
                            text_0.offset(text_len as isize),
                            glyph_len_0,
                        )
                    } else {
                        glyphs += 1;
                        text_len += glyph_len_0;
                        line_width += glyph_width;
                        glyph_len_0 = nk_utf_decode(
                            text_0.offset(text_len as isize),
                            &mut unicode_0,
                            len - text_len,
                        );
                        glyph_width = (*font).width.expect("non-null function pointer")(
                            (*font).userdata,
                            (*font).height,
                            text_0.offset(text_len as isize),
                            glyph_len_0,
                        )
                    }
                }
                text_size.y = total_lines as f32 * row_height;
                /* handle case when cursor is at end of text buffer */
                if cursor_ptr.is_null() && (*edit).cursor == (*edit).string.len {
                    cursor_pos.x = line_width;
                    cursor_pos.y = text_size.y - row_height
                }
            }
            /* scrollbar */
            if 0 != cursor_follow {
                /* update scrollbar to follow cursor */
                if 0 == flags & NK_EDIT_NO_HORIZONTAL_SCROLL as Int as Uint {
                    /* horizontal scroll */
                    let scroll_increment: f32 = area.w * 0.25f32;
                    if cursor_pos.x < (*edit).scrollbar.x {
                        (*edit).scrollbar.x = (if 0.0f32 < cursor_pos.x - scroll_increment {
                            cursor_pos.x - scroll_increment
                        } else {
                            0.0f32
                        }) as Int as f32
                    }
                    if cursor_pos.x >= (*edit).scrollbar.x + area.w {
                        (*edit).scrollbar.x = (if 0.0f32 < (*edit).scrollbar.x + scroll_increment {
                            (*edit).scrollbar.x + scroll_increment
                        } else {
                            0.0f32
                        }) as Int as f32
                    }
                } else {
                    (*edit).scrollbar.x = 0i32 as f32
                }
                if 0 != flags & NK_EDIT_MULTILINE as Int as Uint {
                    /* vertical scroll */
                    if cursor_pos.y < (*edit).scrollbar.y {
                        (*edit).scrollbar.y = if 0.0f32 < cursor_pos.y - row_height {
                            cursor_pos.y - row_height
                        } else {
                            0.0f32
                        }
                    }
                    if cursor_pos.y >= (*edit).scrollbar.y + area.h {
                        (*edit).scrollbar.y = (*edit).scrollbar.y + row_height
                    }
                } else {
                    (*edit).scrollbar.y = 0i32 as f32
                }
            }
            /* scrollbar widget */
            if 0 != flags & NK_EDIT_MULTILINE as Int as Uint {
                let mut ws: Flags = 0;
                let mut scroll: Rect = Rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                let mut scroll_target: f32 = 0.;
                let mut scroll_offset: f32 = 0.;
                let mut scroll_step: f32 = 0.;
                let mut scroll_inc: f32 = 0.;
                scroll = area;
                scroll.x = bounds.x + bounds.w - (*style).border - (*style).scrollbar_size.x;
                scroll.w = (*style).scrollbar_size.x;
                scroll_offset = (*edit).scrollbar.y;
                scroll_step = scroll.h * 0.10000000149011612f32;
                scroll_inc = scroll.h * 0.009999999776482582f32;
                scroll_target = text_size.y;
                (*edit).scrollbar.y = nk_do_scrollbarv(
                    &mut ws,
                    out,
                    scroll,
                    0i32,
                    scroll_offset,
                    scroll_target,
                    scroll_step,
                    scroll_inc,
                    &(*style).scrollbar,
                    in_0,
                    font,
                )
            }
            /* draw text */
            let mut background_color: Color = Color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut text_color: Color = Color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut sel_background_color: Color = Color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut sel_text_color: Color = Color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut cursor_color: Color = Color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut cursor_text_color: Color = Color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut background_0: *const StyleItem = 0 as *const StyleItem;
            nk_push_scissor(out, clip);
            /* select correct colors to draw */
            if 0 != *state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
                background_0 = &(*style).active as *const StyleItem;
                text_color = (*style).text_active;
                sel_text_color = (*style).selected_text_hover;
                sel_background_color = (*style).selected_hover;
                cursor_color = (*style).cursor_hover;
                cursor_text_color = (*style).cursor_text_hover
            } else if 0 != *state & NK_WIDGET_STATE_HOVER as Int as Uint {
                background_0 = &(*style).hover as *const StyleItem;
                text_color = (*style).text_hover;
                sel_text_color = (*style).selected_text_hover;
                sel_background_color = (*style).selected_hover;
                cursor_text_color = (*style).cursor_text_hover;
                cursor_color = (*style).cursor_hover
            } else {
                background_0 = &(*style).normal as *const StyleItem;
                text_color = (*style).text_normal;
                sel_text_color = (*style).selected_text_normal;
                sel_background_color = (*style).selected_normal;
                cursor_color = (*style).cursor_normal;
                cursor_text_color = (*style).cursor_text_normal
            }
            if (*background_0).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                background_color = nk_rgba(0i32, 0i32, 0i32, 0i32)
            } else {
                background_color = (*background_0).data.color
            }
            if (*edit).select_start == (*edit).select_end {
                /* no selection so just draw the complete text */
                begin_0 = nk_str_get_const(&mut (*edit).string);
                l = nk_str_len_char(&mut (*edit).string);
                nk_edit_draw_text(
                    out,
                    style,
                    area.x - (*edit).scrollbar.x,
                    area.y - (*edit).scrollbar.y,
                    0i32 as f32,
                    begin_0,
                    l,
                    row_height,
                    font,
                    background_color,
                    text_color,
                    nk_false as Int,
                );
            } else {
                /* edit has selection so draw 1-3 text chunks */
                if (*edit).select_start != (*edit).select_end && selection_begin > 0i32 {
                    /* draw unselected text before selection */
                    begin_1 = nk_str_get_const(&mut (*edit).string);
                    nk_edit_draw_text(
                        out,
                        style,
                        area.x - (*edit).scrollbar.x,
                        area.y - (*edit).scrollbar.y,
                        0i32 as f32,
                        begin_1,
                        begin_1
                            .ptr_offset_to(select_begin_ptr)
                            .expect("bad offset_to") as Long as Int,
                        row_height,
                        font,
                        background_color,
                        text_color,
                        nk_false as Int,
                    );
                }
                if (*edit).select_start != (*edit).select_end {
                    /* draw selected text */
                    if select_end_ptr.is_null() {
                        begin_2 = nk_str_get_const(&mut (*edit).string);
                        select_end_ptr =
                            begin_2.offset(nk_str_len_char(&mut (*edit).string) as isize)
                    }
                    nk_edit_draw_text(
                        out,
                        style,
                        area.x - (*edit).scrollbar.x,
                        area.y + selection_offset_start.y - (*edit).scrollbar.y,
                        selection_offset_start.x,
                        select_begin_ptr,
                        select_begin_ptr
                            .ptr_offset_to(select_end_ptr)
                            .expect("bad offset_to") as Long as Int,
                        row_height,
                        font,
                        sel_background_color,
                        sel_text_color,
                        nk_true as Int,
                    );
                }
                if (*edit).select_start != (*edit).select_end && selection_end < (*edit).string.len
                {
                    /* draw unselected text after selected text */
                    let mut begin_3: *const Char = select_end_ptr;
                    let mut end_0: *const Char = nk_str_get_const(&mut (*edit).string)
                        .offset(nk_str_len_char(&mut (*edit).string) as isize);
                    nk_edit_draw_text(
                        out,
                        style,
                        area.x - (*edit).scrollbar.x,
                        area.y + selection_offset_end.y - (*edit).scrollbar.y,
                        selection_offset_end.x,
                        begin_3,
                        begin_3.ptr_offset_to(end_0).expect("bad offset_to") as Long as Int,
                        row_height,
                        font,
                        background_color,
                        text_color,
                        nk_true as Int,
                    );
                }
            }
            /* cursor */
            if (*edit).select_start == (*edit).select_end {
                if (*edit).cursor >= nk_str_len(&mut (*edit).string)
                    || !cursor_ptr.is_null() && *cursor_ptr as Int == '\n' as i32
                {
                    /* draw cursor at end of line */
                    cursor = Rect {
                        x: 0.,
                        y: 0.,
                        w: 0.,
                        h: 0.,
                    };
                    cursor.w = (*style).cursor_size;
                    cursor.h = (*font).height;
                    cursor.x = area.x + cursor_pos.x - (*edit).scrollbar.x;
                    cursor.y = area.y + cursor_pos.y + row_height / 2.0f32 - cursor.h / 2.0f32;
                    cursor.y -= (*edit).scrollbar.y;
                    nk_fill_rect(out, cursor, 0i32 as f32, cursor_color);
                } else {
                    /* draw cursor inside text */
                    let mut glyph_len_1: Int = 0;
                    let mut label: Rect = Rect {
                        x: 0.,
                        y: 0.,
                        w: 0.,
                        h: 0.,
                    };
                    let mut txt: Text = Text {
                        padding: Point { x: 0., y: 0. },
                        background: Color {
                            r: 0,
                            g: 0,
                            b: 0,
                            a: 0,
                        },
                        text: Color {
                            r: 0,
                            g: 0,
                            b: 0,
                            a: 0,
                        },
                    };
                    let mut unicode_1: Rune = 0;
                    glyph_len_1 = nk_utf_decode(cursor_ptr, &mut unicode_1, 4i32);
                    label.x = area.x + cursor_pos.x - (*edit).scrollbar.x;
                    label.y = area.y + cursor_pos.y - (*edit).scrollbar.y;
                    label.w = (*font).width.expect("non-null function pointer")(
                        (*font).userdata,
                        (*font).height,
                        cursor_ptr,
                        glyph_len_1,
                    );
                    label.h = row_height;
                    txt.padding = Point::new(0i32 as f32, 0i32 as f32);
                    txt.background = cursor_color;
                    txt.text = cursor_text_color;
                    nk_fill_rect(out, label, 0i32 as f32, cursor_color);
                    nk_widget_text(
                        out,
                        label,
                        cursor_ptr,
                        glyph_len_1,
                        &mut txt,
                        NK_TEXT_LEFT as Int as Flags,
                        font,
                    );
                }
            }
        } else {
            /* not active so just draw text */
            let mut l_0: Int = nk_str_len_char(&mut (*edit).string);
            let mut begin_4: *const Char = nk_str_get_const(&mut (*edit).string);
            let mut background_1: *const StyleItem = 0 as *const StyleItem;
            let mut background_color_0: Color = Color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            let mut text_color_0: Color = Color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            };
            nk_push_scissor(out, clip);
            if 0 != *state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
                background_1 = &(*style).active as *const StyleItem;
                text_color_0 = (*style).text_active
            } else if 0 != *state & NK_WIDGET_STATE_HOVER as Int as Uint {
                background_1 = &(*style).hover as *const StyleItem;
                text_color_0 = (*style).text_hover
            } else {
                background_1 = &(*style).normal as *const StyleItem;
                text_color_0 = (*style).text_normal
            }
            if (*background_1).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                background_color_0 = nk_rgba(0i32, 0i32, 0i32, 0i32)
            } else {
                background_color_0 = (*background_1).data.color
            }
            nk_edit_draw_text(
                out,
                style,
                area.x - (*edit).scrollbar.x,
                area.y - (*edit).scrollbar.y,
                0i32 as f32,
                begin_4,
                l_0,
                row_height,
                font,
                background_color_0,
                text_color_0,
                nk_false as Int,
            );
        }
        nk_push_scissor(out, old_clip);
        return ret;
    };
}

pub unsafe fn nk_str_len_char(mut s: *mut Str) -> Int {
    if s.is_null() || 0 == (*s).len || 0 == (*s).buffer.allocated {
        return 0i32;
    } else {
        return (*s).buffer.allocated as Int;
    };
}

pub unsafe fn nk_str_get_const(mut s: *const Str) -> *const Char {
    if s.is_null() || 0 == (*s).len || 0 == (*s).buffer.allocated {
        return 0 as *const Char;
    } else {
        return (*s).buffer.memory.ptr as *const Char;
    };
}
unsafe fn nk_edit_draw_text(
    mut out: *mut CommandBuffer,
    mut style: *const StyleEdit,
    mut pos_x: f32,
    mut pos_y: f32,
    mut x_offset: f32,
    mut text: *const Char,
    mut byte_len: Int,
    mut row_height: f32,
    mut font: *const UserFont,
    mut background: Color,
    mut foreground: Color,
    mut is_selected: Int,
) -> () {
    if text.is_null() || 0 == byte_len || out.is_null() || style.is_null() {
        return;
    } else {
        let mut glyph_len: Int = 0i32;
        let mut unicode: Rune = 0i32 as Rune;
        let mut text_len: Int = 0i32;
        let mut line_width: f32 = 0i32 as f32;
        let mut glyph_width: f32 = 0.;
        let mut line: *const Char = text;
        let mut line_offset: f32 = 0i32 as f32;
        let mut line_count: Int = 0i32;
        let mut txt: Text = Text {
            padding: Point { x: 0., y: 0. },
            background: Color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            },
            text: Color {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
            },
        };
        txt.padding = Point::new(0i32 as f32, 0i32 as f32);
        txt.background = background;
        txt.text = foreground;
        glyph_len = nk_utf_decode(
            text.offset(text_len as isize),
            &mut unicode,
            byte_len - text_len,
        );
        if 0 == glyph_len {
            return;
        } else {
            while text_len < byte_len && 0 != glyph_len {
                if unicode == '\n' as i32 as Uint {
                    /* new line separator so draw previous line */
                    let mut label: Rect = Rect {
                        x: 0.,
                        y: 0.,
                        w: 0.,
                        h: 0.,
                    };
                    label.y = pos_y + line_offset;
                    label.h = row_height;
                    label.w = line_width;
                    label.x = pos_x;
                    if 0 == line_count {
                        label.x += x_offset
                    }
                    /* selection needs to draw different background color */
                    if 0 != is_selected {
                        nk_fill_rect(out, label, 0i32 as f32, background);
                    }
                    nk_widget_text(
                        out,
                        label,
                        line,
                        line.ptr_offset_to(text.offset(text_len as isize))
                            .expect("bad offset_to") as Long as Int,
                        &mut txt,
                        NK_TEXT_CENTERED as Int as Flags,
                        font,
                    );
                    text_len += 1;
                    line_count += 1;
                    line_width = 0i32 as f32;
                    line = text.offset(text_len as isize);
                    line_offset += row_height;
                    glyph_len = nk_utf_decode(
                        text.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    )
                } else if unicode == '\r' as i32 as Uint {
                    text_len += 1;
                    glyph_len = nk_utf_decode(
                        text.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    )
                } else {
                    glyph_width = (*font).width.expect("non-null function pointer")(
                        (*font).userdata,
                        (*font).height,
                        text.offset(text_len as isize),
                        glyph_len,
                    );
                    line_width += glyph_width;
                    text_len += glyph_len;
                    glyph_len = nk_utf_decode(
                        text.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    )
                }
            }
            if line_width > 0i32 as f32 {
                /* draw last line */
                let mut label_0: Rect = Rect {
                    x: 0.,
                    y: 0.,
                    w: 0.,
                    h: 0.,
                };
                label_0.y = pos_y + line_offset;
                label_0.h = row_height;
                label_0.w = line_width;
                label_0.x = pos_x;
                if 0 == line_count {
                    label_0.x += x_offset
                }
                if 0 != is_selected {
                    nk_fill_rect(out, label_0, 0i32 as f32, background);
                }
                nk_widget_text(
                    out,
                    label_0,
                    line,
                    line.ptr_offset_to(text.offset(text_len as isize))
                        .expect("bad offset_to") as Long as Int,
                    &mut txt,
                    NK_TEXT_LEFT as Int as Flags,
                    font,
                );
            }
            return;
        }
    };
}

pub unsafe fn nk_str_len(mut s: *mut Str) -> Int {
    if s.is_null() || 0 == (*s).len || 0 == (*s).buffer.allocated {
        return 0i32;
    } else {
        return (*s).len;
    };
}
unsafe fn nk_text_calculate_text_bounds(
    mut font: *const UserFont,
    mut begin: *const Char,
    mut byte_len: Int,
    mut row_height: f32,
    mut remaining: *mut *const Char,
    mut out_offset: *mut Point,
    mut glyphs: *mut Int,
    mut op: Int,
) -> Point {
    let mut line_height: f32 = row_height;
    let mut text_size: Point = Point::new(0i32 as f32, 0i32 as f32);
    let mut line_width: f32 = 0.0f32;
    let mut glyph_width: f32 = 0.;
    let mut glyph_len: Int = 0i32;
    let mut unicode: Rune = 0i32 as Rune;
    let mut text_len: Int = 0i32;
    if begin.is_null() || byte_len <= 0i32 || font.is_null() {
        return Point::new(0i32 as f32, row_height);
    } else {
        glyph_len = nk_utf_decode(begin, &mut unicode, byte_len);
        if 0 == glyph_len {
            return text_size;
        } else {
            glyph_width = (*font).width.expect("non-null function pointer")(
                (*font).userdata,
                (*font).height,
                begin,
                glyph_len,
            );
            *glyphs = 0i32;
            while text_len < byte_len && 0 != glyph_len {
                if unicode == '\n' as i32 as Uint {
                    text_size.x = if text_size.x < line_width {
                        line_width
                    } else {
                        text_size.x
                    };
                    text_size.y += line_height;
                    line_width = 0i32 as f32;
                    *glyphs += 1i32;
                    if op == NK_STOP_ON_NEW_LINE as Int {
                        break;
                    }
                    text_len += 1;
                    glyph_len = nk_utf_decode(
                        begin.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    )
                } else if unicode == '\r' as i32 as Uint {
                    text_len += 1;
                    *glyphs += 1i32;
                    glyph_len = nk_utf_decode(
                        begin.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    )
                } else {
                    *glyphs = *glyphs + 1i32;
                    text_len += glyph_len;
                    line_width += glyph_width;
                    glyph_len = nk_utf_decode(
                        begin.offset(text_len as isize),
                        &mut unicode,
                        byte_len - text_len,
                    );
                    glyph_width = (*font).width.expect("non-null function pointer")(
                        (*font).userdata,
                        (*font).height,
                        begin.offset(text_len as isize),
                        glyph_len,
                    )
                }
            }
            if text_size.x < line_width {
                text_size.x = line_width
            }
            if !out_offset.is_null() {
                *out_offset = Point::new(line_width, text_size.y + line_height)
            }
            if line_width > 0i32 as f32 || text_size.y == 0.0f32 {
                text_size.y += line_height
            }
            if !remaining.is_null() {
                *remaining = begin.offset(text_len as isize)
            }
            return text_size;
        }
    };
}

pub unsafe fn nk_textedit_text(
    mut state: *mut TextEdit,
    mut text: *const Char,
    mut total_len: Int,
) -> () {
    let mut unicode: Rune = 0;
    let mut glyph_len: Int = 0;
    let mut text_len: Int = 0i32;
    if text.is_null() || 0 == total_len || (*state).mode as Int == NK_TEXT_EDIT_MODE_VIEW as Int {
        return;
    } else {
        glyph_len = nk_utf_decode(text, &mut unicode, total_len);
        while text_len < total_len && 0 != glyph_len {
            /* don't insert a backward delete, just process the event */
            if !(unicode == 127i32 as Uint) {
                /* can't add newline in single-line mode */
                if !(unicode == '\n' as i32 as Uint && 0 != (*state).single_line as Int) {
                    /* filter incoming text */
                    if !((*state).filter.is_some()
                        && 0 == (*state).filter.expect("non-null function pointer")(state, unicode))
                    {
                        if !((*state).select_start != (*state).select_end)
                            && (*state).cursor < (*state).string.len
                        {
                            if (*state).mode as Int == NK_TEXT_EDIT_MODE_REPLACE as Int {
                                nk_textedit_makeundo_replace(state, (*state).cursor, 1i32, 1i32);
                                nk_str_delete_runes(&mut (*state).string, (*state).cursor, 1i32);
                            }
                            if 0 != nk_str_insert_text_utf8(
                                &mut (*state).string,
                                (*state).cursor,
                                text.offset(text_len as isize),
                                1i32,
                            ) {
                                (*state).cursor += 1;
                                (*state).has_preferred_x = 0i32 as Uchar
                            }
                        } else {
                            /* implicitly clamps */
                            nk_textedit_delete_selection(state);
                            if 0 != nk_str_insert_text_utf8(
                                &mut (*state).string,
                                (*state).cursor,
                                text.offset(text_len as isize),
                                1i32,
                            ) {
                                nk_textedit_makeundo_insert(state, (*state).cursor, 1i32);
                                (*state).cursor += 1;
                                (*state).has_preferred_x = 0i32 as Uchar
                            }
                        }
                    }
                }
            }
            text_len += glyph_len;
            glyph_len = nk_utf_decode(
                text.offset(text_len as isize),
                &mut unicode,
                total_len - text_len,
            )
        }
        return;
    };
}
unsafe fn nk_textedit_makeundo_insert(
    mut state: *mut TextEdit,
    mut where_0: Int,
    mut length: Int,
) -> () {
    nk_textedit_createundo(&mut (*state).undo, where_0, 0i32, length);
}
unsafe fn nk_textedit_createundo(
    mut state: *mut TextUndoState,
    mut pos: Int,
    mut insert_len: Int,
    mut delete_len: Int,
) -> *mut Rune {
    let mut r: *mut TextUndoRecord = nk_textedit_create_undo_record(state, insert_len);
    if r.is_null() {
        return 0 as *mut Rune;
    } else {
        (*r).where_0 = pos;
        (*r).insert_length = insert_len as Short;
        (*r).delete_length = delete_len as Short;
        if insert_len == 0i32 {
            (*r).char_storage = -1i32 as Short;
            return 0 as *mut Rune;
        } else {
            (*r).char_storage = (*state).undo_char_point;
            (*state).undo_char_point = ((*state).undo_char_point as Int + insert_len) as Short;
            return &mut (*state).undo_char[(*r).char_storage as usize] as *mut Rune;
        }
    };
}
unsafe fn nk_textedit_create_undo_record(
    mut state: *mut TextUndoState,
    mut numchars: Int,
) -> *mut TextUndoRecord {
    /* any time we create a new undo record, we discard redo*/
    nk_textedit_flush_redo(state);
    /* if we have no free records, we have to make room,
     * by sliding the existing records down */
    if (*state).undo_point as Int == 99i32 {
        nk_textedit_discard_undo(state);
    }
    /* if the characters to store won't possibly fit in the buffer,
     * we can't undo */
    if numchars > 999i32 {
        (*state).undo_point = 0i32 as Short;
        (*state).undo_char_point = 0i32 as Short;
        return 0 as *mut TextUndoRecord;
    } else {
        /* if we don't have enough free characters in the buffer,
         * we have to make room */
        while (*state).undo_char_point as Int + numchars > 999i32 {
            nk_textedit_discard_undo(state);
        }
        let fresh21 = (*state).undo_point;
        (*state).undo_point = (*state).undo_point + 1;
        return &mut (*state).undo_rec[fresh21 as usize] as *mut TextUndoRecord;
    };
}
unsafe fn nk_textedit_discard_undo(mut state: *mut TextUndoState) -> () {
    /* discard the oldest entry in the undo list */
    if (*state).undo_point as Int > 0i32 {
        /* if the 0th undo state has characters, clean those up */
        if (*state).undo_rec[0usize].char_storage as Int >= 0i32 {
            let mut n: Int = (*state).undo_rec[0usize].insert_length as Int;
            let mut i: Int = 0;
            /* delete n characters from all other records */
            (*state).undo_char_point = ((*state).undo_char_point as Int - n) as Short;
            nk_memcopy(
                (*state).undo_char.as_mut_ptr() as *mut Void,
                (*state).undo_char.as_mut_ptr().offset(n as isize) as *const Void,
                ((*state).undo_char_point as Size).wrapping_mul(mem::size_of::<Rune>() as Ulong),
            );
            i = 0i32;
            while i < (*state).undo_point as Int {
                if (*state).undo_rec[i as usize].char_storage as Int >= 0i32 {
                    (*state).undo_rec[i as usize].char_storage =
                        ((*state).undo_rec[i as usize].char_storage as Int - n) as Short
                }
                i += 1
            }
        }
        (*state).undo_point -= 1;
        nk_memcopy(
            (*state).undo_rec.as_mut_ptr() as *mut Void,
            (*state).undo_rec.as_mut_ptr().offset(1isize) as *const Void,
            ((*state).undo_point as Size).wrapping_mul(mem::size_of::<TextUndoRecord>() as Ulong),
        );
    };
}
unsafe fn nk_textedit_flush_redo(mut state: *mut TextUndoState) -> () {
    (*state).redo_point = 99i32 as Short;
    (*state).redo_char_point = 999i32 as Short;
}

pub unsafe fn nk_str_insert_text_utf8(
    mut str: *mut Str,
    mut pos: Int,
    mut text: *const Char,
    mut len: Int,
) -> Int {
    let mut i: Int = 0i32;
    let mut byte_len: Int = 0i32;
    let mut unicode: Rune = 0;
    if str.is_null() || text.is_null() || 0 == len {
        return 0i32;
    } else {
        i = 0i32;
        while i < len {
            byte_len += nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
            i += 1
        }
        nk_str_insert_at_rune(str, pos, text, byte_len);
        return len;
    };
}

pub unsafe fn nk_str_insert_at_rune(
    mut str: *mut Str,
    mut pos: Int,
    mut cstr: *const Char,
    mut len: Int,
) -> Int {
    let mut glyph_len: Int = 0;
    let mut unicode: Rune = 0;
    let mut begin: *const Char = 0 as *const Char;
    let mut buffer: *const Char = 0 as *const Char;
    if str.is_null() || cstr.is_null() || 0 == len {
        return 0i32;
    } else {
        begin = nk_str_at_rune(str, pos, &mut unicode, &mut glyph_len);
        if 0 == (*str).len {
            return nk_str_append_text_char(str, cstr, len);
        } else {
            buffer = nk_str_get_const(str);
            if begin.is_null() {
                return 0i32;
            } else {
                return nk_str_insert_at_char(
                    str,
                    buffer.ptr_offset_to(begin).expect("bad offset_to") as Long as Int,
                    cstr,
                    len,
                );
            }
        }
    };
}

pub unsafe fn nk_str_insert_at_char(
    mut s: *mut Str,
    mut pos: Int,
    mut str: *const Char,
    mut len: Int,
) -> Int {
    let mut i: Int = 0;
    let mut mem: *mut Void = 0 as *mut Void;
    let mut src: *mut Char = 0 as *mut Char;
    let mut dst: *mut Char = 0 as *mut Char;
    let mut copylen: Int = 0;
    if s.is_null() || str.is_null() || 0 == len || pos as Size > (*s).buffer.allocated {
        return 0i32;
    } else if (*s).buffer.allocated.wrapping_add(len as Size) >= (*s).buffer.memory.size
        && (*s).buffer.type_0 as Uint == NK_BUFFER_FIXED as Int as Uint
    {
        return 0i32;
    } else {
        copylen = (*s).buffer.allocated as Int - pos;
        if 0 == copylen {
            nk_str_append_text_char(s, str, len);
            return 1i32;
        } else {
            mem = nk_buffer_alloc(
                &mut (*s).buffer,
                NK_BUFFER_FRONT,
                (len as Size).wrapping_mul(mem::size_of::<Char>() as Ulong),
                0i32 as Size,
            );
            if mem.is_null() {
                return 0i32;
            } else {
                /* memmove */
                dst = ((*s).buffer.memory.ptr as *mut u8)
                    .offset((pos + len + (copylen - 1i32)) as isize)
                    as *mut Void as *mut Char;
                src = ((*s).buffer.memory.ptr as *mut u8).offset((pos + (copylen - 1i32)) as isize)
                    as *mut Void as *mut Char;
                i = 0i32;
                while i < copylen {
                    let fresh23 = dst;
                    dst = dst.offset(-1);
                    let fresh22 = src;
                    src = src.offset(-1);
                    *fresh23 = *fresh22;
                    i += 1
                }
                mem = ((*s).buffer.memory.ptr as *mut u8).offset(pos as isize) as *mut Void;
                nk_memcopy(
                    mem,
                    str as *const Void,
                    (len as Size).wrapping_mul(mem::size_of::<Char>() as Ulong),
                );
                (*s).len = nk_utf_len(
                    (*s).buffer.memory.ptr as *mut Char,
                    (*s).buffer.allocated as Int,
                );
                return 1i32;
            }
        }
    };
}

pub unsafe fn nk_utf_len(mut str: *const Char, mut len: Int) -> Int {
    let mut text: *const Char = 0 as *const Char;
    let mut glyphs: Int = 0i32;
    let mut text_len: Int = 0;
    let mut glyph_len: Int = 0;
    let mut src_len: Int = 0i32;
    let mut unicode: Rune = 0;
    if str.is_null() || 0 == len {
        return 0i32;
    } else {
        text = str;
        text_len = len;
        glyph_len = nk_utf_decode(text, &mut unicode, text_len);
        while 0 != glyph_len && src_len < len {
            glyphs += 1;
            src_len = src_len + glyph_len;
            glyph_len = nk_utf_decode(
                text.offset(src_len as isize),
                &mut unicode,
                text_len - src_len,
            )
        }
        return glyphs;
    };
}

pub unsafe fn nk_str_append_text_char(mut s: *mut Str, mut str: *const Char, mut len: Int) -> Int {
    let mut mem: *mut Char = 0 as *mut Char;
    if s.is_null() || str.is_null() || 0 == len {
        return 0i32;
    } else {
        mem = nk_buffer_alloc(
            &mut (*s).buffer,
            NK_BUFFER_FRONT,
            (len as Size).wrapping_mul(mem::size_of::<Char>() as Ulong),
            0i32 as Size,
        ) as *mut Char;
        if mem.is_null() {
            return 0i32;
        } else {
            nk_memcopy(
                mem as *mut Void,
                str as *const Void,
                (len as Size).wrapping_mul(mem::size_of::<Char>() as Ulong),
            );
            (*s).len += nk_utf_len(str, len);
            return len;
        }
    };
}

pub unsafe fn nk_str_at_rune(
    mut str: *mut Str,
    mut pos: Int,
    mut unicode: *mut Rune,
    mut len: *mut Int,
) -> *mut Char {
    let mut i: Int = 0i32;
    let mut src_len: Int = 0i32;
    let mut glyph_len: Int = 0i32;
    let mut text: *mut Char = 0 as *mut Char;
    let mut text_len: Int = 0;
    if str.is_null() || unicode.is_null() || len.is_null() {
        return 0 as *mut Char;
    } else if pos < 0i32 {
        *unicode = 0i32 as Rune;
        *len = 0i32;
        return 0 as *mut Char;
    } else {
        text = (*str).buffer.memory.ptr as *mut Char;
        text_len = (*str).buffer.allocated as Int;
        glyph_len = nk_utf_decode(text, unicode, text_len);
        while 0 != glyph_len {
            if i == pos {
                *len = glyph_len;
                break;
            } else {
                i += 1;
                src_len = src_len + glyph_len;
                glyph_len =
                    nk_utf_decode(text.offset(src_len as isize), unicode, text_len - src_len)
            }
        }
        if i != pos {
            return 0 as *mut Char;
        } else {
            return text.offset(src_len as isize);
        }
    };
}

pub unsafe fn nk_textedit_delete_selection(mut state: *mut TextEdit) -> () {
    /* delete the section */
    nk_textedit_clamp(state);
    if (*state).select_start != (*state).select_end {
        if (*state).select_start < (*state).select_end {
            nk_textedit_delete(
                state,
                (*state).select_start,
                (*state).select_end - (*state).select_start,
            );
            (*state).cursor = (*state).select_start;
            (*state).select_end = (*state).cursor
        } else {
            nk_textedit_delete(
                state,
                (*state).select_end,
                (*state).select_start - (*state).select_end,
            );
            (*state).cursor = (*state).select_end;
            (*state).select_start = (*state).cursor
        }
        (*state).has_preferred_x = 0i32 as Uchar
    };
}

pub unsafe fn nk_textedit_delete(mut state: *mut TextEdit, mut where_0: Int, mut len: Int) -> () {
    /* delete characters while updating undo */
    nk_textedit_makeundo_delete(state, where_0, len);
    nk_str_delete_runes(&mut (*state).string, where_0, len);
    (*state).has_preferred_x = 0i32 as Uchar;
}

pub unsafe fn nk_str_delete_runes(mut s: *mut Str, mut pos: Int, mut len: Int) -> () {
    let mut temp: *mut Char = 0 as *mut Char;
    let mut unicode: Rune = 0;
    let mut begin: *mut Char = 0 as *mut Char;
    let mut end: *mut Char = 0 as *mut Char;
    let mut unused: Int = 0;
    if (*s).len < pos + len {
        len = if if (*s).len - pos < (*s).len {
            (*s).len - pos
        } else {
            (*s).len
        } < 0i32
        {
            0i32
        } else if (*s).len - pos < (*s).len {
            (*s).len - pos
        } else {
            (*s).len
        }
    }
    if 0 == len {
        return;
    } else {
        temp = (*s).buffer.memory.ptr as *mut Char;
        begin = nk_str_at_rune(s, pos, &mut unicode, &mut unused);
        if begin.is_null() {
            return;
        } else {
            (*s).buffer.memory.ptr = begin as *mut Void;
            end = nk_str_at_rune(s, len, &mut unicode, &mut unused);
            (*s).buffer.memory.ptr = temp as *mut Void;
            if end.is_null() {
                return;
            } else {
                nk_str_delete_chars(
                    s,
                    temp.ptr_offset_to(begin).expect("bad offset_to") as Long as Int,
                    begin.ptr_offset_to(end).expect("bad offset_to") as Long as Int,
                );
                return;
            }
        }
    };
}

pub unsafe fn nk_str_delete_chars(mut s: *mut Str, mut pos: Int, mut len: Int) -> () {
    let mut dst: *mut Char = 0 as *mut Char;
    let mut src: *mut Char = 0 as *mut Char;
    if s.is_null()
        || 0 == len
        || pos as Size > (*s).buffer.allocated
        || (pos + len) as Size > (*s).buffer.allocated
    {
        return;
    } else {
        if ((pos + len) as Size) < (*s).buffer.allocated {
            /* memmove */
            dst =
                ((*s).buffer.memory.ptr as *mut u8).offset(pos as isize) as *mut Void as *mut Char;
            src = ((*s).buffer.memory.ptr as *mut u8).offset((pos + len) as isize) as *mut Void
                as *mut Char;
            nk_memcopy(
                dst as *mut Void,
                src as *const Void,
                (*s).buffer.allocated.wrapping_sub((pos + len) as Size),
            );
            (*s).buffer.allocated =
                ((*s).buffer.allocated as Ulong).wrapping_sub(len as Size) as Size as Size
        } else {
            nk_str_remove_chars(s, len);
        }
        (*s).len = nk_utf_len(
            (*s).buffer.memory.ptr as *mut Char,
            (*s).buffer.allocated as Int,
        );
        return;
    };
}

pub unsafe fn nk_str_remove_chars(mut s: *mut Str, mut len: Int) -> () {
    if s.is_null() || len < 0i32 || len as Size > (*s).buffer.allocated {
        return;
    } else {
        (*s).buffer.allocated =
            ((*s).buffer.allocated as Ulong).wrapping_sub(len as Size) as Size as Size;
        (*s).len = nk_utf_len(
            (*s).buffer.memory.ptr as *mut Char,
            (*s).buffer.allocated as Int,
        );
        return;
    };
}
unsafe fn nk_textedit_makeundo_delete(
    mut state: *mut TextEdit,
    mut where_0: Int,
    mut length: Int,
) -> () {
    let mut i: Int = 0;
    let mut p: *mut Rune = nk_textedit_createundo(&mut (*state).undo, where_0, length, 0i32);
    if !p.is_null() {
        i = 0i32;
        while i < length {
            *p.offset(i as isize) = nk_str_rune_at(&mut (*state).string, where_0 + i);
            i += 1
        }
    };
}

pub unsafe fn nk_str_rune_at(mut str: *const Str, mut pos: Int) -> Rune {
    let mut len: Int = 0;
    let mut unicode: Rune = 0i32 as Rune;
    nk_str_at_const(str, pos, &mut unicode, &mut len);
    return unicode;
}

pub unsafe fn nk_str_at_const(
    mut str: *const Str,
    mut pos: Int,
    mut unicode: *mut Rune,
    mut len: *mut Int,
) -> *const Char {
    let mut i: Int = 0i32;
    let mut src_len: Int = 0i32;
    let mut glyph_len: Int = 0i32;
    let mut text: *mut Char = 0 as *mut Char;
    let mut text_len: Int = 0;
    if str.is_null() || unicode.is_null() || len.is_null() {
        return 0 as *const Char;
    } else if pos < 0i32 {
        *unicode = 0i32 as Rune;
        *len = 0i32;
        return 0 as *const Char;
    } else {
        text = (*str).buffer.memory.ptr as *mut Char;
        text_len = (*str).buffer.allocated as Int;
        glyph_len = nk_utf_decode(text, unicode, text_len);
        while 0 != glyph_len {
            if i == pos {
                *len = glyph_len;
                break;
            } else {
                i += 1;
                src_len = src_len + glyph_len;
                glyph_len =
                    nk_utf_decode(text.offset(src_len as isize), unicode, text_len - src_len)
            }
        }
        if i != pos {
            return 0 as *const Char;
        } else {
            return text.offset(src_len as isize);
        }
    };
}
unsafe fn nk_textedit_clamp(mut state: *mut TextEdit) -> () {
    /* make the selection/cursor state valid if client altered the string */
    let mut n: Int = (*state).string.len;
    if (*state).select_start != (*state).select_end {
        if (*state).select_start > n {
            (*state).select_start = n
        }
        if (*state).select_end > n {
            (*state).select_end = n
        }
        /* if clamping forced them to be equal, move the cursor to match */
        if (*state).select_start == (*state).select_end {
            (*state).cursor = (*state).select_start
        }
    }
    if (*state).cursor > n {
        (*state).cursor = n
    };
}
unsafe fn nk_textedit_makeundo_replace(
    mut state: *mut TextEdit,
    mut where_0: Int,
    mut old_length: Int,
    mut new_length: Int,
) -> () {
    let mut i: Int = 0;
    let mut p: *mut Rune =
        nk_textedit_createundo(&mut (*state).undo, where_0, old_length, new_length);
    if !p.is_null() {
        i = 0i32;
        while i < old_length {
            *p.offset(i as isize) = nk_str_rune_at(&mut (*state).string, where_0 + i);
            i += 1
        }
    };
}

pub unsafe fn nk_textedit_cut(mut state: *mut TextEdit) -> Int {
    /* API cut: delete selection */
    if (*state).mode as Int == NK_TEXT_EDIT_MODE_VIEW as Int {
        return 0i32;
    } else if (*state).select_start != (*state).select_end {
        /* implicitly clamps */
        nk_textedit_delete_selection(state);
        (*state).has_preferred_x = 0i32 as Uchar;
        return 1i32;
    } else {
        return 0i32;
    };
}

unsafe fn nk_textedit_key(
    mut state: *mut TextEdit,
    mut key: Keys,
    mut shift_mod: Int,
    mut font: *const UserFont,
    mut row_height: f32,
) -> () {
    let mut sel: Int = 0;
    let mut find: TextFind = TextFind {
        x: 0.,
        y: 0.,
        height: 0.,
        first_char: 0,
        length: 0,
        prev_first: 0,
    };
    let mut row: TextEditRow = TextEditRow {
        x0: 0.,
        x1: 0.,
        baseline_y_delta: 0.,
        ymin: 0.,
        ymax: 0.,
        num_chars: 0,
    };
    let mut sel_0: Int = 0;
    let mut i_0: Int = 0;
    let mut row_0: TextEditRow = TextEditRow {
        x0: 0.,
        x1: 0.,
        baseline_y_delta: 0.,
        ymin: 0.,
        ymax: 0.,
        num_chars: 0,
    };
    let mut i: Int = 0;
    let mut find_0: TextFind = TextFind {
        x: 0.,
        y: 0.,
        height: 0.,
        first_char: 0,
        length: 0,
        prev_first: 0,
    };
    let mut current_block: u64;
    loop {
        match key as Uint {
            21 => {
                nk_textedit_undo(state);
                (*state).has_preferred_x = 0i32 as Uchar;
                current_block = 6281126495347172768;
                break;
            }
            22 => {
                nk_textedit_redo(state);
                (*state).has_preferred_x = 0i32 as Uchar;
                current_block = 6281126495347172768;
                break;
            }
            23 => {
                nk_textedit_select_all(state);
                (*state).has_preferred_x = 0i32 as Uchar;
                current_block = 6281126495347172768;
                break;
            }
            14 => {
                if (*state).mode as Int == NK_TEXT_EDIT_MODE_VIEW as Int {
                    current_block = 16658872821858055392;
                    break;
                } else {
                    current_block = 6281126495347172768;
                    break;
                }
            }
            15 => {
                if (*state).mode as Int == NK_TEXT_EDIT_MODE_VIEW as Int {
                    current_block = 17179679302217393232;
                    break;
                } else {
                    current_block = 6281126495347172768;
                    break;
                }
            }
            16 => {
                if (*state).mode as Int == NK_TEXT_EDIT_MODE_INSERT as Int
                    || (*state).mode as Int == NK_TEXT_EDIT_MODE_REPLACE as Int
                {
                    current_block = 820271813250567934;
                    break;
                } else {
                    current_block = 6281126495347172768;
                    break;
                }
            }
            12 => {
                if 0 != shift_mod {
                    current_block = 15619007995458559411;
                    break;
                } else {
                    current_block = 10886091980245723256;
                    break;
                }
            }
            13 => {
                if 0 != shift_mod {
                    current_block = 11650488183268122163;
                    break;
                } else {
                    current_block = 5399440093318478209;
                    break;
                }
            }
            24 => {
                if 0 != shift_mod {
                    current_block = 8236137900636309791;
                    break;
                } else {
                    current_block = 12039483399334584727;
                    break;
                }
            }
            25 => {
                if 0 != shift_mod {
                    current_block = 7175849428784450219;
                    break;
                } else {
                    current_block = 224731115979188411;
                    break;
                }
            }
            11 => {
                find = TextFind {
                    x: 0.,
                    y: 0.,
                    height: 0.,
                    first_char: 0,
                    length: 0,
                    prev_first: 0,
                };
                row = TextEditRow {
                    x0: 0.,
                    x1: 0.,
                    baseline_y_delta: 0.,
                    ymin: 0.,
                    ymax: 0.,
                    num_chars: 0,
                };
                i = 0;
                sel = shift_mod;
                if 0 != (*state).single_line {
                    /* on windows, up&down in single-line behave like left&right */
                    key = NK_KEY_RIGHT
                } else if 0 != sel {
                    current_block = 18386322304582297246;
                    break;
                } else {
                    current_block = 6669252993407410313;
                    break;
                }
            }
            10 => {
                find_0 = TextFind {
                    x: 0.,
                    y: 0.,
                    height: 0.,
                    first_char: 0,
                    length: 0,
                    prev_first: 0,
                };
                row_0 = TextEditRow {
                    x0: 0.,
                    x1: 0.,
                    baseline_y_delta: 0.,
                    ymin: 0.,
                    ymax: 0.,
                    num_chars: 0,
                };
                i_0 = 0;
                sel_0 = shift_mod;
                if 0 != (*state).single_line {
                    /* on windows, up&down become left&right */
                    key = NK_KEY_LEFT
                } else if 0 != sel_0 {
                    current_block = 10692455896603418738;
                    break;
                } else {
                    current_block = 1836292691772056875;
                    break;
                }
            }
            3 => {
                if (*state).mode as Int == NK_TEXT_EDIT_MODE_VIEW as Int {
                    current_block = 6281126495347172768;
                    break;
                } else {
                    current_block = 1847472278776910194;
                    break;
                }
            }
            6 => {
                if (*state).mode as Int == NK_TEXT_EDIT_MODE_VIEW as Int {
                    current_block = 6281126495347172768;
                    break;
                } else {
                    current_block = 6174974146017752131;
                    break;
                }
            }
            19 => {
                if 0 != shift_mod {
                    current_block = 7990025728955927862;
                    break;
                } else {
                    current_block = 2516253395664191498;
                    break;
                }
            }
            20 => {
                if 0 != shift_mod {
                    current_block = 7018308795614528254;
                    break;
                } else {
                    current_block = 17233182392562552756;
                    break;
                }
            }
            17 => {
                if 0 != shift_mod {
                    current_block = 2520131295878969859;
                    break;
                } else {
                    current_block = 11441799814184323368;
                    break;
                }
            }
            18 => {
                if 0 != shift_mod {
                    current_block = 9437013279121998969;
                    break;
                } else {
                    current_block = 7494008139977416618;
                    break;
                }
            }
            0 | 2 | 4 | 1 | 5 | 7 | 8 | 9 | 30 | _ => {
                current_block = 6281126495347172768;
                break;
            }
        }
    }
    match current_block {
        10886091980245723256 => {
            /* if currently there's a selection,
             * move cursor to start of selection */
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_first(state);
            } else if (*state).cursor > 0i32 {
                (*state).cursor -= 1
            }
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        10692455896603418738 => {
            nk_textedit_prep_selection_at_cursor(state);
            current_block = 2604890879466389055;
        }
        6174974146017752131 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_delete_selection(state);
            } else {
                nk_textedit_clamp(state);
                if (*state).cursor > 0i32 {
                    nk_textedit_delete(state, (*state).cursor - 1i32, 1i32);
                    (*state).cursor -= 1
                }
            }
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        7990025728955927862 => {
            nk_textedit_prep_selection_at_cursor(state);
            (*state).select_end = 0i32;
            (*state).cursor = (*state).select_end;
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        1836292691772056875 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_first(state);
                current_block = 2604890879466389055;
            } else {
                current_block = 2604890879466389055;
            }
        }
        15619007995458559411 => {
            nk_textedit_clamp(state);
            nk_textedit_prep_selection_at_cursor(state);
            /* move selection left */
            if (*state).select_end > 0i32 {
                (*state).select_end -= 1
            }
            (*state).cursor = (*state).select_end;
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        9437013279121998969 => {
            let mut find_3: TextFind = TextFind {
                x: 0.,
                y: 0.,
                height: 0.,
                first_char: 0,
                length: 0,
                prev_first: 0,
            };
            nk_textedit_clamp(state);
            nk_textedit_prep_selection_at_cursor(state);
            nk_textedit_find_charpos(
                &mut find_3,
                state,
                (*state).cursor,
                (*state).single_line as Int,
                font,
                row_height,
            );
            (*state).has_preferred_x = 0i32 as Uchar;
            (*state).cursor = find_3.first_char + find_3.length;
            if find_3.length > 0i32
                && nk_str_rune_at(&mut (*state).string, (*state).cursor - 1i32)
                    == '\n' as i32 as Uint
            {
                (*state).cursor -= 1
            }
            (*state).select_end = (*state).cursor;
            current_block = 6281126495347172768;
        }
        8236137900636309791 => {
            if !((*state).select_start != (*state).select_end) {
                nk_textedit_prep_selection_at_cursor(state);
            }
            (*state).cursor = nk_textedit_move_to_word_previous(state);
            (*state).select_end = (*state).cursor;
            nk_textedit_clamp(state);
            current_block = 6281126495347172768;
        }
        7175849428784450219 => {
            if !((*state).select_start != (*state).select_end) {
                nk_textedit_prep_selection_at_cursor(state);
            }
            (*state).cursor = nk_textedit_move_to_word_next(state);
            (*state).select_end = (*state).cursor;
            nk_textedit_clamp(state);
            current_block = 6281126495347172768;
        }
        7494008139977416618 => {
            let mut find_4: TextFind = TextFind {
                x: 0.,
                y: 0.,
                height: 0.,
                first_char: 0,
                length: 0,
                prev_first: 0,
            };
            nk_textedit_clamp(state);
            nk_textedit_move_to_first(state);
            nk_textedit_find_charpos(
                &mut find_4,
                state,
                (*state).cursor,
                (*state).single_line as Int,
                font,
                row_height,
            );
            (*state).has_preferred_x = 0i32 as Uchar;
            (*state).cursor = find_4.first_char + find_4.length;
            if find_4.length > 0i32
                && nk_str_rune_at(&mut (*state).string, (*state).cursor - 1i32)
                    == '\n' as i32 as Uint
            {
                (*state).cursor -= 1;
                current_block = 6281126495347172768;
            } else {
                current_block = 6281126495347172768;
            }
        }
        5399440093318478209 => {
            /* if currently there's a selection,
             * move cursor to end of selection */
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_last(state);
            } else {
                (*state).cursor += 1
            }
            nk_textedit_clamp(state);
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        18386322304582297246 => {
            nk_textedit_prep_selection_at_cursor(state);
            current_block = 7172762164747879670;
        }
        224731115979188411 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_last(state);
            } else {
                (*state).cursor = nk_textedit_move_to_word_next(state);
                nk_textedit_clamp(state);
            }
            current_block = 6281126495347172768;
        }
        11441799814184323368 => {
            let mut find_2: TextFind = TextFind {
                x: 0.,
                y: 0.,
                height: 0.,
                first_char: 0,
                length: 0,
                prev_first: 0,
            };
            if 0 != (*state).string.len && (*state).cursor == (*state).string.len {
                (*state).cursor -= 1
            }
            nk_textedit_clamp(state);
            nk_textedit_move_to_first(state);
            nk_textedit_find_charpos(
                &mut find_2,
                state,
                (*state).cursor,
                (*state).single_line as Int,
                font,
                row_height,
            );
            (*state).cursor = find_2.first_char;
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        7018308795614528254 => {
            nk_textedit_prep_selection_at_cursor(state);
            (*state).select_end = (*state).string.len;
            (*state).cursor = (*state).select_end;
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        1847472278776910194 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_delete_selection(state);
            } else {
                let mut n: Int = (*state).string.len;
                if (*state).cursor < n {
                    nk_textedit_delete(state, (*state).cursor, 1i32);
                }
            }
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        11650488183268122163 => {
            nk_textedit_prep_selection_at_cursor(state);
            /* move selection right */
            (*state).select_end += 1;
            nk_textedit_clamp(state);
            (*state).cursor = (*state).select_end;
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        6669252993407410313 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_last(state);
                current_block = 7172762164747879670;
            } else {
                current_block = 7172762164747879670;
            }
        }
        2520131295878969859 => {
            let mut find_1: TextFind = TextFind {
                x: 0.,
                y: 0.,
                height: 0.,
                first_char: 0,
                length: 0,
                prev_first: 0,
            };
            nk_textedit_clamp(state);
            nk_textedit_prep_selection_at_cursor(state);
            if 0 != (*state).string.len && (*state).cursor == (*state).string.len {
                (*state).cursor -= 1
            }
            nk_textedit_find_charpos(
                &mut find_1,
                state,
                (*state).cursor,
                (*state).single_line as Int,
                font,
                row_height,
            );
            (*state).select_end = find_1.first_char;
            (*state).cursor = (*state).select_end;
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        12039483399334584727 => {
            if (*state).select_start != (*state).select_end {
                nk_textedit_move_to_first(state);
            } else {
                (*state).cursor = nk_textedit_move_to_word_previous(state);
                nk_textedit_clamp(state);
            }
            current_block = 6281126495347172768;
        }
        16658872821858055392 => {
            (*state).mode = NK_TEXT_EDIT_MODE_INSERT as Int as Uchar;
            current_block = 6281126495347172768;
        }
        820271813250567934 => {
            (*state).mode = NK_TEXT_EDIT_MODE_VIEW as Int as Uchar;
            current_block = 6281126495347172768;
        }
        17233182392562552756 => {
            (*state).cursor = (*state).string.len;
            (*state).select_end = 0i32;
            (*state).select_start = (*state).select_end;
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        17179679302217393232 => {
            (*state).mode = NK_TEXT_EDIT_MODE_REPLACE as Int as Uchar;
            current_block = 6281126495347172768;
        }
        2516253395664191498 => {
            (*state).select_end = 0i32;
            (*state).select_start = (*state).select_end;
            (*state).cursor = (*state).select_start;
            (*state).has_preferred_x = 0i32 as Uchar;
            current_block = 6281126495347172768;
        }
        _ => {}
    }
    match current_block {
        7172762164747879670 => {
            /* compute current position of cursor point */
            nk_textedit_clamp(state);
            nk_textedit_find_charpos(
                &mut find,
                state,
                (*state).cursor,
                (*state).single_line as Int,
                font,
                row_height,
            );
            /* now find character position down a row */
            if 0 != find.length {
                let mut x: f32 = 0.;
                let mut goal_x: f32 = if 0 != (*state).has_preferred_x as Int {
                    (*state).preferred_x
                } else {
                    find.x
                };
                let mut start: Int = find.first_char + find.length;
                (*state).cursor = start;
                nk_textedit_layout_row(&mut row, state, (*state).cursor, row_height, font);
                x = row.x0;
                i = 0i32;
                while i < row.num_chars && x < row.x1 {
                    let mut dx: f32 = nk_textedit_get_width(state, start, i, font);
                    x += dx;
                    if x > goal_x {
                        break;
                    }
                    (*state).cursor += 1;
                    i += 1
                }
                nk_textedit_clamp(state);
                (*state).has_preferred_x = 1i32 as Uchar;
                (*state).preferred_x = goal_x;
                if 0 != sel {
                    (*state).select_end = (*state).cursor
                }
            }
        }
        2604890879466389055 => {
            /* compute current position of cursor point */
            nk_textedit_clamp(state);
            nk_textedit_find_charpos(
                &mut find_0,
                state,
                (*state).cursor,
                (*state).single_line as Int,
                font,
                row_height,
            );
            /* can only go up if there's a previous row */
            if find_0.prev_first != find_0.first_char {
                /* now find character position up a row */
                let mut x_0: f32 = 0.;
                let mut goal_x_0: f32 = if 0 != (*state).has_preferred_x as Int {
                    (*state).preferred_x
                } else {
                    find_0.x
                };
                (*state).cursor = find_0.prev_first;
                nk_textedit_layout_row(&mut row_0, state, (*state).cursor, row_height, font);
                x_0 = row_0.x0;
                i_0 = 0i32;
                while i_0 < row_0.num_chars && x_0 < row_0.x1 {
                    let mut dx_0: f32 = nk_textedit_get_width(state, find_0.prev_first, i_0, font);
                    x_0 += dx_0;
                    if x_0 > goal_x_0 {
                        break;
                    }
                    (*state).cursor += 1;
                    i_0 += 1
                }
                nk_textedit_clamp(state);
                (*state).has_preferred_x = 1i32 as Uchar;
                (*state).preferred_x = goal_x_0;
                if 0 != sel_0 {
                    (*state).select_end = (*state).cursor
                }
            }
        }
        _ => {}
    };
}

unsafe fn nk_textedit_find_charpos(
    mut find: *mut TextFind,
    mut state: *mut TextEdit,
    mut n: Int,
    mut single_line: Int,
    mut font: *const UserFont,
    mut row_height: f32,
) -> () {
    /* find the x/y location of a character, and remember info about the previous
     * row in case we get a move-up event (for page up, we'll have to rescan) */
    let mut r: TextEditRow = TextEditRow {
        x0: 0.,
        x1: 0.,
        baseline_y_delta: 0.,
        ymin: 0.,
        ymax: 0.,
        num_chars: 0,
    };
    let mut prev_start: Int = 0i32;
    let mut z: Int = (*state).string.len;
    let mut i: Int = 0i32;
    let mut first: Int = 0;
    nk_zero(
        &mut r as *mut TextEditRow as *mut Void,
        mem::size_of::<TextEditRow>() as Ulong,
    );
    if n == z {
        /* if it's at the end, then find the last line -- simpler than trying to
        explicitly handle this case in the regular code */
        nk_textedit_layout_row(&mut r, state, 0i32, row_height, font);
        if 0 != single_line {
            (*find).first_char = 0i32;
            (*find).length = z
        } else {
            while i < z {
                prev_start = i;
                i += r.num_chars;
                nk_textedit_layout_row(&mut r, state, i, row_height, font);
            }
            (*find).first_char = i;
            (*find).length = r.num_chars
        }
        (*find).x = r.x1;
        (*find).y = r.ymin;
        (*find).height = r.ymax - r.ymin;
        (*find).prev_first = prev_start;
        return;
    } else {
        /* search rows to find the one that straddles character n */
        (*find).y = 0i32 as f32;
        loop {
            nk_textedit_layout_row(&mut r, state, i, row_height, font);
            if n < i + r.num_chars {
                break;
            }
            prev_start = i;
            i += r.num_chars;
            (*find).y += r.baseline_y_delta
        }
        first = i;
        (*find).first_char = first;
        (*find).length = r.num_chars;
        (*find).height = r.ymax - r.ymin;
        (*find).prev_first = prev_start;
        /* now scan to find xpos */
        (*find).x = r.x0;
        i = 0i32;
        while first + i < n {
            (*find).x += nk_textedit_get_width(state, first, i, font);
            i += 1
        }
        return;
    };
}
unsafe fn nk_textedit_get_width(
    mut edit: *const TextEdit,
    mut line_start: Int,
    mut char_id: Int,
    mut font: *const UserFont,
) -> f32 {
    let mut len: Int = 0i32;
    let mut unicode: Rune = 0i32 as Rune;
    let mut str: *const Char = nk_str_at_const(
        &(*edit).string,
        line_start + char_id,
        &mut unicode,
        &mut len,
    );
    return (*font).width.expect("non-null function pointer")(
        (*font).userdata,
        (*font).height,
        str,
        len,
    );
}
unsafe fn nk_textedit_layout_row(
    mut r: *mut TextEditRow,
    mut edit: *mut TextEdit,
    mut line_start_id: Int,
    mut row_height: f32,
    mut font: *const UserFont,
) -> () {
    let mut l: Int = 0;
    let mut glyphs: Int = 0i32;
    let mut unicode: Rune = 0;
    let mut remaining: *const Char = 0 as *const Char;
    let mut len: Int = nk_str_len_char(&mut (*edit).string);
    let mut end: *const Char = nk_str_get_const(&mut (*edit).string).offset(len as isize);
    let mut text: *const Char =
        nk_str_at_const(&mut (*edit).string, line_start_id, &mut unicode, &mut l);
    let size: Point = nk_text_calculate_text_bounds(
        font,
        text,
        text.ptr_offset_to(end).expect("bad offset_to") as Long as Int,
        row_height,
        &mut remaining,
        0 as *mut Point,
        &mut glyphs,
        NK_STOP_ON_NEW_LINE as Int,
    );
    (*r).x0 = 0.0f32;
    (*r).x1 = size.x;
    (*r).baseline_y_delta = size.y;
    (*r).ymin = 0.0f32;
    (*r).ymax = size.y;
    (*r).num_chars = glyphs;
}
unsafe fn nk_textedit_move_to_first(mut state: *mut TextEdit) -> () {
    /* move cursor to first character of selection */
    if (*state).select_start != (*state).select_end {
        nk_textedit_sortselection(state);
        (*state).cursor = (*state).select_start;
        (*state).select_end = (*state).select_start;
        (*state).has_preferred_x = 0i32 as Uchar
    };
}
unsafe fn nk_textedit_sortselection(mut state: *mut TextEdit) -> () {
    /* canonicalize the selection so start <= end */
    if (*state).select_end < (*state).select_start {
        let mut temp: Int = (*state).select_end;
        (*state).select_end = (*state).select_start;
        (*state).select_start = temp
    };
}
unsafe fn nk_textedit_prep_selection_at_cursor(mut state: *mut TextEdit) -> () {
    /* update selection and cursor to match each other */
    if !((*state).select_start != (*state).select_end) {
        (*state).select_end = (*state).cursor;
        (*state).select_start = (*state).select_end
    } else {
        (*state).cursor = (*state).select_end
    };
}
unsafe fn nk_textedit_move_to_last(mut state: *mut TextEdit) -> () {
    /* move cursor to last character of selection */
    if (*state).select_start != (*state).select_end {
        nk_textedit_sortselection(state);
        nk_textedit_clamp(state);
        (*state).cursor = (*state).select_end;
        (*state).select_start = (*state).select_end;
        (*state).has_preferred_x = 0i32 as Uchar
    };
}
unsafe fn nk_textedit_move_to_word_next(mut state: *mut TextEdit) -> Int {
    let len: Int = (*state).string.len;
    let mut c: Int = (*state).cursor + 1i32;
    while c < len && 0 == nk_is_word_boundary(state, c) {
        c += 1
    }
    if c > len {
        c = len
    }
    return c;
}
unsafe fn nk_is_word_boundary(mut state: *mut TextEdit, mut idx: Int) -> Int {
    let mut len: Int = 0;
    let mut c: Rune = 0;
    if idx <= 0i32 {
        return 1i32;
    } else if nk_str_at_rune(&mut (*state).string, idx, &mut c, &mut len).is_null() {
        return 1i32;
    } else {
        return (c == ' ' as i32 as Uint
            || c == '\t' as i32 as Uint
            || c == 12288i32 as Uint
            || c == ',' as i32 as Uint
            || c == ';' as i32 as Uint
            || c == '(' as i32 as Uint
            || c == ')' as i32 as Uint
            || c == '{' as i32 as Uint
            || c == '}' as i32 as Uint
            || c == '[' as i32 as Uint
            || c == ']' as i32 as Uint
            || c == '|' as i32 as Uint) as Int;
    };
}
unsafe fn nk_textedit_move_to_word_previous(mut state: *mut TextEdit) -> Int {
    let mut c: Int = (*state).cursor - 1i32;
    while c >= 0i32 && 0 == nk_is_word_boundary(state, c) {
        c -= 1
    }
    if c < 0i32 {
        c = 0i32
    }
    return c;
}

pub unsafe fn nk_textedit_select_all(mut state: *mut TextEdit) -> () {
    (*state).select_start = 0i32;
    (*state).select_end = (*state).string.len;
}

pub unsafe fn nk_textedit_redo(mut state: *mut TextEdit) -> () {
    let mut s: *mut TextUndoState = &mut (*state).undo as *mut TextUndoState;
    let mut u: *mut TextUndoRecord = 0 as *mut TextUndoRecord;
    let mut r: TextUndoRecord = TextUndoRecord {
        where_0: 0,
        insert_length: 0,
        delete_length: 0,
        char_storage: 0,
    };
    if (*s).redo_point as Int == 99i32 {
        return;
    } else {
        /* we need to do two things: apply the redo record, and create an undo record */
        u = &mut (*s).undo_rec[(*s).undo_point as usize] as *mut TextUndoRecord;
        r = (*s).undo_rec[(*s).redo_point as usize];
        /* we KNOW there must be room for the undo record, because the redo record
    was derived from an undo record */
        (*u).delete_length = r.insert_length;
        (*u).insert_length = r.delete_length;
        (*u).where_0 = r.where_0;
        (*u).char_storage = -1i32 as Short;
        if 0 != r.delete_length {
            /* the redo record requires us to delete characters, so the undo record
        needs to store the characters */
            if (*s).undo_char_point as Int + (*u).insert_length as Int > (*s).redo_char_point as Int
            {
                (*u).insert_length = 0i32 as Short;
                (*u).delete_length = 0i32 as Short
            } else {
                let mut i: Int = 0;
                (*u).char_storage = (*s).undo_char_point;
                (*s).undo_char_point =
                    ((*s).undo_char_point as Int + (*u).insert_length as Int) as Short;
                /* now save the characters */
                i = 0i32;
                while i < (*u).insert_length as Int {
                    (*s).undo_char[((*u).char_storage as Int + i) as usize] =
                        nk_str_rune_at(&mut (*state).string, (*u).where_0 + i);
                    i += 1
                }
            }
            nk_str_delete_runes(&mut (*state).string, r.where_0, r.delete_length as Int);
        }
        if 0 != r.insert_length {
            /* easy case: need to insert n characters */
            nk_str_insert_text_runes(
                &mut (*state).string,
                r.where_0,
                &mut (*s).undo_char[r.char_storage as usize],
                r.insert_length as Int,
            );
        }
        (*state).cursor = r.where_0 + r.insert_length as Int;
        (*s).undo_point += 1;
        (*s).redo_point += 1;
        return;
    };
}

pub unsafe fn nk_str_insert_text_runes(
    mut str: *mut Str,
    mut pos: Int,
    mut runes: *const Rune,
    mut len: Int,
) -> Int {
    let mut i: Int = 0i32;
    let mut byte_len: Int = 0i32;
    let mut glyph: Glyph = [0; 4];
    if str.is_null() || runes.is_null() || 0 == len {
        return 0i32;
    } else {
        i = 0i32;
        while i < len {
            byte_len = nk_utf_encode(*runes.offset(i as isize), glyph.as_mut_ptr(), 4i32);
            if 0 == byte_len {
                break;
            }
            nk_str_insert_at_rune(str, pos + i, glyph.as_mut_ptr(), byte_len);
            i += 1
        }
        return len;
    };
}

pub unsafe fn nk_textedit_undo(mut state: *mut TextEdit) -> () {
    let mut s: *mut TextUndoState = &mut (*state).undo as *mut TextUndoState;
    let mut u: TextUndoRecord = TextUndoRecord {
        where_0: 0,
        insert_length: 0,
        delete_length: 0,
        char_storage: 0,
    };
    let mut r: *mut TextUndoRecord = 0 as *mut TextUndoRecord;
    if (*s).undo_point as Int == 0i32 {
        return;
    } else {
        /* we need to do two things: apply the undo record, and create a redo record */
        u = (*s).undo_rec[((*s).undo_point as Int - 1i32) as usize];
        r = &mut (*s).undo_rec[((*s).redo_point as Int - 1i32) as usize] as *mut TextUndoRecord;
        (*r).char_storage = -1i32 as Short;
        (*r).insert_length = u.delete_length;
        (*r).delete_length = u.insert_length;
        (*r).where_0 = u.where_0;
        if 0 != u.delete_length {
            /*   if the undo record says to delete characters, then the redo record will
            need to re-insert the characters that get deleted, so we need to store
            them.
            there are three cases:
                - there's enough room to store the characters
                - characters stored for *redoing* don't leave room for redo
                - characters stored for *undoing* don't leave room for redo
            if the last is true, we have to bail */
            if (*s).undo_char_point as Int + u.delete_length as Int >= 999i32 {
                /* the undo records take up too much character space; there's no space
                 * to store the redo characters */
                (*r).insert_length = 0i32 as Short
            } else {
                let mut i: Int = 0;
                /* there's definitely room to store the characters eventually */
                while (*s).undo_char_point as Int + u.delete_length as Int
                    > (*s).redo_char_point as Int
                {
                    /* there's currently not enough room, so discard a redo record */
                    nk_textedit_discard_redo(s);
                    /* should never happen: */
                    if !((*s).redo_point as Int == 99i32) {
                        continue;
                    }
                    return;
                }
                r = &mut (*s).undo_rec[((*s).redo_point as Int - 1i32) as usize]
                    as *mut TextUndoRecord;
                (*r).char_storage = ((*s).redo_char_point as Int - u.delete_length as Int) as Short;
                (*s).redo_char_point =
                    ((*s).redo_char_point as Int - u.delete_length as Int) as Short;
                /* now save the characters */
                i = 0i32;
                while i < u.delete_length as Int {
                    (*s).undo_char[((*r).char_storage as Int + i) as usize] =
                        nk_str_rune_at(&mut (*state).string, u.where_0 + i);
                    i += 1
                }
            }
            /* now we can carry out the deletion */
            nk_str_delete_runes(&mut (*state).string, u.where_0, u.delete_length as Int);
        }
        /* check type of recorded action: */
        if 0 != u.insert_length {
            /* easy case: was a deletion, so we need to insert n characters */
            nk_str_insert_text_runes(
                &mut (*state).string,
                u.where_0,
                &mut (*s).undo_char[u.char_storage as usize],
                u.insert_length as Int,
            );
            (*s).undo_char_point = ((*s).undo_char_point as Int - u.insert_length as Int) as Short
        }
        (*state).cursor = (u.where_0 + u.insert_length as Int) as Short as Int;
        (*s).undo_point -= 1;
        (*s).redo_point -= 1;
        return;
    };
}
unsafe fn nk_textedit_discard_redo(mut state: *mut TextUndoState) -> () {
    /*  discard the oldest entry in the redo list--it's bad if this
    ever happens, but because undo & redo have to store the actual
    characters in different cases, the redo character buffer can
    fill up even though the undo buffer didn't */
    let mut num: Size = 0;
    let mut k: Int = 99i32 - 1i32;
    if (*state).redo_point as Int <= k {
        /* if the k'th undo state has characters, clean those up */
        if (*state).undo_rec[k as usize].char_storage as Int >= 0i32 {
            let mut n: Int = (*state).undo_rec[k as usize].insert_length as Int;
            let mut i: Int = 0;
            /* delete n characters from all other records */
            (*state).redo_char_point = ((*state).redo_char_point as Int + n) as Short;
            num = (999i32 - (*state).redo_char_point as Int) as Size;
            nk_memcopy(
                (*state)
                    .undo_char
                    .as_mut_ptr()
                    .offset((*state).redo_char_point as Int as isize) as *mut Void,
                (*state)
                    .undo_char
                    .as_mut_ptr()
                    .offset((*state).redo_char_point as Int as isize)
                    .offset(-(n as isize)) as *const Void,
                num.wrapping_mul(mem::size_of::<Char>() as Ulong),
            );
            i = (*state).redo_point as Int;
            while i < k {
                if (*state).undo_rec[i as usize].char_storage as Int >= 0i32 {
                    (*state).undo_rec[i as usize].char_storage =
                        ((*state).undo_rec[i as usize].char_storage as Int + n) as Short
                }
                i += 1
            }
        }
        (*state).redo_point += 1;
        num = (99i32 - (*state).redo_point as Int) as Size;
        if 0 != num {
            nk_memcopy(
                (*state)
                    .undo_rec
                    .as_mut_ptr()
                    .offset((*state).redo_point as Int as isize)
                    .offset(-1isize) as *mut Void,
                (*state)
                    .undo_rec
                    .as_mut_ptr()
                    .offset((*state).redo_point as Int as isize) as *const Void,
                num.wrapping_mul(mem::size_of::<TextUndoRecord>() as Ulong),
            );
        }
    };
}
unsafe fn nk_textedit_drag(
    mut state: *mut TextEdit,
    mut x: f32,
    mut y: f32,
    mut font: *const UserFont,
    mut row_height: f32,
) -> () {
    /* API drag: on mouse drag, move the cursor and selection endpoint
     * to the clicked location */
    let mut p: Int = nk_textedit_locate_coord(state, x, y, font, row_height);
    if (*state).select_start == (*state).select_end {
        (*state).select_start = (*state).cursor
    }
    (*state).select_end = p;
    (*state).cursor = (*state).select_end;
}
unsafe fn nk_textedit_locate_coord(
    mut edit: *mut TextEdit,
    mut x: f32,
    mut y: f32,
    mut font: *const UserFont,
    mut row_height: f32,
) -> Int {
    let mut r: TextEditRow = TextEditRow {
        x0: 0.,
        x1: 0.,
        baseline_y_delta: 0.,
        ymin: 0.,
        ymax: 0.,
        num_chars: 0,
    };
    let mut n: Int = (*edit).string.len;
    let mut base_y: f32 = 0i32 as f32;
    let mut prev_x: f32 = 0.;
    let mut i: Int = 0i32;
    let mut k: Int = 0;
    r.x1 = 0i32 as f32;
    r.x0 = r.x1;
    r.ymax = 0i32 as f32;
    r.ymin = r.ymax;
    r.num_chars = 0i32;
    /* search rows to find one that straddles 'y' */
    while i < n {
        nk_textedit_layout_row(&mut r, edit, i, row_height, font);
        if r.num_chars <= 0i32 {
            return n;
        } else if i == 0i32 && y < base_y + r.ymin {
            return 0i32;
        } else {
            if y < base_y + r.ymax {
                break;
            }
            i += r.num_chars;
            base_y += r.baseline_y_delta
        }
    }
    /* below all text, return 'after' last character */
    if i >= n {
        return n;
    } else if x < r.x0 {
        return i;
    } else {
        /* check if it's before the end of the line */
        if x < r.x1 {
            /* search characters in row for one that straddles 'x' */
            k = i;
            prev_x = r.x0;
            i = 0i32;
            while i < r.num_chars {
                let mut w: f32 = nk_textedit_get_width(edit, k, i, font);
                if x < prev_x + w {
                    if x < prev_x + w / 2i32 as f32 {
                        return k + i;
                    } else {
                        return k + i + 1i32;
                    }
                } else {
                    prev_x += w;
                    i += 1
                }
            }
        }
        /* shouldn't happen, but if it does, fall through to end-of-line case */
        /* if the last character is a newline, return that.
         * otherwise return 'after' the last character */
        if nk_str_rune_at(&mut (*edit).string, i + r.num_chars - 1i32) == '\n' as i32 as Uint {
            return i + r.num_chars - 1i32;
        } else {
            return i + r.num_chars;
        }
    };
}
unsafe fn nk_textedit_click(
    mut state: *mut TextEdit,
    mut x: f32,
    mut y: f32,
    mut font: *const UserFont,
    mut row_height: f32,
) -> () {
    /* API click: on mouse down, move the cursor to the clicked location,
     * and reset the selection */
    (*state).cursor = nk_textedit_locate_coord(state, x, y, font, row_height);
    (*state).select_start = (*state).cursor;
    (*state).select_end = (*state).cursor;
    (*state).has_preferred_x = 0i32 as Uchar;
}
unsafe fn nk_textedit_clear_state(
    mut state: *mut TextEdit,
    mut type_0: TextEditType,
    mut filter: PluginFilter,
) -> () {
    /* reset the state to default */
    (*state).undo.undo_point = 0i32 as Short;
    (*state).undo.undo_char_point = 0i32 as Short;
    (*state).undo.redo_point = 99i32 as Short;
    (*state).undo.redo_char_point = 999i32 as Short;
    (*state).select_start = 0i32;
    (*state).select_end = (*state).select_start;
    (*state).cursor = 0i32;
    (*state).has_preferred_x = 0i32 as Uchar;
    (*state).preferred_x = 0i32 as f32;
    (*state).cursor_at_end_of_line = 0i32 as Uchar;
    (*state).initialized = 1i32 as Uchar;
    (*state).single_line =
        (type_0 as Uint == NK_TEXT_EDIT_SINGLE_LINE as Int as Uint) as Int as Uchar;
    (*state).mode = NK_TEXT_EDIT_MODE_VIEW as Int as Uchar;
    (*state).filter = filter;
    (*state).scrollbar = Point::new(0i32 as f32, 0i32 as f32);
}
unsafe fn nk_draw_property(
    mut out: *mut CommandBuffer,
    mut style: *const StyleProperty,
    mut bounds: *const Rect,
    mut label: *const Rect,
    mut state: Flags,
    mut name: *const Char,
    mut len: Int,
    mut font: *const UserFont,
) -> () {
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    let mut background: *const StyleItem = 0 as *const StyleItem;
    /* select correct background and text color */
    if 0 != state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
        background = &(*style).active as *const StyleItem;
        text.text = (*style).label_active
    } else if 0 != state & NK_WIDGET_STATE_HOVER as Int as Uint {
        background = &(*style).hover as *const StyleItem;
        text.text = (*style).label_hover
    } else {
        background = &(*style).normal as *const StyleItem;
        text.text = (*style).label_normal
    }
    /* draw background */
    if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
        nk_draw_image(out, *bounds, &(*background).data.image, nk_white);
        text.background = nk_rgba(0i32, 0i32, 0i32, 0i32)
    } else {
        text.background = (*background).data.color;
        nk_fill_rect(out, *bounds, (*style).rounding, (*background).data.color);
        nk_stroke_rect(
            out,
            *bounds,
            (*style).rounding,
            (*style).border,
            (*background).data.color,
        );
    }
    /* draw label */
    text.padding = Point::new(0i32 as f32, 0i32 as f32);
    nk_widget_text(
        out,
        *label,
        name,
        len,
        &mut text,
        NK_TEXT_CENTERED as Int as Flags,
        font,
    );
}
unsafe fn nk_property_behavior(
    mut ws: *mut Flags,
    mut in_0: *const Input,
    mut property: Rect,
    mut label: Rect,
    mut edit: Rect,
    mut empty: Rect,
    mut state: *mut Int,
    mut variant: *mut PropertyVariant,
    mut inc_per_pixel: f32,
) -> () {
    if !in_0.is_null() && *state == NK_PROPERTY_DEFAULT as Int {
        if 0 != ButtonBehavior(ws, edit, in_0, NK_BUTTON_DEFAULT) {
            *state = NK_PROPERTY_EDIT as Int
        } else if 0
            != nk_input_is_mouse_click_down_in_rect(in_0, NK_BUTTON_LEFT, label, nk_true as Int)
        {
            *state = NK_PROPERTY_DRAG as Int
        } else if 0
            != nk_input_is_mouse_click_down_in_rect(in_0, NK_BUTTON_LEFT, empty, nk_true as Int)
        {
            *state = NK_PROPERTY_DRAG as Int
        }
    }
    if *state == NK_PROPERTY_DRAG as Int {
        nk_drag_behavior(ws, in_0, property, variant, inc_per_pixel);
        if 0 == *ws & NK_WIDGET_STATE_ACTIVED as Int as Uint {
            *state = NK_PROPERTY_DEFAULT as Int
        }
    };
}
unsafe fn nk_drag_behavior(
    mut state: *mut Flags,
    mut in_0: *const Input,
    mut drag: Rect,
    mut variant: *mut PropertyVariant,
    mut inc_per_pixel: f32,
) -> () {
    let mut left_mouse_down: Int =
        (!in_0.is_null() && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down) as Int;
    let mut left_mouse_click_in_cursor: Int = (!in_0.is_null()
        && 0 != nk_input_has_mouse_click_down_in_rect(in_0, NK_BUTTON_LEFT, drag, nk_true as Int))
        as Int;
    if 0 != *state & NK_WIDGET_STATE_MODIFIED as Int as Uint {
        *state = (NK_WIDGET_STATE_INACTIVE as Int | NK_WIDGET_STATE_MODIFIED as Int) as Flags
    } else {
        *state = NK_WIDGET_STATE_INACTIVE as Int as Flags
    }
    if 0 != nk_input_is_mouse_hovering_rect(in_0, drag) {
        *state = NK_WIDGET_STATE_HOVERED as Int as Flags
    }
    if 0 != left_mouse_down && 0 != left_mouse_click_in_cursor {
        let mut delta: f32 = 0.;
        let mut pixels: f32 = 0.;
        pixels = (*in_0).mouse.delta.x;
        delta = pixels * inc_per_pixel;
        match (*variant).kind as Uint {
            0 => {
                (*variant).value.i = (*variant).value.i + delta as Int;
                (*variant).value.i = if if (*variant).value.i < (*variant).max_value.i {
                    (*variant).value.i
                } else {
                    (*variant).max_value.i
                } < (*variant).min_value.i
                {
                    (*variant).min_value.i
                } else if (*variant).value.i < (*variant).max_value.i {
                    (*variant).value.i
                } else {
                    (*variant).max_value.i
                }
            }
            1 => {
                (*variant).value.f = (*variant).value.f + delta;
                (*variant).value.f = if if (*variant).value.f < (*variant).max_value.f {
                    (*variant).value.f
                } else {
                    (*variant).max_value.f
                } < (*variant).min_value.f
                {
                    (*variant).min_value.f
                } else if (*variant).value.f < (*variant).max_value.f {
                    (*variant).value.f
                } else {
                    (*variant).max_value.f
                }
            }
            2 => {
                (*variant).value.d = (*variant).value.d + delta as f64;
                (*variant).value.d = if if (*variant).value.d < (*variant).max_value.d {
                    (*variant).value.d
                } else {
                    (*variant).max_value.d
                } < (*variant).min_value.d
                {
                    (*variant).min_value.d
                } else if (*variant).value.d < (*variant).max_value.d {
                    (*variant).value.d
                } else {
                    (*variant).max_value.d
                }
            }
            _ => {}
        }
        *state = NK_WIDGET_STATE_ACTIVE as Int as Flags
    }
    if 0 != *state & NK_WIDGET_STATE_HOVER as Int as Uint
        && 0 == nk_input_is_mouse_prev_hovering_rect(in_0, drag)
    {
        *state |= NK_WIDGET_STATE_ENTERED as Int as Uint
    } else if 0 != nk_input_is_mouse_prev_hovering_rect(in_0, drag) {
        *state |= NK_WIDGET_STATE_LEFT as Int as Uint
    };
}

pub unsafe fn nk_input_is_mouse_click_down_in_rect(
    mut i: *const Input,
    mut id: Buttons,
    mut b: Rect,
    mut down: Int,
) -> Int {
    let mut btn: *const MouseButton = 0 as *const MouseButton;
    if i.is_null() {
        return nk_false as Int;
    } else {
        btn = &(*i).mouse.buttons[id as usize] as *const MouseButton;
        return if 0 != nk_input_has_mouse_click_down_in_rect(i, id, b, down) && 0 != (*btn).clicked
        {
            nk_true as Int
        } else {
            nk_false as Int
        };
    };
}
unsafe fn nk_dtoa(mut s: *mut Char, mut n: f64) -> *mut Char {
    let mut t: f64 = 0.;
    let mut useExp: Int = 0i32;
    let mut digit: Int = 0i32;
    let mut m: Int = 0i32;
    let mut m1: Int = 0i32;
    let mut c: *mut Char = s;
    let mut neg: Int = 0i32;
    if s.is_null() {
        return 0 as *mut Char;
    } else if n == 0.0f64 {
        *s.offset(0isize) = '0' as i32 as Char;
        *s.offset(1isize) = '\u{0}' as i32 as Char;
        return s;
    } else {
        neg = (n < 0i32 as f64) as Int;
        if 0 != neg {
            n = -n
        }
        /* calculate magnitude */
        m = nk_log10(n);
        useExp = (m >= 14i32 || 0 != neg && m >= 9i32 || m <= -9i32) as Int;
        if 0 != neg {
            let fresh24 = c;
            c = c.offset(1);
            *fresh24 = '-' as i32 as Char
        }
        /* set up for scientific notation */
        if 0 != useExp {
            if m < 0i32 {
                m -= 1i32
            }
            n = n / nk_pow(10.0f64, m);
            m1 = m;
            m = 0i32
        }
        if (m as f64) < 1.0f64 {
            m = 0i32
        }
        /* convert the number */
        while n > 1e-14f64 || m >= 0i32 {
            let mut weight: f64 = nk_pow(10.0f64, m);
            if weight > 0i32 as f64 {
                t = n / weight;
                digit = nk_ifloord(t);
                n -= digit as f64 * weight;
                let fresh25 = c;
                c = c.offset(1);
                *fresh25 = ('0' as i32 + digit as Char as Int) as Char
            }
            if m == 0i32 && n > 0i32 as f64 {
                let fresh26 = c;
                c = c.offset(1);
                *fresh26 = '.' as i32 as Char
            }
            m -= 1
        }
        if 0 != useExp {
            let mut i: Int = 0;
            /* convert the exponent */
            let mut j: Int = 0;
            let fresh27 = c;
            c = c.offset(1);
            *fresh27 = 'e' as i32 as Char;
            if m1 > 0i32 {
                let fresh28 = c;
                c = c.offset(1);
                *fresh28 = '+' as i32 as Char
            } else {
                let fresh29 = c;
                c = c.offset(1);
                *fresh29 = '-' as i32 as Char;
                m1 = -m1
            }
            m = 0i32;
            while m1 > 0i32 {
                let fresh30 = c;
                c = c.offset(1);
                *fresh30 = ('0' as i32 + (m1 % 10i32) as Char as Int) as Char;
                m1 /= 10i32;
                m += 1
            }
            c = c.offset(-(m as isize));
            i = 0i32;
            j = m - 1i32;
            while i < j {
                /* swap without temporary */
                let ref mut fresh31 = *c.offset(i as isize);
                *fresh31 = (*fresh31 as Int ^ *c.offset(j as isize) as Int) as Char;
                let ref mut fresh32 = *c.offset(j as isize);
                *fresh32 = (*fresh32 as Int ^ *c.offset(i as isize) as Int) as Char;
                let ref mut fresh33 = *c.offset(i as isize);
                *fresh33 = (*fresh33 as Int ^ *c.offset(j as isize) as Int) as Char;
                i += 1;
                j -= 1
            }
            c = c.offset(m as isize)
        }
        *c = '\u{0}' as i32 as Char;
        return s;
    };
}
unsafe fn nk_pow(mut x: f64, mut n: Int) -> f64 {
    /*  check the sign of n */
    let mut r: f64 = 1i32 as f64;
    let mut plus: Int = (n >= 0i32) as Int;
    n = if 0 != plus { n } else { -n };
    while n > 0i32 {
        if n & 1i32 == 1i32 {
            r *= x
        }
        n /= 2i32;
        x *= x
    }
    return if 0 != plus { r } else { 1.0f64 / r };
}
unsafe fn nk_ifloord(mut x: f64) -> Int {
    x = (x as Int - if x < 0.0f64 { 1i32 } else { 0i32 }) as f64;
    return x as Int;
}
unsafe fn nk_log10(mut n: f64) -> Int {
    let mut neg: Int = 0;
    let mut ret: Int = 0;
    let mut exp: Int = 0i32;
    neg = if n < 0i32 as f64 { 1i32 } else { 0i32 };
    ret = if 0 != neg { -n as Int } else { n as Int };
    while ret / 10i32 > 0i32 {
        ret /= 10i32;
        exp += 1
    }
    if 0 != neg {
        exp = -exp
    }
    return exp;
}
unsafe fn nk_itoa(mut s: *mut Char, mut n: Long) -> *mut Char {
    let mut i: Long = 0i32 as Long;
    if n == 0i32 as Long {
        let fresh34 = i;
        i = i + 1;
        *s.offset(fresh34 as isize) = '0' as i32 as Char;
        *s.offset(i as isize) = 0i32 as Char;
        return s;
    } else {
        if n < 0i32 as Long {
            let fresh35 = i;
            i = i + 1;
            *s.offset(fresh35 as isize) = '-' as i32 as Char;
            n = -n
        }
        while n > 0i32 as Long {
            let fresh36 = i;
            i = i + 1;
            *s.offset(fresh36 as isize) = ('0' as i32 as Long + n % 10i32 as Long) as Char;
            n /= 10i32 as Long
        }
        *s.offset(i as isize) = 0i32 as Char;
        if *s.offset(0isize) as Int == '-' as i32 {
            s = s.offset(1isize)
        }
        nk_strrev_ascii(s);
        return s;
    };
}
unsafe fn nk_strrev_ascii(mut s: *mut Char) -> () {
    let mut len: Int = nk_strlen(s);
    let mut end: Int = len / 2i32;
    let mut i: Int = 0i32;
    let mut t: Char = 0;
    while i < end {
        t = *s.offset(i as isize);
        *s.offset(i as isize) = *s.offset((len - 1i32 - i) as isize);
        *s.offset((len - 1i32 - i) as isize) = t;
        i += 1
    }
}
unsafe fn nk_property_variant_int(
    mut value: Int,
    mut min_value: Int,
    mut max_value: Int,
    mut step: Int,
) -> PropertyVariant {
    let mut result: PropertyVariant = PropertyVariant {
        kind: NK_PROPERTY_INT,
        value: Property { i: 0 },
        min_value: Property { i: 0 },
        max_value: Property { i: 0 },
        step: Property { i: 0 },
    };
    result.kind = NK_PROPERTY_INT;
    result.value.i = value;
    result.min_value.i = min_value;
    result.max_value.i = max_value;
    result.step.i = step;
    return result;
}

pub unsafe fn nk_property_float(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut min: f32,
    mut val: *mut f32,
    mut max: f32,
    mut step: f32,
    mut inc_per_pixel: f32,
) -> () {
    let mut variant: PropertyVariant = PropertyVariant {
        kind: NK_PROPERTY_INT,
        value: Property { i: 0 },
        min_value: Property { i: 0 },
        max_value: Property { i: 0 },
        step: Property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() || val.is_null() {
        return;
    } else {
        variant = nk_property_variant_float(*val, min, max, step);
        Property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_FLOAT);
        *val = variant.value.f;
        return;
    };
}
unsafe fn nk_property_variant_float(
    mut value: f32,
    mut min_value: f32,
    mut max_value: f32,
    mut step: f32,
) -> PropertyVariant {
    let mut result: PropertyVariant = PropertyVariant {
        kind: NK_PROPERTY_INT,
        value: Property { i: 0 },
        min_value: Property { i: 0 },
        max_value: Property { i: 0 },
        step: Property { i: 0 },
    };
    result.kind = NK_PROPERTY_FLOAT;
    result.value.f = value;
    result.min_value.f = min_value;
    result.max_value.f = max_value;
    result.step.f = step;
    return result;
}

pub unsafe fn nk_property_double(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut min: f64,
    mut val: *mut f64,
    mut max: f64,
    mut step: f64,
    mut inc_per_pixel: f32,
) -> () {
    let mut variant: PropertyVariant = PropertyVariant {
        kind: NK_PROPERTY_INT,
        value: Property { i: 0 },
        min_value: Property { i: 0 },
        max_value: Property { i: 0 },
        step: Property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() || val.is_null() {
        return;
    } else {
        variant = nk_property_variant_double(*val, min, max, step);
        Property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_FLOAT);
        *val = variant.value.d;
        return;
    };
}
unsafe fn nk_property_variant_double(
    mut value: f64,
    mut min_value: f64,
    mut max_value: f64,
    mut step: f64,
) -> PropertyVariant {
    let mut result: PropertyVariant = PropertyVariant {
        kind: NK_PROPERTY_INT,
        value: Property { i: 0 },
        min_value: Property { i: 0 },
        max_value: Property { i: 0 },
        step: Property { i: 0 },
    };
    result.kind = NK_PROPERTY_DOUBLE;
    result.value.d = value;
    result.min_value.d = min_value;
    result.max_value.d = max_value;
    result.step.d = step;
    return result;
}

pub unsafe fn nk_propertyi(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut min: Int,
    mut val: Int,
    mut max: Int,
    mut step: Int,
    mut inc_per_pixel: f32,
) -> Int {
    let mut variant: PropertyVariant = PropertyVariant {
        kind: NK_PROPERTY_INT,
        value: Property { i: 0 },
        min_value: Property { i: 0 },
        max_value: Property { i: 0 },
        step: Property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() {
        return val;
    } else {
        variant = nk_property_variant_int(val, min, max, step);
        Property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_INT);
        val = variant.value.i;
        return val;
    };
}

pub unsafe fn nk_propertyf(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut min: f32,
    mut val: f32,
    mut max: f32,
    mut step: f32,
    mut inc_per_pixel: f32,
) -> f32 {
    let mut variant: PropertyVariant = PropertyVariant {
        kind: NK_PROPERTY_INT,
        value: Property { i: 0 },
        min_value: Property { i: 0 },
        max_value: Property { i: 0 },
        step: Property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() {
        return val;
    } else {
        variant = nk_property_variant_float(val, min, max, step);
        Property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_FLOAT);
        val = variant.value.f;
        return val;
    };
}

pub unsafe fn nk_propertyd(
    mut ctx: *mut Context,
    mut name: *const Char,
    mut min: f64,
    mut val: f64,
    mut max: f64,
    mut step: f64,
    mut inc_per_pixel: f32,
) -> f64 {
    let mut variant: PropertyVariant = PropertyVariant {
        kind: NK_PROPERTY_INT,
        value: Property { i: 0 },
        min_value: Property { i: 0 },
        max_value: Property { i: 0 },
        step: Property { i: 0 },
    };
    if ctx.is_null() || (*ctx).current.is_null() || name.is_null() {
        return val;
    } else {
        variant = nk_property_variant_double(val, min, max, step);
        Property(ctx, name, &mut variant, inc_per_pixel, NK_FILTER_FLOAT);
        val = variant.value.d;
        return val;
    };
}

pub unsafe fn nk_edit_string(
    mut ctx: *mut Context,
    mut flags: Flags,
    mut memory: *mut Char,
    mut len: *mut Int,
    mut max: Int,
    mut filter: PluginFilter,
) -> Flags {
    let mut hash: Hash = 0;
    let mut state: Flags = 0;
    let mut edit: *mut TextEdit = 0 as *mut TextEdit;
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() || memory.is_null() || len.is_null() {
        return 0i32 as Flags;
    } else {
        filter = if filter.is_none() {
            Some(nk_filter_default)
        } else {
            filter
        };
        win = (*ctx).current;
        hash = (*win).edit.seq;
        edit = &mut (*ctx).text_edit as *mut TextEdit;
        nk_textedit_clear_state(
            &mut (*ctx).text_edit,
            (if 0 != flags & NK_EDIT_MULTILINE as Int as Uint {
                NK_TEXT_EDIT_MULTI_LINE as Int
            } else {
                NK_TEXT_EDIT_SINGLE_LINE as Int
            }) as TextEditType,
            filter,
        );
        if 0 != (*win).edit.active && hash == (*win).edit.name {
            if 0 != flags & NK_EDIT_NO_CURSOR as Int as Uint {
                (*edit).cursor = nk_utf_len(memory, *len)
            } else {
                (*edit).cursor = (*win).edit.cursor
            }
            if 0 == flags & NK_EDIT_SELECTABLE as Int as Uint {
                (*edit).select_start = (*win).edit.cursor;
                (*edit).select_end = (*win).edit.cursor
            } else {
                (*edit).select_start = (*win).edit.sel_start;
                (*edit).select_end = (*win).edit.sel_end
            }
            (*edit).mode = (*win).edit.mode;
            (*edit).scrollbar.x = (*win).edit.scrollbar.x as f32;
            (*edit).scrollbar.y = (*win).edit.scrollbar.y as f32;
            (*edit).active = nk_true as Int as Uchar
        } else {
            (*edit).active = nk_false as Int as Uchar
        }
        max = if 1i32 < max { max } else { 1i32 };
        *len = if *len < max - 1i32 { *len } else { max - 1i32 };
        nk_str_init_fixed(&mut (*edit).string, memory as *mut Void, max as Size);
        (*edit).string.buffer.allocated = *len as Size;
        (*edit).string.len = nk_utf_len(memory, *len);
        state = nk_edit_buffer(ctx, flags, edit, filter);
        *len = (*edit).string.buffer.allocated as Int;
        if 0 != (*edit).active {
            (*win).edit.cursor = (*edit).cursor;
            (*win).edit.sel_start = (*edit).select_start;
            (*win).edit.sel_end = (*edit).select_end;
            (*win).edit.mode = (*edit).mode;
            (*win).edit.scrollbar.x = (*edit).scrollbar.x as u32;
            (*win).edit.scrollbar.y = (*edit).scrollbar.y as u32
        }
        return state;
    };
}

pub unsafe fn nk_edit_buffer(
    mut ctx: *mut Context,
    mut flags: Flags,
    mut edit: *mut TextEdit,
    mut filter: PluginFilter,
) -> Flags {
    let mut win: *mut Window = 0 as *mut Window;
    let mut style: *mut Style = 0 as *mut Style;
    let mut in_0: *mut Input = 0 as *mut Input;
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut ret_flags: Flags = 0i32 as Flags;
    let mut prev_state: Uchar = 0;
    let mut hash: Hash = 0;
    /* make sure correct values */
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32 as Flags;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        state = nk_widget(&mut bounds, ctx);
        if 0 == state as u64 {
            return state as Flags;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            /* check if edit is currently hot item */
            let fresh37 = (*win).edit.seq;
            (*win).edit.seq = (*win).edit.seq.wrapping_add(1);
            hash = fresh37;
            if 0 != (*win).edit.active && hash == (*win).edit.name {
                if 0 != flags & NK_EDIT_NO_CURSOR as Int as Uint {
                    (*edit).cursor = (*edit).string.len
                }
                if 0 == flags & NK_EDIT_SELECTABLE as Int as Uint {
                    (*edit).select_start = (*edit).cursor;
                    (*edit).select_end = (*edit).cursor
                }
                if 0 != flags & NK_EDIT_CLIPBOARD as Int as Uint {
                    (*edit).clip = (*ctx).clip
                }
                (*edit).active = (*win).edit.active as Uchar
            } else {
                (*edit).active = nk_false as Int as Uchar
            }
            (*edit).mode = (*win).edit.mode;
            filter = if filter.is_none() {
                Some(nk_filter_default)
            } else {
                filter
            };
            prev_state = (*edit).active;
            in_0 = if 0 != flags & NK_EDIT_READ_ONLY as Int as Uint {
                0 as *mut Input
            } else {
                in_0
            };
            ret_flags = nk_do_edit(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                flags,
                filter,
                edit,
                &mut (*style).edit,
                in_0,
                (*style).font,
            );
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                (*ctx).style.cursor_active = (*ctx).style.cursors[NK_CURSOR_TEXT as Int as usize]
            }
            if 0 != (*edit).active as Int && prev_state as Int != (*edit).active as Int {
                /* current edit is now hot */
                (*win).edit.active = nk_true as Int;
                (*win).edit.name = hash
            } else if 0 != prev_state as Int && 0 == (*edit).active {
                /* current edit is now cold */
                (*win).edit.active = nk_false as Int
            }
            return ret_flags;
        }
    };
}

pub unsafe fn nk_filter_default(mut box_0: *const TextEdit, mut unicode: Rune) -> Int {
    return nk_true as Int;
}

pub unsafe fn nk_str_init_fixed(mut str: *mut Str, mut memory: *mut Void, mut size: Size) -> () {
    nk_buffer_init_fixed(&mut (*str).buffer, memory, size);
    (*str).len = 0i32;
}

pub unsafe fn nk_edit_string_zero_terminated(
    mut ctx: *mut Context,
    mut flags: Flags,
    mut buffer: *mut Char,
    mut max: Int,
    mut filter: PluginFilter,
) -> Flags {
    let mut result: Flags = 0;
    let mut len: Int = nk_strlen(buffer);
    result = nk_edit_string(ctx, flags, buffer, &mut len, max, filter);
    *buffer.offset(
        (if if max - 1i32 < 0i32 { 0i32 } else { max - 1i32 } < len {
            if max - 1i32 < 0i32 {
                0i32
            } else {
                max - 1i32
            }
        } else {
            len
        }) as isize,
    ) = '\u{0}' as i32 as Char;
    return result;
}

pub unsafe fn nk_edit_focus(mut ctx: *mut Context, mut flags: Flags) -> () {
    let mut hash: Hash = 0;
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        win = (*ctx).current;
        hash = (*win).edit.seq;
        (*win).edit.active = nk_true as Int;
        (*win).edit.name = hash;
        if 0 != flags & NK_EDIT_ALWAYS_INSERT_MODE as Int as Uint {
            (*win).edit.mode = NK_TEXT_EDIT_MODE_INSERT as Int as Uchar
        }
        return;
    };
}

pub unsafe fn nk_edit_unfocus(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        win = (*ctx).current;
        (*win).edit.active = nk_false as Int;
        (*win).edit.name = 0i32 as Hash;
        return;
    };
}

pub unsafe fn nk_chart_begin(
    mut ctx: *mut Context,
    type_0: ChartType,
    mut count: Int,
    mut min_value: f32,
    mut max_value: f32,
) -> Int {
    return nk_chart_begin_colored(
        ctx,
        type_0,
        (*ctx).style.chart.color,
        (*ctx).style.chart.selected_color,
        count,
        min_value,
        max_value,
    );
}

pub unsafe fn nk_chart_begin_colored(
    mut ctx: *mut Context,
    mut type_0: ChartType,
    mut color: Color,
    mut highlight: Color,
    mut count: Int,
    mut min_value: f32,
    mut max_value: f32,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut chart: *mut Chart = 0 as *mut Chart;
    let mut config: *const Style = 0 as *const Style;
    let mut style: *const StyleChart = 0 as *const StyleChart;
    let mut background: *const StyleItem = 0 as *const StyleItem;
    let mut bounds: Rect = Rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else if 0 == nk_widget(&mut bounds, ctx) as u64 {
        chart = &mut (*(*(*ctx).current).layout).chart as *mut Chart;
        nk_zero(chart as *mut Void, mem::size_of::<Chart>() as Ulong);
        return 0i32;
    } else {
        win = (*ctx).current;
        config = &mut (*ctx).style as *mut Style;
        chart = &mut (*(*win).layout).chart as *mut Chart;
        style = &(*config).chart as *const StyleChart;
        /* setup basic generic chart  */
        nk_zero(chart as *mut Void, mem::size_of::<Chart>() as Ulong);
        (*chart).x = bounds.x + (*style).padding.x;
        (*chart).y = bounds.y + (*style).padding.y;
        (*chart).w = bounds.w - 2i32 as f32 * (*style).padding.x;
        (*chart).h = bounds.h - 2i32 as f32 * (*style).padding.y;
        (*chart).w = if (*chart).w < 2i32 as f32 * (*style).padding.x {
            2i32 as f32 * (*style).padding.x
        } else {
            (*chart).w
        };
        (*chart).h = if (*chart).h < 2i32 as f32 * (*style).padding.y {
            2i32 as f32 * (*style).padding.y
        } else {
            (*chart).h
        };
        /* add first slot into chart */
        let fresh38 = (*chart).slot;
        (*chart).slot = (*chart).slot + 1;
        let mut slot: *mut ChartSlot = &mut (*chart).slots[fresh38 as usize] as *mut ChartSlot;
        (*slot).type_0 = type_0;
        (*slot).count = count;
        (*slot).color = color;
        (*slot).highlight = highlight;
        (*slot).min = if min_value < max_value {
            min_value
        } else {
            max_value
        };
        (*slot).max = if min_value < max_value {
            max_value
        } else {
            min_value
        };
        (*slot).range = (*slot).max - (*slot).min;
        /* draw chart background */
        background = &(*style).background as *const StyleItem;
        if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
            nk_draw_image(
                &mut (*win).buffer,
                bounds,
                &(*background).data.image,
                nk_white,
            );
        } else {
            nk_fill_rect(
                &mut (*win).buffer,
                bounds,
                (*style).rounding,
                (*style).border_color,
            );
            nk_fill_rect(
                &mut (*win).buffer,
                nk_shrink_rect(bounds, (*style).border),
                (*style).rounding,
                (*style).background.data.color,
            );
        }
        return 1i32;
    };
}

pub unsafe fn nk_chart_add_slot(
    mut ctx: *mut Context,
    type_0: ChartType,
    mut count: Int,
    mut min_value: f32,
    mut max_value: f32,
) -> () {
    nk_chart_add_slot_colored(
        ctx,
        type_0,
        (*ctx).style.chart.color,
        (*ctx).style.chart.selected_color,
        count,
        min_value,
        max_value,
    );
}

pub unsafe fn nk_chart_add_slot_colored(
    mut ctx: *mut Context,
    type_0: ChartType,
    mut color: Color,
    mut highlight: Color,
    mut count: Int,
    mut min_value: f32,
    mut max_value: f32,
) -> () {
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else if (*(*(*ctx).current).layout).chart.slot >= 4i32 {
        return;
    } else {
        /* add another slot into the graph */
        let mut chart: *mut Chart = &mut (*(*(*ctx).current).layout).chart as *mut Chart;
        let fresh39 = (*chart).slot;
        (*chart).slot = (*chart).slot + 1;
        let mut slot: *mut ChartSlot = &mut (*chart).slots[fresh39 as usize] as *mut ChartSlot;
        (*slot).type_0 = type_0;
        (*slot).count = count;
        (*slot).color = color;
        (*slot).highlight = highlight;
        (*slot).min = if min_value < max_value {
            min_value
        } else {
            max_value
        };
        (*slot).max = if min_value < max_value {
            max_value
        } else {
            min_value
        };
        (*slot).range = (*slot).max - (*slot).min;
        return;
    };
}

pub unsafe fn nk_chart_push(mut ctx: *mut Context, mut value: f32) -> Flags {
    return nk_chart_push_slot(ctx, value, 0i32);
}

pub unsafe fn nk_chart_push_slot(mut ctx: *mut Context, mut value: f32, mut slot: Int) -> Flags {
    let mut flags: Flags = 0;
    let mut win: *mut Window = 0 as *mut Window;
    if ctx.is_null() || (*ctx).current.is_null() || slot >= 4i32 {
        return nk_false as Int as Flags;
    } else if slot >= (*(*(*ctx).current).layout).chart.slot {
        return nk_false as Int as Flags;
    } else {
        win = (*ctx).current;
        if (*(*win).layout).chart.slot < slot {
            return nk_false as Int as Flags;
        } else {
            match (*(*win).layout).chart.slots[slot as usize].type_0 as Uint {
                0 => flags = nk_chart_push_line(ctx, win, &mut (*(*win).layout).chart, value, slot),
                1 => {
                    flags = nk_chart_push_column(ctx, win, &mut (*(*win).layout).chart, value, slot)
                }
                2 | _ => flags = 0i32 as Flags,
            }
            return flags;
        }
    };
}
unsafe fn nk_chart_push_column(
    mut ctx: *const Context,
    mut win: *mut Window,
    mut chart: *mut Chart,
    mut value: f32,
    mut slot: Int,
) -> Flags {
    let mut padding: f32 = 0.;
    let mut out: *mut CommandBuffer = &mut (*win).buffer as *mut CommandBuffer;
    let mut in_0: *const Input = &(*ctx).input as *const Input;
    let mut layout: *mut Panel = (*win).layout;
    let mut ratio: f32 = 0.;
    let mut ret: Flags = 0i32 as Flags;
    let mut color: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut item: Rect = Rect {
        x: 0i32 as f32,
        y: 0i32 as f32,
        w: 0i32 as f32,
        h: 0i32 as f32,
    };
    if (*chart).slots[slot as usize].index >= (*chart).slots[slot as usize].count {
        return nk_false as Int as Flags;
    } else {
        if 0 != (*chart).slots[slot as usize].count {
            padding = ((*chart).slots[slot as usize].count - 1i32) as f32;
            item.w = ((*chart).w - padding) / (*chart).slots[slot as usize].count as f32
        }
        /* calculate bounds of current bar chart entry */
        color = (*chart).slots[slot as usize].color;
        item.h = (*chart).h * if value / (*chart).slots[slot as usize].range < 0i32 as f32 {
            -(value / (*chart).slots[slot as usize].range)
        } else {
            value / (*chart).slots[slot as usize].range
        };
        if value >= 0i32 as f32 {
            ratio = (value + if (*chart).slots[slot as usize].min < 0i32 as f32 {
                -(*chart).slots[slot as usize].min
            } else {
                (*chart).slots[slot as usize].min
            }) / if (*chart).slots[slot as usize].range < 0i32 as f32 {
                -(*chart).slots[slot as usize].range
            } else {
                (*chart).slots[slot as usize].range
            };
            item.y = (*chart).y + (*chart).h - (*chart).h * ratio
        } else {
            ratio =
                (value - (*chart).slots[slot as usize].max) / (*chart).slots[slot as usize].range;
            item.y =
                (*chart).y + (*chart).h * if ratio < 0i32 as f32 { -ratio } else { ratio } - item.h
        }
        item.x = (*chart).x + (*chart).slots[slot as usize].index as f32 * item.w;
        item.x = item.x + (*chart).slots[slot as usize].index as f32;
        /* user chart bar selection */
        if 0 == (*layout).flags & NK_WINDOW_ROM as Int as Uint
            && (item.x <= (*in_0).mouse.pos.x
                && (*in_0).mouse.pos.x < item.x + item.w
                && (item.y <= (*in_0).mouse.pos.y && (*in_0).mouse.pos.y < item.y + item.h))
        {
            ret = NK_CHART_HOVERING as Int as Flags;
            ret |= (if 0 == (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down
                && 0 != (*in_0).mouse.buttons[NK_BUTTON_LEFT as Int as usize].clicked
            {
                NK_CHART_CLICKED as Int
            } else {
                0i32
            }) as Uint;
            color = (*chart).slots[slot as usize].highlight
        }
        nk_fill_rect(out, item, 0i32 as f32, color);
        (*chart).slots[slot as usize].index += 1i32;
        return ret;
    };
}
unsafe fn nk_chart_push_line(
    mut ctx: *mut Context,
    mut win: *mut Window,
    mut g: *mut Chart,
    mut value: f32,
    mut slot: Int,
) -> Flags {
    let mut layout: *mut Panel = (*win).layout;
    let mut i: *const Input = &mut (*ctx).input as *mut Input;
    let mut out: *mut CommandBuffer = &mut (*win).buffer as *mut CommandBuffer;
    let mut ret: Flags = 0i32 as Flags;
    let mut cur: Point = Point { x: 0., y: 0. };
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut color: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut step: f32 = 0.;
    let mut range: f32 = 0.;
    let mut ratio: f32 = 0.;
    step = (*g).w / (*g).slots[slot as usize].count as f32;
    range = (*g).slots[slot as usize].max - (*g).slots[slot as usize].min;
    ratio = (value - (*g).slots[slot as usize].min) / range;
    if (*g).slots[slot as usize].index == 0i32 {
        /* first data point does not have a connection */
        (*g).slots[slot as usize].last.x = (*g).x;
        (*g).slots[slot as usize].last.y = (*g).y + (*g).h - ratio * (*g).h;
        bounds.x = (*g).slots[slot as usize].last.x - 2i32 as f32;
        bounds.y = (*g).slots[slot as usize].last.y - 2i32 as f32;
        bounds.h = 4i32 as f32;
        bounds.w = bounds.h;
        color = (*g).slots[slot as usize].color;
        if 0 == (*layout).flags & NK_WINDOW_ROM as Int as Uint
            && ((*g).slots[slot as usize].last.x - 3i32 as f32 <= (*i).mouse.pos.x
                && (*i).mouse.pos.x < (*g).slots[slot as usize].last.x - 3i32 as f32 + 6i32 as f32
                && ((*g).slots[slot as usize].last.y - 3i32 as f32 <= (*i).mouse.pos.y
                    && (*i).mouse.pos.y
                        < (*g).slots[slot as usize].last.y - 3i32 as f32 + 6i32 as f32))
        {
            ret = (if 0 != nk_input_is_mouse_hovering_rect(i, bounds) {
                NK_CHART_HOVERING as Int
            } else {
                0i32
            }) as Flags;
            ret |= (if 0 != (*i).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down
                && 0 != (*i).mouse.buttons[NK_BUTTON_LEFT as Int as usize].clicked
            {
                NK_CHART_CLICKED as Int
            } else {
                0i32
            }) as Uint;
            color = (*g).slots[slot as usize].highlight
        }
        nk_fill_rect(out, bounds, 0i32 as f32, color);
        (*g).slots[slot as usize].index += 1i32;
        return ret;
    } else {
        /* draw a line between the last data point and the new one */
        color = (*g).slots[slot as usize].color;
        cur.x = (*g).x + step * (*g).slots[slot as usize].index as f32;
        cur.y = (*g).y + (*g).h - ratio * (*g).h;
        nk_stroke_line(
            out,
            (*g).slots[slot as usize].last.x,
            (*g).slots[slot as usize].last.y,
            cur.x,
            cur.y,
            1.0f32,
            color,
        );
        bounds.x = cur.x - 3i32 as f32;
        bounds.y = cur.y - 3i32 as f32;
        bounds.h = 6i32 as f32;
        bounds.w = bounds.h;
        /* user selection of current data point */
        if 0 == (*layout).flags & NK_WINDOW_ROM as Int as Uint {
            if 0 != nk_input_is_mouse_hovering_rect(i, bounds) {
                ret = NK_CHART_HOVERING as Int as Flags;
                ret |= (if 0 == (*i).mouse.buttons[NK_BUTTON_LEFT as Int as usize].down
                    && 0 != (*i).mouse.buttons[NK_BUTTON_LEFT as Int as usize].clicked
                {
                    NK_CHART_CLICKED as Int
                } else {
                    0i32
                }) as Uint;
                color = (*g).slots[slot as usize].highlight
            }
        }
        nk_fill_rect(
            out,
            Rect::new(
                cur.x - 2i32 as f32,
                cur.y - 2i32 as f32,
                4i32 as f32,
                4i32 as f32,
            ),
            0i32 as f32,
            color,
        );
        /* save current data point position */
        (*g).slots[slot as usize].last.x = cur.x;
        (*g).slots[slot as usize].last.y = cur.y;
        (*g).slots[slot as usize].index += 1i32;
        return ret;
    };
}

pub unsafe fn nk_chart_end(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut chart: *mut Chart = 0 as *mut Chart;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        win = (*ctx).current;
        chart = &mut (*(*win).layout).chart as *mut Chart;
        nk_memset(chart as *mut Void, 0i32, mem::size_of::<Chart>() as Ulong);
        return;
    };
}

pub unsafe fn nk_plot(
    mut ctx: *mut Context,
    mut type_0: ChartType,
    mut values: *const f32,
    mut count: Int,
    mut offset: Int,
) -> () {
    let mut i: Int = 0i32;
    let mut min_value: f32 = 0.;
    let mut max_value: f32 = 0.;
    if ctx.is_null() || values.is_null() || 0 == count {
        return;
    } else {
        min_value = *values.offset(offset as isize);
        max_value = *values.offset(offset as isize);
        i = 0i32;
        while i < count {
            min_value = if *values.offset((i + offset) as isize) < min_value {
                *values.offset((i + offset) as isize)
            } else {
                min_value
            };
            max_value = if *values.offset((i + offset) as isize) < max_value {
                max_value
            } else {
                *values.offset((i + offset) as isize)
            };
            i += 1
        }
        if 0 != nk_chart_begin(ctx, type_0, count, min_value, max_value) {
            i = 0i32;
            while i < count {
                nk_chart_push(ctx, *values.offset((i + offset) as isize));
                i += 1
            }
            nk_chart_end(ctx);
        }
        return;
    };
}

pub unsafe fn nk_plot_function(
    mut ctx: *mut Context,
    mut type_0: ChartType,
    mut userdata: *mut Void,
    mut value_getter: Option<unsafe fn(_: *mut Void, _: Int) -> f32>,
    mut count: Int,
    mut offset: Int,
) -> () {
    let mut i: Int = 0i32;
    let mut min_value: f32 = 0.;
    let mut max_value: f32 = 0.;
    if ctx.is_null() || value_getter.is_none() || 0 == count {
        return;
    } else {
        min_value = value_getter.expect("non-null function pointer")(userdata, offset);
        max_value = min_value;
        i = 0i32;
        while i < count {
            let mut value: f32 =
                value_getter.expect("non-null function pointer")(userdata, i + offset);
            min_value = if value < min_value { value } else { min_value };
            max_value = if value < max_value { max_value } else { value };
            i += 1
        }
        if 0 != nk_chart_begin(ctx, type_0, count, min_value, max_value) {
            i = 0i32;
            while i < count {
                nk_chart_push(
                    ctx,
                    value_getter.expect("non-null function pointer")(userdata, i + offset),
                );
                i += 1
            }
            nk_chart_end(ctx);
        }
        return;
    };
}

pub unsafe fn nk_popup_begin(
    mut ctx: *mut Context,
    mut type_0: PopupType,
    mut title: *const Char,
    mut flags: Flags,
    mut rect: Rect,
) -> Int {
    let mut popup: *mut Window = 0 as *mut Window;
    let mut win: *mut Window = 0 as *mut Window;
    let mut panel: *mut Panel = 0 as *mut Panel;
    let mut title_len: Int = 0;
    let mut title_hash: Hash = 0;
    let mut allocated: Size = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        panel = (*win).layout;
        title_len = nk_strlen(title);
        title_hash = nk_murmur_hash(
            title as *const Void,
            title_len,
            NK_PANEL_POPUP as Int as Hash,
        );
        popup = (*win).popup.win;
        if popup.is_null() {
            popup = nk_create_window(ctx) as *mut Window;
            (*popup).parent = win;
            (*win).popup.win = popup;
            (*win).popup.active = 0i32;
            (*win).popup.type_0 = NK_PANEL_POPUP
        }
        /* make sure we have correct popup */
        if (*win).popup.name != title_hash {
            if 0 == (*win).popup.active {
                nk_zero(popup as *mut Void, mem::size_of::<Window>() as Ulong);
                (*win).popup.name = title_hash;
                (*win).popup.active = 1i32;
                (*win).popup.type_0 = NK_PANEL_POPUP
            } else {
                return 0i32;
            }
        }
        /* popup position is local to window */
        (*ctx).current = popup;
        rect.x += (*(*win).layout).clip.x;
        rect.y += (*(*win).layout).clip.y;
        /* setup popup data */
        (*popup).parent = win;
        (*popup).bounds = rect;
        (*popup).seq = (*ctx).seq;
        (*popup).layout = nk_create_panel(ctx) as *mut Panel;
        (*popup).flags = flags;
        (*popup).flags |= NK_WINDOW_BORDER as Int as Uint;
        if type_0 as Uint == NK_POPUP_DYNAMIC as Int as Uint {
            (*popup).flags |= NK_WINDOW_DYNAMIC as Int as Uint
        }
        (*popup).buffer = (*win).buffer;
        nk_start_popup(ctx, win);
        allocated = (*ctx).memory.allocated;
        nk_push_scissor(&mut (*popup).buffer, nk_null_rect);
        if 0 != nk_panel_begin(ctx, title, NK_PANEL_POPUP) {
            /* popup is running therefore invalidate parent panels */
            let mut root: *mut Panel = 0 as *mut Panel;
            root = (*win).layout;
            while !root.is_null() {
                (*root).flags |= NK_WINDOW_ROM as Int as Uint;
                (*root).flags &= !(NK_WINDOW_REMOVE_ROM as Int as Flags);
                root = (*root).parent
            }
            (*win).popup.active = 1i32;
            (*(*popup).layout).offset_x = &mut (*popup).scrollbar.x as *mut u32;
            (*(*popup).layout).offset_y = &mut (*popup).scrollbar.y as *mut u32;
            (*(*popup).layout).parent = (*win).layout;
            return 1i32;
        } else {
            /* popup was closed/is invalid so cleanup */
            let mut root_0: *mut Panel = 0 as *mut Panel;
            root_0 = (*win).layout;
            while !root_0.is_null() {
                (*root_0).flags |= NK_WINDOW_REMOVE_ROM as Int as Uint;
                root_0 = (*root_0).parent
            }
            (*win).popup.buf.active = 0i32;
            (*win).popup.active = 0i32;
            (*ctx).memory.allocated = allocated;
            (*ctx).current = win;
            nk_free_panel(ctx, (*popup).layout);
            (*popup).layout = 0 as *mut Panel;
            return 0i32;
        }
    };
}
unsafe fn nk_start_popup(mut ctx: *mut Context, mut win: *mut Window) -> () {
    let mut buf: *mut PopupBuffer = 0 as *mut PopupBuffer;
    if ctx.is_null() || win.is_null() {
        return;
    } else {
        /* save buffer fill state for popup */
        buf = &mut (*win).popup.buf as *mut PopupBuffer;
        (*buf).begin = (*win).buffer.end;
        (*buf).end = (*win).buffer.end;
        (*buf).parent = (*win).buffer.last;
        (*buf).last = (*buf).begin;
        (*buf).active = nk_true as Int;
        return;
    };
}

pub unsafe fn nk_popup_close(mut ctx: *mut Context) -> () {
    let mut popup: *mut Window = 0 as *mut Window;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        popup = (*ctx).current;
        (*popup).flags |= NK_WINDOW_HIDDEN as Int as Uint;
        return;
    };
}

pub unsafe fn nk_popup_end(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut popup: *mut Window = 0 as *mut Window;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        popup = (*ctx).current;
        if (*popup).parent.is_null() {
            return;
        } else {
            win = (*popup).parent;
            if 0 != (*popup).flags & NK_WINDOW_HIDDEN as Int as Uint {
                let mut root: *mut Panel = 0 as *mut Panel;
                root = (*win).layout;
                while !root.is_null() {
                    (*root).flags |= NK_WINDOW_REMOVE_ROM as Int as Uint;
                    root = (*root).parent
                }
                (*win).popup.active = 0i32
            }
            nk_push_scissor(&mut (*popup).buffer, nk_null_rect);
            nk_end(ctx);
            (*win).buffer = (*popup).buffer;
            nk_finish_popup(ctx, win);
            (*ctx).current = win;
            nk_push_scissor(&mut (*win).buffer, (*(*win).layout).clip);
            return;
        }
    };
}
unsafe fn nk_finish_popup(mut ctx: *mut Context, mut win: *mut Window) -> () {
    let mut buf: *mut PopupBuffer = 0 as *mut PopupBuffer;
    if ctx.is_null() || win.is_null() {
        return;
    } else {
        buf = &mut (*win).popup.buf as *mut PopupBuffer;
        (*buf).last = (*win).buffer.last;
        (*buf).end = (*win).buffer.end;
        return;
    };
}

pub unsafe fn nk_combo(
    mut ctx: *mut Context,
    mut items: *mut *const Char,
    mut count: Int,
    mut selected: Int,
    mut item_height: Int,
    mut size: Point,
) -> Int {
    let mut i: Int = 0i32;
    let mut max_height: Int = 0;
    let mut item_spacing: Point = Point { x: 0., y: 0. };
    let mut window_padding: Point = Point { x: 0., y: 0. };
    if ctx.is_null() || items.is_null() || 0 == count {
        return selected;
    } else {
        item_spacing = (*ctx).style.window.spacing;
        window_padding =
            nk_panel_get_padding(&mut (*ctx).style, (*(*(*ctx).current).layout).type_0);
        max_height = count * item_height + count * item_spacing.y as Int;
        max_height += item_spacing.y as Int * 2i32 + window_padding.y as Int * 2i32;
        size.y = if size.y < max_height as f32 {
            size.y
        } else {
            max_height as f32
        };
        if 0 != nk_combo_begin_label(ctx, *items.offset(selected as isize), size) {
            nk_layout_row_dynamic(ctx, item_height as f32, 1i32);
            i = 0i32;
            while i < count {
                if 0 != nk_combo_item_label(
                    ctx,
                    *items.offset(i as isize),
                    NK_TEXT_LEFT as Int as Flags,
                ) {
                    selected = i
                }
                i += 1
            }
            nk_combo_end(ctx);
        }
        return selected;
    };
}

pub unsafe fn nk_combo_end(mut ctx: *mut Context) -> () {
    nk_contextual_end(ctx);
}

pub unsafe fn nk_contextual_end(mut ctx: *mut Context) -> () {
    let mut padding: Point = Point { x: 0., y: 0. };
    let mut popup: *mut Window = 0 as *mut Window;
    let mut panel: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        popup = (*ctx).current;
        panel = (*popup).layout;
        if 0 != (*panel).flags & NK_WINDOW_DYNAMIC as Int as Uint {
            /* Close behavior
        This is a bit of a hack solution since we do not know before we end our popup
        how big it will be. We therefore do not directly know when a
        click outside the non-blocking popup must close it at that direct frame.
        Instead it will be closed in the next frame.*/
            let mut body: Rect = Rect {
                x: 0i32 as f32,
                y: 0i32 as f32,
                w: 0i32 as f32,
                h: 0i32 as f32,
            };
            if (*panel).at_y < (*panel).bounds.y + (*panel).bounds.h {
                padding = nk_panel_get_padding(&mut (*ctx).style, (*panel).type_0);
                body = (*panel).bounds;
                body.y = (*panel).at_y
                    + (*panel).footer_height
                    + (*panel).border
                    + padding.y
                    + (*panel).row.height;
                body.h = (*panel).bounds.y + (*panel).bounds.h - body.y
            }
            let mut pressed: Int = nk_input_is_mouse_pressed(&mut (*ctx).input, NK_BUTTON_LEFT);
            let mut in_body: Int = nk_input_is_mouse_hovering_rect(&mut (*ctx).input, body);
            if 0 != pressed && 0 != in_body {
                (*popup).flags |= NK_WINDOW_HIDDEN as Int as Uint
            }
        }
        if 0 != (*popup).flags & NK_WINDOW_HIDDEN as Int as Uint {
            (*popup).seq = 0i32 as Uint
        }
        nk_popup_end(ctx);
        return;
    };
}

pub unsafe fn nk_combo_item_label(
    mut ctx: *mut Context,
    mut label: *const Char,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_label(ctx, label, align);
}

pub unsafe fn nk_contextual_item_label(
    mut ctx: *mut Context,
    mut label: *const Char,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_text(ctx, label, nk_strlen(label), align);
}

pub unsafe fn nk_contextual_item_text(
    mut ctx: *mut Context,
    mut text: *const Char,
    mut len: Int,
    mut alignment: Flags,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut in_0: *const Input = 0 as *const Input;
    let mut style: *const Style = 0 as *const Style;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        state = nk_widget_fitting(&mut bounds, ctx, (*style).contextual_button.padding);
        if 0 == state as u64 {
            return nk_false as Int;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != nk_do_button_text(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                text,
                len,
                alignment,
                NK_BUTTON_DEFAULT,
                &(*style).contextual_button,
                in_0,
                (*style).font,
            ) {
                nk_contextual_close(ctx);
                return nk_true as Int;
            } else {
                return nk_false as Int;
            }
        }
    };
}

pub unsafe fn nk_contextual_close(mut ctx: *mut Context) -> () {
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        nk_popup_close(ctx);
        return;
    };
}

pub unsafe fn nk_combo_begin_label(
    mut ctx: *mut Context,
    mut selected: *const Char,
    mut size: Point,
) -> Int {
    return nk_combo_begin_text(ctx, selected, nk_strlen(selected), size);
}

pub unsafe fn nk_combo_begin_text(
    mut ctx: *mut Context,
    mut selected: *const Char,
    mut len: Int,
    mut size: Point,
) -> Int {
    let mut in_0: *const Input = 0 as *const Input;
    let mut win: *mut Window = 0 as *mut Window;
    let mut style: *mut Style = 0 as *mut Style;
    let mut s: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut is_clicked: Int = nk_false as Int;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut background: *const StyleItem = 0 as *const StyleItem;
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || selected.is_null()
    {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        s = nk_widget(&mut header, ctx);
        if s as Uint == NK_WIDGET_INVALID as Int as Uint {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
                || s as Uint == NK_WIDGET_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != ButtonBehavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as Int
            }
            /* draw combo box header background and border */
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
                background = &mut (*style).combo.active as *mut StyleItem;
                text.text = (*style).combo.label_active
            } else if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                background = &mut (*style).combo.hover as *mut StyleItem;
                text.text = (*style).combo.label_hover
            } else {
                background = &mut (*style).combo.normal as *mut StyleItem;
                text.text = (*style).combo.label_normal
            }
            if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                text.background = nk_rgba(0i32, 0i32, 0i32, 0i32);
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                text.background = (*background).data.color;
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            /* print currently selected text item */
            let mut label: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut content: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: SymbolType = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.x;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            /* draw selected label */
            text.padding = Point::new(0i32 as f32, 0i32 as f32);
            label.x = header.x + (*style).combo.content_padding.x;
            label.y = header.y + (*style).combo.content_padding.y;
            label.w =
                button.x - ((*style).combo.content_padding.x + (*style).combo.spacing.x) - label.x;
            label.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            nk_widget_text(
                &mut (*win).buffer,
                label,
                selected,
                len,
                &mut text,
                NK_TEXT_LEFT as Int as Flags,
                (*ctx).style.font,
            );
            /* draw open/close button */
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut button,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}
unsafe fn nk_combo_begin(
    mut ctx: *mut Context,
    mut win: *mut Window,
    mut size: Point,
    mut is_clicked: Int,
    mut header: Rect,
) -> Int {
    let mut popup: *mut Window = 0 as *mut Window;
    let mut is_open: Int = 0i32;
    let mut is_active: Int = 0i32;
    let mut body: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut hash: Hash = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        popup = (*win).popup.win;
        body.x = header.x;
        body.w = size.x;
        body.y = header.y + header.h - (*ctx).style.window.combo_border;
        body.h = size.y;
        let fresh40 = (*win).popup.combo_count;
        (*win).popup.combo_count = (*win).popup.combo_count.wrapping_add(1);
        hash = fresh40;
        is_open = if !popup.is_null() {
            nk_true as Int
        } else {
            nk_false as Int
        };
        is_active = (!popup.is_null()
            && (*win).popup.name == hash
            && (*win).popup.type_0 as Uint == NK_PANEL_COMBO as Int as Uint)
            as Int;
        if 0 != is_clicked && 0 != is_open && 0 == is_active
            || 0 != is_open && 0 == is_active
            || 0 == is_open && 0 == is_active && 0 == is_clicked
        {
            return 0i32;
        } else if 0 == nk_nonblock_begin(
            ctx,
            0i32 as Flags,
            body,
            if 0 != is_clicked && 0 != is_open {
                Rect::new(0i32 as f32, 0i32 as f32, 0i32 as f32, 0i32 as f32)
            } else {
                header
            },
            NK_PANEL_COMBO,
        ) {
            return 0i32;
        } else {
            (*win).popup.type_0 = NK_PANEL_COMBO;
            (*win).popup.name = hash;
            return 1i32;
        }
    };
}
unsafe fn nk_nonblock_begin(
    mut ctx: *mut Context,
    mut flags: Flags,
    mut body: Rect,
    mut header: Rect,
    mut panel_type: PanelType,
) -> Int {
    let mut popup: *mut Window = 0 as *mut Window;
    let mut win: *mut Window = 0 as *mut Window;
    let mut panel: *mut Panel = 0 as *mut Panel;
    let mut is_active: Int = nk_true as Int;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        /* popups cannot have popups */
        win = (*ctx).current;
        panel = (*win).layout;
        popup = (*win).popup.win;
        if popup.is_null() {
            /* create window for nonblocking popup */
            popup = nk_create_window(ctx) as *mut Window;
            (*popup).parent = win;
            (*win).popup.win = popup;
            (*win).popup.type_0 = panel_type;
            nk_command_buffer_init(&mut (*popup).buffer, &mut (*ctx).memory, NK_CLIPPING_ON);
        } else {
            let mut pressed: Int = 0;
            let mut in_body: Int = 0;
            /* close the popup if user pressed outside or in the header */
            let mut in_header: Int = 0;
            pressed = nk_input_is_mouse_pressed(&mut (*ctx).input, NK_BUTTON_LEFT);
            in_body = nk_input_is_mouse_hovering_rect(&mut (*ctx).input, body);
            in_header = nk_input_is_mouse_hovering_rect(&mut (*ctx).input, header);
            if 0 != pressed && (0 == in_body || 0 != in_header) {
                is_active = nk_false as Int
            }
        }
        (*win).popup.header = header;
        if 0 == is_active {
            /* remove read only mode from all parent panels */
            let mut root: *mut Panel = (*win).layout;
            while !root.is_null() {
                (*root).flags |= NK_WINDOW_REMOVE_ROM as Int as Uint;
                root = (*root).parent
            }
            return is_active;
        } else {
            (*popup).bounds = body;
            (*popup).parent = win;
            (*popup).layout = nk_create_panel(ctx) as *mut Panel;
            (*popup).flags = flags;
            (*popup).flags |= NK_WINDOW_BORDER as Int as Uint;
            (*popup).flags |= NK_WINDOW_DYNAMIC as Int as Uint;
            (*popup).seq = (*ctx).seq;
            (*win).popup.active = 1i32;
            nk_start_popup(ctx, win);
            (*popup).buffer = (*win).buffer;
            nk_push_scissor(&mut (*popup).buffer, nk_null_rect);
            (*ctx).current = popup;
            nk_panel_begin(ctx, 0 as *const Char, panel_type);
            (*win).buffer = (*popup).buffer;
            (*(*popup).layout).parent = (*win).layout;
            (*(*popup).layout).offset_x = &mut (*popup).scrollbar.x as *mut u32;
            (*(*popup).layout).offset_y = &mut (*popup).scrollbar.y as *mut u32;
            /* set read only mode to all parent panels */
            let mut root_0: *mut Panel = 0 as *mut Panel;
            root_0 = (*win).layout;
            while !root_0.is_null() {
                (*root_0).flags |= NK_WINDOW_ROM as Int as Uint;
                root_0 = (*root_0).parent
            }
            return is_active;
        }
    };
}

pub unsafe fn nk_combo_separator(
    mut ctx: *mut Context,
    mut items_separated_by_separator: *const Char,
    mut separator: Int,
    mut selected: Int,
    mut count: Int,
    mut item_height: Int,
    mut size: Point,
) -> Int {
    let mut i: Int = 0;
    let mut max_height: Int = 0;
    let mut item_spacing: Point = Point { x: 0., y: 0. };
    let mut window_padding: Point = Point { x: 0., y: 0. };
    let mut current_item: *const Char = 0 as *const Char;
    let mut iter: *const Char = 0 as *const Char;
    let mut length: Int = 0i32;
    if ctx.is_null() || items_separated_by_separator.is_null() {
        return selected;
    } else {
        /* calculate popup window */
        item_spacing = (*ctx).style.window.spacing;
        window_padding =
            nk_panel_get_padding(&mut (*ctx).style, (*(*(*ctx).current).layout).type_0);
        max_height = count * item_height + count * item_spacing.y as Int;
        max_height += item_spacing.y as Int * 2i32 + window_padding.y as Int * 2i32;
        size.y = if size.y < max_height as f32 {
            size.y
        } else {
            max_height as f32
        };
        /* find selected item */
        current_item = items_separated_by_separator;
        i = 0i32;
        while i < count {
            iter = current_item;
            while 0 != *iter as Int && *iter as Int != separator {
                iter = iter.offset(1isize)
            }
            length = current_item.ptr_offset_to(iter).expect("bad offset_to") as Long as Int;
            if i == selected {
                break;
            }
            current_item = iter.offset(1isize);
            i += 1
        }
        if 0 != nk_combo_begin_text(ctx, current_item, length, size) {
            current_item = items_separated_by_separator;
            nk_layout_row_dynamic(ctx, item_height as f32, 1i32);
            i = 0i32;
            while i < count {
                iter = current_item;
                while 0 != *iter as Int && *iter as Int != separator {
                    iter = iter.offset(1isize)
                }
                length = current_item.ptr_offset_to(iter).expect("bad offset_to") as Long as Int;
                if 0 != nk_combo_item_text(ctx, current_item, length, NK_TEXT_LEFT as Int as Flags)
                {
                    selected = i
                }
                current_item = current_item.offset(length as isize).offset(1isize);
                i += 1
            }
            nk_combo_end(ctx);
        }
        return selected;
    };
}

pub unsafe fn nk_combo_item_text(
    mut ctx: *mut Context,
    mut text: *const Char,
    mut len: Int,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_text(ctx, text, len, align);
}

pub unsafe fn nk_combo_string(
    mut ctx: *mut Context,
    mut items_separated_by_zeros: *const Char,
    mut selected: Int,
    mut count: Int,
    mut item_height: Int,
    mut size: Point,
) -> Int {
    return nk_combo_separator(
        ctx,
        items_separated_by_zeros,
        '\u{0}' as i32,
        selected,
        count,
        item_height,
        size,
    );
}

pub unsafe fn nk_combo_callback(
    mut ctx: *mut Context,
    mut item_getter: Option<unsafe fn(_: *mut Void, _: Int, _: *mut *const Char) -> ()>,
    mut userdata: *mut Void,
    mut selected: Int,
    mut count: Int,
    mut item_height: Int,
    mut size: Point,
) -> Int {
    let mut i: Int = 0;
    let mut max_height: Int = 0;
    let mut item_spacing: Point = Point { x: 0., y: 0. };
    let mut window_padding: Point = Point { x: 0., y: 0. };
    let mut item: *const Char = 0 as *const Char;
    if ctx.is_null() || item_getter.is_none() {
        return selected;
    } else {
        /* calculate popup window */
        item_spacing = (*ctx).style.window.spacing;
        window_padding =
            nk_panel_get_padding(&mut (*ctx).style, (*(*(*ctx).current).layout).type_0);
        max_height = count * item_height + count * item_spacing.y as Int;
        max_height += item_spacing.y as Int * 2i32 + window_padding.y as Int * 2i32;
        size.y = if size.y < max_height as f32 {
            size.y
        } else {
            max_height as f32
        };
        item_getter.expect("non-null function pointer")(userdata, selected, &mut item);
        if 0 != nk_combo_begin_label(ctx, item, size) {
            nk_layout_row_dynamic(ctx, item_height as f32, 1i32);
            i = 0i32;
            while i < count {
                item_getter.expect("non-null function pointer")(userdata, i, &mut item);
                if 0 != nk_combo_item_label(ctx, item, NK_TEXT_LEFT as Int as Flags) {
                    selected = i
                }
                i += 1
            }
            nk_combo_end(ctx);
        }
        return selected;
    };
}

pub unsafe fn nk_combobox(
    mut ctx: *mut Context,
    mut items: *mut *const Char,
    mut count: Int,
    mut selected: *mut Int,
    mut item_height: Int,
    mut size: Point,
) -> () {
    *selected = nk_combo(ctx, items, count, *selected, item_height, size);
}

pub unsafe fn nk_combobox_string(
    mut ctx: *mut Context,
    mut items_separated_by_zeros: *const Char,
    mut selected: *mut Int,
    mut count: Int,
    mut item_height: Int,
    mut size: Point,
) -> () {
    *selected = nk_combo_string(
        ctx,
        items_separated_by_zeros,
        *selected,
        count,
        item_height,
        size,
    );
}

pub unsafe fn nk_combobox_separator(
    mut ctx: *mut Context,
    mut items_separated_by_separator: *const Char,
    mut separator: Int,
    mut selected: *mut Int,
    mut count: Int,
    mut item_height: Int,
    mut size: Point,
) -> () {
    *selected = nk_combo_separator(
        ctx,
        items_separated_by_separator,
        separator,
        *selected,
        count,
        item_height,
        size,
    );
}

pub unsafe fn nk_combobox_callback(
    mut ctx: *mut Context,
    mut item_getter: Option<unsafe fn(_: *mut Void, _: Int, _: *mut *const Char) -> ()>,
    mut userdata: *mut Void,
    mut selected: *mut Int,
    mut count: Int,
    mut item_height: Int,
    mut size: Point,
) -> () {
    *selected = nk_combo_callback(
        ctx,
        item_getter,
        userdata,
        *selected,
        count,
        item_height,
        size,
    );
}

pub unsafe fn nk_combo_begin_color(
    mut ctx: *mut Context,
    mut color: Color,
    mut size: Point,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut style: *mut Style = 0 as *mut Style;
    let mut in_0: *const Input = 0 as *const Input;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: Int = nk_false as Int;
    let mut s: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut background: *const StyleItem = 0 as *const StyleItem;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        s = nk_widget(&mut header, ctx);
        if s as Uint == NK_WIDGET_INVALID as Int as Uint {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
                || s as Uint == NK_WIDGET_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != ButtonBehavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as Int
            }
            /* draw combo box header background and border */
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
                background = &mut (*style).combo.active as *mut StyleItem
            } else if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                background = &mut (*style).combo.hover as *mut StyleItem
            } else {
                background = &mut (*style).combo.normal as *mut StyleItem
            }
            if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            let mut content: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut bounds: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: SymbolType = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.x;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            /* draw color */
            bounds.h = header.h - 4i32 as f32 * (*style).combo.content_padding.y;
            bounds.y = header.y + 2i32 as f32 * (*style).combo.content_padding.y;
            bounds.x = header.x + 2i32 as f32 * (*style).combo.content_padding.x;
            bounds.w =
                button.x - ((*style).combo.content_padding.x + (*style).combo.spacing.x) - bounds.x;
            nk_fill_rect(&mut (*win).buffer, bounds, 0i32 as f32, color);
            /* draw open/close button */
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut button,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}

pub unsafe fn nk_combo_begin_symbol(
    mut ctx: *mut Context,
    mut symbol: SymbolType,
    mut size: Point,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut style: *mut Style = 0 as *mut Style;
    let mut in_0: *const Input = 0 as *const Input;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: Int = nk_false as Int;
    let mut s: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut background: *const StyleItem = 0 as *const StyleItem;
    let mut sym_background: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut symbol_color: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        s = nk_widget(&mut header, ctx);
        if s as Uint == NK_WIDGET_INVALID as Int as Uint {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
                || s as Uint == NK_WIDGET_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != ButtonBehavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as Int
            }
            /* draw combo box header background and border */
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
                background = &mut (*style).combo.active as *mut StyleItem;
                symbol_color = (*style).combo.symbol_active
            } else if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                background = &mut (*style).combo.hover as *mut StyleItem;
                symbol_color = (*style).combo.symbol_hover
            } else {
                background = &mut (*style).combo.normal as *mut StyleItem;
                symbol_color = (*style).combo.symbol_hover
            }
            if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                sym_background = nk_rgba(0i32, 0i32, 0i32, 0i32);
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                sym_background = (*background).data.color;
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            let mut bounds: Rect = Rect {
                x: 0i32 as f32,
                y: 0i32 as f32,
                w: 0i32 as f32,
                h: 0i32 as f32,
            };
            let mut content: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: SymbolType = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.y;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            /* draw symbol */
            bounds.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            bounds.y = header.y + (*style).combo.content_padding.y;
            bounds.x = header.x + (*style).combo.content_padding.x;
            bounds.w = button.x - (*style).combo.content_padding.y - bounds.x;
            nk_draw_symbol(
                &mut (*win).buffer,
                symbol,
                bounds,
                sym_background,
                symbol_color,
                1.0f32,
                (*style).font,
            );
            /* draw open/close button */
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut bounds,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}

pub unsafe fn nk_combo_begin_symbol_label(
    mut ctx: *mut Context,
    mut selected: *const Char,
    mut type_0: SymbolType,
    mut size: Point,
) -> Int {
    return nk_combo_begin_symbol_text(ctx, selected, nk_strlen(selected), type_0, size);
}

pub unsafe fn nk_combo_begin_symbol_text(
    mut ctx: *mut Context,
    mut selected: *const Char,
    mut len: Int,
    mut symbol: SymbolType,
    mut size: Point,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut style: *mut Style = 0 as *mut Style;
    let mut in_0: *mut Input = 0 as *mut Input;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: Int = nk_false as Int;
    let mut s: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut background: *const StyleItem = 0 as *const StyleItem;
    let mut symbol_color: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        s = nk_widget(&mut header, ctx);
        if 0 == s as u64 {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
                || s as Uint == NK_WIDGET_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != ButtonBehavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as Int
            }
            /* draw combo box header background and border */
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
                background = &mut (*style).combo.active as *mut StyleItem;
                symbol_color = (*style).combo.symbol_active;
                text.text = (*style).combo.label_active
            } else if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                background = &mut (*style).combo.hover as *mut StyleItem;
                symbol_color = (*style).combo.symbol_hover;
                text.text = (*style).combo.label_hover
            } else {
                background = &mut (*style).combo.normal as *mut StyleItem;
                symbol_color = (*style).combo.symbol_normal;
                text.text = (*style).combo.label_normal
            }
            if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                text.background = nk_rgba(0i32, 0i32, 0i32, 0i32);
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                text.background = (*background).data.color;
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            let mut content: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut label: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut image: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: SymbolType = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.x;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut button,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            /* draw symbol */
            image.x = header.x + (*style).combo.content_padding.x;
            image.y = header.y + (*style).combo.content_padding.y;
            image.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            image.w = image.h;
            nk_draw_symbol(
                &mut (*win).buffer,
                symbol,
                image,
                text.background,
                symbol_color,
                1.0f32,
                (*style).font,
            );
            /* draw label */
            text.padding = Point::new(0i32 as f32, 0i32 as f32);
            label.x =
                image.x + image.w + (*style).combo.spacing.x + (*style).combo.content_padding.x;
            label.y = header.y + (*style).combo.content_padding.y;
            label.w = button.x - (*style).combo.content_padding.x - label.x;
            label.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            nk_widget_text(
                &mut (*win).buffer,
                label,
                selected,
                len,
                &mut text,
                NK_TEXT_LEFT as Int as Flags,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}

pub unsafe fn nk_combo_begin_image(mut ctx: *mut Context, mut img: Image, mut size: Point) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut style: *mut Style = 0 as *mut Style;
    let mut in_0: *const Input = 0 as *const Input;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: Int = nk_false as Int;
    let mut s: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut background: *const StyleItem = 0 as *const StyleItem;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        s = nk_widget(&mut header, ctx);
        if s as Uint == NK_WIDGET_INVALID as Int as Uint {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
                || s as Uint == NK_WIDGET_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != ButtonBehavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as Int
            }
            /* draw combo box header background and border */
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
                background = &mut (*style).combo.active as *mut StyleItem
            } else if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                background = &mut (*style).combo.hover as *mut StyleItem
            } else {
                background = &mut (*style).combo.normal as *mut StyleItem
            }
            if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            let mut bounds: Rect = Rect {
                x: 0i32 as f32,
                y: 0i32 as f32,
                w: 0i32 as f32,
                h: 0i32 as f32,
            };
            let mut content: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: SymbolType = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.y;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            /* draw image */
            bounds.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            bounds.y = header.y + (*style).combo.content_padding.y;
            bounds.x = header.x + (*style).combo.content_padding.x;
            bounds.w = button.x - (*style).combo.content_padding.y - bounds.x;
            nk_draw_image(&mut (*win).buffer, bounds, &mut img, nk_white);
            /* draw open/close button */
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut bounds,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}

pub unsafe fn nk_combo_begin_image_label(
    mut ctx: *mut Context,
    mut selected: *const Char,
    mut img: Image,
    mut size: Point,
) -> Int {
    return nk_combo_begin_image_text(ctx, selected, nk_strlen(selected), img, size);
}

pub unsafe fn nk_combo_begin_image_text(
    mut ctx: *mut Context,
    mut selected: *const Char,
    mut len: Int,
    mut img: Image,
    mut size: Point,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut style: *mut Style = 0 as *mut Style;
    let mut in_0: *mut Input = 0 as *mut Input;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: Int = nk_false as Int;
    let mut s: WidgetLayoutStates = NK_WIDGET_INVALID;
    let mut background: *const StyleItem = 0 as *const StyleItem;
    let mut text: Text = Text {
        padding: Point { x: 0., y: 0. },
        background: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
        text: Color {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
        },
    };
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        s = nk_widget(&mut header, ctx);
        if 0 == s as u64 {
            return 0i32;
        } else {
            in_0 = if 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
                || s as Uint == NK_WIDGET_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != ButtonBehavior(
                &mut (*ctx).last_widget_state,
                header,
                in_0,
                NK_BUTTON_DEFAULT,
            ) {
                is_clicked = nk_true as Int
            }
            /* draw combo box header background and border */
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_ACTIVED as Int as Uint {
                background = &mut (*style).combo.active as *mut StyleItem;
                text.text = (*style).combo.label_active
            } else if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                background = &mut (*style).combo.hover as *mut StyleItem;
                text.text = (*style).combo.label_hover
            } else {
                background = &mut (*style).combo.normal as *mut StyleItem;
                text.text = (*style).combo.label_normal
            }
            if (*background).type_0 as Uint == NK_STYLE_ITEM_IMAGE as Int as Uint {
                text.background = nk_rgba(0i32, 0i32, 0i32, 0i32);
                nk_draw_image(
                    &mut (*win).buffer,
                    header,
                    &(*background).data.image,
                    nk_white,
                );
            } else {
                text.background = (*background).data.color;
                nk_fill_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*background).data.color,
                );
                nk_stroke_rect(
                    &mut (*win).buffer,
                    header,
                    (*style).combo.rounding,
                    (*style).combo.border,
                    (*style).combo.border_color,
                );
            }
            let mut content: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut button: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut label: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut image: Rect = Rect {
                x: 0.,
                y: 0.,
                w: 0.,
                h: 0.,
            };
            let mut sym: SymbolType = NK_SYMBOL_NONE;
            if 0 != (*ctx).last_widget_state & NK_WIDGET_STATE_HOVER as Int as Uint {
                sym = (*style).combo.sym_hover
            } else if 0 != is_clicked {
                sym = (*style).combo.sym_active
            } else {
                sym = (*style).combo.sym_normal
            }
            /* calculate button */
            button.w = header.h - 2i32 as f32 * (*style).combo.button_padding.y;
            button.x = header.x + header.w - header.h - (*style).combo.button_padding.x;
            button.y = header.y + (*style).combo.button_padding.y;
            button.h = button.w;
            content.x = button.x + (*style).combo.button.padding.x;
            content.y = button.y + (*style).combo.button.padding.y;
            content.w = button.w - 2i32 as f32 * (*style).combo.button.padding.x;
            content.h = button.h - 2i32 as f32 * (*style).combo.button.padding.y;
            nk_draw_button_symbol(
                &mut (*win).buffer,
                &mut button,
                &mut content,
                (*ctx).last_widget_state,
                &mut (*ctx).style.combo.button,
                sym,
                (*style).font,
            );
            /* draw image */
            image.x = header.x + (*style).combo.content_padding.x;
            image.y = header.y + (*style).combo.content_padding.y;
            image.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            image.w = image.h;
            nk_draw_image(&mut (*win).buffer, image, &mut img, nk_white);
            /* draw label */
            text.padding = Point::new(0i32 as f32, 0i32 as f32);
            label.x =
                image.x + image.w + (*style).combo.spacing.x + (*style).combo.content_padding.x;
            label.y = header.y + (*style).combo.content_padding.y;
            label.w = button.x - (*style).combo.content_padding.x - label.x;
            label.h = header.h - 2i32 as f32 * (*style).combo.content_padding.y;
            nk_widget_text(
                &mut (*win).buffer,
                label,
                selected,
                len,
                &mut text,
                NK_TEXT_LEFT as Int as Flags,
                (*style).font,
            );
            return nk_combo_begin(ctx, win, size, is_clicked, header);
        }
    };
}

pub unsafe fn nk_combo_item_image_label(
    mut ctx: *mut Context,
    mut img: Image,
    mut text: *const Char,
    mut alignment: Flags,
) -> Int {
    return nk_contextual_item_image_label(ctx, img, text, alignment);
}

pub unsafe fn nk_contextual_item_image_label(
    mut ctx: *mut Context,
    mut img: Image,
    mut label: *const Char,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_image_text(ctx, img, label, nk_strlen(label), align);
}

pub unsafe fn nk_contextual_item_image_text(
    mut ctx: *mut Context,
    mut img: Image,
    mut text: *const Char,
    mut len: Int,
    mut align: Flags,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut in_0: *const Input = 0 as *const Input;
    let mut style: *const Style = 0 as *const Style;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        state = nk_widget_fitting(&mut bounds, ctx, (*style).contextual_button.padding);
        if 0 == state as u64 {
            return nk_false as Int;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != nk_do_button_text_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                img,
                text,
                len,
                align,
                NK_BUTTON_DEFAULT,
                &(*style).contextual_button,
                (*style).font,
                in_0,
            ) {
                nk_contextual_close(ctx);
                return nk_true as Int;
            } else {
                return nk_false as Int;
            }
        }
    };
}

pub unsafe fn nk_combo_item_image_text(
    mut ctx: *mut Context,
    mut img: Image,
    mut text: *const Char,
    mut len: Int,
    mut alignment: Flags,
) -> Int {
    return nk_contextual_item_image_text(ctx, img, text, len, alignment);
}

pub unsafe fn nk_combo_item_symbol_label(
    mut ctx: *mut Context,
    mut sym: SymbolType,
    mut label: *const Char,
    mut alignment: Flags,
) -> Int {
    return nk_contextual_item_symbol_label(ctx, sym, label, alignment);
}

pub unsafe fn nk_contextual_item_symbol_label(
    mut ctx: *mut Context,
    mut symbol: SymbolType,
    mut text: *const Char,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_symbol_text(ctx, symbol, text, nk_strlen(text), align);
}

pub unsafe fn nk_contextual_item_symbol_text(
    mut ctx: *mut Context,
    mut symbol: SymbolType,
    mut text: *const Char,
    mut len: Int,
    mut align: Flags,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut in_0: *const Input = 0 as *const Input;
    let mut style: *const Style = 0 as *const Style;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut state: WidgetLayoutStates = NK_WIDGET_INVALID;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        style = &mut (*ctx).style as *mut Style;
        state = nk_widget_fitting(&mut bounds, ctx, (*style).contextual_button.padding);
        if 0 == state as u64 {
            return nk_false as Int;
        } else {
            in_0 = if state as Uint == NK_WIDGET_ROM as Int as Uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != nk_do_button_text_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                bounds,
                symbol,
                text,
                len,
                align,
                NK_BUTTON_DEFAULT,
                &(*style).contextual_button,
                (*style).font,
                in_0,
            ) {
                nk_contextual_close(ctx);
                return nk_true as Int;
            } else {
                return nk_false as Int;
            }
        }
    };
}

pub unsafe fn nk_combo_item_symbol_text(
    mut ctx: *mut Context,
    mut sym: SymbolType,
    mut text: *const Char,
    mut len: Int,
    mut alignment: Flags,
) -> Int {
    return nk_contextual_item_symbol_text(ctx, sym, text, len, alignment);
}

pub unsafe fn nk_combo_close(mut ctx: *mut Context) -> () {
    nk_contextual_close(ctx);
}

pub unsafe fn nk_contextual_begin(
    mut ctx: *mut Context,
    mut flags: Flags,
    mut size: Point,
    mut trigger_bounds: Rect,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut popup: *mut Window = 0 as *mut Window;
    let mut body: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    static mut null_rect: Rect = unsafe {
        Rect {
            x: -1i32 as f32,
            y: -1i32 as f32,
            w: 0i32 as f32,
            h: 0i32 as f32,
        }
    };
    let mut is_clicked: Int = 0i32;
    let mut is_open: Int = 0i32;
    let mut ret: Int = 0i32;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        (*win).popup.con_count = (*win).popup.con_count.wrapping_add(1);
        if (*ctx).current != (*ctx).active {
            return 0i32;
        } else {
            /* check if currently active contextual is active */
            popup = (*win).popup.win;
            is_open = (!popup.is_null()
                && (*win).popup.type_0 as Uint == NK_PANEL_CONTEXTUAL as Int as Uint)
                as Int;
            is_clicked = nk_input_mouse_clicked(&mut (*ctx).input, NK_BUTTON_RIGHT, trigger_bounds);
            if 0 != (*win).popup.active_con && (*win).popup.con_count != (*win).popup.active_con {
                return 0i32;
            } else {
                if 0 == is_open && 0 != (*win).popup.active_con {
                    (*win).popup.active_con = 0i32 as Uint
                }
                if 0 == is_open && 0 == is_clicked {
                    return 0i32;
                } else {
                    /* calculate contextual position on click */
                    (*win).popup.active_con = (*win).popup.con_count;
                    if 0 != is_clicked {
                        body.x = (*ctx).input.mouse.pos.x;
                        body.y = (*ctx).input.mouse.pos.y
                    } else {
                        body.x = (*popup).bounds.x;
                        body.y = (*popup).bounds.y
                    }
                    body.w = size.x;
                    body.h = size.y;
                    /* start nonblocking contextual popup */
                    ret = nk_nonblock_begin(
                        ctx,
                        flags | NK_WINDOW_NO_SCROLLBAR as Int as Uint,
                        body,
                        null_rect,
                        NK_PANEL_CONTEXTUAL,
                    );
                    if 0 != ret {
                        (*win).popup.type_0 = NK_PANEL_CONTEXTUAL
                    } else {
                        (*win).popup.active_con = 0i32 as Uint;
                        (*win).popup.type_0 = NK_PANEL_NONE;
                        if !(*win).popup.win.is_null() {
                            (*(*win).popup.win).flags = 0i32 as Flags
                        }
                    }
                    return ret;
                }
            }
        }
    };
}

pub unsafe fn nk_tooltip(mut ctx: *mut Context, mut text: *const Char) -> () {
    let mut style: *const Style = 0 as *const Style;
    let mut padding: Point = Point { x: 0., y: 0. };
    let mut text_len: Int = 0;
    let mut text_width: f32 = 0.;
    let mut text_height: f32 = 0.;
    if ctx.is_null()
        || (*ctx).current.is_null()
        || (*(*ctx).current).layout.is_null()
        || text.is_null()
    {
        return;
    } else {
        /* fetch configuration data */
        style = &mut (*ctx).style as *mut Style;
        padding = (*style).window.padding;
        /* calculate size of the text and tooltip */
        text_len = nk_strlen(text);
        text_width = (*(*style).font).width.expect("non-null function pointer")(
            (*(*style).font).userdata,
            (*(*style).font).height,
            text,
            text_len,
        );
        text_width += 4i32 as f32 * padding.x;
        text_height = (*(*style).font).height + 2i32 as f32 * padding.y;
        /* execute tooltip and fill with text */
        if 0 != nk_tooltip_begin(ctx, text_width) {
            nk_layout_row_dynamic(ctx, text_height, 1i32);
            Text(ctx, text, text_len, NK_TEXT_LEFT as Int as Flags);
            nk_tooltip_end(ctx);
        }
        return;
    };
}

pub unsafe fn nk_tooltip_end(mut ctx: *mut Context) -> () {
    if ctx.is_null() || (*ctx).current.is_null() {
        return;
    } else {
        (*(*ctx).current).seq = (*(*ctx).current).seq.wrapping_sub(1);
        nk_popup_close(ctx);
        nk_popup_end(ctx);
        return;
    };
}

pub unsafe fn nk_tooltip_begin(mut ctx: *mut Context, mut width: f32) -> Int {
    let mut x: Int = 0;
    let mut y: Int = 0;
    let mut w: Int = 0;
    let mut h: Int = 0;
    let mut win: *mut Window = 0 as *mut Window;
    let mut in_0: *const Input = 0 as *const Input;
    let mut bounds: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut ret: Int = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        /* make sure that no nonblocking popup is currently active */
        win = (*ctx).current;
        in_0 = &mut (*ctx).input as *mut Input;
        if !(*win).popup.win.is_null()
            && 0 != (*win).popup.type_0 as Uint & NK_PANEL_SET_NONBLOCK as Int as Uint
        {
            return 0i32;
        } else {
            w = nk_iceilf(width);
            h = nk_iceilf(nk_null_rect.h);
            x = nk_ifloorf((*in_0).mouse.pos.x + 1i32 as f32) - (*(*win).layout).clip.x as Int;
            y = nk_ifloorf((*in_0).mouse.pos.y + 1i32 as f32) - (*(*win).layout).clip.y as Int;
            bounds.x = x as f32;
            bounds.y = y as f32;
            bounds.w = w as f32;
            bounds.h = h as f32;
            ret = nk_popup_begin(
                ctx,
                NK_POPUP_DYNAMIC,
                b"__##Tooltip##__\x00" as *const u8 as *const Char,
                (NK_WINDOW_NO_SCROLLBAR as Int | NK_WINDOW_BORDER as Int) as Flags,
                bounds,
            );
            if 0 != ret {
                (*(*win).layout).flags &= !(NK_WINDOW_ROM as Int as Flags)
            }
            (*win).popup.type_0 = NK_PANEL_TOOLTIP;
            (*(*(*ctx).current).layout).type_0 = NK_PANEL_TOOLTIP;
            return ret;
        }
    };
}
unsafe fn nk_ifloorf(mut x: f32) -> Int {
    x = (x as Int - if x < 0.0f32 { 1i32 } else { 0i32 }) as f32;
    return x as Int;
}

pub unsafe fn nk_menubar_begin(mut ctx: *mut Context) -> () {
    let mut layout: *mut Panel = 0 as *mut Panel;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        layout = (*(*ctx).current).layout;
        /* if this assert triggers you allocated space between nk_begin and nk_menubar_begin.
    If you want a menubar the first nuklear function after `nk_begin` has to be a
    `nk_menubar_begin` call. Inside the menubar you then have to allocate space for
    widgets (also supports multiple rows).
    Example:
        if (nk_begin(...)) {
            nk_menubar_begin(...);
                nk_layout_xxxx(...);
                nk_button(...);
                nk_layout_xxxx(...);
                nk_button(...);
            nk_menubar_end(...);
        }
        nk_end(...);
    */
        if 0 != (*layout).flags & NK_WINDOW_HIDDEN as Int as Uint
            || 0 != (*layout).flags & NK_WINDOW_MINIMIZED as Int as Uint
        {
            return;
        } else {
            (*layout).menu.x = (*layout).at_x;
            (*layout).menu.y = (*layout).at_y + (*layout).row.height;
            (*layout).menu.w = (*layout).bounds.w;
            (*layout).menu.offset.x = *(*layout).offset_x;
            (*layout).menu.offset.y = *(*layout).offset_y;
            *(*layout).offset_y = 0i32 as u32;
            return;
        }
    };
}

pub unsafe fn nk_menubar_end(mut ctx: *mut Context) -> () {
    let mut win: *mut Window = 0 as *mut Window;
    let mut layout: *mut Panel = 0 as *mut Panel;
    let mut out: *mut CommandBuffer = 0 as *mut CommandBuffer;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return;
    } else {
        win = (*ctx).current;
        out = &mut (*win).buffer as *mut CommandBuffer;
        layout = (*win).layout;
        if 0 != (*layout).flags & NK_WINDOW_HIDDEN as Int as Uint
            || 0 != (*layout).flags & NK_WINDOW_MINIMIZED as Int as Uint
        {
            return;
        } else {
            (*layout).menu.h = (*layout).at_y - (*layout).menu.y;
            (*layout).bounds.y +=
                (*layout).menu.h + (*ctx).style.window.spacing.y + (*layout).row.height;
            (*layout).bounds.h -=
                (*layout).menu.h + (*ctx).style.window.spacing.y + (*layout).row.height;
            *(*layout).offset_x = (*layout).menu.offset.x;
            *(*layout).offset_y = (*layout).menu.offset.y;
            (*layout).at_y = (*layout).bounds.y - (*layout).row.height;
            (*layout).clip.y = (*layout).bounds.y;
            (*layout).clip.h = (*layout).bounds.h;
            nk_push_scissor(out, (*layout).clip);
            return;
        }
    };
}

pub unsafe fn nk_menu_begin_text(
    mut ctx: *mut Context,
    mut title: *const Char,
    mut len: Int,
    mut align: Flags,
    mut size: Point,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut in_0: *const Input = 0 as *const Input;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: Int = nk_false as Int;
    let mut state: Flags = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        state = nk_widget(&mut header, ctx) as Flags;
        if 0 == state {
            return 0i32;
        } else {
            in_0 = if state == NK_WIDGET_ROM as Int as Uint
                || 0 != (*win).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != nk_do_button_text(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                header,
                title,
                len,
                align,
                NK_BUTTON_DEFAULT,
                &mut (*ctx).style.menu_button,
                in_0,
                (*ctx).style.font,
            ) {
                is_clicked = nk_true as Int
            }
            return nk_menu_begin(ctx, win, title, is_clicked, header, size);
        }
    };
}
unsafe fn nk_menu_begin(
    mut ctx: *mut Context,
    mut win: *mut Window,
    mut id: *const Char,
    mut is_clicked: Int,
    mut header: Rect,
    mut size: Point,
) -> Int {
    let mut is_open: Int = 0i32;
    let mut is_active: Int = 0i32;
    let mut body: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut popup: *mut Window = 0 as *mut Window;
    let mut hash: Hash = nk_murmur_hash(
        id as *const Void,
        nk_strlen(id),
        NK_PANEL_MENU as Int as Hash,
    );
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        body.x = header.x;
        body.w = size.x;
        body.y = header.y + header.h;
        body.h = size.y;
        popup = (*win).popup.win;
        is_open = if !popup.is_null() {
            nk_true as Int
        } else {
            nk_false as Int
        };
        is_active = (!popup.is_null()
            && (*win).popup.name == hash
            && (*win).popup.type_0 as Uint == NK_PANEL_MENU as Int as Uint)
            as Int;
        if 0 != is_clicked && 0 != is_open && 0 == is_active
            || 0 != is_open && 0 == is_active
            || 0 == is_open && 0 == is_active && 0 == is_clicked
        {
            return 0i32;
        } else if 0 == nk_nonblock_begin(
            ctx,
            NK_WINDOW_NO_SCROLLBAR as Int as Flags,
            body,
            header,
            NK_PANEL_MENU,
        ) {
            return 0i32;
        } else {
            (*win).popup.type_0 = NK_PANEL_MENU;
            (*win).popup.name = hash;
            return 1i32;
        }
    };
}

pub unsafe fn nk_menu_begin_label(
    mut ctx: *mut Context,
    mut text: *const Char,
    mut align: Flags,
    mut size: Point,
) -> Int {
    return nk_menu_begin_text(ctx, text, nk_strlen(text), align, size);
}

pub unsafe fn nk_menu_begin_image(
    mut ctx: *mut Context,
    mut id: *const Char,
    mut img: Image,
    mut size: Point,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut in_0: *const Input = 0 as *const Input;
    let mut is_clicked: Int = nk_false as Int;
    let mut state: Flags = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        state = nk_widget(&mut header, ctx) as Flags;
        if 0 == state {
            return 0i32;
        } else {
            in_0 = if state == NK_WIDGET_ROM as Int as Uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != nk_do_button_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                header,
                img,
                NK_BUTTON_DEFAULT,
                &mut (*ctx).style.menu_button,
                in_0,
            ) {
                is_clicked = nk_true as Int
            }
            return nk_menu_begin(ctx, win, id, is_clicked, header, size);
        }
    };
}

pub unsafe fn nk_menu_begin_image_text(
    mut ctx: *mut Context,
    mut title: *const Char,
    mut len: Int,
    mut align: Flags,
    mut img: Image,
    mut size: Point,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut in_0: *const Input = 0 as *const Input;
    let mut is_clicked: Int = nk_false as Int;
    let mut state: Flags = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        state = nk_widget(&mut header, ctx) as Flags;
        if 0 == state {
            return 0i32;
        } else {
            in_0 = if state == NK_WIDGET_ROM as Int as Uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != nk_do_button_text_image(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                header,
                img,
                title,
                len,
                align,
                NK_BUTTON_DEFAULT,
                &mut (*ctx).style.menu_button,
                (*ctx).style.font,
                in_0,
            ) {
                is_clicked = nk_true as Int
            }
            return nk_menu_begin(ctx, win, title, is_clicked, header, size);
        }
    };
}

pub unsafe fn nk_menu_begin_image_label(
    mut ctx: *mut Context,
    mut title: *const Char,
    mut align: Flags,
    mut img: Image,
    mut size: Point,
) -> Int {
    return nk_menu_begin_image_text(ctx, title, nk_strlen(title), align, img, size);
}

pub unsafe fn nk_menu_begin_symbol(
    mut ctx: *mut Context,
    mut id: *const Char,
    mut sym: SymbolType,
    mut size: Point,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut in_0: *const Input = 0 as *const Input;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut is_clicked: Int = nk_false as Int;
    let mut state: Flags = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        state = nk_widget(&mut header, ctx) as Flags;
        if 0 == state {
            return 0i32;
        } else {
            in_0 = if state == NK_WIDGET_ROM as Int as Uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != nk_do_button_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                header,
                sym,
                NK_BUTTON_DEFAULT,
                &mut (*ctx).style.menu_button,
                in_0,
                (*ctx).style.font,
            ) {
                is_clicked = nk_true as Int
            }
            return nk_menu_begin(ctx, win, id, is_clicked, header, size);
        }
    };
}

pub unsafe fn nk_menu_begin_symbol_text(
    mut ctx: *mut Context,
    mut title: *const Char,
    mut len: Int,
    mut align: Flags,
    mut sym: SymbolType,
    mut size: Point,
) -> Int {
    let mut win: *mut Window = 0 as *mut Window;
    let mut header: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    let mut in_0: *const Input = 0 as *const Input;
    let mut is_clicked: Int = nk_false as Int;
    let mut state: Flags = 0;
    if ctx.is_null() || (*ctx).current.is_null() || (*(*ctx).current).layout.is_null() {
        return 0i32;
    } else {
        win = (*ctx).current;
        state = nk_widget(&mut header, ctx) as Flags;
        if 0 == state {
            return 0i32;
        } else {
            in_0 = if state == NK_WIDGET_ROM as Int as Uint
                || 0 != (*(*win).layout).flags & NK_WINDOW_ROM as Int as Uint
            {
                0 as *mut Input
            } else {
                &mut (*ctx).input as *mut Input
            };
            if 0 != nk_do_button_text_symbol(
                &mut (*ctx).last_widget_state,
                &mut (*win).buffer,
                header,
                sym,
                title,
                len,
                align,
                NK_BUTTON_DEFAULT,
                &mut (*ctx).style.menu_button,
                (*ctx).style.font,
                in_0,
            ) {
                is_clicked = nk_true as Int
            }
            return nk_menu_begin(ctx, win, title, is_clicked, header, size);
        }
    };
}

pub unsafe fn nk_menu_begin_symbol_label(
    mut ctx: *mut Context,
    mut title: *const Char,
    mut align: Flags,
    mut sym: SymbolType,
    mut size: Point,
) -> Int {
    return nk_menu_begin_symbol_text(ctx, title, nk_strlen(title), align, sym, size);
}

pub unsafe fn nk_menu_item_text(
    mut ctx: *mut Context,
    mut title: *const Char,
    mut len: Int,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_text(ctx, title, len, align);
}

pub unsafe fn nk_menu_item_label(
    mut ctx: *mut Context,
    mut label: *const Char,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_label(ctx, label, align);
}

pub unsafe fn nk_menu_item_image_label(
    mut ctx: *mut Context,
    mut img: Image,
    mut label: *const Char,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_image_label(ctx, img, label, align);
}

pub unsafe fn nk_menu_item_image_text(
    mut ctx: *mut Context,
    mut img: Image,
    mut text: *const Char,
    mut len: Int,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_image_text(ctx, img, text, len, align);
}

pub unsafe fn nk_menu_item_symbol_text(
    mut ctx: *mut Context,
    mut sym: SymbolType,
    mut text: *const Char,
    mut len: Int,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_symbol_text(ctx, sym, text, len, align);
}

pub unsafe fn nk_menu_item_symbol_label(
    mut ctx: *mut Context,
    mut sym: SymbolType,
    mut label: *const Char,
    mut align: Flags,
) -> Int {
    return nk_contextual_item_symbol_label(ctx, sym, label, align);
}

pub unsafe fn nk_menu_close(mut ctx: *mut Context) -> () {
    nk_contextual_close(ctx);
}

pub unsafe fn nk_menu_end(mut ctx: *mut Context) -> () {
    nk_contextual_end(ctx);
}

pub unsafe fn nk_style_load_cursor(
    mut ctx: *mut Context,
    mut cursor: StyleCursor,
    mut c: *const Cursor,
) -> () {
    let mut style: *mut Style = 0 as *mut Style;
    if ctx.is_null() {
        return;
    } else {
        style = &mut (*ctx).style as *mut Style;
        (*style).cursors[cursor as usize] = c;
        return;
    };
}

pub unsafe fn nk_style_load_all_cursors(mut ctx: *mut Context, mut cursors: *mut Cursor) -> () {
    let mut i: Int = 0i32;
    let mut style: *mut Style = 0 as *mut Style;
    if ctx.is_null() {
        return;
    } else {
        style = &mut (*ctx).style as *mut Style;
        i = 0i32;
        while i < NK_CURSOR_COUNT as Int {
            (*style).cursors[i as usize] = &mut *cursors.offset(i as isize) as *mut Cursor;
            i += 1
        }
        (*style).cursor_visible = nk_true as Int;
        return;
    };
}

pub unsafe fn nk_style_get_color_by_name(mut c: StyleColors) -> *const Char {
    return nk_color_names[c as usize];
}
static mut nk_color_names: [*const Char; 28] = unsafe {
    [
        b"NK_COLOR_TEXT\x00" as *const u8 as *const Char,
        b"NK_COLOR_WINDOW\x00" as *const u8 as *const Char,
        b"NK_COLOR_HEADER\x00" as *const u8 as *const Char,
        b"NK_COLOR_BORDER\x00" as *const u8 as *const Char,
        b"NK_COLOR_BUTTON\x00" as *const u8 as *const Char,
        b"NK_COLOR_BUTTON_HOVER\x00" as *const u8 as *const Char,
        b"NK_COLOR_BUTTON_ACTIVE\x00" as *const u8 as *const Char,
        b"NK_COLOR_TOGGLE\x00" as *const u8 as *const Char,
        b"NK_COLOR_TOGGLE_HOVER\x00" as *const u8 as *const Char,
        b"NK_COLOR_TOGGLE_CURSOR\x00" as *const u8 as *const Char,
        b"NK_COLOR_SELECT\x00" as *const u8 as *const Char,
        b"NK_COLOR_SELECT_ACTIVE\x00" as *const u8 as *const Char,
        b"NK_COLOR_SLIDER\x00" as *const u8 as *const Char,
        b"NK_COLOR_SLIDER_CURSOR\x00" as *const u8 as *const Char,
        b"NK_COLOR_SLIDER_CURSOR_HOVER\x00" as *const u8 as *const Char,
        b"NK_COLOR_SLIDER_CURSOR_ACTIVE\x00" as *const u8 as *const Char,
        b"NK_COLOR_PROPERTY\x00" as *const u8 as *const Char,
        b"NK_COLOR_EDIT\x00" as *const u8 as *const Char,
        b"NK_COLOR_EDIT_CURSOR\x00" as *const u8 as *const Char,
        b"NK_COLOR_COMBO\x00" as *const u8 as *const Char,
        b"NK_COLOR_CHART\x00" as *const u8 as *const Char,
        b"NK_COLOR_CHART_COLOR\x00" as *const u8 as *const Char,
        b"NK_COLOR_CHART_COLOR_HIGHLIGHT\x00" as *const u8 as *const Char,
        b"NK_COLOR_SCROLLBAR\x00" as *const u8 as *const Char,
        b"NK_COLOR_SCROLLBAR_CURSOR\x00" as *const u8 as *const Char,
        b"NK_COLOR_SCROLLBAR_CURSOR_HOVER\x00" as *const u8 as *const Char,
        b"NK_COLOR_SCROLLBAR_CURSOR_ACTIVE\x00" as *const u8 as *const Char,
        b"NK_COLOR_TAB_HEADER\x00" as *const u8 as *const Char,
    ]
};

pub unsafe fn nk_style_set_font(mut ctx: *mut Context, mut font: *const UserFont) -> () {
    let mut style: *mut Style = 0 as *mut Style;
    if ctx.is_null() {
        return;
    } else {
        style = &mut (*ctx).style as *mut Style;
        (*style).font = font;
        (*ctx).stacks.fonts.head = 0i32;
        if !(*ctx).current.is_null() {
            nk_layout_reset_min_row_height(ctx);
        }
        return;
    };
}

pub unsafe fn nk_style_set_cursor(mut ctx: *mut Context, mut c: StyleCursor) -> Int {
    let mut style: *mut Style = 0 as *mut Style;
    if ctx.is_null() {
        return 0i32;
    } else {
        style = &mut (*ctx).style as *mut Style;
        if !(*style).cursors[c as usize].is_null() {
            (*style).cursor_active = (*style).cursors[c as usize];
            return 1i32;
        } else {
            return 0i32;
        }
    };
}

pub unsafe fn nk_style_show_cursor(mut ctx: *mut Context) -> () {
    (*ctx).style.cursor_visible = nk_true as Int;
}

pub unsafe fn nk_style_hide_cursor(mut ctx: *mut Context) -> () {
    (*ctx).style.cursor_visible = nk_false as Int;
}

pub unsafe fn nk_style_push_font(mut ctx: *mut Context, mut font: *const UserFont) -> Int {
    let mut font_stack: *mut ConfigStackUserFont = 0 as *mut ConfigStackUserFont;
    let mut element: *mut ConfigStackUserFontElement = 0 as *mut ConfigStackUserFontElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        font_stack = &mut (*ctx).stacks.fonts as *mut ConfigStackUserFont;
        if (*font_stack).head
            >= (mem::size_of::<[ConfigStackUserFontElement; 8]>() as Ulong)
                .wrapping_div(mem::size_of::<ConfigStackUserFontElement>() as Ulong)
                as Int
        {
            return 0i32;
        } else {
            let fresh41 = (*font_stack).head;
            (*font_stack).head = (*font_stack).head + 1;
            element =
                &mut (*font_stack).elements[fresh41 as usize] as *mut ConfigStackUserFontElement;
            (*element).address = &mut (*ctx).style.font as *mut *const UserFont;
            (*element).old_value = (*ctx).style.font;
            (*ctx).style.font = font;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_push_float(
    mut ctx: *mut Context,
    mut address: *mut f32,
    mut value: f32,
) -> Int {
    let mut type_stack: *mut ConfigStackFloat = 0 as *mut ConfigStackFloat;
    let mut element: *mut ConfigStackFloatElement = 0 as *mut ConfigStackFloatElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.floats as *mut ConfigStackFloat;
        if (*type_stack).head
            >= (mem::size_of::<[ConfigStackFloatElement; 32]>() as Ulong)
                .wrapping_div(mem::size_of::<ConfigStackFloatElement>() as Ulong)
                as Int
        {
            return 0i32;
        } else {
            let fresh42 = (*type_stack).head;
            (*type_stack).head = (*type_stack).head + 1;
            element = &mut (*type_stack).elements[fresh42 as usize] as *mut ConfigStackFloatElement;
            (*element).address = address;
            (*element).old_value = *address;
            *address = value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_push_point(
    mut ctx: *mut Context,
    mut address: *mut Point,
    mut value: Point,
) -> Int {
    let mut type_stack: *mut ConfigStackPoint = 0 as *mut ConfigStackPoint;
    let mut element: *mut ConfigStackPointElement = 0 as *mut ConfigStackPointElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.vectors as *mut ConfigStackPoint;
        if (*type_stack).head
            >= (mem::size_of::<[ConfigStackPointElement; 16]>() as Ulong)
                .wrapping_div(mem::size_of::<ConfigStackPointElement>() as Ulong)
                as Int
        {
            return 0i32;
        } else {
            let fresh43 = (*type_stack).head;
            (*type_stack).head = (*type_stack).head + 1;
            element = &mut (*type_stack).elements[fresh43 as usize] as *mut ConfigStackPointElement;
            (*element).address = address;
            (*element).old_value = *address;
            *address = value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_push_style_item(
    mut ctx: *mut Context,
    mut address: *mut StyleItem,
    mut value: StyleItem,
) -> Int {
    let mut type_stack: *mut ConfigStackStyleItem = 0 as *mut ConfigStackStyleItem;
    let mut element: *mut ConfigStackStyleItemElement = 0 as *mut ConfigStackStyleItemElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.style_items as *mut ConfigStackStyleItem;
        if (*type_stack).head
            >= (mem::size_of::<[ConfigStackStyleItemElement; 16]>() as Ulong)
                .wrapping_div(mem::size_of::<ConfigStackStyleItemElement>() as Ulong)
                as Int
        {
            return 0i32;
        } else {
            let fresh44 = (*type_stack).head;
            (*type_stack).head = (*type_stack).head + 1;
            element =
                &mut (*type_stack).elements[fresh44 as usize] as *mut ConfigStackStyleItemElement;
            (*element).address = address;
            (*element).old_value = *address;
            *address = value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_push_flags(
    mut ctx: *mut Context,
    mut address: *mut Flags,
    mut value: Flags,
) -> Int {
    let mut type_stack: *mut ConfigStackFlags = 0 as *mut ConfigStackFlags;
    let mut element: *mut ConfigStackFlagsElement = 0 as *mut ConfigStackFlagsElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.flags as *mut ConfigStackFlags;
        if (*type_stack).head
            >= (mem::size_of::<[ConfigStackFlagsElement; 32]>() as Ulong)
                .wrapping_div(mem::size_of::<ConfigStackFlagsElement>() as Ulong)
                as Int
        {
            return 0i32;
        } else {
            let fresh45 = (*type_stack).head;
            (*type_stack).head = (*type_stack).head + 1;
            element = &mut (*type_stack).elements[fresh45 as usize] as *mut ConfigStackFlagsElement;
            (*element).address = address;
            (*element).old_value = *address;
            *address = value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_push_color(
    mut ctx: *mut Context,
    mut address: *mut Color,
    mut value: Color,
) -> Int {
    let mut type_stack: *mut ConfigStackColor = 0 as *mut ConfigStackColor;
    let mut element: *mut ConfigStackColorElement = 0 as *mut ConfigStackColorElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.colors as *mut ConfigStackColor;
        if (*type_stack).head
            >= (mem::size_of::<[ConfigStackColorElement; 32]>() as Ulong)
                .wrapping_div(mem::size_of::<ConfigStackColorElement>() as Ulong)
                as Int
        {
            return 0i32;
        } else {
            let fresh46 = (*type_stack).head;
            (*type_stack).head = (*type_stack).head + 1;
            element = &mut (*type_stack).elements[fresh46 as usize] as *mut ConfigStackColorElement;
            (*element).address = address;
            (*element).old_value = *address;
            *address = value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_pop_font(mut ctx: *mut Context) -> Int {
    let mut font_stack: *mut ConfigStackUserFont = 0 as *mut ConfigStackUserFont;
    let mut element: *mut ConfigStackUserFontElement = 0 as *mut ConfigStackUserFontElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        font_stack = &mut (*ctx).stacks.fonts as *mut ConfigStackUserFont;
        if (*font_stack).head < 1i32 {
            return 0i32;
        } else {
            (*font_stack).head -= 1;
            element = &mut (*font_stack).elements[(*font_stack).head as usize]
                as *mut ConfigStackUserFontElement;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_pop_float(mut ctx: *mut Context) -> Int {
    let mut type_stack: *mut ConfigStackFloat = 0 as *mut ConfigStackFloat;
    let mut element: *mut ConfigStackFloatElement = 0 as *mut ConfigStackFloatElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.floats as *mut ConfigStackFloat;
        if (*type_stack).head < 1i32 {
            return 0i32;
        } else {
            (*type_stack).head -= 1;
            element = &mut (*type_stack).elements[(*type_stack).head as usize]
                as *mut ConfigStackFloatElement;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_pop_point(mut ctx: *mut Context) -> Int {
    let mut type_stack: *mut ConfigStackPoint = 0 as *mut ConfigStackPoint;
    let mut element: *mut ConfigStackPointElement = 0 as *mut ConfigStackPointElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.vectors as *mut ConfigStackPoint;
        if (*type_stack).head < 1i32 {
            return 0i32;
        } else {
            (*type_stack).head -= 1;
            element = &mut (*type_stack).elements[(*type_stack).head as usize]
                as *mut ConfigStackPointElement;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_pop_style_item(mut ctx: *mut Context) -> Int {
    let mut type_stack: *mut ConfigStackStyleItem = 0 as *mut ConfigStackStyleItem;
    let mut element: *mut ConfigStackStyleItemElement = 0 as *mut ConfigStackStyleItemElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.style_items as *mut ConfigStackStyleItem;
        if (*type_stack).head < 1i32 {
            return 0i32;
        } else {
            (*type_stack).head -= 1;
            element = &mut (*type_stack).elements[(*type_stack).head as usize]
                as *mut ConfigStackStyleItemElement;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_pop_flags(mut ctx: *mut Context) -> Int {
    let mut type_stack: *mut ConfigStackFlags = 0 as *mut ConfigStackFlags;
    let mut element: *mut ConfigStackFlagsElement = 0 as *mut ConfigStackFlagsElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.flags as *mut ConfigStackFlags;
        if (*type_stack).head < 1i32 {
            return 0i32;
        } else {
            (*type_stack).head -= 1;
            element = &mut (*type_stack).elements[(*type_stack).head as usize]
                as *mut ConfigStackFlagsElement;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_style_pop_color(mut ctx: *mut Context) -> Int {
    let mut type_stack: *mut ConfigStackColor = 0 as *mut ConfigStackColor;
    let mut element: *mut ConfigStackColorElement = 0 as *mut ConfigStackColorElement;
    if ctx.is_null() {
        return 0i32;
    } else {
        type_stack = &mut (*ctx).stacks.colors as *mut ConfigStackColor;
        if (*type_stack).head < 1i32 {
            return 0i32;
        } else {
            (*type_stack).head -= 1;
            element = &mut (*type_stack).elements[(*type_stack).head as usize]
                as *mut ConfigStackColorElement;
            *(*element).address = (*element).old_value;
            return 1i32;
        }
    };
}

pub unsafe fn nk_rgb_iv(mut c: *const Int) -> Color {
    return nk_rgb(*c.offset(0isize), *c.offset(1isize), *c.offset(2isize));
}

pub unsafe fn nk_rgb_bv(mut c: *const u8) -> Color {
    return nk_rgb(
        *c.offset(0isize) as Int,
        *c.offset(1isize) as Int,
        *c.offset(2isize) as Int,
    );
}

pub unsafe fn nk_rgb_f(mut r: f32, mut g: f32, mut b: f32) -> Color {
    let mut ret: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    ret.r = (if (0i32 as f32) < if 1.0f32 < r { 1.0f32 } else { r } {
        if 1.0f32 < r {
            1.0f32
        } else {
            r
        }
    } else {
        0i32 as f32
    } * 255.0f32) as u8;
    ret.g = (if (0i32 as f32) < if 1.0f32 < g { 1.0f32 } else { g } {
        if 1.0f32 < g {
            1.0f32
        } else {
            g
        }
    } else {
        0i32 as f32
    } * 255.0f32) as u8;
    ret.b = (if (0i32 as f32) < if 1.0f32 < b { 1.0f32 } else { b } {
        if 1.0f32 < b {
            1.0f32
        } else {
            b
        }
    } else {
        0i32 as f32
    } * 255.0f32) as u8;
    ret.a = 255i32 as u8;
    return ret;
}

pub unsafe fn nk_rgb_fv(mut c: *const f32) -> Color {
    return nk_rgb_f(*c.offset(0isize), *c.offset(1isize), *c.offset(2isize));
}

pub unsafe fn nk_rgb_cf(mut c: ColorF) -> Color {
    return nk_rgb_f(c.r, c.g, c.b);
}

pub unsafe fn nk_rgb_hex(mut rgb: *const Char) -> Color {
    let mut col: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut c: *const Char = rgb;
    if *c as Int == '#' as i32 {
        c = c.offset(1isize)
    }
    col.r = nk_parse_hex(c, 2i32) as u8;
    col.g = nk_parse_hex(c.offset(2isize), 2i32) as u8;
    col.b = nk_parse_hex(c.offset(4isize), 2i32) as u8;
    col.a = 255i32 as u8;
    return col;
}
unsafe fn nk_parse_hex(mut p: *const Char, mut length: Int) -> Int {
    let mut i: Int = 0i32;
    let mut len: Int = 0i32;
    while len < length {
        i <<= 4i32;
        if *p.offset(len as isize) as Int >= 'a' as i32
            && *p.offset(len as isize) as Int <= 'f' as i32
        {
            i += *p.offset(len as isize) as Int - 'a' as i32 + 10i32
        } else if *p.offset(len as isize) as Int >= 'A' as i32
            && *p.offset(len as isize) as Int <= 'F' as i32
        {
            i += *p.offset(len as isize) as Int - 'A' as i32 + 10i32
        } else {
            i += *p.offset(len as isize) as Int - '0' as i32
        }
        len += 1
    }
    return i;
}

pub unsafe fn nk_rgba_u32(mut in_0: u32) -> Color {
    let mut ret: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    ret.r = (in_0 & 255i32 as Uint) as u8;
    ret.g = (in_0 >> 8i32 & 255i32 as Uint) as u8;
    ret.b = (in_0 >> 16i32 & 255i32 as Uint) as u8;
    ret.a = (in_0 >> 24i32 & 255i32 as Uint) as u8;
    return ret;
}

pub unsafe fn nk_rgba_iv(mut c: *const Int) -> Color {
    return nk_rgba(
        *c.offset(0isize),
        *c.offset(1isize),
        *c.offset(2isize),
        *c.offset(3isize),
    );
}

pub unsafe fn nk_rgba_bv(mut c: *const u8) -> Color {
    return nk_rgba(
        *c.offset(0isize) as Int,
        *c.offset(1isize) as Int,
        *c.offset(2isize) as Int,
        *c.offset(3isize) as Int,
    );
}

pub unsafe fn nk_rgba_cf(mut c: ColorF) -> Color {
    return nk_rgba_f(c.r, c.g, c.b, c.a);
}

pub unsafe fn nk_rgba_hex(mut rgb: *const Char) -> Color {
    let mut col: Color = Color {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    let mut c: *const Char = rgb;
    if *c as Int == '#' as i32 {
        c = c.offset(1isize)
    }
    col.r = nk_parse_hex(c, 2i32) as u8;
    col.g = nk_parse_hex(c.offset(2isize), 2i32) as u8;
    col.b = nk_parse_hex(c.offset(4isize), 2i32) as u8;
    col.a = nk_parse_hex(c.offset(6isize), 2i32) as u8;
    return col;
}

pub unsafe fn nk_hsv(mut h: Int, mut s: Int, mut v: Int) -> Color {
    return nk_hsva(h, s, v, 255i32);
}

pub unsafe fn nk_hsva(mut h: Int, mut s: Int, mut v: Int, mut a: Int) -> Color {
    let mut hf: f32 = (if if h < 255i32 { h } else { 255i32 } < 0i32 {
        0i32
    } else if h < 255i32 {
        h
    } else {
        255i32
    }) as f32 / 255.0f32;
    let mut sf: f32 = (if if s < 255i32 { s } else { 255i32 } < 0i32 {
        0i32
    } else if s < 255i32 {
        s
    } else {
        255i32
    }) as f32 / 255.0f32;
    let mut vf: f32 = (if if v < 255i32 { v } else { 255i32 } < 0i32 {
        0i32
    } else if v < 255i32 {
        v
    } else {
        255i32
    }) as f32 / 255.0f32;
    let mut af: f32 = (if if a < 255i32 { a } else { 255i32 } < 0i32 {
        0i32
    } else if a < 255i32 {
        a
    } else {
        255i32
    }) as f32 / 255.0f32;
    return nk_hsva_f(hf, sf, vf, af);
}

pub unsafe fn nk_hsv_iv(mut c: *const Int) -> Color {
    return nk_hsv(*c.offset(0isize), *c.offset(1isize), *c.offset(2isize));
}

pub unsafe fn nk_hsv_bv(mut c: *const u8) -> Color {
    return nk_hsv(
        *c.offset(0isize) as Int,
        *c.offset(1isize) as Int,
        *c.offset(2isize) as Int,
    );
}

pub unsafe fn nk_hsv_fv(mut c: *const f32) -> Color {
    return nk_hsv_f(*c.offset(0isize), *c.offset(1isize), *c.offset(2isize));
}

pub unsafe fn nk_hsva_iv(mut c: *const Int) -> Color {
    return nk_hsva(
        *c.offset(0isize),
        *c.offset(1isize),
        *c.offset(2isize),
        *c.offset(3isize),
    );
}

pub unsafe fn nk_hsva_bv(mut c: *const u8) -> Color {
    return nk_hsva(
        *c.offset(0isize) as Int,
        *c.offset(1isize) as Int,
        *c.offset(2isize) as Int,
        *c.offset(3isize) as Int,
    );
}

pub unsafe fn nk_hsva_fv(mut c: *const f32) -> Color {
    return nk_hsva_f(
        *c.offset(0isize),
        *c.offset(1isize),
        *c.offset(2isize),
        *c.offset(3isize),
    );
}

pub unsafe fn nk_color_cf(mut in_0: Color) -> ColorF {
    let mut o: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    nk_color_f(&mut o.r, &mut o.g, &mut o.b, &mut o.a, in_0);
    return o;
}

pub unsafe fn nk_color_d(
    mut r: *mut f64,
    mut g: *mut f64,
    mut b: *mut f64,
    mut a: *mut f64,
    mut in_0: Color,
) -> () {
    static mut s: f64 = unsafe { 1.0f64 / 255.0f64 };
    *r = in_0.r as f64 * s;
    *g = in_0.g as f64 * s;
    *b = in_0.b as f64 * s;
    *a = in_0.a as f64 * s;
}

pub unsafe fn nk_color_dv(mut c: *mut f64, mut in_0: Color) -> () {
    nk_color_d(
        &mut *c.offset(0isize),
        &mut *c.offset(1isize),
        &mut *c.offset(2isize),
        &mut *c.offset(3isize),
        in_0,
    );
}

pub unsafe fn nk_color_hex_rgba(mut output: *mut Char, mut col: Color) -> () {
    *output.offset(0isize) = (if (col.r as Int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.r as Int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.r as Int & 240i32) >> 4i32)
    }) as Char;
    *output.offset(1isize) = (if col.r as Int & 15i32 <= 9i32 {
        '0' as i32 + (col.r as Int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.r as Int & 15i32)
    }) as Char;
    *output.offset(2isize) = (if (col.g as Int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.g as Int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.g as Int & 240i32) >> 4i32)
    }) as Char;
    *output.offset(3isize) = (if col.g as Int & 15i32 <= 9i32 {
        '0' as i32 + (col.g as Int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.g as Int & 15i32)
    }) as Char;
    *output.offset(4isize) = (if (col.b as Int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.b as Int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.b as Int & 240i32) >> 4i32)
    }) as Char;
    *output.offset(5isize) = (if col.b as Int & 15i32 <= 9i32 {
        '0' as i32 + (col.b as Int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.b as Int & 15i32)
    }) as Char;
    *output.offset(6isize) = (if (col.a as Int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.a as Int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.a as Int & 240i32) >> 4i32)
    }) as Char;
    *output.offset(7isize) = (if col.a as Int & 15i32 <= 9i32 {
        '0' as i32 + (col.a as Int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.a as Int & 15i32)
    }) as Char;
    *output.offset(8isize) = '\u{0}' as i32 as Char;
}

pub unsafe fn nk_color_hex_rgb(mut output: *mut Char, mut col: Color) -> () {
    *output.offset(0isize) = (if (col.r as Int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.r as Int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.r as Int & 240i32) >> 4i32)
    }) as Char;
    *output.offset(1isize) = (if col.r as Int & 15i32 <= 9i32 {
        '0' as i32 + (col.r as Int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.r as Int & 15i32)
    }) as Char;
    *output.offset(2isize) = (if (col.g as Int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.g as Int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.g as Int & 240i32) >> 4i32)
    }) as Char;
    *output.offset(3isize) = (if col.g as Int & 15i32 <= 9i32 {
        '0' as i32 + (col.g as Int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.g as Int & 15i32)
    }) as Char;
    *output.offset(4isize) = (if (col.b as Int & 240i32) >> 4i32 <= 9i32 {
        '0' as i32 + ((col.b as Int & 240i32) >> 4i32)
    } else {
        'A' as i32 - 10i32 + ((col.b as Int & 240i32) >> 4i32)
    }) as Char;
    *output.offset(5isize) = (if col.b as Int & 15i32 <= 9i32 {
        '0' as i32 + (col.b as Int & 15i32)
    } else {
        'A' as i32 - 10i32 + (col.b as Int & 15i32)
    }) as Char;
    *output.offset(6isize) = '\u{0}' as i32 as Char;
}

pub unsafe fn nk_color_hsv_i(
    mut out_h: *mut Int,
    mut out_s: *mut Int,
    mut out_v: *mut Int,
    mut in_0: Color,
) -> () {
    let mut a: Int = 0;
    nk_color_hsva_i(out_h, out_s, out_v, &mut a, in_0);
}

pub unsafe fn nk_color_hsva_i(
    mut out_h: *mut Int,
    mut out_s: *mut Int,
    mut out_v: *mut Int,
    mut out_a: *mut Int,
    mut in_0: Color,
) -> () {
    let mut h: f32 = 0.;
    let mut s: f32 = 0.;
    let mut v: f32 = 0.;
    let mut a: f32 = 0.;
    nk_color_hsva_f(&mut h, &mut s, &mut v, &mut a, in_0);
    *out_h = (h * 255.0f32) as u8 as Int;
    *out_s = (s * 255.0f32) as u8 as Int;
    *out_v = (v * 255.0f32) as u8 as Int;
    *out_a = (a * 255.0f32) as u8 as Int;
}

pub unsafe fn nk_color_hsva_f(
    mut out_h: *mut f32,
    mut out_s: *mut f32,
    mut out_v: *mut f32,
    mut out_a: *mut f32,
    mut in_0: Color,
) -> () {
    let mut col: ColorF = ColorF {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 0.,
    };
    nk_color_f(&mut col.r, &mut col.g, &mut col.b, &mut col.a, in_0);
    nk_colorf_hsva_f(out_h, out_s, out_v, out_a, col);
}

pub unsafe fn nk_color_hsv_b(
    mut out_h: *mut u8,
    mut out_s: *mut u8,
    mut out_v: *mut u8,
    mut in_0: Color,
) -> () {
    let mut tmp: [Int; 4] = [0; 4];
    nk_color_hsva_i(
        &mut tmp[0usize],
        &mut tmp[1usize],
        &mut tmp[2usize],
        &mut tmp[3usize],
        in_0,
    );
    *out_h = tmp[0usize] as u8;
    *out_s = tmp[1usize] as u8;
    *out_v = tmp[2usize] as u8;
}

pub unsafe fn nk_color_hsv_iv(mut out: *mut Int, mut in_0: Color) -> () {
    nk_color_hsv_i(
        &mut *out.offset(0isize),
        &mut *out.offset(1isize),
        &mut *out.offset(2isize),
        in_0,
    );
}

pub unsafe fn nk_color_hsv_bv(mut out: *mut u8, mut in_0: Color) -> () {
    let mut tmp: [Int; 4] = [0; 4];
    nk_color_hsv_i(&mut tmp[0usize], &mut tmp[1usize], &mut tmp[2usize], in_0);
    *out.offset(0isize) = tmp[0usize] as u8;
    *out.offset(1isize) = tmp[1usize] as u8;
    *out.offset(2isize) = tmp[2usize] as u8;
}

pub unsafe fn nk_color_hsv_f(
    mut out_h: *mut f32,
    mut out_s: *mut f32,
    mut out_v: *mut f32,
    mut in_0: Color,
) -> () {
    let mut a: f32 = 0.;
    nk_color_hsva_f(out_h, out_s, out_v, &mut a, in_0);
}

pub unsafe fn nk_color_hsv_fv(mut out: *mut f32, mut in_0: Color) -> () {
    let mut a: f32 = 0.;
    nk_color_hsva_f(
        &mut *out.offset(0isize),
        &mut *out.offset(1isize),
        &mut *out.offset(2isize),
        &mut a,
        in_0,
    );
}

pub unsafe fn nk_color_hsva_b(
    mut h: *mut u8,
    mut s: *mut u8,
    mut v: *mut u8,
    mut a: *mut u8,
    mut in_0: Color,
) -> () {
    let mut tmp: [Int; 4] = [0; 4];
    nk_color_hsva_i(
        &mut tmp[0usize],
        &mut tmp[1usize],
        &mut tmp[2usize],
        &mut tmp[3usize],
        in_0,
    );
    *h = tmp[0usize] as u8;
    *s = tmp[1usize] as u8;
    *v = tmp[2usize] as u8;
    *a = tmp[3usize] as u8;
}

pub unsafe fn nk_color_hsva_iv(mut out: *mut Int, mut in_0: Color) -> () {
    nk_color_hsva_i(
        &mut *out.offset(0isize),
        &mut *out.offset(1isize),
        &mut *out.offset(2isize),
        &mut *out.offset(3isize),
        in_0,
    );
}

pub unsafe fn nk_color_hsva_bv(mut out: *mut u8, mut in_0: Color) -> () {
    let mut tmp: [Int; 4] = [0; 4];
    nk_color_hsva_i(
        &mut tmp[0usize],
        &mut tmp[1usize],
        &mut tmp[2usize],
        &mut tmp[3usize],
        in_0,
    );
    *out.offset(0isize) = tmp[0usize] as u8;
    *out.offset(1isize) = tmp[1usize] as u8;
    *out.offset(2isize) = tmp[2usize] as u8;
    *out.offset(3isize) = tmp[3usize] as u8;
}

pub unsafe fn nk_color_hsva_fv(mut out: *mut f32, mut in_0: Color) -> () {
    nk_color_hsva_f(
        &mut *out.offset(0isize),
        &mut *out.offset(1isize),
        &mut *out.offset(2isize),
        &mut *out.offset(3isize),
        in_0,
    );
}

pub unsafe fn nk_handle_id(mut id: Int) -> Handle {
    let mut handle: Handle = Handle {
        ptr: 0 as *mut Void,
    };
    nk_zero(
        &mut handle as *mut Handle as *mut Void,
        mem::size_of::<Handle>() as Ulong,
    );
    handle.id = id;
    return handle;
}

pub unsafe fn nk_image_handle(mut handle: Handle) -> Image {
    let mut s: Image = Image {
        handle: Handle {
            ptr: 0 as *mut Void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut Image as *mut Void,
        mem::size_of::<Image>() as Ulong,
    );
    s.handle = handle;
    s.w = 0i32 as Ushort;
    s.h = 0i32 as Ushort;
    s.region[0usize] = 0i32 as Ushort;
    s.region[1usize] = 0i32 as Ushort;
    s.region[2usize] = 0i32 as Ushort;
    s.region[3usize] = 0i32 as Ushort;
    return s;
}

pub unsafe fn nk_image_ptr(mut ptr: *mut Void) -> Image {
    let mut s: Image = Image {
        handle: Handle {
            ptr: 0 as *mut Void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut Image as *mut Void,
        mem::size_of::<Image>() as Ulong,
    );
    s.handle.ptr = ptr;
    s.w = 0i32 as Ushort;
    s.h = 0i32 as Ushort;
    s.region[0usize] = 0i32 as Ushort;
    s.region[1usize] = 0i32 as Ushort;
    s.region[2usize] = 0i32 as Ushort;
    s.region[3usize] = 0i32 as Ushort;
    return s;
}

pub unsafe fn nk_image_id(mut id: Int) -> Image {
    let mut s: Image = Image {
        handle: Handle {
            ptr: 0 as *mut Void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut Image as *mut Void,
        mem::size_of::<Image>() as Ulong,
    );
    s.handle.id = id;
    s.w = 0i32 as Ushort;
    s.h = 0i32 as Ushort;
    s.region[0usize] = 0i32 as Ushort;
    s.region[1usize] = 0i32 as Ushort;
    s.region[2usize] = 0i32 as Ushort;
    s.region[3usize] = 0i32 as Ushort;
    return s;
}

pub unsafe fn nk_subimage_ptr(
    mut ptr: *mut Void,
    mut w: Ushort,
    mut h: Ushort,
    mut r: Rect,
) -> Image {
    let mut s: Image = Image {
        handle: Handle {
            ptr: 0 as *mut Void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut Image as *mut Void,
        mem::size_of::<Image>() as Ulong,
    );
    s.handle.ptr = ptr;
    s.w = w;
    s.h = h;
    s.region[0usize] = r.x as Ushort;
    s.region[1usize] = r.y as Ushort;
    s.region[2usize] = r.w as Ushort;
    s.region[3usize] = r.h as Ushort;
    return s;
}

pub unsafe fn nk_subimage_id(mut id: Int, mut w: Ushort, mut h: Ushort, mut r: Rect) -> Image {
    let mut s: Image = Image {
        handle: Handle {
            ptr: 0 as *mut Void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut Image as *mut Void,
        mem::size_of::<Image>() as Ulong,
    );
    s.handle.id = id;
    s.w = w;
    s.h = h;
    s.region[0usize] = r.x as Ushort;
    s.region[1usize] = r.y as Ushort;
    s.region[2usize] = r.w as Ushort;
    s.region[3usize] = r.h as Ushort;
    return s;
}

pub unsafe fn nk_subimage_handle(
    mut handle: Handle,
    mut w: Ushort,
    mut h: Ushort,
    mut r: Rect,
) -> Image {
    let mut s: Image = Image {
        handle: Handle {
            ptr: 0 as *mut Void,
        },
        w: 0,
        h: 0,
        region: [0; 4],
    };
    nk_zero(
        &mut s as *mut Image as *mut Void,
        mem::size_of::<Image>() as Ulong,
    );
    s.handle = handle;
    s.w = w;
    s.h = h;
    s.region[0] = r.x as Ushort;
    s.region[1] = r.y as Ushort;
    s.region[2] = r.w as Ushort;
    s.region[3] = r.h as Ushort;
    return s;
}

pub unsafe fn PointI(mut x: Int, mut y: Int) -> Point {
    let mut ret: Point = Point { x: 0., y: 0. };
    ret.x = x as f32;
    ret.y = y as f32;
    return ret;
}

pub unsafe fn nk_pointv(mut v: *const f32) -> Point {
    return Point::new(*v.offset(0isize), *v.offset(1isize));
}

pub unsafe fn nk_pointiv(mut v: *const Int) -> Point {
    return PointI(*v.offset(0isize), *v.offset(1isize));
}

pub unsafe fn nk_get_null_rect() -> Rect {
    return nk_null_rect;
}

pub unsafe fn RectI(mut x: Int, mut y: Int, mut w: Int, mut h: Int) -> Rect {
    let mut r: Rect = Rect {
        x: 0.,
        y: 0.,
        w: 0.,
        h: 0.,
    };
    r.x = x as f32;
    r.y = y as f32;
    r.w = w as f32;
    r.h = h as f32;
    return r;
}

pub unsafe fn nk_recta(mut pos: Point, mut size: Point) -> Rect {
    return Rect::new(pos.x, pos.y, size.x, size.y);
}

pub unsafe fn nk_rectv(mut r: *const f32) -> Rect {
    return Rect::new(*r.offset(0), *r.offset(1), *r.offset(2), *r.offset(3));
}

pub unsafe fn nk_rectiv(mut r: *const Int) -> Rect {
    return RectI(*r.offset(0), *r.offset(1), *r.offset(2), *r.offset(3));
}

pub unsafe fn nk_rect_pos(mut r: Rect) -> Point {
    Point { x: r.x, y: r.y }
}

pub unsafe fn nk_rect_size(mut r: Rect) -> Point {
    Point { x: r.w, y: r.h }
}

pub unsafe fn nk_stricmp(mut s1: *const Char, mut s2: *const Char) -> Int {
    let mut current_block: u64;
    let mut c1: i32 = 0;
    let mut c2: i32 = 0;
    let mut d: i32 = 0;
    loop {
        let fresh47 = s1;
        s1 = s1.offset(1);
        c1 = *fresh47 as i32;
        let fresh48 = s2;
        s2 = s2.offset(1);
        c2 = *fresh48 as i32;
        d = c1 - c2;
        if 0 != d {
            if c1 <= 'Z' as i32 && c1 >= 'A' as i32 {
                d += 'a' as i32 - 'A' as i32;
                if 0 == d {
                    current_block = 9386390421034826751;
                } else {
                    current_block = 12675440807659640239;
                }
            } else {
                current_block = 12675440807659640239;
            }
            match current_block {
                9386390421034826751 => {}
                _ => {
                    if c2 <= 'Z' as i32 && c2 >= 'A' as i32 {
                        d -= 'a' as i32 - 'A' as i32;
                        if 0 == d {
                            current_block = 9386390421034826751;
                        } else {
                            current_block = 820271813250567934;
                        }
                    } else {
                        current_block = 820271813250567934;
                    }
                    match current_block {
                        9386390421034826751 => {}
                        _ => return (((d >= 0i32) as Int) << 1i32) - 1i32,
                    }
                }
            }
        }
        if !(0 != c1) {
            break;
        }
    }
    return 0i32;
}

pub unsafe fn nk_strfilter(mut text: *const Char, mut regexp: *const Char) -> Int {
    /*
    c    matches any literal character c
    .    matches any single character
    ^    matches the beginning of the input string
    $    matches the end of the input string
    *    matches zero or more occurrences of the previous character*/
    if *regexp.offset(0isize) as Int == '^' as i32 {
        return nk_str_match_here(regexp.offset(1isize), text);
    } else {
        loop {
            /* must look even if string is empty */
            if 0 != nk_str_match_here(regexp, text) {
                return 1i32;
            } else {
                let fresh49 = text;
                text = text.offset(1);
                if !(*fresh49 as Int != '\u{0}' as i32) {
                    break;
                }
            }
        }
        return 0i32;
    };
}
unsafe fn nk_str_match_here(mut regexp: *const Char, mut text: *const Char) -> Int {
    if *regexp.offset(0isize) as Int == '\u{0}' as i32 {
        return 1i32;
    } else if *regexp.offset(1isize) as Int == '*' as i32 {
        return nk_str_match_star(*regexp.offset(0isize) as Int, regexp.offset(2isize), text);
    } else if *regexp.offset(0isize) as Int == '$' as i32
        && *regexp.offset(1isize) as Int == '\u{0}' as i32
    {
        return (*text as Int == '\u{0}' as i32) as Int;
    } else if *text as Int != '\u{0}' as i32
        && (*regexp.offset(0isize) as Int == '.' as i32
            || *regexp.offset(0isize) as Int == *text as Int)
    {
        return nk_str_match_here(regexp.offset(1isize), text.offset(1isize));
    } else {
        return 0i32;
    };
}
unsafe fn nk_str_match_star(mut c: Int, mut regexp: *const Char, mut text: *const Char) -> Int {
    loop {
        /* a '* matches zero or more instances */
        if 0 != nk_str_match_here(regexp, text) {
            return 1i32;
        } else if !(*text as Int != '\u{0}' as i32 && {
            let fresh50 = text;
            text = text.offset(1);
            *fresh50 as Int == c || c == '.' as i32
        }) {
            break;
        }
    }
    return 0i32;
}

pub unsafe fn nk_strmatch_fuzzy_string(
    mut str: *const Char,
    mut pattern: *const Char,
    mut out_score: *mut Int,
) -> Int {
    return nk_strmatch_fuzzy_text(str, nk_strlen(str), pattern, out_score);
}

pub unsafe fn nk_strmatch_fuzzy_text(
    mut str: *const Char,
    mut str_len: Int,
    mut pattern: *const Char,
    mut out_score: *mut Int,
) -> Int {
    /* Returns true if each character in pattern is found sequentially within str
     * if found then out_score is also set. Score value has no intrinsic meaning.
     * Range varies with pattern. Can only compare scores with same search pattern. */
    /* bonus for adjacent matches */
    /* bonus if match occurs after a separator */
    /* bonus if match is uppercase and prev is lower */
    /* penalty applied for every letter in str before the first match */
    /* maximum penalty for leading letters */
    /* penalty for every letter that doesn't matter */
    /* loop variables */
    let mut score: Int = 0i32;
    let mut pattern_iter: *const Char = pattern;
    let mut str_iter: Int = 0i32;
    let mut prev_matched: Int = nk_false as Int;
    let mut prev_lower: Int = nk_false as Int;
    /* true so if first letter match gets separator bonus*/
    let mut prev_separator: Int = nk_true as Int;
    /* use "best" matched letter if multiple string letters match the pattern */
    let mut best_letter: *const Char = 0 as *const Char;
    let mut best_letter_score: Int = 0i32;
    /* loop over strings */
    if str.is_null() || 0 == str_len || pattern.is_null() {
        return 0i32;
    } else {
        while str_iter < str_len {
            let pattern_letter: Char = *pattern_iter;
            let str_letter: Char = *str.offset(str_iter as isize);
            let mut next_match: Int = (*pattern_iter as Int != '\u{0}' as i32
                && nk_to_lower(pattern_letter as Int) == nk_to_lower(str_letter as Int))
                as Int;
            let mut rematch: Int = (!best_letter.is_null()
                && nk_to_upper(*best_letter as Int) == nk_to_upper(str_letter as Int))
                as Int;
            let mut advanced: Int = (0 != next_match && !best_letter.is_null()) as Int;
            let mut pattern_repeat: Int =
                (!best_letter.is_null() && *pattern_iter as Int != '\u{0}' as i32) as Int;
            pattern_repeat = (0 != pattern_repeat
                && nk_to_lower(*best_letter as Int) == nk_to_lower(pattern_letter as Int))
                as Int;
            if 0 != advanced || 0 != pattern_repeat {
                score += best_letter_score;
                best_letter = 0 as *const Char;
                best_letter_score = 0i32
            }
            if 0 != next_match || 0 != rematch {
                let mut new_score: Int = 0i32;
                /* Apply penalty for each letter before the first pattern match */
                if pattern_iter == pattern {
                    let mut count: Int =
                        str.ptr_offset_to(&*str.offset(str_iter as isize) as *const Char)
                            .expect("bad offset_to") as Long as Int;
                    let mut penalty: Int = -3i32 * count;
                    if penalty < -9i32 {
                        penalty = -9i32
                    }
                    score += penalty
                }
                /* apply bonus for consecutive bonuses */
                if 0 != prev_matched {
                    new_score += 5i32
                }
                /* apply bonus for matches after a separator */
                if 0 != prev_separator {
                    new_score += 10i32
                }
                /* apply bonus across camel case boundaries */
                if 0 != prev_lower && 0 != nk_is_upper(str_letter as Int) {
                    new_score += 10i32
                }
                /* update pattern iter IFF the next pattern letter was matched */
                if 0 != next_match {
                    pattern_iter = pattern_iter.offset(1isize)
                }
                /* update best letter in str which may be for a "next" letter or a rematch */
                if new_score >= best_letter_score {
                    /* apply penalty for now skipped letter */
                    if !best_letter.is_null() {
                        score += -1i32
                    }
                    best_letter = &*str.offset(str_iter as isize) as *const Char;
                    best_letter_score = new_score
                }
                prev_matched = nk_true as Int
            } else {
                score += -1i32;
                prev_matched = nk_false as Int
            }
            /* separators should be more easily defined */
            prev_lower = (nk_is_lower(str_letter as Int) != 0i32) as Int;
            prev_separator =
                (str_letter as Int == '_' as i32 || str_letter as Int == ' ' as i32) as Int;
            str_iter += 1
        }
        /* apply score for last match */
        if !best_letter.is_null() {
            score += best_letter_score
        }
        /* did not match full pattern */
        if *pattern_iter as Int != '\u{0}' as i32 {
            return nk_false as Int;
        } else {
            if !out_score.is_null() {
                *out_score = score
            }
            return nk_true as Int;
        }
    };
}
unsafe fn nk_is_lower(mut c: Int) -> Int {
    return (c >= 'a' as i32 && c <= 'z' as i32 || c >= 224i32 && c <= 255i32) as Int;
}
unsafe fn nk_to_lower(mut c: Int) -> Int {
    return if c >= 'A' as i32 && c <= 'Z' as i32 {
        c - ('a' as i32 + 'A' as i32)
    } else {
        c
    };
}
unsafe fn nk_is_upper(mut c: Int) -> Int {
    return (c >= 'A' as i32 && c <= 'Z' as i32 || c >= 192i32 && c <= 223i32) as Int;
}
unsafe fn nk_to_upper(mut c: Int) -> Int {
    return if c >= 'a' as i32 && c <= 'z' as i32 {
        c - ('a' as i32 - 'A' as i32)
    } else {
        c
    };
}

pub unsafe fn nk_utf_at(
    mut buffer: *const Char,
    mut length: Int,
    mut index: Int,
    mut unicode: *mut Rune,
    mut len: *mut Int,
) -> *const Char {
    let mut i: Int = 0i32;
    let mut src_len: Int = 0i32;
    let mut glyph_len: Int = 0i32;
    let mut text: *const Char = 0 as *const Char;
    let mut text_len: Int = 0;
    if buffer.is_null() || unicode.is_null() || len.is_null() {
        return 0 as *const Char;
    } else if index < 0i32 {
        *unicode = 65533i32 as Rune;
        *len = 0i32;
        return 0 as *const Char;
    } else {
        text = buffer;
        text_len = length;
        glyph_len = nk_utf_decode(text, unicode, text_len);
        while 0 != glyph_len {
            if i == index {
                *len = glyph_len;
                break;
            } else {
                i += 1;
                src_len = src_len + glyph_len;
                glyph_len =
                    nk_utf_decode(text.offset(src_len as isize), unicode, text_len - src_len)
            }
        }
        if i != index {
            return 0 as *const Char;
        } else {
            return buffer.offset(src_len as isize);
        }
    };
}

pub unsafe fn nk_font_default_glyph_ranges() -> *const Rune {
    static mut ranges: [Rune; 3] = unsafe { [32i32 as Rune, 255i32 as Rune, 0i32 as Rune] };
    return ranges.as_ptr();
}

pub unsafe fn nk_font_chinese_glyph_ranges() -> *const Rune {
    static mut ranges: [Rune; 11] = unsafe {
        [
            32i32 as Rune,
            255i32 as Rune,
            12288i32 as Rune,
            12543i32 as Rune,
            12784i32 as Rune,
            12799i32 as Rune,
            65280i32 as Rune,
            65519i32 as Rune,
            19968i32 as Rune,
            40879i32 as Rune,
            0i32 as Rune,
        ]
    };
    return ranges.as_ptr();
}

pub unsafe fn nk_font_cyrillic_glyph_ranges() -> *const Rune {
    static mut ranges: [Rune; 9] = unsafe {
        [
            32i32 as Rune,
            255i32 as Rune,
            1024i32 as Rune,
            1327i32 as Rune,
            11744i32 as Rune,
            11775i32 as Rune,
            42560i32 as Rune,
            42655i32 as Rune,
            0i32 as Rune,
        ]
    };
    return ranges.as_ptr();
}

pub unsafe fn nk_font_korean_glyph_ranges() -> *const Rune {
    static mut ranges: [Rune; 7] = unsafe {
        [
            32i32 as Rune,
            255i32 as Rune,
            12593i32 as Rune,
            12643i32 as Rune,
            44032i32 as Rune,
            55197i32 as Rune,
            0i32 as Rune,
        ]
    };
    return ranges.as_ptr();
}

pub unsafe fn nk_font_atlas_init_default(mut atlas: *mut FontAtlas) -> () {
    if atlas.is_null() {
        return;
    } else {
        nk_zero(atlas as *mut Void, mem::size_of::<FontAtlas>() as Ulong);
        (*atlas).temporary.userdata.ptr = 0 as *mut Void;
        (*atlas).temporary.alloc = Some(nk_malloc);
        (*atlas).temporary.free = Some(nk_mfree);
        (*atlas).permanent.userdata.ptr = 0 as *mut Void;
        (*atlas).permanent.alloc = Some(nk_malloc);
        (*atlas).permanent.free = Some(nk_mfree);
        return;
    };
}

pub unsafe fn nk_font_atlas_init(mut atlas: *mut FontAtlas, mut alloc: *mut Allocator) -> () {
    if atlas.is_null() || alloc.is_null() {
        return;
    } else {
        nk_zero(atlas as *mut Void, mem::size_of::<FontAtlas>() as Ulong);
        (*atlas).permanent = *alloc;
        (*atlas).temporary = *alloc;
        return;
    };
}

pub unsafe fn nk_font_atlas_init_custom(
    mut atlas: *mut FontAtlas,
    mut permanent: *mut Allocator,
    mut temporary: *mut Allocator,
) -> () {
    if atlas.is_null() || permanent.is_null() || temporary.is_null() {
        return;
    } else {
        nk_zero(atlas as *mut Void, mem::size_of::<FontAtlas>() as Ulong);
        (*atlas).permanent = *permanent;
        (*atlas).temporary = *temporary;
        return;
    };
}

pub unsafe fn nk_font_atlas_begin(mut atlas: *mut FontAtlas) -> () {
    if atlas.is_null()
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
    {
        return;
    } else {
        if !(*atlas).glyphs.is_null() {
            (*atlas).permanent.free.expect("non-null function pointer")(
                (*atlas).permanent.userdata,
                (*atlas).glyphs as *mut Void,
            );
            (*atlas).glyphs = 0 as *mut FontGlyph
        }
        if !(*atlas).pixel.is_null() {
            (*atlas).permanent.free.expect("non-null function pointer")(
                (*atlas).permanent.userdata,
                (*atlas).pixel,
            );
            (*atlas).pixel = 0 as *mut Void
        }
        return;
    };
}

pub unsafe fn FontConfig(mut pixel_height: f32) -> FontConfig {
    let mut cfg: FontConfig = FontConfig {
        next: 0 as *mut FontConfig,
        ttf_blob: 0 as *mut Void,
        ttf_size: 0,
        ttf_data_owned_by_atlas: 0,
        merge_mode: 0,
        pixel_snap: 0,
        oversample_v: 0,
        oversample_h: 0,
        padding: [0; 3],
        size: 0.,
        coord_type: NK_COORD_UV,
        spacing: Point { x: 0., y: 0. },
        range: 0 as *const Rune,
        font: 0 as *mut BakedFont,
        fallback_glyph: 0,
        n: 0 as *mut FontConfig,
        p: 0 as *mut FontConfig,
    };
    nk_zero(
        &mut cfg as *mut FontConfig as *mut Void,
        mem::size_of::<FontConfig>() as Ulong,
    );
    cfg.ttf_blob = 0 as *mut Void;
    cfg.ttf_size = 0i32 as Size;
    cfg.ttf_data_owned_by_atlas = 0i32 as Uchar;
    cfg.size = pixel_height;
    cfg.oversample_h = 3i32 as Uchar;
    cfg.oversample_v = 1i32 as Uchar;
    cfg.pixel_snap = 0i32 as Uchar;
    cfg.coord_type = NK_COORD_UV;
    cfg.spacing = Point::new(0i32 as f32, 0i32 as f32);
    cfg.range = nk_font_default_glyph_ranges();
    cfg.merge_mode = 0i32 as Uchar;
    cfg.fallback_glyph = '?' as i32 as Rune;
    cfg.font = 0 as *mut BakedFont;
    cfg.n = 0 as *mut FontConfig;
    return cfg;
}

pub unsafe fn nk_font_atlas_add(
    mut atlas: *mut FontAtlas,
    mut config: *const FontConfig,
) -> *mut Font {
    let mut c: *mut FontConfig = 0 as *mut FontConfig;
    let mut f: *mut Font = 0 as *mut Font;
    let mut font: *mut Font = 0 as *mut Font;
    let mut cfg: *mut FontConfig = 0 as *mut FontConfig;
    if atlas.is_null()
        || config.is_null()
        || (*config).ttf_blob.is_null()
        || 0 == (*config).ttf_size
        || (*config).size <= 0.0f32
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
    {
        return 0 as *mut Font;
    } else {
        /* allocate font config  */
        cfg = (*atlas).permanent.alloc.expect("non-null function pointer")(
            (*atlas).permanent.userdata,
            0 as *mut Void,
            mem::size_of::<FontConfig>() as Ulong,
        ) as *mut FontConfig;
        nk_memcopy(
            cfg as *mut Void,
            config as *const Void,
            mem::size_of::<FontConfig>() as Ulong,
        );
        (*cfg).n = cfg;
        (*cfg).p = cfg;
        if 0 == (*config).merge_mode {
            /* insert font config into list */
            if (*atlas).config.is_null() {
                (*atlas).config = cfg;
                (*cfg).next = 0 as *mut FontConfig
            } else {
                let mut i: *mut FontConfig = (*atlas).config;
                while !(*i).next.is_null() {
                    i = (*i).next
                }
                (*i).next = cfg;
                (*cfg).next = 0 as *mut FontConfig
            }
            /* allocate new font */
            font = (*atlas).permanent.alloc.expect("non-null function pointer")(
                (*atlas).permanent.userdata,
                0 as *mut Void,
                mem::size_of::<Font>() as Ulong,
            ) as *mut Font;
            nk_zero(font as *mut Void, mem::size_of::<Font>() as Ulong);
            if font.is_null() {
                return 0 as *mut Font;
            } else {
                (*font).config = cfg;
                /* insert font into list */
                if (*atlas).fonts.is_null() {
                    (*atlas).fonts = font;
                    (*font).next = 0 as *mut Font
                } else {
                    let mut i_0: *mut Font = (*atlas).fonts;
                    while !(*i_0).next.is_null() {
                        i_0 = (*i_0).next
                    }
                    (*i_0).next = font;
                    (*font).next = 0 as *mut Font
                }
                (*cfg).font = &mut (*font).info as *mut BakedFont
            }
        } else {
            /* extend previously added font */
            f = 0 as *mut Font;
            c = 0 as *mut FontConfig;
            f = (*atlas).fonts;
            c = (*f).config;
            (*cfg).font = &mut (*f).info as *mut BakedFont;
            (*cfg).n = c;
            (*cfg).p = (*c).p;
            (*(*c).p).n = cfg;
            (*c).p = cfg
        }
        /* create own copy of .TTF font blob */
        if 0 == (*config).ttf_data_owned_by_atlas {
            (*cfg).ttf_blob = (*atlas).permanent.alloc.expect("non-null function pointer")(
                (*atlas).permanent.userdata,
                0 as *mut Void,
                (*cfg).ttf_size,
            );
            if (*cfg).ttf_blob.is_null() {
                (*atlas).font_num += 1;
                return 0 as *mut Font;
            } else {
                nk_memcopy((*cfg).ttf_blob, (*config).ttf_blob, (*cfg).ttf_size);
                (*cfg).ttf_data_owned_by_atlas = 1i32 as Uchar
            }
        }
        (*atlas).font_num += 1;
        return font;
    };
}

pub unsafe fn nk_font_atlas_add_default(
    mut atlas: *mut FontAtlas,
    mut pixel_height: f32,
    mut config: *const FontConfig,
) -> *mut Font {
    return nk_font_atlas_add_compressed_base85(
        atlas,
        nk_proggy_clean_ttf_compressed_data_base85.as_ptr(),
        pixel_height,
        config,
    );
}
static mut nk_proggy_clean_ttf_compressed_data_base85: [Char; 11981] = unsafe {
    [
        55, 93, 41, 35, 35, 35, 35, 35, 35, 35, 104, 86, 48, 113, 115, 39, 47, 35, 35, 35, 91, 41,
        44, 35, 35, 47, 108, 58, 36, 35, 81, 54, 62, 35, 35, 53, 91, 110, 52, 50, 62, 99, 45, 84,
        72, 96, 45, 62, 62, 35, 47, 101, 62, 49, 49, 78, 78, 86, 61, 66, 118, 40, 42, 58, 46, 70,
        63, 117, 117, 35, 40, 103, 82, 85, 46, 111, 48, 88, 71, 72, 96, 36, 118, 104, 76, 71, 49,
        104, 120, 116, 57, 63, 87, 96, 35, 44, 53, 76, 115, 67, 112, 35, 45, 105, 62, 46, 114, 36,
        60, 36, 54, 112, 68, 62, 76, 98, 39, 59, 57, 67, 114, 99, 54, 116, 103, 88, 109, 75, 86,
        101, 85, 50, 99, 68, 52, 69, 111, 51, 82, 47, 50, 42, 62, 93, 98, 40, 77, 67, 59, 36, 106,
        80, 102, 89, 46, 59, 104, 94, 96, 73, 87, 77, 57, 60, 76, 104, 50, 84, 108, 83, 43, 102,
        45, 115, 36, 111, 54, 81, 60, 66, 87, 72, 96, 89, 105, 85, 46, 120, 102, 76, 113, 36, 78,
        59, 36, 48, 105, 82, 47, 71, 88, 58, 85, 40, 106, 99, 87, 50, 112, 47, 87, 42, 113, 63, 45,
        113, 109, 110, 85, 67, 73, 59, 106, 72, 83, 65, 105, 70, 87, 77, 46, 82, 42, 107, 85, 64,
        67, 61, 71, 72, 63, 97, 57, 119, 112, 56, 102, 36, 101, 46, 45, 52, 94, 81, 103, 49, 41,
        81, 45, 71, 76, 40, 108, 102, 40, 114, 47, 55, 71, 114, 82, 103, 119, 86, 37, 77, 83, 61,
        67, 35, 96, 56, 78, 68, 62, 81, 111, 35, 116, 39, 88, 35, 40, 118, 35, 89, 57, 119, 48, 35,
        49, 68, 36, 67, 73, 102, 59, 87, 39, 35, 112, 87, 85, 80, 88, 79, 117, 120, 88, 117, 85,
        40, 72, 57, 77, 40, 49, 60, 113, 45, 85, 69, 51, 49, 35, 94, 45, 86, 39, 56, 73, 82, 85,
        111, 55, 81, 102, 46, 47, 76, 62, 61, 75, 101, 36, 36, 39, 53, 70, 37, 41, 93, 48, 94, 35,
        48, 88, 64, 85, 46, 97, 60, 114, 58, 81, 76, 116, 70, 115, 76, 99, 76, 54, 35, 35, 108, 79,
        106, 41, 35, 46, 89, 53, 60, 45, 82, 38, 75, 103, 76, 119, 113, 74, 102, 76, 103, 78, 38,
        59, 81, 63, 103, 73, 94, 35, 68, 89, 50, 117, 76, 105, 64, 94, 114, 77, 108, 57, 116, 61,
        99, 87, 113, 54, 35, 35, 119, 101, 103, 62, 36, 70, 66, 106, 86, 81, 84, 83, 68, 103, 69,
        75, 110, 73, 83, 55, 69, 77, 57, 62, 90, 89, 57, 119, 48, 35, 76, 59, 62, 62, 35, 77, 120,
        38, 52, 77, 118, 116, 47, 47, 76, 91, 77, 107, 65, 35, 87, 64, 108, 75, 46, 78, 39, 91, 48,
        35, 55, 82, 76, 95, 38, 35, 119, 43, 70, 37, 72, 116, 71, 57, 77, 35, 88, 76, 96, 78, 38,
        46, 44, 71, 77, 52, 80, 103, 59, 45, 60, 110, 76, 69, 78, 104, 118, 120, 62, 45, 86, 115,
        77, 46, 77, 48, 114, 74, 102, 76, 72, 50, 101, 84, 77, 96, 42, 111, 74, 77, 72, 82, 67, 96,
        78, 107, 102, 105, 109, 77, 50, 74, 44, 87, 45, 106, 88, 83, 58, 41, 114, 48, 119, 75, 35,
        64, 70, 103, 101, 36, 85, 62, 96, 119, 39, 78, 55, 71, 35, 36, 35, 102, 66, 35, 36, 69, 94,
        36, 35, 58, 57, 58, 104, 107, 43, 101, 79, 101, 45, 45, 54, 120, 41, 70, 55, 42, 69, 37,
        63, 55, 54, 37, 94, 71, 77, 72, 101, 80, 87, 45, 90, 53, 108, 39, 38, 71, 105, 70, 35, 36,
        57, 53, 54, 58, 114, 83, 63, 100, 65, 35, 102, 105, 75, 58, 41, 89, 114, 43, 96, 38, 35,
        48, 106, 64, 39, 68, 98, 71, 38, 35, 94, 36, 80, 71, 46, 76, 108, 43, 68, 78, 97, 60, 88,
        67, 77, 75, 69, 86, 42, 78, 41, 76, 78, 47, 78, 42, 98, 61, 37, 81, 54, 112, 105, 97, 45,
        88, 103, 56, 73, 36, 60, 77, 82, 38, 44, 86, 100, 74, 101, 36, 60, 40, 55, 71, 59, 67, 107,
        108, 39, 38, 104, 70, 59, 59, 36, 60, 95, 61, 88, 40, 98, 46, 82, 83, 37, 37, 41, 35, 35,
        35, 77, 80, 66, 117, 117, 69, 49, 86, 58, 118, 38, 99, 88, 38, 35, 50, 109, 35, 40, 38, 99,
        86, 93, 96, 107, 57, 79, 104, 76, 77, 98, 110, 37, 115, 36, 71, 50, 44, 66, 36, 66, 102,
        68, 51, 88, 42, 115, 112, 53, 35, 108, 44, 36, 82, 35, 93, 120, 95, 88, 49, 120, 75, 88,
        37, 98, 53, 85, 42, 91, 114, 53, 105, 77, 102, 85, 111, 57, 85, 96, 78, 57, 57, 104, 71,
        41, 116, 109, 43, 47, 85, 115, 57, 112, 71, 41, 88, 80, 117, 96, 60, 48, 115, 45, 41, 87,
        84, 116, 40, 103, 67, 82, 120, 73, 103, 40, 37, 54, 115, 102, 104, 61, 107, 116, 77, 75,
        110, 51, 106, 41, 60, 54, 60, 98, 53, 83, 107, 95, 47, 48, 40, 94, 93, 65, 97, 78, 35, 40,
        112, 47, 76, 62, 38, 86, 90, 62, 49, 105, 37, 104, 49, 83, 57, 117, 53, 111, 64, 89, 97,
        97, 87, 36, 101, 43, 98, 60, 84, 87, 70, 110, 47, 90, 58, 79, 104, 40, 67, 120, 50, 36,
        108, 78, 69, 111, 78, 94, 101, 41, 35, 67, 70, 89, 64, 64, 73, 59, 66, 79, 81, 42, 115, 82,
        119, 90, 116, 90, 120, 82, 99, 85, 55, 117, 87, 54, 67, 88, 111, 119, 48, 105, 40, 63, 36,
        81, 91, 99, 106, 79, 100, 91, 80, 52, 100, 41, 93, 62, 82, 79, 80, 79, 112, 120, 84, 79,
        55, 83, 116, 119, 105, 49, 58, 58, 105, 66, 49, 113, 41, 67, 95, 61, 100, 86, 50, 54, 74,
        59, 50, 44, 93, 55, 111, 112, 36, 93, 117, 81, 114, 64, 95, 86, 55, 36, 113, 94, 37, 108,
        81, 119, 116, 117, 72, 89, 93, 61, 68, 88, 44, 110, 51, 76, 35, 48, 80, 72, 68, 79, 52,
        102, 57, 62, 100, 67, 64, 79, 62, 72, 66, 117, 75, 80, 112, 80, 42, 69, 44, 78, 43, 98, 51,
        76, 35, 108, 112, 82, 47, 77, 114, 84, 69, 72, 46, 73, 65, 81, 107, 46, 97, 62, 68, 91, 46,
        101, 59, 109, 99, 46, 120, 93, 73, 112, 46, 80, 72, 94, 39, 47, 97, 113, 85, 79, 47, 36,
        49, 87, 120, 76, 111, 87, 48, 91, 105, 76, 65, 60, 81, 84, 59, 53, 72, 75, 68, 43, 64, 113,
        81, 39, 78, 81, 40, 51, 95, 80, 76, 104, 69, 52, 56, 82, 46, 113, 65, 80, 83, 119, 81, 48,
        47, 87, 75, 63, 90, 44, 91, 120, 63, 45, 74, 59, 106, 81, 84, 87, 65, 48, 88, 64, 75, 74,
        40, 95, 89, 56, 78, 45, 58, 47, 77, 55, 52, 58, 47, 45, 90, 112, 75, 114, 85, 115, 115, 63,
        100, 35, 100, 90, 113, 93, 68, 65, 98, 107, 85, 42, 74, 113, 107, 76, 43, 110, 119, 88, 64,
        64, 52, 55, 96, 53, 62, 119, 61, 52, 104, 40, 57, 46, 96, 71, 67, 82, 85, 120, 72, 80, 101,
        82, 96, 53, 77, 106, 111, 108, 40, 100, 85, 87, 120, 90, 97, 40, 62, 83, 84, 114, 80, 107,
        114, 74, 105, 87, 120, 96, 53, 85, 55, 70, 35, 46, 103, 42, 106, 114, 111, 104, 71, 103,
        96, 99, 103, 58, 108, 83, 84, 118, 69, 89, 47, 69, 86, 95, 55, 72, 52, 81, 57, 91, 90, 37,
        99, 110, 118, 59, 74, 81, 89, 90, 53, 113, 46, 108, 55, 90, 101, 97, 115, 58, 72, 79, 73,
        90, 79, 66, 63, 71, 60, 78, 97, 108, 100, 36, 113, 115, 93, 64, 93, 76, 60, 74, 55, 98, 82,
        42, 62, 103, 118, 58, 91, 55, 77, 73, 50, 107, 41, 46, 39, 50, 40, 36, 53, 70, 78, 80, 38,
        69, 81, 40, 44, 41, 85, 93, 87, 93, 43, 102, 104, 49, 56, 46, 118, 115, 97, 105, 48, 48,
        41, 59, 68, 51, 64, 52, 107, 117, 53, 80, 63, 68, 80, 56, 97, 74, 116, 43, 59, 113, 85, 77,
        93, 61, 43, 98, 39, 56, 64, 59, 109, 86, 105, 66, 75, 120, 48, 68, 69, 91, 45, 97, 117, 71,
        108, 56, 58, 80, 74, 38, 68, 106, 43, 77, 54, 79, 67, 93, 79, 94, 40, 40, 35, 35, 93, 96,
        48, 105, 41, 100, 114, 84, 59, 45, 55, 88, 96, 61, 45, 72, 51, 91, 105, 103, 85, 110, 80,
        71, 45, 78, 90, 108, 111, 46, 35, 107, 64, 104, 35, 61, 79, 114, 107, 36, 109, 62, 97, 62,
        36, 45, 63, 84, 109, 36, 85, 86, 40, 63, 35, 80, 54, 89, 89, 35, 39, 47, 35, 35, 35, 120,
        101, 55, 113, 46, 55, 51, 114, 73, 51, 42, 112, 80, 47, 36, 49, 62, 115, 57, 41, 87, 44,
        74, 114, 77, 55, 83, 78, 93, 39, 47, 52, 67, 35, 118, 36, 85, 96, 48, 35, 86, 46, 91, 48,
        62, 120, 81, 115, 72, 36, 102, 69, 109, 80, 77, 103, 89, 50, 117, 55, 75, 104, 40, 71, 37,
        115, 105, 73, 102, 76, 83, 111, 83, 43, 77, 75, 50, 101, 84, 77, 36, 61, 53, 44, 77, 56,
        112, 96, 65, 46, 59, 95, 82, 37, 35, 117, 91, 75, 35, 36, 120, 52, 65, 71, 56, 46, 107, 75,
        47, 72, 83, 66, 61, 61, 45, 39, 73, 101, 47, 81, 84, 116, 71, 63, 45, 46, 42, 94, 78, 45,
        52, 66, 47, 90, 77, 95, 51, 89, 108, 81, 67, 55, 40, 112, 55, 113, 41, 38, 93, 40, 96, 54,
        95, 99, 41, 36, 47, 42, 74, 76, 40, 76, 45, 94, 40, 93, 36, 119, 73, 77, 96, 100, 80, 116,
        79, 100, 71, 65, 44, 85, 51, 58, 119, 50, 77, 45, 48, 60, 113, 45, 93, 76, 95, 63, 94, 41,
        49, 118, 119, 39, 46, 44, 77, 82, 115, 113, 86, 114, 46, 76, 59, 97, 78, 38, 35, 47, 69,
        103, 74, 41, 80, 66, 99, 91, 45, 102, 62, 43, 87, 111, 109, 88, 50, 117, 55, 108, 113, 77,
        50, 105, 69, 117, 109, 77, 84, 99, 115, 70, 63, 45, 97, 84, 61, 90, 45, 57, 55, 85, 69,
        110, 88, 103, 108, 69, 110, 49, 75, 45, 98, 110, 69, 79, 96, 103, 117, 70, 116, 40, 99, 37,
        61, 59, 65, 109, 95, 81, 115, 64, 106, 76, 111, 111, 73, 38, 78, 88, 59, 93, 48, 35, 106,
        52, 35, 70, 49, 52, 59, 103, 108, 56, 45, 71, 81, 112, 103, 119, 104, 114, 113, 56, 39, 61,
        108, 95, 102, 45, 98, 52, 57, 39, 85, 79, 113, 107, 76, 117, 55, 45, 35, 35, 111, 68, 89,
        50, 76, 40, 116, 101, 43, 77, 99, 104, 38, 103, 76, 89, 116, 74, 44, 77, 69, 116, 74, 102,
        76, 104, 39, 120, 39, 77, 61, 36, 67, 83, 45, 90, 90, 37, 80, 93, 56, 98, 90, 62, 35, 83,
        63, 89, 89, 35, 37, 81, 38, 113, 39, 51, 94, 70, 119, 38, 63, 68, 41, 85, 68, 78, 114, 111,
        99, 77, 51, 65, 55, 54, 47, 47, 111, 76, 63, 35, 104, 55, 103, 108, 56, 53, 91, 113, 87,
        47, 78, 68, 79, 107, 37, 49, 54, 105, 106, 59, 43, 58, 49, 97, 39, 105, 78, 73, 100, 98,
        45, 111, 117, 56, 46, 80, 42, 119, 44, 118, 53, 35, 69, 73, 36, 84, 87, 83, 62, 80, 111,
        116, 45, 82, 42, 72, 39, 45, 83, 69, 112, 65, 58, 103, 41, 102, 43, 79, 36, 37, 37, 96,
        107, 65, 35, 71, 61, 56, 82, 77, 109, 71, 49, 38, 79, 96, 62, 116, 111, 56, 98, 67, 93, 84,
        38, 36, 44, 110, 46, 76, 111, 79, 62, 50, 57, 115, 112, 51, 100, 116, 45, 53, 50, 85, 37,
        86, 77, 35, 113, 55, 39, 68, 72, 112, 103, 43, 35, 90, 57, 37, 72, 91, 75, 60, 76, 37, 97,
        50, 69, 45, 103, 114, 87, 86, 77, 51, 64, 50, 61, 45, 107, 50, 50, 116, 76, 93, 52, 36, 35,
        35, 54, 87, 101, 39, 56, 85, 74, 67, 75, 69, 91, 100, 95, 61, 37, 119, 73, 59, 39, 54, 88,
        45, 71, 115, 76, 88, 52, 106, 94, 83, 103, 74, 36, 35, 35, 82, 42, 119, 44, 118, 80, 51,
        119, 75, 35, 105, 105, 87, 38, 35, 42, 104, 94, 68, 38, 82, 63, 106, 112, 55, 43, 47, 117,
        38, 35, 40, 65, 80, 35, 35, 88, 85, 56, 99, 36, 102, 83, 89, 87, 45, 74, 57, 53, 95, 45,
        68, 112, 91, 103, 57, 119, 99, 79, 38, 35, 77, 45, 104, 49, 79, 99, 74, 108, 99, 45, 42,
        118, 112, 119, 48, 120, 85, 88, 38, 35, 79, 81, 70, 75, 78, 88, 64, 81, 73, 39, 73, 111,
        80, 112, 55, 110, 98, 44, 81, 85, 47, 47, 77, 81, 38, 90, 68, 107, 75, 80, 41, 88, 60, 87,
        83, 86, 76, 40, 54, 56, 117, 86, 108, 38, 35, 99, 39, 91, 48, 35, 40, 115, 49, 88, 38, 120,
        109, 36, 89, 37, 66, 55, 42, 75, 58, 101, 68, 65, 51, 50, 51, 106, 57, 57, 56, 71, 88, 98,
        65, 35, 112, 119, 77, 115, 45, 106, 103, 68, 36, 57, 81, 73, 83, 66, 45, 65, 95, 40, 97,
        78, 52, 120, 111, 70, 77, 94, 64, 67, 53, 56, 68, 48, 43, 81, 43, 113, 51, 110, 48, 35, 51,
        85, 49, 73, 110, 68, 106, 70, 54, 56, 50, 45, 83, 106, 77, 88, 74, 75, 41, 40, 104, 36,
        104, 120, 117, 97, 95, 75, 93, 117, 108, 57, 50, 37, 39, 66, 79, 85, 38, 35, 66, 82, 82,
        104, 45, 115, 108, 103, 56, 75, 68, 108, 114, 58, 37, 76, 55, 49, 75, 97, 58, 46, 65, 59,
        37, 89, 85, 76, 106, 68, 80, 109, 76, 60, 76, 89, 115, 56, 105, 35, 88, 119, 74, 79, 89,
        97, 75, 80, 75, 99, 49, 104, 58, 39, 57, 75, 101, 44, 103, 41, 98, 41, 44, 55, 56, 61, 73,
        51, 57, 66, 59, 120, 105, 89, 36, 98, 103, 71, 119, 45, 38, 46, 90, 105, 57, 73, 110, 88,
        68, 117, 89, 97, 37, 71, 42, 102, 50, 66, 113, 55, 109, 110, 57, 94, 35, 112, 49, 118, 118,
        37, 35, 40, 87, 105, 45, 59, 47, 90, 53, 104, 111, 59, 35, 50, 58, 59, 37, 100, 38, 35,
        120, 57, 118, 54, 56, 67, 53, 103, 63, 110, 116, 88, 48, 88, 41, 112, 84, 96, 59, 37, 112,
        66, 51, 113, 55, 109, 103, 71, 78, 41, 51, 37, 40, 80, 56, 110, 84, 100, 53, 76, 55, 71,
        101, 65, 45, 71, 76, 64, 43, 37, 74, 51, 117, 50, 58, 40, 89, 102, 62, 101, 116, 96, 101,
        59, 41, 102, 35, 75, 109, 56, 38, 43, 68, 67, 36, 73, 52, 54, 62, 35, 75, 114, 93, 93, 117,
        45, 91, 61, 57, 57, 116, 116, 115, 49, 46, 113, 98, 35, 113, 55, 50, 103, 49, 87, 74, 79,
        56, 49, 113, 43, 101, 78, 39, 48, 51, 39, 101, 77, 62, 38, 49, 88, 120, 89, 45, 99, 97, 69,
        110, 79, 106, 37, 50, 110, 56, 41, 41, 44, 63, 73, 76, 82, 53, 94, 46, 73, 98, 110, 60, 45,
        88, 45, 77, 113, 55, 91, 97, 56, 50, 76, 113, 58, 70, 38, 35, 99, 101, 43, 83, 57, 119,
        115, 67, 75, 42, 120, 96, 53, 54, 57, 69, 56, 101, 119, 39, 72, 101, 93, 104, 58, 115, 73,
        91, 50, 76, 77, 36, 91, 103, 117, 107, 97, 51, 90, 82, 100, 54, 58, 116, 37, 73, 71, 58,
        59, 36, 37, 89, 105, 74, 58, 78, 113, 61, 63, 101, 65, 119, 59, 47, 58, 110, 110, 68, 113,
        48, 40, 67, 89, 99, 77, 112, 71, 41, 113, 76, 78, 52, 36, 35, 35, 38, 74, 60, 106, 36, 85,
        112, 75, 60, 81, 52, 97, 49, 93, 77, 117, 112, 87, 94, 45, 115, 106, 95, 36, 37, 91, 72,
        75, 37, 39, 70, 35, 35, 35, 35, 81, 82, 90, 74, 58, 58, 89, 51, 69, 71, 108, 52, 39, 64,
        37, 70, 107, 105, 65, 79, 103, 35, 112, 91, 35, 35, 79, 96, 103, 117, 107, 84, 102, 66, 72,
        97, 103, 76, 60, 76, 72, 119, 37, 113, 38, 79, 86, 48, 35, 35, 70, 61, 54, 47, 58, 99, 104,
        73, 109, 48, 64, 101, 67, 80, 56, 88, 93, 58, 107, 70, 73, 37, 104, 108, 56, 104, 103, 79,
        64, 82, 99, 66, 104, 83, 45, 64, 81, 98, 36, 37, 43, 109, 61, 104, 80, 68, 76, 103, 42, 37,
        75, 56, 108, 110, 40, 119, 99, 102, 51, 47, 39, 68, 87, 45, 36, 46, 108, 82, 63, 110, 91,
        110, 67, 72, 45, 101, 88, 79, 79, 78, 84, 74, 108, 104, 58, 46, 82, 89, 70, 37, 51, 39,
        112, 54, 115, 113, 58, 85, 73, 77, 65, 57, 52, 53, 38, 94, 72, 70, 83, 56, 55, 64, 36, 69,
        80, 50, 105, 71, 60, 45, 108, 67, 79, 36, 37, 99, 96, 117, 75, 71, 68, 51, 114, 67, 36,
        120, 48, 66, 76, 56, 97, 70, 110, 45, 45, 96, 107, 101, 37, 35, 72, 77, 80, 39, 118, 104,
        49, 47, 82, 38, 79, 95, 74, 57, 39, 117, 109, 44, 46, 60, 116, 120, 91, 64, 37, 119, 115,
        74, 107, 38, 98, 85, 84, 50, 96, 48, 117, 77, 118, 55, 103, 103, 35, 113, 112, 47, 105,
        106, 46, 76, 53, 54, 39, 104, 108, 59, 46, 115, 53, 67, 85, 114, 120, 106, 79, 77, 55, 45,
        35, 35, 46, 108, 43, 65, 117, 39, 65, 38, 79, 58, 45, 84, 55, 50, 76, 93, 80, 96, 38, 61,
        59, 99, 116, 112, 39, 88, 83, 99, 88, 42, 114, 85, 46, 62, 45, 88, 84, 116, 44, 37, 79, 86,
        85, 52, 41, 83, 49, 43, 82, 45, 35, 100, 103, 48, 47, 78, 110, 63, 75, 117, 49, 94, 48,
        102, 36, 66, 42, 80, 58, 82, 111, 119, 119, 109, 45, 96, 48, 80, 75, 106, 89, 68, 68, 77,
        39, 51, 93, 100, 51, 57, 86, 90, 72, 69, 108, 52, 44, 46, 106, 39, 93, 80, 107, 45, 77, 46,
        104, 94, 38, 58, 48, 70, 65, 67, 109, 36, 109, 97, 113, 45, 38, 115, 103, 119, 48, 116, 55,
        47, 54, 40, 94, 120, 116, 107, 37, 76, 117, 72, 56, 56, 70, 106, 45, 101, 107, 109, 62, 71,
        65, 35, 95, 62, 53, 54, 56, 120, 54, 40, 79, 70, 82, 108, 45, 73, 90, 112, 96, 38, 98, 44,
        95, 80, 39, 36, 77, 60, 74, 110, 113, 55, 57, 86, 115, 74, 87, 47, 109, 87, 83, 42, 80, 85,
        105, 113, 55, 54, 59, 93, 47, 78, 77, 95, 62, 104, 76, 98, 120, 102, 99, 36, 109, 106, 96,
        44, 79, 59, 38, 37, 87, 50, 109, 96, 90, 104, 58, 47, 41, 85, 101, 116, 119, 58, 97, 74,
        37, 93, 75, 57, 104, 58, 84, 99, 70, 93, 117, 95, 45, 83, 106, 57, 44, 86, 75, 51, 77, 46,
        42, 39, 38, 48, 68, 91, 67, 97, 93, 74, 57, 103, 112, 56, 44, 107, 65, 87, 93, 37, 40, 63,
        65, 37, 82, 36, 102, 60, 45, 62, 90, 116, 115, 39, 94, 107, 110, 61, 45, 94, 64, 99, 52,
        37, 45, 112, 89, 54, 113, 73, 37, 74, 37, 49, 73, 71, 120, 102, 76, 85, 57, 67, 80, 56, 99,
        98, 80, 108, 88, 118, 41, 59, 67, 61, 98, 41, 44, 60, 50, 109, 79, 118, 80, 56, 117, 112,
        44, 85, 86, 102, 51, 56, 51, 57, 97, 99, 65, 87, 65, 87, 45, 87, 63, 35, 97, 111, 47, 94,
        35, 37, 75, 89, 111, 56, 102, 82, 85, 76, 78, 100, 50, 46, 62, 37, 109, 93, 85, 75, 58,
        110, 37, 114, 36, 39, 115, 119, 93, 74, 59, 53, 112, 65, 111, 79, 95, 35, 50, 109, 79, 51,
        110, 44, 39, 61, 72, 53, 40, 101, 116, 72, 103, 42, 96, 43, 82, 76, 103, 118, 62, 61, 52,
        85, 56, 103, 117, 68, 36, 73, 37, 68, 58, 87, 62, 45, 114, 53, 86, 42, 37, 106, 42, 87, 58,
        75, 118, 101, 106, 46, 76, 112, 36, 60, 77, 45, 83, 71, 90, 39, 58, 43, 81, 95, 107, 43,
        117, 118, 79, 83, 76, 105, 69, 111, 40, 60, 97, 68, 47, 75, 60, 67, 67, 99, 96, 39, 76,
        120, 62, 39, 63, 59, 43, 43, 79, 39, 62, 40, 41, 106, 76, 82, 45, 94, 117, 54, 56, 80, 72,
        109, 56, 90, 70, 87, 101, 43, 101, 106, 56, 104, 58, 57, 114, 54, 76, 42, 48, 47, 47, 99,
        38, 105, 72, 38, 82, 56, 112, 82, 98, 65, 35, 75, 106, 109, 37, 117, 112, 86, 49, 103, 58,
        97, 95, 35, 85, 114, 55, 70, 117, 65, 35, 40, 116, 82, 104, 35, 46, 89, 53, 75, 43, 64, 63,
        51, 60, 45, 56, 109, 48, 36, 80, 69, 110, 59, 74, 58, 114, 104, 54, 63, 73, 54, 117, 71,
        60, 45, 96, 119, 77, 85, 39, 105, 114, 99, 112, 48, 76, 97, 69, 95, 79, 116, 108, 77, 98,
        38, 49, 35, 54, 84, 46, 35, 70, 68, 75, 117, 35, 49, 76, 119, 37, 117, 37, 43, 71, 77, 43,
        88, 39, 101, 63, 89, 76, 102, 106, 77, 91, 86, 79, 48, 77, 98, 117, 70, 112, 55, 59, 62,
        81, 38, 35, 87, 73, 111, 41, 48, 64, 70, 37, 113, 55, 99, 35, 52, 88, 65, 88, 78, 45, 85,
        38, 86, 66, 60, 72, 70, 70, 42, 113, 76, 40, 36, 47, 86, 44, 59, 40, 107, 88, 90, 101, 106,
        87, 79, 96, 60, 91, 53, 63, 63, 101, 119, 89, 40, 42, 57, 61, 37, 119, 68, 99, 59, 44, 117,
        60, 39, 57, 116, 51, 87, 45, 40, 72, 49, 116, 104, 51, 43, 71, 93, 117, 99, 81, 93, 107,
        76, 115, 55, 100, 102, 40, 36, 47, 42, 74, 76, 93, 64, 42, 116, 55, 66, 117, 95, 71, 51,
        95, 55, 109, 112, 55, 60, 105, 97, 81, 106, 79, 64, 46, 107, 76, 103, 59, 120, 51, 66, 48,
        108, 113, 112, 55, 72, 102, 44, 94, 90, 101, 55, 45, 35, 35, 64, 47, 99, 53, 56, 77, 111,
        40, 51, 59, 107, 110, 112, 48, 37, 41, 65, 55, 63, 45, 87, 43, 101, 73, 39, 111, 56, 41,
        98, 60, 110, 75, 110, 119, 39, 72, 111, 56, 67, 61, 89, 62, 112, 113, 66, 62, 48, 105, 101,
        38, 106, 104, 90, 91, 63, 105, 76, 82, 64, 64, 95, 65, 118, 65, 45, 105, 81, 67, 40, 61,
        107, 115, 82, 90, 82, 86, 112, 55, 96, 46, 61, 43, 78, 112, 66, 67, 37, 114, 104, 38, 51,
        93, 82, 58, 56, 88, 68, 109, 69, 53, 94, 86, 56, 79, 40, 120, 60, 60, 97, 71, 47, 49, 78,
        36, 35, 70, 88, 36, 48, 86, 53, 89, 54, 120, 39, 97, 69, 114, 73, 51, 73, 36, 55, 120, 37,
        69, 96, 118, 60, 45, 66, 89, 44, 41, 37, 45, 63, 80, 115, 102, 42, 108, 63, 37, 67, 51, 46,
        109, 77, 40, 61, 47, 77, 48, 58, 74, 120, 71, 39, 63, 55, 87, 104, 72, 37, 111, 39, 97, 60,
        45, 56, 48, 103, 48, 78, 66, 120, 111, 79, 40, 71, 72, 60, 100, 77, 93, 110, 46, 43, 37,
        113, 64, 106, 72, 63, 102, 46, 85, 115, 74, 50, 71, 103, 115, 38, 52, 60, 45, 101, 52, 55,
        38, 75, 108, 43, 102, 47, 47, 57, 64, 96, 98, 43, 63, 46, 84, 101, 78, 95, 38, 66, 56, 83,
        115, 63, 118, 59, 94, 84, 114, 107, 59, 102, 35, 89, 118, 74, 107, 108, 38, 119, 36, 93,
        62, 45, 43, 107, 63, 39, 40, 60, 83, 58, 54, 56, 116, 113, 42, 87, 111, 68, 102, 90, 117,
        39, 59, 109, 77, 63, 56, 88, 91, 109, 97, 56, 87, 37, 42, 96, 45, 61, 59, 68, 46, 40, 110,
        99, 55, 47, 59, 41, 103, 58, 84, 49, 61, 94, 74, 36, 38, 66, 82, 86, 40, 45, 108, 84, 109,
        78, 66, 54, 120, 113, 66, 91, 64, 48, 42, 111, 46, 101, 114, 77, 42, 60, 83, 87, 70, 93,
        117, 50, 61, 115, 116, 45, 42, 40, 54, 118, 62, 94, 93, 40, 72, 46, 97, 82, 69, 90, 83,
        105, 44, 35, 49, 58, 91, 73, 88, 97, 90, 70, 79, 109, 60, 45, 117, 105, 35, 113, 85, 113,
        50, 36, 35, 35, 82, 105, 59, 117, 55, 53, 79, 75, 35, 40, 82, 116, 97, 87, 45, 75, 45, 70,
        96, 83, 43, 99, 70, 93, 117, 78, 96, 45, 75, 77, 81, 37, 114, 80, 47, 88, 114, 105, 46, 76,
        82, 99, 66, 35, 35, 61, 89, 76, 51, 66, 103, 77, 47, 51, 77, 68, 63, 64, 102, 38, 49, 39,
        66, 87, 45, 41, 74, 117, 60, 76, 50, 53, 103, 108, 56, 117, 104, 86, 109, 49, 104, 76, 36,
        35, 35, 42, 56, 35, 35, 35, 39, 65, 51, 47, 76, 107, 75, 87, 43, 40, 94, 114, 87, 88, 63,
        53, 87, 95, 56, 103, 41, 97, 40, 109, 38, 75, 56, 80, 62, 35, 98, 109, 109, 87, 67, 77,
        107, 107, 38, 35, 84, 82, 96, 67, 44, 53, 100, 62, 103, 41, 70, 59, 116, 44, 52, 58, 64,
        95, 108, 56, 71, 47, 53, 104, 52, 118, 85, 100, 37, 38, 37, 57, 53, 48, 58, 86, 88, 68, 39,
        81, 100, 87, 111, 89, 45, 70, 36, 66, 116, 85, 119, 109, 102, 101, 36, 89, 113, 76, 39, 56,
        40, 80, 87, 88, 40, 80, 63, 94, 64, 80, 111, 51, 36, 35, 35, 96, 77, 83, 115, 63, 68, 87,
        66, 90, 47, 83, 62, 43, 52, 37, 62, 102, 88, 44, 86, 87, 118, 47, 119, 39, 75, 68, 96, 76,
        80, 53, 73, 98, 72, 59, 114, 84, 86, 62, 110, 51, 99, 69, 75, 56, 85, 35, 98, 88, 93, 108,
        45, 47, 86, 43, 94, 108, 106, 51, 59, 118, 108, 77, 98, 38, 91, 53, 89, 81, 56, 35, 112,
        101, 107, 88, 57, 74, 80, 51, 88, 85, 67, 55, 50, 76, 44, 44, 63, 43, 78, 105, 38, 99, 111,
        55, 65, 112, 110, 79, 42, 53, 78, 75, 44, 40, 40, 87, 45, 105, 58, 36, 44, 107, 112, 39,
        85, 68, 65, 79, 40, 71, 48, 83, 113, 55, 77, 86, 106, 74, 115, 98, 73, 117, 41, 39, 90, 44,
        42, 91, 62, 98, 114, 53, 102, 88, 94, 58, 70, 80, 65, 87, 114, 45, 109, 50, 75, 103, 76,
        60, 76, 85, 78, 48, 57, 56, 107, 84, 70, 38, 35, 108, 118, 111, 53, 56, 61, 47, 118, 106,
        68, 111, 59, 46, 59, 41, 75, 97, 42, 104, 76, 82, 35, 47, 107, 61, 114, 75, 98, 120, 117,
        86, 96, 62, 81, 95, 110, 78, 54, 39, 56, 117, 84, 71, 38, 35, 49, 84, 53, 103, 41, 117, 76,
        118, 58, 56, 55, 51, 85, 112, 84, 76, 103, 72, 43, 35, 70, 103, 112, 72, 39, 95, 111, 49,
        55, 56, 48, 80, 104, 56, 75, 109, 120, 81, 74, 56, 35, 72, 55, 50, 76, 52, 64, 55, 54, 56,
        64, 84, 109, 38, 81, 104, 52, 67, 66, 47, 53, 79, 118, 109, 65, 38, 44, 81, 38, 81, 98, 85,
        111, 105, 36, 97, 95, 37, 51, 77, 48, 49, 72, 41, 52, 120, 55, 73, 94, 38, 75, 81, 86, 103,
        116, 70, 110, 86, 43, 59, 91, 80, 99, 62, 91, 109, 52, 107, 47, 47, 44, 93, 49, 63, 35, 96,
        86, 89, 91, 74, 114, 42, 51, 38, 38, 115, 108, 82, 102, 76, 105, 86, 90, 74, 58, 93, 63,
        61, 75, 51, 83, 119, 61, 91, 36, 61, 117, 82, 66, 63, 51, 120, 107, 52, 56, 64, 97, 101,
        103, 60, 90, 39, 60, 36, 35, 52, 72, 41, 54, 44, 62, 101, 48, 106, 84, 54, 39, 78, 35, 40,
        113, 37, 46, 79, 61, 63, 50, 83, 93, 117, 42, 40, 109, 60, 45, 86, 56, 74, 39, 40, 49, 41,
        71, 93, 91, 54, 56, 104, 87, 36, 53, 39, 113, 91, 71, 67, 38, 53, 106, 96, 84, 69, 63, 109,
        39, 101, 115, 70, 71, 78, 82, 77, 41, 106, 44, 102, 102, 90, 63, 45, 113, 120, 56, 59, 45,
        62, 103, 52, 116, 42, 58, 67, 73, 80, 47, 91, 81, 97, 112, 55, 47, 57, 39, 35, 40, 49, 115,
        97, 111, 55, 119, 45, 46, 113, 78, 85, 100, 107, 74, 41, 116, 67, 70, 38, 35, 66, 94, 59,
        120, 71, 118, 110, 50, 114, 57, 70, 69, 80, 70, 70, 70, 99, 76, 64, 46, 105, 70, 78, 107,
        84, 118, 101, 36, 109, 37, 35, 81, 118, 81, 83, 56, 85, 64, 41, 50, 90, 43, 51, 75, 58, 65,
        75, 77, 53, 105, 115, 90, 56, 56, 43, 100, 75, 81, 41, 87, 54, 62, 74, 37, 67, 76, 60, 75,
        69, 62, 96, 46, 100, 42, 40, 66, 96, 45, 110, 56, 68, 57, 111, 75, 60, 85, 112, 93, 99, 36,
        88, 36, 40, 44, 41, 77, 56, 90, 116, 55, 47, 91, 114, 100, 107, 113, 84, 103, 108, 45, 48,
        99, 117, 71, 77, 118, 39, 63, 62, 45, 88, 86, 49, 113, 91, 39, 45, 53, 107, 39, 99, 65, 90,
        54, 57, 101, 59, 68, 95, 63, 36, 90, 80, 80, 38, 115, 94, 43, 55, 93, 41, 36, 42, 36, 35,
        64, 81, 89, 105, 57, 44, 53, 80, 38, 35, 57, 114, 43, 36, 37, 67, 69, 61, 54, 56, 62, 75,
        56, 114, 48, 61, 100, 83, 67, 37, 37, 40, 64, 112, 55, 46, 109, 55, 106, 105, 108, 81, 48,
        50, 39, 48, 45, 86, 87, 65, 103, 60, 97, 47, 39, 39, 51, 117, 46, 61, 52, 76, 36, 89, 41,
        54, 107, 47, 75, 58, 95, 91, 51, 61, 38, 106, 118, 76, 60, 76, 48, 67, 47, 50, 39, 118, 58,
        94, 59, 45, 68, 73, 66, 87, 44, 66, 52, 69, 54, 56, 58, 107, 90, 59, 37, 63, 56, 40, 81,
        56, 66, 72, 61, 107, 79, 54, 53, 66, 87, 63, 120, 83, 71, 38, 35, 64, 117, 85, 44, 68, 83,
        42, 44, 63, 46, 43, 40, 111, 40, 35, 49, 118, 67, 83, 56, 35, 67, 72, 70, 62, 84, 108, 71,
        87, 39, 98, 41, 84, 113, 55, 86, 84, 57, 113, 94, 42, 94, 36, 36, 46, 58, 38, 78, 64, 64,
        36, 38, 41, 87, 72, 116, 80, 109, 42, 53, 95, 114, 79, 48, 38, 101, 37, 75, 38, 35, 45, 51,
        48, 106, 40, 69, 52, 35, 39, 90, 98, 46, 111, 47, 40, 84, 112, 109, 36, 62, 75, 39, 102,
        64, 91, 80, 118, 70, 108, 44, 104, 102, 73, 78, 84, 78, 85, 54, 117, 39, 48, 112, 97, 111,
        55, 37, 88, 85, 112, 57, 93, 53, 46, 62, 37, 104, 96, 56, 95, 61, 86, 89, 98, 120, 117,
        101, 108, 46, 78, 84, 83, 115, 74, 102, 76, 97, 99, 70, 117, 51, 66, 39, 108, 81, 83, 117,
        47, 109, 54, 45, 79, 113, 101, 109, 56, 84, 43, 111, 69, 45, 45, 36, 48, 97, 47, 107, 93,
        117, 106, 57, 69, 119, 115, 71, 62, 37, 118, 101, 82, 42, 104, 118, 94, 66, 70, 112, 81,
        106, 58, 75, 39, 35, 83, 74, 44, 115, 66, 45, 39, 35, 93, 40, 106, 46, 76, 103, 57, 50,
        114, 84, 119, 45, 42, 110, 37, 64, 47, 59, 51, 57, 114, 114, 74, 70, 44, 108, 35, 113, 86,
        37, 79, 114, 116, 66, 101, 67, 54, 47, 44, 59, 113, 66, 51, 101, 98, 78, 87, 91, 63, 44,
        72, 113, 106, 50, 76, 46, 49, 78, 80, 38, 71, 106, 85, 82, 61, 49, 68, 56, 81, 97, 83, 51,
        85, 112, 38, 64, 42, 57, 119, 80, 63, 43, 108, 111, 55, 98, 63, 64, 37, 39, 107, 52, 96,
        112, 48, 90, 36, 50, 50, 37, 75, 51, 43, 105, 67, 90, 106, 63, 88, 74, 78, 52, 78, 109, 38,
        43, 89, 70, 93, 117, 64, 45, 87, 36, 85, 37, 86, 69, 81, 47, 44, 44, 62, 62, 35, 41, 68,
        60, 104, 35, 96, 41, 104, 48, 58, 60, 81, 54, 57, 48, 57, 117, 97, 43, 38, 86, 85, 37, 110,
        50, 58, 99, 71, 51, 70, 74, 45, 37, 64, 66, 106, 45, 68, 103, 76, 114, 96, 72, 119, 38, 72,
        65, 75, 106, 75, 106, 115, 101, 75, 60, 47, 120, 75, 84, 42, 41, 66, 44, 78, 57, 88, 51,
        93, 107, 114, 99, 49, 50, 116, 39, 112, 103, 84, 86, 40, 76, 118, 45, 116, 76, 91, 120,
        103, 95, 37, 61, 77, 95, 113, 55, 97, 94, 120, 63, 55, 85, 98, 100, 62, 35, 37, 56, 99, 89,
        35, 89, 90, 63, 61, 44, 96, 87, 100, 120, 117, 47, 97, 101, 38, 35, 119, 54, 41, 82, 56,
        57, 116, 73, 35, 54, 64, 115, 39, 40, 54, 66, 102, 55, 97, 38, 63, 83, 61, 94, 90, 73, 95,
        107, 83, 38, 97, 105, 96, 38, 61, 116, 69, 55, 50, 76, 95, 68, 44, 59, 94, 82, 41, 55, 91,
        36, 115, 60, 69, 104, 35, 99, 38, 41, 113, 46, 77, 88, 73, 37, 35, 118, 57, 82, 79, 97, 53,
        70, 90, 79, 37, 115, 70, 55, 113, 55, 78, 119, 98, 38, 35, 112, 116, 85, 74, 58, 97, 113,
        74, 101, 36, 83, 108, 54, 56, 37, 46, 68, 35, 35, 35, 69, 67, 62, 60, 63, 45, 97, 70, 38,
        35, 82, 78, 81, 118, 62, 111, 56, 108, 75, 78, 37, 53, 47, 36, 40, 118, 100, 102, 113, 55,
        43, 101, 98, 65, 35, 117, 49, 112, 93, 111, 118, 85, 75, 87, 38, 89, 37, 113, 93, 39, 62,
        36, 49, 64, 45, 91, 120, 102, 110, 36, 55, 90, 84, 112, 55, 109, 77, 44, 71, 44, 75, 111,
        55, 97, 38, 71, 117, 37, 71, 91, 82, 77, 120, 74, 115, 91, 48, 77, 77, 37, 119, 99, 105,
        46, 76, 70, 68, 75, 41, 40, 60, 99, 96, 81, 56, 78, 41, 106, 69, 73, 70, 42, 43, 63, 80,
        50, 97, 56, 103, 37, 41, 36, 113, 93, 111, 50, 97, 72, 56, 67, 38, 60, 83, 105, 98, 67, 47,
        113, 44, 40, 101, 58, 118, 59, 45, 98, 35, 54, 91, 36, 78, 116, 68, 90, 56, 52, 74, 101,
        50, 75, 78, 118, 66, 35, 36, 80, 53, 63, 116, 81, 51, 110, 116, 40, 48, 100, 61, 106, 46,
        76, 81, 102, 46, 47, 76, 108, 51, 51, 43, 40, 59, 113, 51, 76, 45, 119, 61, 56, 100, 88,
        36, 35, 87, 70, 38, 117, 73, 74, 64, 45, 98, 102, 73, 62, 37, 58, 95, 105, 50, 66, 53, 67,
        115, 82, 56, 38, 57, 90, 38, 35, 61, 109, 80, 69, 110, 109, 48, 102, 96, 60, 38, 99, 41,
        81, 76, 53, 117, 74, 35, 37, 117, 37, 108, 74, 106, 43, 68, 45, 114, 59, 66, 111, 70, 38,
        35, 52, 68, 111, 83, 57, 55, 104, 53, 103, 41, 69, 35, 111, 58, 38, 83, 52, 119, 101, 68,
        70, 44, 57, 94, 72, 111, 101, 96, 104, 42, 76, 43, 95, 97, 42, 78, 114, 76, 87, 45, 49,
        112, 71, 95, 38, 50, 85, 100, 66, 56, 54, 101, 37, 66, 47, 58, 61, 62, 41, 78, 52, 120,
        101, 87, 46, 42, 119, 102, 116, 45, 59, 36, 39, 53, 56, 45, 69, 83, 113, 114, 60, 98, 63,
        85, 73, 40, 95, 37, 64, 91, 80, 52, 54, 62, 35, 85, 96, 39, 54, 65, 81, 93, 109, 38, 54,
        47, 96, 90, 62, 35, 83, 63, 89, 89, 35, 86, 99, 59, 114, 55, 85, 50, 38, 51, 50, 54, 100,
        61, 119, 38, 72, 35, 35, 35, 35, 63, 84, 90, 96, 42, 52, 63, 38, 46, 77, 75, 63, 76, 80,
        56, 86, 120, 103, 62, 36, 91, 81, 88, 99, 37, 81, 74, 118, 57, 50, 46, 40, 68, 98, 42, 66,
        41, 103, 98, 42, 66, 77, 57, 100, 77, 42, 104, 74, 77, 65, 111, 42, 99, 38, 35, 98, 48,
        118, 61, 80, 106, 101, 114, 93, 36, 103, 71, 38, 74, 88, 68, 102, 45, 62, 39, 83, 116, 118,
        85, 55, 53, 48, 53, 108, 57, 36, 65, 70, 118, 103, 89, 82, 73, 94, 38, 60, 94, 98, 54, 56,
        63, 106, 35, 113, 57, 81, 88, 52, 83, 77, 39, 82, 79, 35, 38, 115, 76, 49, 73, 77, 46, 114,
        74, 102, 76, 85, 65, 106, 50, 50, 49, 93, 100, 35, 35, 68, 87, 61, 109, 56, 51, 117, 53,
        59, 39, 98, 89, 120, 44, 42, 83, 108, 48, 104, 76, 40, 87, 59, 59, 36, 100, 111, 66, 38,
        79, 47, 84, 81, 58, 40, 90, 94, 120, 66, 100, 76, 106, 76, 60, 76, 110, 105, 59, 39, 39,
        88, 46, 96, 36, 35, 56, 43, 49, 71, 68, 58, 107, 36, 89, 85, 87, 115, 98, 110, 56, 111,
        103, 104, 54, 114, 120, 90, 50, 90, 57, 93, 37, 110, 100, 43, 62, 86, 35, 42, 56, 85, 95,
        55, 50, 76, 104, 43, 50, 81, 56, 67, 106, 48, 105, 58, 54, 104, 112, 38, 36, 67, 47, 58,
        112, 40, 72, 75, 62, 84, 56, 89, 91, 103, 72, 81, 52, 96, 52, 41, 39, 36, 65, 98, 40, 78,
        111, 102, 37, 86, 39, 56, 104, 76, 38, 35, 60, 78, 69, 100, 116, 103, 40, 110, 39, 61, 83,
        49, 65, 40, 81, 49, 47, 73, 38, 52, 40, 91, 37, 100, 77, 96, 44, 73, 117, 39, 49, 58, 95,
        104, 76, 62, 83, 102, 68, 48, 55, 38, 54, 68, 60, 102, 112, 56, 100, 72, 77, 55, 47, 103,
        43, 116, 108, 80, 78, 57, 74, 42, 114, 75, 97, 80, 99, 116, 38, 63, 39, 117, 66, 67, 101,
        109, 94, 106, 110, 37, 57, 95, 75, 41, 60, 44, 67, 53, 75, 51, 115, 61, 53, 103, 38, 71,
        109, 74, 98, 42, 91, 83, 89, 113, 55, 75, 59, 84, 82, 76, 71, 67, 115, 77, 45, 36, 36, 59,
        83, 37, 58, 89, 64, 114, 55, 65, 75, 48, 112, 112, 114, 112, 76, 60, 76, 114, 104, 44, 113,
        55, 101, 47, 37, 75, 87, 75, 58, 53, 48, 73, 94, 43, 109, 39, 118, 105, 96, 51, 63, 37, 90,
        112, 43, 60, 45, 100, 43, 36, 76, 45, 83, 118, 58, 64, 46, 111, 49, 57, 110, 36, 115, 48,
        38, 51, 57, 59, 107, 110, 59, 83, 37, 66, 83, 113, 42, 36, 51, 87, 111, 74, 83, 67, 76,
        119, 101, 86, 91, 97, 90, 39, 77, 81, 73, 106, 79, 60, 55, 59, 88, 45, 88, 59, 38, 43, 100,
        77, 76, 118, 117, 35, 94, 85, 115, 71, 69, 67, 57, 87, 69, 99, 91, 88, 40, 119, 73, 55, 35,
        50, 46, 40, 70, 48, 106, 86, 42, 101, 90, 102, 60, 45, 81, 118, 51, 74, 45, 99, 43, 74, 53,
        65, 108, 114, 66, 35, 36, 112, 40, 72, 54, 56, 76, 118, 69, 65, 39, 113, 51, 110, 48, 35,
        109, 44, 91, 96, 42, 56, 70, 116, 41, 70, 99, 89, 103, 69, 117, 100, 93, 67, 87, 102, 109,
        54, 56, 44, 40, 97, 76, 65, 36, 64, 69, 70, 84, 103, 76, 88, 111, 66, 113, 47, 85, 80, 108,
        112, 55, 58, 100, 91, 47, 59, 114, 95, 105, 120, 61, 58, 84, 70, 96, 83, 53, 72, 45, 98,
        60, 76, 73, 38, 72, 89, 40, 75, 61, 104, 35, 41, 93, 76, 107, 36, 75, 49, 52, 108, 86, 102,
        109, 58, 120, 36, 72, 60, 51, 94, 81, 108, 60, 77, 96, 36, 79, 104, 97, 112, 66, 110, 107,
        117, 112, 39, 68, 35, 76, 36, 80, 98, 95, 96, 78, 42, 103, 93, 50, 101, 59, 88, 47, 68,
        116, 103, 44, 98, 115, 106, 38, 75, 35, 50, 91, 45, 58, 105, 89, 114, 39, 95, 119, 103, 72,
        41, 78, 85, 73, 82, 56, 97, 49, 110, 35, 83, 63, 89, 101, 106, 39, 104, 56, 94, 53, 56, 85,
        98, 90, 100, 43, 94, 70, 75, 68, 42, 84, 64, 59, 54, 65, 55, 97, 81, 67, 91, 75, 56, 100,
        45, 40, 118, 54, 71, 73, 36, 120, 58, 84, 60, 38, 39, 71, 112, 53, 85, 102, 62, 64, 77, 46,
        42, 74, 58, 59, 36, 45, 114, 118, 50, 57, 39, 77, 93, 56, 113, 77, 118, 45, 116, 76, 112,
        44, 39, 56, 56, 54, 105, 97, 67, 61, 72, 98, 42, 89, 74, 111, 75, 74, 44, 40, 106, 37, 75,
        61, 72, 96, 75, 46, 118, 57, 72, 103, 103, 113, 66, 73, 105, 90, 117, 39, 81, 118, 66, 84,
        46, 35, 61, 41, 48, 117, 107, 114, 117, 86, 38, 46, 41, 51, 61, 40, 94, 49, 96, 111, 42,
        80, 106, 52, 60, 45, 60, 97, 78, 40, 40, 94, 55, 40, 39, 35, 90, 48, 119, 75, 35, 53, 71,
        88, 64, 55, 117, 93, 91, 96, 42, 83, 94, 52, 51, 57, 51, 51, 65, 52, 114, 108, 93, 91, 96,
        42, 79, 52, 67, 103, 76, 69, 108, 93, 118, 36, 49, 81, 51, 65, 101, 70, 51, 55, 100, 98,
        88, 107, 44, 46, 41, 118, 106, 35, 120, 39, 100, 96, 59, 113, 103, 98, 81, 82, 37, 70, 87,
        44, 50, 40, 63, 76, 79, 61, 115, 37, 83, 99, 54, 56, 37, 78, 80, 39, 35, 35, 65, 111, 116,
        108, 56, 120, 61, 66, 69, 35, 106, 49, 85, 68, 40, 91, 51, 36, 77, 40, 93, 85, 73, 50, 76,
        88, 51, 82, 112, 75, 78, 64, 59, 47, 35, 102, 39, 102, 47, 38, 95, 109, 116, 38, 70, 41,
        88, 100, 70, 60, 57, 116, 52, 41, 81, 97, 46, 42, 107, 84, 76, 119, 81, 39, 40, 84, 84, 66,
        57, 46, 120, 72, 39, 62, 35, 77, 74, 43, 103, 76, 113, 57, 45, 35, 35, 64, 72, 117, 90, 80,
        78, 48, 93, 117, 58, 104, 55, 46, 84, 46, 46, 71, 58, 59, 36, 47, 85, 115, 106, 40, 84, 55,
        96, 81, 56, 116, 84, 55, 50, 76, 110, 89, 108, 60, 45, 113, 120, 56, 59, 45, 72, 86, 55,
        81, 45, 38, 88, 100, 120, 37, 49, 97, 44, 104, 67, 61, 48, 117, 43, 72, 108, 115, 86, 62,
        110, 117, 73, 81, 76, 45, 53, 60, 78, 63, 41, 78, 66, 83, 41, 81, 78, 42, 95, 73, 44, 63,
        38, 41, 50, 39, 73, 77, 37, 76, 51, 73, 41, 88, 40, 40, 101, 47, 100, 108, 50, 38, 56, 39,
        60, 77, 58, 94, 35, 77, 42, 81, 43, 91, 84, 46, 88, 114, 105, 46, 76, 89, 83, 51, 118, 37,
        102, 70, 96, 54, 56, 104, 59, 98, 45, 88, 91, 47, 69, 110, 39, 67, 82, 46, 113, 55, 69, 41,
        112, 39, 47, 107, 108, 101, 50, 72, 77, 44, 117, 59, 94, 37, 79, 75, 67, 45, 78, 43, 76,
        108, 37, 70, 57, 67, 70, 60, 78, 102, 39, 94, 35, 116, 50, 76, 44, 59, 50, 55, 87, 58, 48,
        79, 64, 54, 35, 35, 85, 54, 87, 55, 58, 36, 114, 74, 102, 76, 87, 72, 106, 36, 35, 41, 119,
        111, 113, 66, 101, 102, 73, 90, 46, 80, 75, 60, 98, 42, 116, 55, 101, 100, 59, 112, 42, 95,
        109, 59, 52, 69, 120, 75, 35, 104, 64, 38, 93, 62, 95, 62, 64, 107, 88, 81, 116, 77, 97,
        99, 102, 68, 46, 109, 45, 86, 65, 98, 56, 59, 73, 82, 101, 77, 51, 36, 119, 102, 48, 39,
        39, 104, 114, 97, 42, 115, 111, 53, 54, 56, 39, 73, 112, 38, 118, 82, 115, 56, 52, 57, 39,
        77, 82, 89, 83, 112, 37, 58, 116, 58, 104, 53, 113, 83, 103, 119, 112, 69, 114, 36, 66, 62,
        81, 44, 59, 115, 40, 67, 35, 36, 41, 96, 115, 118, 81, 117, 70, 36, 35, 35, 45, 68, 44, 35,
        35, 44, 103, 54, 56, 64, 50, 91, 84, 59, 46, 88, 83, 100, 78, 57, 81, 101, 41, 114, 112,
        116, 46, 95, 75, 45, 35, 53, 119, 70, 41, 115, 80, 39, 35, 35, 112, 35, 67, 48, 99, 37, 45,
        71, 98, 37, 104, 100, 43, 60, 45, 106, 39, 65, 105, 42, 120, 38, 38, 72, 77, 107, 84, 93,
        67, 39, 79, 83, 108, 35, 35, 53, 82, 71, 91, 74, 88, 97, 72, 78, 59, 100, 39, 117, 65, 35,
        120, 46, 95, 85, 59, 46, 96, 80, 85, 64, 40, 90, 51, 100, 116, 52, 114, 49, 53, 50, 64, 58,
        118, 44, 39, 82, 46, 83, 106, 39, 119, 35, 48, 60, 45, 59, 107, 80, 73, 41, 70, 102, 74,
        38, 35, 65, 89, 74, 38, 35, 47, 47, 41, 62, 45, 107, 61, 109, 61, 42, 88, 110, 75, 36, 62,
        61, 41, 55, 50, 76, 93, 48, 73, 37, 62, 46, 71, 54, 57, 48, 97, 58, 36, 35, 35, 60, 44, 41,
        59, 63, 59, 55, 50, 35, 63, 120, 57, 43, 100, 59, 94, 86, 39, 57, 59, 106, 89, 64, 59, 41,
        98, 114, 35, 113, 94, 89, 81, 112, 120, 58, 88, 35, 84, 101, 36, 90, 94, 39, 61, 45, 61,
        98, 71, 104, 76, 102, 58, 68, 54, 38, 98, 78, 119, 90, 57, 45, 90, 68, 35, 110, 94, 57, 72,
        104, 76, 77, 114, 53, 71, 59, 39, 93, 100, 38, 54, 39, 119, 89, 109, 84, 70, 109, 76, 60,
        76, 68, 41, 70, 94, 37, 91, 116, 67, 39, 56, 59, 43, 57, 69, 35, 67, 36, 103, 37, 35, 53,
        89, 62, 113, 57, 119, 73, 62, 80, 40, 57, 109, 73, 91, 62, 107, 67, 45, 101, 107, 76, 67,
        47, 82, 38, 67, 72, 43, 115, 39, 66, 59, 75, 45, 77, 54, 36, 69, 66, 37, 105, 115, 48, 48,
        58, 43, 65, 52, 91, 55, 120, 107, 115, 46, 76, 114, 78, 107, 48, 38, 69, 41, 119, 73, 76,
        89, 70, 64, 50, 76, 39, 48, 78, 98, 36, 43, 112, 118, 60, 40, 50, 46, 55, 54, 56, 47, 70,
        114, 89, 38, 104, 36, 94, 51, 105, 38, 64, 43, 71, 37, 74, 84, 39, 60, 45, 44, 118, 96, 51,
        59, 95, 41, 73, 57, 77, 94, 65, 69, 93, 67, 78, 63, 67, 108, 50, 65, 90, 103, 43, 37, 52,
        105, 84, 112, 84, 51, 60, 110, 45, 38, 37, 72, 37, 98, 60, 70, 68, 106, 50, 77, 60, 104,
        72, 61, 38, 69, 104, 60, 50, 76, 101, 110, 36, 98, 42, 97, 84, 88, 61, 45, 56, 81, 120, 78,
        41, 107, 49, 49, 73, 77, 49, 99, 94, 106, 37, 57, 115, 60, 76, 60, 78, 70, 83, 111, 41, 66,
        63, 43, 60, 45, 40, 71, 120, 115, 70, 44, 94, 45, 69, 104, 64, 36, 52, 100, 88, 104, 78,
        36, 43, 35, 114, 120, 75, 56, 39, 106, 101, 39, 68, 55, 107, 96, 101, 59, 41, 50, 112, 89,
        119, 80, 65, 39, 95, 112, 57, 38, 64, 94, 49, 56, 109, 108, 49, 94, 91, 64, 103, 52, 116,
        42, 91, 74, 79, 97, 42, 91, 61, 81, 112, 55, 40, 113, 74, 95, 111, 79, 76, 94, 40, 39, 55,
        102, 66, 38, 72, 113, 45, 58, 115, 102, 44, 115, 78, 106, 56, 120, 113, 94, 62, 36, 85, 52,
        79, 93, 71, 75, 120, 39, 109, 57, 41, 98, 64, 112, 55, 89, 115, 118, 75, 51, 119, 94, 89,
        82, 45, 67, 100, 81, 42, 58, 73, 114, 60, 40, 36, 117, 38, 41, 35, 40, 38, 63, 76, 57, 82,
        103, 51, 72, 41, 52, 102, 105, 69, 112, 94, 105, 73, 57, 79, 56, 75, 110, 84, 106, 44, 93,
        72, 63, 68, 42, 114, 55, 39, 77, 59, 80, 119, 90, 57, 75, 48, 69, 94, 107, 38, 45, 99, 112,
        73, 59, 46, 112, 47, 54, 95, 118, 119, 111, 70, 77, 86, 60, 45, 62, 35, 37, 88, 105, 46,
        76, 120, 86, 110, 114, 85, 40, 52, 38, 56, 47, 80, 43, 58, 104, 76, 83, 75, 106, 36, 35,
        85, 37, 93, 52, 57, 116, 39, 73, 58, 114, 103, 77, 105, 39, 70, 76, 64, 97, 58, 48, 89, 45,
        117, 65, 91, 51, 57, 39, 44, 40, 118, 98, 109, 97, 42, 104, 85, 37, 60, 45, 83, 82, 70, 96,
        84, 116, 58, 53, 52, 50, 82, 95, 86, 86, 36, 112, 64, 91, 112, 56, 68, 86, 91, 65, 44, 63,
        49, 56, 51, 57, 70, 87, 100, 70, 60, 84, 100, 100, 70, 60, 57, 65, 104, 45, 54, 38, 57,
        116, 87, 111, 68, 108, 104, 93, 38, 49, 83, 112, 71, 77, 113, 62, 84, 105, 49, 79, 42, 72,
        38, 35, 40, 65, 76, 56, 91, 95, 80, 37, 46, 77, 62, 118, 94, 45, 41, 41, 113, 79, 84, 42,
        70, 53, 67, 113, 48, 96, 89, 101, 37, 43, 36, 66, 54, 105, 58, 55, 64, 48, 73, 88, 60, 78,
        43, 84, 43, 48, 77, 108, 77, 66, 80, 81, 42, 86, 106, 62, 83, 115, 68, 60, 85, 52, 74, 72,
        89, 56, 107, 68, 50, 41, 50, 102, 85, 47, 77, 35, 36, 101, 46, 41, 84, 52, 44, 95, 61, 56,
        104, 76, 105, 109, 91, 38, 41, 59, 63, 85, 107, 75, 39, 45, 120, 63, 39, 40, 58, 115, 105,
        73, 102, 76, 60, 36, 112, 70, 77, 96, 105, 60, 63, 37, 87, 40, 109, 71, 68, 72, 77, 37, 62,
        105, 87, 80, 44, 35, 35, 80, 96, 37, 47, 76, 60, 101, 88, 105, 58, 64, 90, 57, 67, 46, 55,
        111, 61, 64, 40, 112, 88, 100, 65, 79, 47, 78, 76, 81, 56, 108, 80, 108, 43, 72, 80, 79,
        81, 97, 56, 119, 68, 56, 61, 94, 71, 108, 80, 97, 56, 84, 75, 73, 49, 67, 106, 104, 115,
        67, 84, 83, 76, 74, 77, 39, 47, 87, 108, 62, 45, 83, 40, 113, 119, 37, 115, 102, 47, 64,
        37, 35, 66, 54, 59, 47, 85, 55, 75, 93, 117, 90, 98, 105, 94, 79, 99, 94, 50, 110, 60, 98,
        104, 80, 109, 85, 107, 77, 119, 62, 37, 116, 60, 41, 39, 109, 69, 86, 69, 39, 39, 110, 96,
        87, 110, 74, 114, 97, 36, 94, 84, 75, 118, 88, 53, 66, 62, 59, 95, 97, 83, 69, 75, 39, 44,
        40, 104, 119, 97, 48, 58, 105, 52, 71, 63, 46, 66, 99, 105, 46, 40, 88, 91, 63, 98, 42, 40,
        36, 44, 61, 45, 110, 60, 46, 81, 37, 96, 40, 88, 61, 63, 43, 64, 65, 109, 42, 74, 115, 48,
        38, 61, 51, 98, 104, 56, 75, 93, 109, 76, 60, 76, 111, 78, 115, 39, 54, 44, 39, 56, 53, 96,
        48, 63, 116, 47, 39, 95, 85, 53, 57, 64, 93, 100, 100, 70, 60, 35, 76, 100, 70, 60, 101,
        87, 100, 70, 60, 79, 117, 78, 47, 52, 53, 114, 89, 60, 45, 76, 64, 38, 35, 43, 102, 109,
        62, 54, 57, 61, 76, 98, 44, 79, 99, 90, 86, 47, 41, 59, 84, 84, 109, 56, 86, 73, 59, 63,
        37, 79, 116, 74, 60, 40, 98, 52, 109, 113, 55, 77, 54, 58, 117, 63, 75, 82, 100, 70, 60,
        103, 82, 64, 50, 76, 61, 70, 78, 85, 45, 60, 98, 91, 40, 57, 99, 47, 77, 76, 51, 109, 59,
        90, 91, 36, 111, 70, 51, 103, 41, 71, 65, 87, 113, 112, 65, 82, 99, 61, 60, 82, 79, 117,
        55, 99, 76, 53, 108, 59, 45, 91, 65, 93, 37, 47, 43, 102, 115, 100, 59, 108, 35, 83, 97,
        102, 84, 47, 102, 42, 87, 93, 48, 61, 79, 39, 36, 40, 84, 98, 60, 91, 41, 42, 64, 101, 55,
        55, 53, 82, 45, 58, 89, 111, 98, 37, 103, 42, 62, 108, 42, 58, 120, 80, 63, 89, 98, 46, 53,
        41, 37, 119, 95, 73, 63, 55, 117, 107, 53, 74, 67, 43, 70, 83, 40, 109, 35, 105, 39, 107,
        46, 39, 97, 48, 105, 41, 57, 60, 55, 98, 39, 102, 115, 39, 53, 57, 104, 113, 36, 42, 53,
        85, 104, 118, 35, 35, 112, 105, 94, 56, 43, 104, 73, 69, 66, 70, 96, 110, 118, 111, 96, 59,
        39, 108, 48, 46, 94, 83, 49, 60, 45, 119, 85, 75, 50, 47, 67, 111, 104, 53, 56, 75, 75,
        104, 76, 106, 77, 61, 83, 79, 42, 114, 102, 79, 96, 43, 113, 67, 96, 87, 45, 79, 110, 46,
        61, 65, 74, 53, 54, 62, 62, 105, 50, 64, 50, 76, 72, 54, 65, 58, 38, 53, 113, 96, 63, 57,
        73, 51, 64, 64, 39, 48, 52, 38, 112, 50, 47, 76, 86, 97, 42, 84, 45, 52, 60, 45, 105, 51,
        59, 77, 57, 85, 118, 90, 100, 43, 78, 55, 62, 98, 42, 101, 73, 119, 103, 58, 67, 67, 41,
        99, 60, 62, 110, 79, 38, 35, 60, 73, 71, 101, 59, 95, 95, 46, 116, 104, 106, 90, 108, 60,
        37, 119, 40, 87, 107, 50, 120, 109, 112, 52, 81, 64, 73, 35, 73, 57, 44, 68, 70, 93, 117,
        55, 45, 80, 61, 46, 45, 95, 58, 89, 74, 93, 97, 83, 64, 86, 63, 54, 42, 67, 40, 41, 100,
        79, 112, 55, 58, 87, 76, 44, 98, 38, 51, 82, 103, 47, 46, 99, 109, 77, 57, 38, 114, 94, 62,
        36, 40, 62, 46, 90, 45, 73, 38, 74, 40, 81, 48, 72, 100, 53, 81, 37, 55, 67, 111, 45, 98,
        96, 45, 99, 60, 78, 40, 54, 114, 64, 105, 112, 43, 65, 117, 114, 75, 60, 109, 56, 54, 81,
        73, 116, 104, 42, 35, 118, 59, 45, 79, 66, 113, 105, 43, 76, 55, 119, 68, 69, 45, 73, 114,
        56, 75, 91, 39, 109, 43, 68, 68, 83, 76, 119, 75, 38, 47, 46, 63, 45, 86, 37, 85, 95, 37,
        51, 58, 113, 75, 78, 117, 36, 95, 98, 42, 66, 45, 107, 112, 55, 78, 97, 68, 39, 81, 100,
        87, 81, 80, 75, 89, 113, 91, 64, 62, 80, 41, 104, 73, 59, 42, 95, 70, 93, 117, 96, 82, 98,
        91, 46, 106, 56, 95, 81, 47, 60, 38, 62, 117, 117, 43, 86, 115, 72, 36, 115, 77, 57, 84,
        65, 37, 63, 41, 40, 118, 109, 74, 56, 48, 41, 44, 80, 55, 69, 62, 41, 116, 106, 68, 37, 50,
        76, 61, 45, 116, 35, 102, 75, 91, 37, 96, 118, 61, 81, 56, 60, 70, 102, 78, 107, 103, 103,
        94, 111, 73, 98, 97, 104, 42, 35, 56, 47, 81, 116, 36, 70, 38, 58, 75, 42, 45, 40, 78, 47,
        39, 43, 49, 118, 77, 66, 44, 117, 40, 41, 45, 97, 46, 86, 85, 85, 42, 35, 91, 101, 37, 103,
        65, 65, 79, 40, 83, 62, 87, 108, 65, 50, 41, 59, 83, 97, 62, 103, 88, 109, 56, 89, 66, 96,
        49, 100, 64, 75, 35, 110, 93, 55, 54, 45, 97, 36, 85, 44, 109, 70, 60, 102, 88, 93, 105,
        100, 113, 100, 41, 60, 51, 44, 93, 74, 55, 74, 109, 87, 52, 96, 54, 93, 117, 107, 115, 61,
        52, 45, 55, 50, 76, 40, 106, 69, 107, 43, 58, 98, 74, 48, 77, 94, 113, 45, 56, 68, 109, 95,
        90, 63, 48, 111, 108, 80, 49, 67, 57, 83, 97, 38, 72, 91, 100, 38, 99, 36, 111, 111, 81,
        85, 106, 93, 69, 120, 100, 42, 51, 90, 77, 64, 45, 87, 71, 87, 50, 37, 115, 39, 44, 66, 45,
        95, 77, 37, 62, 37, 85, 108, 58, 35, 47, 39, 120, 111, 70, 77, 57, 81, 88, 45, 36, 46, 81,
        78, 39, 62, 91, 37, 36, 90, 36, 117, 70, 54, 112, 65, 54, 75, 105, 50, 79, 53, 58, 56, 119,
        42, 118, 80, 49, 60, 45, 49, 96, 91, 71, 44, 41, 45, 109, 35, 62, 48, 96, 80, 38, 35, 101,
        98, 35, 46, 51, 105, 41, 114, 116, 66, 54, 49, 40, 111, 39, 36, 63, 88, 51, 66, 60, 47, 82,
        57, 48, 59, 101, 90, 93, 37, 78, 99, 113, 59, 45, 84, 108, 93, 35, 70, 62, 50, 81, 102,
        116, 94, 97, 101, 95, 53, 116, 75, 76, 57, 77, 85, 101, 57, 98, 42, 115, 76, 69, 81, 57,
        53, 67, 38, 96, 61, 71, 63, 64, 77, 106, 61, 119, 104, 42, 39, 51, 69, 62, 61, 45, 60, 41,
        71, 116, 42, 73, 119, 41, 39, 81, 71, 58, 96, 64, 73, 119, 79, 102, 55, 38, 93, 49, 105,
        39, 83, 48, 49, 66, 43, 69, 118, 47, 78, 97, 99, 35, 57, 83, 59, 61, 59, 89, 81, 112, 103,
        95, 54, 85, 96, 42, 107, 86, 89, 51, 57, 120, 75, 44, 91, 47, 54, 65, 106, 55, 58, 39, 49,
        66, 109, 45, 95, 49, 69, 89, 102, 97, 49, 43, 111, 38, 111, 52, 104, 112, 55, 75, 78, 95,
        81, 40, 79, 108, 73, 111, 64, 83, 37, 59, 106, 86, 100, 110, 48, 39, 49, 60, 86, 99, 53,
        50, 61, 117, 96, 51, 94, 111, 45, 110, 49, 39, 103, 52, 118, 53, 56, 72, 106, 38, 54, 95,
        116, 55, 36, 35, 35, 63, 77, 41, 99, 60, 36, 98, 103, 81, 95, 39, 83, 89, 40, 40, 45, 120,
        107, 65, 35, 89, 40, 44, 112, 39, 72, 57, 114, 73, 86, 89, 45, 98, 44, 39, 37, 98, 67, 80,
        70, 55, 46, 74, 60, 85, 112, 94, 44, 40, 100, 85, 49, 86, 89, 42, 53, 35, 87, 107, 84, 85,
        62, 104, 49, 57, 119, 44, 87, 81, 104, 76, 73, 41, 51, 83, 35, 102, 36, 50, 40, 101, 98,
        44, 106, 114, 42, 98, 59, 51, 86, 119, 93, 42, 55, 78, 72, 37, 36, 99, 52, 86, 115, 44,
        101, 68, 57, 62, 88, 87, 56, 63, 78, 93, 111, 43, 40, 42, 112, 103, 67, 37, 47, 55, 50, 76,
        86, 45, 117, 60, 72, 112, 44, 51, 64, 101, 94, 57, 85, 66, 49, 74, 43, 97, 107, 57, 45, 84,
        78, 47, 109, 104, 75, 80, 103, 43, 65, 74, 89, 100, 36, 77, 108, 118, 65, 70, 95, 106, 67,
        75, 42, 46, 79, 45, 94, 40, 54, 51, 97, 100, 77, 84, 45, 62, 87, 37, 105, 101, 119, 83, 56,
        87, 54, 109, 50, 114, 116, 67, 112, 111, 39, 82, 83, 49, 82, 56, 52, 61, 64, 112, 97, 84,
        75, 116, 41, 62, 61, 37, 38, 49, 91, 41, 42, 118, 112, 39, 117, 43, 120, 44, 86, 114, 119,
        78, 59, 38, 93, 107, 117, 79, 57, 74, 68, 98, 103, 61, 112, 79, 36, 74, 42, 46, 106, 86,
        101, 59, 117, 39, 109, 48, 100, 114, 57, 108, 44, 60, 42, 119, 77, 75, 42, 79, 101, 61,
        103, 56, 108, 86, 95, 75, 69, 66, 70, 107, 79, 39, 111, 85, 93, 94, 61, 91, 45, 55, 57, 50,
        35, 111, 107, 44, 41, 105, 93, 108, 82, 56, 113, 81, 50, 111, 65, 56, 119, 99, 82, 67, 90,
        94, 55, 119, 47, 78, 106, 104, 59, 63, 46, 115, 116, 88, 63, 81, 49, 62, 83, 49, 113, 52,
        66, 110, 36, 41, 75, 49, 60, 45, 114, 71, 100, 79, 39, 36, 87, 114, 46, 76, 99, 46, 67, 71,
        41, 36, 47, 42, 74, 76, 52, 116, 78, 82, 47, 44, 83, 86, 79, 51, 44, 97, 85, 119, 39, 68,
        74, 78, 58, 41, 83, 115, 59, 119, 71, 110, 57, 65, 51, 50, 105, 106, 119, 37, 70, 76, 43,
        90, 48, 70, 110, 46, 85, 57, 59, 114, 101, 83, 113, 41, 98, 109, 73, 51, 50, 85, 61, 61,
        53, 65, 76, 117, 71, 38, 35, 86, 102, 49, 51, 57, 56, 47, 112, 86, 111, 49, 42, 99, 45, 40,
        97, 89, 49, 54, 56, 111, 60, 96, 74, 115, 83, 98, 107, 45, 44, 49, 78, 59, 36, 62, 48, 58,
        79, 85, 97, 115, 40, 51, 58, 56, 90, 57, 55, 50, 76, 83, 102, 70, 56, 101, 98, 61, 99, 45,
        59, 62, 83, 80, 119, 55, 46, 54, 104, 110, 51, 109, 96, 57, 94, 88, 107, 110, 40, 114, 46,
        113, 83, 91, 48, 59, 84, 37, 38, 81, 99, 61, 43, 83, 84, 82, 120, 88, 39, 113, 49, 66, 78,
        107, 51, 38, 42, 101, 117, 50, 59, 38, 56, 113, 36, 38, 120, 62, 81, 35, 81, 55, 94, 84,
        102, 43, 54, 60, 40, 100, 37, 90, 86, 109, 106, 50, 98, 68, 105, 37, 46, 51, 76, 50, 110,
        43, 52, 87, 39, 36, 80, 105, 68, 68, 71, 41, 103, 44, 114, 37, 43, 63, 44, 36, 64, 63, 117,
        111, 117, 53, 116, 83, 101, 50, 97, 78, 95, 65, 81, 85, 42, 60, 104, 96, 101, 45, 71, 73,
        55, 41, 63, 79, 75, 50, 65, 46, 100, 55, 95, 99, 41, 63, 119, 81, 53, 65, 83, 64, 68, 76,
        51, 114, 35, 55, 102, 83, 107, 103, 108, 54, 45, 43, 43, 68, 58, 39, 65, 44, 117, 113, 55,
        83, 118, 108, 66, 36, 112, 99, 112, 72, 39, 113, 51, 110, 48, 35, 95, 37, 100, 89, 35, 120,
        67, 112, 114, 45, 108, 60, 70, 48, 78, 82, 64, 45, 35, 35, 70, 69, 86, 54, 78, 84, 70, 54,
        35, 35, 36, 108, 56, 52, 78, 49, 119, 63, 65, 79, 62, 39, 73, 65, 79, 85, 82, 81, 35, 35,
        86, 94, 70, 118, 45, 88, 70, 98, 71, 77, 55, 70, 108, 40, 78, 60, 51, 68, 104, 76, 71, 70,
        37, 113, 46, 49, 114, 67, 36, 35, 58, 84, 95, 95, 38, 80, 105, 54, 56, 37, 48, 120, 105,
        95, 38, 91, 113, 70, 74, 40, 55, 55, 106, 95, 38, 74, 87, 111, 70, 46, 86, 55, 51, 53, 38,
        84, 44, 91, 82, 42, 58, 120, 70, 82, 42, 75, 53, 62, 62, 35, 96, 98, 87, 45, 63, 52, 78,
        101, 95, 38, 54, 78, 101, 95, 38, 54, 78, 101, 95, 38, 110, 96, 107, 114, 45, 35, 71, 74,
        99, 77, 54, 88, 59, 117, 77, 54, 88, 59, 117, 77, 40, 46, 97, 46, 46, 94, 50, 84, 107, 76,
        37, 111, 82, 40, 35, 59, 117, 46, 84, 37, 102, 65, 114, 37, 52, 116, 74, 56, 38, 62, 60,
        49, 61, 71, 72, 90, 95, 43, 109, 57, 47, 35, 72, 49, 70, 94, 82, 35, 83, 67, 35, 42, 78,
        61, 66, 65, 57, 40, 68, 63, 118, 91, 85, 105, 70, 89, 62, 62, 94, 56, 112, 44, 75, 75, 70,
        46, 87, 93, 76, 50, 57, 117, 76, 107, 76, 108, 117, 47, 43, 52, 84, 60, 88, 111, 73, 66,
        38, 104, 120, 61, 84, 49, 80, 99, 68, 97, 66, 38, 59, 72, 72, 43, 45, 65, 70, 114, 63, 40,
        109, 57, 72, 90, 86, 41, 70, 75, 83, 56, 74, 67, 119, 59, 83, 68, 61, 54, 91, 94, 47, 68,
        90, 85, 76, 96, 69, 85, 68, 102, 93, 71, 71, 108, 71, 38, 62, 119, 36, 41, 70, 46, 47, 94,
        110, 51, 43, 114, 108, 111, 43, 68, 66, 59, 53, 115, 73, 89, 71, 78, 107, 43, 105, 49, 116,
        45, 54, 57, 74, 103, 45, 45, 48, 112, 97, 111, 55, 83, 109, 35, 75, 41, 112, 100, 72, 87,
        38, 59, 76, 117, 68, 78, 72, 64, 72, 62, 35, 47, 88, 45, 84, 73, 40, 59, 80, 62, 35, 44,
        71, 99, 62, 35, 48, 83, 117, 62, 35, 52, 96, 49, 63, 35, 56, 108, 67, 63, 35, 60, 120, 85,
        63, 35, 64, 46, 105, 63, 35, 68, 58, 37, 64, 35, 72, 70, 55, 64, 35, 76, 82, 73, 64, 35,
        80, 95, 91, 64, 35, 84, 107, 110, 64, 35, 88, 119, 42, 65, 35, 93, 45, 61, 65, 35, 97, 57,
        79, 65, 35, 100, 60, 70, 38, 35, 42, 59, 71, 35, 35, 46, 71, 89, 35, 35, 50, 83, 108, 35,
        35, 54, 96, 40, 36, 35, 58, 108, 58, 36, 35, 62, 120, 76, 36, 35, 66, 46, 96, 36, 35, 70,
        58, 114, 36, 35, 74, 70, 46, 37, 35, 78, 82, 64, 37, 35, 82, 95, 82, 37, 35, 86, 107, 101,
        37, 35, 90, 119, 119, 37, 35, 95, 45, 52, 38, 35, 51, 94, 82, 104, 37, 83, 102, 108, 114,
        45, 107, 39, 77, 83, 46, 111, 63, 46, 53, 47, 115, 87, 101, 108, 47, 119, 112, 69, 77, 48,
        37, 51, 39, 47, 49, 41, 75, 94, 102, 49, 45, 100, 62, 71, 50, 49, 38, 118, 40, 51, 53, 62,
        86, 96, 51, 57, 86, 55, 65, 52, 61, 111, 110, 120, 52, 65, 49, 79, 89, 53, 69, 73, 48, 59,
        54, 73, 98, 103, 114, 54, 77, 36, 72, 83, 55, 81, 60, 41, 53, 56, 67, 53, 119, 44, 59, 87,
        111, 65, 42, 35, 91, 37, 84, 42, 35, 96, 49, 103, 42, 35, 100, 61, 35, 43, 35, 104, 73, 53,
        43, 35, 108, 85, 71, 43, 35, 112, 98, 89, 43, 35, 116, 110, 108, 43, 35, 120, 36, 41, 44,
        35, 38, 49, 59, 44, 35, 42, 61, 77, 44, 35, 46, 73, 96, 44, 35, 50, 85, 114, 44, 35, 54,
        98, 46, 45, 35, 59, 119, 91, 72, 35, 105, 81, 116, 65, 35, 109, 94, 48, 66, 35, 113, 106,
        66, 66, 35, 117, 118, 84, 66, 35, 35, 45, 104, 66, 35, 39, 57, 36, 67, 35, 43, 69, 54, 67,
        35, 47, 81, 72, 67, 35, 51, 94, 90, 67, 35, 55, 106, 109, 67, 35, 59, 118, 41, 68, 35, 63,
        44, 60, 68, 35, 67, 56, 78, 68, 35, 71, 68, 97, 68, 35, 75, 80, 115, 68, 35, 79, 93, 47,
        69, 35, 103, 49, 65, 53, 35, 75, 65, 42, 49, 35, 103, 67, 49, 55, 35, 77, 71, 100, 59, 35,
        56, 40, 48, 50, 35, 76, 45, 100, 51, 35, 114, 87, 77, 52, 35, 72, 103, 97, 49, 35, 44, 60,
        119, 48, 35, 84, 46, 106, 60, 35, 79, 35, 39, 50, 35, 67, 89, 78, 49, 35, 113, 97, 94, 58,
        35, 95, 52, 109, 51, 35, 111, 64, 47, 61, 35, 101, 71, 56, 61, 35, 116, 56, 74, 53, 35, 96,
        43, 55, 56, 35, 52, 117, 73, 45, 35, 109, 51, 66, 50, 35, 83, 66, 91, 56, 35, 81, 48, 64,
        56, 35, 105, 91, 42, 57, 35, 105, 79, 110, 56, 35, 49, 78, 109, 59, 35, 94, 115, 78, 57,
        35, 113, 104, 60, 57, 35, 58, 61, 120, 45, 35, 80, 59, 75, 50, 35, 36, 37, 88, 57, 35, 98,
        67, 43, 46, 35, 82, 103, 59, 60, 35, 109, 78, 61, 46, 35, 77, 84, 70, 46, 35, 82, 90, 79,
        46, 35, 50, 63, 41, 52, 35, 89, 35, 40, 47, 35, 91, 41, 49, 47, 35, 98, 59, 76, 47, 35,
        100, 65, 85, 47, 35, 48, 83, 118, 59, 35, 108, 89, 36, 48, 35, 110, 96, 45, 48, 35, 115,
        102, 54, 48, 35, 40, 70, 50, 52, 35, 119, 114, 72, 48, 35, 37, 47, 101, 48, 35, 84, 109,
        68, 60, 35, 37, 74, 83, 77, 70, 111, 118, 101, 58, 67, 84, 66, 69, 88, 73, 58, 60, 101,
        104, 50, 103, 41, 66, 44, 51, 104, 50, 94, 71, 51, 105, 59, 35, 100, 51, 106, 68, 62, 41,
        52, 107, 77, 89, 68, 52, 108, 86, 117, 96, 52, 109, 96, 58, 38, 53, 110, 105, 85, 65, 53,
        64, 40, 65, 53, 66, 65, 49, 93, 80, 66, 66, 58, 120, 108, 66, 67, 67, 61, 50, 67, 68, 76,
        88, 77, 67, 69, 85, 116, 105, 67, 102, 38, 48, 103, 50, 39, 116, 78, 63, 80, 71, 84, 52,
        67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71,
        84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67,
        80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 71, 84, 52, 67, 80, 45, 113, 101, 107, 67, 96,
        46, 57, 107, 69, 103, 94, 43, 70, 36, 107, 119, 86, 105, 70, 74, 84, 66, 38, 53, 75, 84,
        66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53,
        75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66,
        38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53, 75, 84, 66, 38, 53,
        111, 44, 94, 60, 45, 50, 56, 90, 73, 39, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79,
        63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63,
        59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59,
        120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 79, 63, 59, 120, 112, 59, 55, 113,
        45, 35, 108, 76, 89, 73, 58, 120, 118, 68, 61, 35, 0,
    ]
};

pub unsafe fn nk_font_atlas_add_compressed_base85(
    mut atlas: *mut FontAtlas,
    mut data_base85: *const Char,
    mut height: f32,
    mut config: *const FontConfig,
) -> *mut Font {
    let mut compressed_size: Int = 0;
    let mut compressed_data: *mut Void = 0 as *mut Void;
    let mut font: *mut Font = 0 as *mut Font;
    if atlas.is_null()
        || data_base85.is_null()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
    {
        return 0 as *mut Font;
    } else {
        compressed_size = (nk_strlen(data_base85) + 4i32) / 5i32 * 4i32;
        compressed_data = (*atlas).temporary.alloc.expect("non-null function pointer")(
            (*atlas).temporary.userdata,
            0 as *mut Void,
            compressed_size as Size,
        );
        if compressed_data.is_null() {
            return 0 as *mut Font;
        } else {
            nk_decode_85(compressed_data as *mut Uchar, data_base85 as *const Uchar);
            font = nk_font_atlas_add_compressed(
                atlas,
                compressed_data,
                compressed_size as Size,
                height,
                config,
            );
            (*atlas).temporary.free.expect("non-null function pointer")(
                (*atlas).temporary.userdata,
                compressed_data,
            );
            return font;
        }
    };
}

pub unsafe fn nk_font_atlas_add_compressed(
    mut atlas: *mut FontAtlas,
    mut compressed_data: *mut Void,
    mut compressed_size: Size,
    mut height: f32,
    mut config: *const FontConfig,
) -> *mut Font {
    let mut decompressed_size: Uint = 0;
    let mut decompressed_data: *mut Void = 0 as *mut Void;
    let mut cfg: FontConfig = FontConfig {
        next: 0 as *mut FontConfig,
        ttf_blob: 0 as *mut Void,
        ttf_size: 0,
        ttf_data_owned_by_atlas: 0,
        merge_mode: 0,
        pixel_snap: 0,
        oversample_v: 0,
        oversample_h: 0,
        padding: [0; 3],
        size: 0.,
        coord_type: NK_COORD_UV,
        spacing: Point { x: 0., y: 0. },
        range: 0 as *const Rune,
        font: 0 as *mut BakedFont,
        fallback_glyph: 0,
        n: 0 as *mut FontConfig,
        p: 0 as *mut FontConfig,
    };
    if atlas.is_null()
        || compressed_data.is_null()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
    {
        return 0 as *mut Font;
    } else {
        decompressed_size = nk_decompress_length(compressed_data as *mut Uchar);
        decompressed_data = (*atlas).permanent.alloc.expect("non-null function pointer")(
            (*atlas).permanent.userdata,
            0 as *mut Void,
            decompressed_size as Size,
        );
        if decompressed_data.is_null() {
            return 0 as *mut Font;
        } else {
            nk_decompress(
                decompressed_data as *mut Uchar,
                compressed_data as *mut Uchar,
                compressed_size as Uint,
            );
            cfg = if !config.is_null() {
                *config
            } else {
                FontConfig(height)
            };
            cfg.ttf_blob = decompressed_data;
            cfg.ttf_size = decompressed_size as Size;
            cfg.size = height;
            cfg.ttf_data_owned_by_atlas = 1i32 as Uchar;
            return nk_font_atlas_add(atlas, &mut cfg);
        }
    };
}
unsafe fn nk_decompress(mut output: *mut Uchar, mut i: *mut Uchar, mut length: Uint) -> Uint {
    let mut olen: Uint = 0;
    if ((*i.offset(0isize) as Int) << 24i32)
        + (((*i.offset((0i32 + 1i32) as isize) as Int) << 16i32)
            + (((*i.offset((0i32 + 1i32 + 1i32) as isize) as Int) << 8i32)
                + *i.offset((0i32 + 1i32 + 1i32 + 1i32) as isize) as Int)) != 1471938560i32
    {
        return 0i32 as Uint;
    } else if ((*i.offset(4isize) as Int) << 24i32)
        + (((*i.offset((4i32 + 1i32) as isize) as Int) << 16i32)
            + (((*i.offset((4i32 + 1i32 + 1i32) as isize) as Int) << 8i32)
                + *i.offset((4i32 + 1i32 + 1i32 + 1i32) as isize) as Int)) != 0i32
    {
        /* error! stream is > 4GB */
        return 0i32 as Uint;
    } else {
        olen = nk_decompress_length(i);
        nk__barrier2 = i;
        nk__barrier3 = i.offset(length as isize);
        nk__barrier = output.offset(olen as isize);
        nk__barrier4 = output;
        i = i.offset(16isize);
        nk__dout = output;
        loop {
            let mut old_i: *mut Uchar = i;
            i = nk_decompress_token(i);
            if i == old_i {
                if *i as Int == 5i32 && *i.offset(1isize) as Int == 250i32 {
                    if nk__dout != output.offset(olen as isize) {
                        return 0i32 as Uint;
                    } else if nk_adler32(1i32 as Uint, output, olen)
                        != (((*i.offset(2isize) as Int) << 24i32)
                            + (((*i.offset((2i32 + 1i32) as isize) as Int) << 16i32)
                                + (((*i.offset((2i32 + 1i32 + 1i32) as isize) as Int) << 8i32)
                                    + *i.offset((2i32 + 1i32 + 1i32 + 1i32) as isize) as Int)))
                            as Uint
                    {
                        return 0i32 as Uint;
                    } else {
                        return olen;
                    }
                } else {
                    return 0i32 as Uint;
                }
            } else {
                if !(nk__dout > output.offset(olen as isize)) {
                    continue;
                }
                return 0i32 as Uint;
            }
        }
    };
}
static mut nk__dout: *mut Uchar = unsafe { 0 as *const Uchar as *mut Uchar };
unsafe fn nk_adler32(mut adler32: Uint, mut buffer: *mut Uchar, mut buflen: Uint) -> Uint {
    let ADLER_MOD: Ulong = 65521i32 as Ulong;
    let mut s1: Ulong = (adler32 & 65535i32 as Uint) as Ulong;
    let mut s2: Ulong = (adler32 >> 16i32) as Ulong;
    let mut blocklen: Ulong = 0;
    let mut i: Ulong = 0;
    blocklen = buflen.wrapping_rem(5552i32 as Uint) as Ulong;
    while 0 != buflen {
        i = 0i32 as Ulong;
        while i.wrapping_add(7i32 as Ulong) < blocklen {
            s1 = s1.wrapping_add(*buffer.offset(0isize) as Ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(1isize) as Ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(2isize) as Ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(3isize) as Ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(4isize) as Ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(5isize) as Ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(6isize) as Ulong);
            s2 = s2.wrapping_add(s1);
            s1 = s1.wrapping_add(*buffer.offset(7isize) as Ulong);
            s2 = s2.wrapping_add(s1);
            buffer = buffer.offset(8isize);
            i = i.wrapping_add(8i32 as Ulong)
        }
        while i < blocklen {
            let fresh51 = buffer;
            buffer = buffer.offset(1);
            s1 = s1.wrapping_add(*fresh51 as Ulong);
            s2 = s2.wrapping_add(s1);
            i = i.wrapping_add(1)
        }
        s1 = s1.wrapping_rem(ADLER_MOD);
        s2 = s2.wrapping_rem(ADLER_MOD);
        buflen = buflen.wrapping_sub(blocklen as Uint);
        blocklen = 5552i32 as Ulong
    }
    return ((s2 << 16i32) as Uint).wrapping_add(s1 as Uint);
}
unsafe fn nk_decompress_token(mut i: *mut Uchar) -> *mut Uchar {
    if *i as Int >= 32i32 {
        /* use fewer if's for cases that expand small */
        if *i as Int >= 128i32 {
            nk__match(
                nk__dout
                    .offset(-(*i.offset(1isize) as Int as isize))
                    .offset(-1isize),
                (*i.offset(0isize) as Uint)
                    .wrapping_sub(128i32 as Uint)
                    .wrapping_add(1i32 as Uint),
            );
            i = i.offset(2isize)
        } else if *i as Int >= 64i32 {
            nk__match(
                nk__dout.offset(
                    -((((*i.offset(0isize) as Int) << 8i32)
                        + *i.offset((0i32 + 1i32) as isize) as Int - 16384i32
                        + 1i32) as isize),
                ),
                (*i.offset(2isize) as Uint).wrapping_add(1i32 as Uint),
            );
            i = i.offset(3isize)
        } else {
            /* *i >= 0x20 */
            nk__lit(
                i.offset(1isize),
                (*i.offset(0isize) as Uint)
                    .wrapping_sub(32i32 as Uint)
                    .wrapping_add(1i32 as Uint),
            );
            i = i.offset((1i32 + (*i.offset(0isize) as Int - 32i32 + 1i32)) as isize)
        }
    } else if *i as Int >= 24i32 {
        nk__match(
            nk__dout.offset(
                -((((*i.offset(0isize) as Int) << 16i32)
                    + (((*i.offset((0i32 + 1i32) as isize) as Int) << 8i32)
                        + *i.offset((0i32 + 1i32 + 1i32) as isize) as Int)
                    - 1572864i32 + 1i32) as Uint as isize),
            ),
            (*i.offset(3isize) as Uint).wrapping_add(1i32 as Uint),
        );
        i = i.offset(4isize)
    } else if *i as Int >= 16i32 {
        nk__match(
            nk__dout.offset(
                -((((*i.offset(0isize) as Int) << 16i32)
                    + (((*i.offset((0i32 + 1i32) as isize) as Int) << 8i32)
                        + *i.offset((0i32 + 1i32 + 1i32) as isize) as Int)
                    - 1048576i32 + 1i32) as Uint as isize),
            ),
            ((((*i.offset(3isize) as Int) << 8i32) + *i.offset((3i32 + 1i32) as isize) as Int)
                as Uint)
                .wrapping_add(1i32 as Uint),
        );
        i = i.offset(5isize)
    } else if *i as Int >= 8i32 {
        nk__lit(
            i.offset(2isize),
            ((((*i.offset(0isize) as Int) << 8i32) + *i.offset((0i32 + 1i32) as isize) as Int)
                as Uint)
                .wrapping_sub(2048i32 as Uint)
                .wrapping_add(1i32 as Uint),
        );
        i = i.offset(
            (2i32
                + (((*i.offset(0isize) as Int) << 8i32) + *i.offset((0i32 + 1i32) as isize) as Int
                    - 2048i32 + 1i32)) as isize,
        )
    } else if *i as Int == 7i32 {
        nk__lit(
            i.offset(3isize),
            ((((*i.offset(1isize) as Int) << 8i32) + *i.offset((1i32 + 1i32) as isize) as Int)
                as Uint)
                .wrapping_add(1i32 as Uint),
        );
        i = i.offset(
            (3i32 + (((*i.offset(1isize) as Int) << 8i32)
                + *i.offset((1i32 + 1i32) as isize) as Int
                + 1i32)) as isize,
        )
    } else if *i as Int == 6i32 {
        nk__match(
            nk__dout.offset(
                -((((*i.offset(1isize) as Int) << 16i32)
                    + (((*i.offset((1i32 + 1i32) as isize) as Int) << 8i32)
                        + *i.offset((1i32 + 1i32 + 1i32) as isize) as Int)
                    + 1i32) as Uint as isize),
            ),
            (*i.offset(4isize) as Uint).wrapping_add(1u32),
        );
        i = i.offset(5isize)
    } else if *i as Int == 4i32 {
        nk__match(
            nk__dout.offset(
                -((((*i.offset(1isize) as Int) << 16i32)
                    + (((*i.offset((1i32 + 1i32) as isize) as Int) << 8i32)
                        + *i.offset((1i32 + 1i32 + 1i32) as isize) as Int)
                    + 1i32) as Uint as isize),
            ),
            ((((*i.offset(4isize) as Int) << 8i32) + *i.offset((4i32 + 1i32) as isize) as Int)
                as Uint)
                .wrapping_add(1u32),
        );
        i = i.offset(6isize)
    }
    return i;
}
unsafe fn nk__match(mut data: *mut Uchar, mut length: Uint) -> () {
    /* INVERSE of memmove... write each byte before copying the next...*/
    if nk__dout.offset(length as isize) > nk__barrier {
        nk__dout = nk__dout.offset(length as isize);
        return;
    } else if data < nk__barrier4 {
        nk__dout = nk__barrier.offset(1isize);
        return;
    } else {
        loop {
            let fresh52 = length;
            length = length.wrapping_sub(1);
            if !(0 != fresh52) {
                break;
            }
            let fresh54 = nk__dout;
            nk__dout = nk__dout.offset(1);
            let fresh53 = data;
            data = data.offset(1);
            *fresh54 = *fresh53
        }
        return;
    };
}
static mut nk__barrier: *mut Uchar = unsafe { 0 as *const Uchar as *mut Uchar };
static mut nk__barrier4: *mut Uchar = unsafe { 0 as *const Uchar as *mut Uchar };
unsafe fn nk__lit(mut data: *mut Uchar, mut length: Uint) -> () {
    if nk__dout.offset(length as isize) > nk__barrier {
        nk__dout = nk__dout.offset(length as isize);
        return;
    } else if data < nk__barrier2 {
        nk__dout = nk__barrier.offset(1isize);
        return;
    } else {
        nk_memcopy(nk__dout as *mut Void, data as *const Void, length as Size);
        nk__dout = nk__dout.offset(length as isize);
        return;
    };
}
static mut nk__barrier2: *mut Uchar = unsafe { 0 as *const Uchar as *mut Uchar };
static mut nk__barrier3: *mut Uchar = unsafe { 0 as *const Uchar as *mut Uchar };
unsafe fn nk_decompress_length(mut input: *mut Uchar) -> Uint {
    return (((*input.offset(8isize) as Int) << 24i32)
        + ((*input.offset(9isize) as Int) << 16i32)
        + ((*input.offset(10isize) as Int) << 8i32)
        + *input.offset(11isize) as Int) as Uint;
}
unsafe fn nk_decode_85(mut dst: *mut Uchar, mut src: *const Uchar) -> () {
    while 0 != *src {
        let mut tmp: Uint = nk_decode_85_byte(*src.offset(0isize) as Char).wrapping_add(
            (85i32 as Uint).wrapping_mul(
                nk_decode_85_byte(*src.offset(1isize) as Char).wrapping_add(
                    (85i32 as Uint).wrapping_mul(
                        nk_decode_85_byte(*src.offset(2isize) as Char).wrapping_add(
                            (85i32 as Uint).wrapping_mul(
                                nk_decode_85_byte(*src.offset(3isize) as Char).wrapping_add(
                                    (85i32 as Uint).wrapping_mul(nk_decode_85_byte(
                                        *src.offset(4isize) as Char,
                                    )),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        );
        /* we can't assume little-endianess. */
        *dst.offset(0isize) = (tmp >> 0i32 & 255i32 as Uint) as Uchar;
        *dst.offset(1isize) = (tmp >> 8i32 & 255i32 as Uint) as Uchar;
        *dst.offset(2isize) = (tmp >> 16i32 & 255i32 as Uint) as Uchar;
        *dst.offset(3isize) = (tmp >> 24i32 & 255i32 as Uint) as Uchar;
        src = src.offset(5isize);
        dst = dst.offset(4isize)
    }
}
unsafe fn nk_decode_85_byte(mut c: Char) -> Uint {
    return (if c as Int >= '\\' as i32 {
        c as Int - 36i32
    } else {
        c as Int - 35i32
    }) as Uint;
}

pub unsafe fn nk_font_atlas_add_from_memory(
    mut atlas: *mut FontAtlas,
    mut memory: *mut Void,
    mut size: Size,
    mut height: f32,
    mut config: *const FontConfig,
) -> *mut Font {
    let mut cfg: FontConfig = FontConfig {
        next: 0 as *mut FontConfig,
        ttf_blob: 0 as *mut Void,
        ttf_size: 0,
        ttf_data_owned_by_atlas: 0,
        merge_mode: 0,
        pixel_snap: 0,
        oversample_v: 0,
        oversample_h: 0,
        padding: [0; 3],
        size: 0.,
        coord_type: NK_COORD_UV,
        spacing: Point { x: 0., y: 0. },
        range: 0 as *const Rune,
        font: 0 as *mut BakedFont,
        fallback_glyph: 0,
        n: 0 as *mut FontConfig,
        p: 0 as *mut FontConfig,
    };
    if atlas.is_null()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
        || memory.is_null()
        || 0 == size
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
    {
        return 0 as *mut Font;
    } else {
        cfg = if !config.is_null() {
            *config
        } else {
            FontConfig(height)
        };
        cfg.ttf_blob = memory;
        cfg.ttf_size = size;
        cfg.size = height;
        cfg.ttf_data_owned_by_atlas = 0i32 as Uchar;
        return nk_font_atlas_add(atlas, &mut cfg);
    };
}

pub unsafe fn nk_font_atlas_add_from_file(
    mut atlas: *mut FontAtlas,
    mut file_path: *const Char,
    mut height: f32,
    mut config: *const FontConfig,
) -> *mut Font {
    let mut size: Size = 0;
    let mut memory: *mut Char = 0 as *mut Char;
    let mut cfg: FontConfig = FontConfig {
        next: 0 as *mut FontConfig,
        ttf_blob: 0 as *mut Void,
        ttf_size: 0,
        ttf_data_owned_by_atlas: 0,
        merge_mode: 0,
        pixel_snap: 0,
        oversample_v: 0,
        oversample_h: 0,
        padding: [0; 3],
        size: 0.,
        coord_type: NK_COORD_UV,
        spacing: Point { x: 0., y: 0. },
        range: 0 as *const Rune,
        font: 0 as *mut BakedFont,
        fallback_glyph: 0,
        n: 0 as *mut FontConfig,
        p: 0 as *mut FontConfig,
    };
    if atlas.is_null() || file_path.is_null() {
        return 0 as *mut Font;
    } else {
        memory = nk_file_load(file_path, &mut size, &mut (*atlas).permanent);
        if memory.is_null() {
            return 0 as *mut Font;
        } else {
            cfg = if !config.is_null() {
                *config
            } else {
                FontConfig(height)
            };
            cfg.ttf_blob = memory as *mut Void;
            cfg.ttf_size = size;
            cfg.size = height;
            cfg.ttf_data_owned_by_atlas = 1i32 as Uchar;
            return nk_font_atlas_add(atlas, &mut cfg);
        }
    };
}
unsafe fn nk_file_load(
    mut path: *const Char,
    mut siz: *mut Size,
    mut alloc: *mut Allocator,
) -> *mut Char {
    let mut buf: *mut Char = 0 as *mut Char;
    let mut fd: *mut FILE = 0 as *mut FILE;
    let mut ret: Long = 0;
    if path.is_null() || siz.is_null() || alloc.is_null() {
        return 0 as *mut Char;
    } else {
        fd = libc::fopen(path, b"rb\x00" as *const u8 as *const Char);
        if fd.is_null() {
            return 0 as *mut Char;
        } else {
            libc::fseek(fd, 0i32 as Long, 2i32);
            ret = libc::ftell(fd);
            if ret < 0i32 as Long {
                libc::fclose(fd);
                return 0 as *mut Char;
            } else {
                *siz = ret as Size;
                libc::fseek(fd, 0i32 as Long, 0i32);
                buf = (*alloc).alloc.expect("non-null function pointer")(
                    (*alloc).userdata,
                    0 as *mut Void,
                    *siz,
                ) as *mut Char;
                if buf.is_null() {
                    libc::fclose(fd);
                    return 0 as *mut Char;
                } else {
                    *siz = libc::fread(buf as *mut Void, 1, *siz as usize, fd) as u64;
                    libc::fclose(fd);
                    return buf;
                }
            }
        }
    };
}

pub unsafe fn nk_font_atlas_bake(
    mut atlas: *mut FontAtlas,
    mut width: *mut Int,
    mut height: *mut Int,
    mut fmt: FontAtlasFormat,
) -> *const Void {
    let mut current_block: u64;
    let mut i: Int = 0i32;
    let mut tmp: *mut Void = 0 as *mut Void;
    let mut tmp_size: Size = 0;
    let mut img_size: Size = 0;
    let mut font_iter: *mut Font = 0 as *mut Font;
    let mut baker: *mut FontBaker = 0 as *mut FontBaker;
    if atlas.is_null()
        || width.is_null()
        || height.is_null()
        || (*atlas).temporary.alloc.is_none()
        || (*atlas).temporary.free.is_none()
        || (*atlas).permanent.alloc.is_none()
        || (*atlas).permanent.free.is_none()
    {
        return 0 as *const Void;
    } else {
        /* no font added so just use default font */
        if 0 == (*atlas).font_num {
            (*atlas).default_font =
                nk_font_atlas_add_default(atlas, 13.0f32, 0 as *const FontConfig)
        }
        if 0 == (*atlas).font_num {
            return 0 as *const Void;
        } else {
            /* allocate temporary baker memory required for the baking process */
            nk_font_baker_memory(
                &mut tmp_size,
                &mut (*atlas).glyph_count,
                (*atlas).config,
                (*atlas).font_num,
            );
            tmp = (*atlas).temporary.alloc.expect("non-null function pointer")(
                (*atlas).temporary.userdata,
                0 as *mut Void,
                tmp_size,
            );
            if !tmp.is_null() {
                /* allocate glyph memory for all fonts */
                baker = FontBaker(
                    tmp,
                    (*atlas).glyph_count,
                    (*atlas).font_num,
                    &mut (*atlas).temporary,
                );
                (*atlas).glyphs = (*atlas).permanent.alloc.expect("non-null function pointer")(
                    (*atlas).permanent.userdata,
                    0 as *mut Void,
                    (mem::size_of::<FontGlyph>() as Ulong)
                        .wrapping_mul((*atlas).glyph_count as Size),
                ) as *mut FontGlyph;
                if !(*atlas).glyphs.is_null() {
                    /* pack all glyphs into a tight fit space */
                    (*atlas).custom.w = (90i32 * 2i32 + 1i32) as Short;
                    (*atlas).custom.h = (27i32 + 1i32) as Short;
                    if !(0 == nk_font_bake_pack(
                        baker,
                        &mut img_size,
                        width,
                        height,
                        &mut (*atlas).custom,
                        (*atlas).config,
                        (*atlas).font_num,
                        &mut (*atlas).temporary,
                    )) {
                        /* allocate memory for the baked image font atlas */
                        (*atlas).pixel =
                            (*atlas).temporary.alloc.expect("non-null function pointer")(
                                (*atlas).temporary.userdata,
                                0 as *mut Void,
                                img_size,
                            );
                        if !(*atlas).pixel.is_null() {
                            /* bake glyphs and custom white pixel into image */
                            nk_font_bake(
                                baker,
                                (*atlas).pixel,
                                *width,
                                *height,
                                (*atlas).glyphs,
                                (*atlas).glyph_count,
                                (*atlas).config,
                                (*atlas).font_num,
                            );
                            nk_font_bake_custom_data(
                                (*atlas).pixel,
                                *width,
                                *height,
                                (*atlas).custom,
                                nk_custom_cursor_data.as_ptr(),
                                90i32,
                                27i32,
                                '.' as i32 as Char,
                                'X' as i32 as Char,
                            );
                            if fmt as Uint == NK_FONT_ATLAS_RGBA32 as Int as Uint {
                                /* convert alpha8 image into rgba32 image */
                                let mut img_rgba: *mut Void =
                                    (*atlas).temporary.alloc.expect("non-null function pointer")(
                                        (*atlas).temporary.userdata,
                                        0 as *mut Void,
                                        (*width * *height * 4i32) as Size,
                                    );
                                if img_rgba.is_null() {
                                    current_block = 10139445023164747751;
                                } else {
                                    nk_font_bake_convert(img_rgba, *width, *height, (*atlas).pixel);
                                    (*atlas).temporary.free.expect("non-null function pointer")(
                                        (*atlas).temporary.userdata,
                                        (*atlas).pixel,
                                    );
                                    (*atlas).pixel = img_rgba;
                                    current_block = 1394248824506584008;
                                }
                            } else {
                                current_block = 1394248824506584008;
                            }
                            match current_block {
                                10139445023164747751 => {}
                                _ => {
                                    (*atlas).tex_width = *width;
                                    (*atlas).tex_height = *height;
                                    /* initialize each font */
                                    font_iter = (*atlas).fonts;
                                    while !font_iter.is_null() {
                                        let mut font: *mut Font =
                                            font_iter;
                                        let mut config: *mut FontConfig =
                                            (*font).config;
                                        nk_font_init(
                                            font,
                                            (*config).size,
                                            (*config).fallback_glyph,
                                            (*atlas).glyphs,
                                            (*config).font,
                                            nk_handle_ptr(0 as *mut Void),
                                        );
                                        font_iter = (*font_iter).next
                                    }
                                    /* initialize each cursor */
                                    static mut nk_cursor_data: [[Point; 3]; 7] = unsafe {
                                        [
                                            [
                                                Point {
                                                    x: 0i32 as f32,
                                                    y: 3i32 as f32,
                                                },
                                                Point {
                                                    x: 12i32 as f32,
                                                    y: 19i32 as f32,
                                                },
                                                Point {
                                                    x: 0i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                            ],
                                            [
                                                Point {
                                                    x: 13i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                                Point {
                                                    x: 7i32 as f32,
                                                    y: 16i32 as f32,
                                                },
                                                Point {
                                                    x: 4i32 as f32,
                                                    y: 8i32 as f32,
                                                },
                                            ],
                                            [
                                                Point {
                                                    x: 31i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                                Point {
                                                    x: 23i32 as f32,
                                                    y: 23i32 as f32,
                                                },
                                                Point {
                                                    x: 11i32 as f32,
                                                    y: 11i32 as f32,
                                                },
                                            ],
                                            [
                                                Point {
                                                    x: 21i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                                Point {
                                                    x: 9i32 as f32,
                                                    y: 23i32 as f32,
                                                },
                                                Point {
                                                    x: 5i32 as f32,
                                                    y: 11i32 as f32,
                                                },
                                            ],
                                            [
                                                Point {
                                                    x: 55i32 as f32,
                                                    y: 18i32 as f32,
                                                },
                                                Point {
                                                    x: 23i32 as f32,
                                                    y: 9i32 as f32,
                                                },
                                                Point {
                                                    x: 11i32 as f32,
                                                    y: 5i32 as f32,
                                                },
                                            ],
                                            [
                                                Point {
                                                    x: 73i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                                Point {
                                                    x: 17i32 as f32,
                                                    y: 17i32 as f32,
                                                },
                                                Point {
                                                    x: 9i32 as f32,
                                                    y: 9i32 as f32,
                                                },
                                            ],
                                            [
                                                Point {
                                                    x: 55i32 as f32,
                                                    y: 0i32 as f32,
                                                },
                                                Point {
                                                    x: 17i32 as f32,
                                                    y: 17i32 as f32,
                                                },
                                                Point {
                                                    x: 9i32 as f32,
                                                    y: 9i32 as f32,
                                                },
                                            ],
                                        ]
                                    };
                                    /* Pos      Size        Offset */
                                    i = 0i32;
                                    while i < NK_CURSOR_COUNT as Int {
                                        let mut cursor: *mut Cursor =
                                            &mut (*atlas).cursors[i as usize]
                                                as *mut Cursor;
                                        (*cursor).img.w = *width as Ushort;
                                        (*cursor).img.h = *height as Ushort;
                                        (*cursor).img.region[0usize] = ((*atlas).custom.x as Int
                                            as f32
                                            + nk_cursor_data[i as usize][0usize].x)
                                            as Ushort;
                                        (*cursor).img.region[1usize] = ((*atlas).custom.y as Int
                                            as f32
                                            + nk_cursor_data[i as usize][0usize].y)
                                            as Ushort;
                                        (*cursor).img.region[2usize] =
                                            nk_cursor_data[i as usize][1usize].x as Ushort;
                                        (*cursor).img.region[3usize] =
                                            nk_cursor_data[i as usize][1usize].y as Ushort;
                                        (*cursor).size = nk_cursor_data[i as usize][1usize];
                                        (*cursor).offset = nk_cursor_data[i as usize][2usize];
                                        i += 1
                                    }
                                    /* free temporary memory */
                                    (*atlas).temporary.free.expect("non-null function pointer")(
                                        (*atlas).temporary.userdata,
                                        tmp,
                                    );
                                    return (*atlas).pixel;
                                }
                            }
                        }
                    }
                }
            }
            /* error so cleanup all memory */
            if !tmp.is_null() {
                (*atlas).temporary.free.expect("non-null function pointer")(
                    (*atlas).temporary.userdata,
                    tmp,
                );
            }
            if !(*atlas).glyphs.is_null() {
                (*atlas).permanent.free.expect("non-null function pointer")(
                    (*atlas).permanent.userdata,
                    (*atlas).glyphs as *mut Void,
                );
                (*atlas).glyphs = 0 as *mut FontGlyph
            }
            if !(*atlas).pixel.is_null() {
                (*atlas).temporary.free.expect("non-null function pointer")(
                    (*atlas).temporary.userdata,
                    (*atlas).pixel,
                );
                (*atlas).pixel = 0 as *mut Void
            }
            return 0 as *const Void;
        }
    };
}
unsafe fn nk_font_init(
    mut font: *mut Font,
    mut pixel_height: f32,
    mut fallback_codepoint: Rune,
    mut glyphs: *mut FontGlyph,
    mut baked_font: *const BakedFont,
    mut atlas: Handle,
) -> () {
    let mut baked: BakedFont = BakedFont {
        height: 0.,
        ascent: 0.,
        descent: 0.,
        glyph_offset: 0,
        glyph_count: 0,
        ranges: 0 as *const Rune,
    };
    if font.is_null() || glyphs.is_null() || baked_font.is_null() {
        return;
    } else {
        baked = *baked_font;
        (*font).fallback = 0 as *const FontGlyph;
        (*font).info = baked;
        (*font).scale = pixel_height / (*font).info.height;
        (*font).glyphs = &mut *glyphs.offset((*baked_font).glyph_offset as isize) as *mut FontGlyph;
        (*font).texture = atlas;
        (*font).fallback_codepoint = fallback_codepoint;
        (*font).fallback = nk_font_find_glyph(font, fallback_codepoint);
        (*font).handle.height = (*font).info.height * (*font).scale;
        (*font).handle.width = Some(nk_font_text_width);
        (*font).handle.userdata.ptr = font as *mut Void;
        (*font).handle.query = Some(nk_font_query_font_glyph);
        (*font).handle.texture = (*font).texture;
        return;
    };
}
unsafe fn nk_font_query_font_glyph(
    mut handle: Handle,
    mut height: f32,
    mut glyph: *mut UserFontGlyph,
    mut codepoint: Rune,
    mut next_codepoint: Rune,
) -> () {
    let mut scale: f32 = 0.;
    let mut g: *const FontGlyph = 0 as *const FontGlyph;
    let mut font: *mut Font = 0 as *mut Font;
    font = handle.ptr as *mut Font;
    if font.is_null() || glyph.is_null() {
        return;
    } else {
        scale = height / (*font).info.height;
        g = nk_font_find_glyph(font, codepoint);
        (*glyph).width = ((*g).x1 - (*g).x0) * scale;
        (*glyph).height = ((*g).y1 - (*g).y0) * scale;
        (*glyph).offset = Point::new((*g).x0 * scale, (*g).y0 * scale);
        (*glyph).xadvance = (*g).xadvance * scale;
        (*glyph).uv[0usize] = Point::new((*g).u0, (*g).v0);
        (*glyph).uv[1usize] = Point::new((*g).u1, (*g).v1);
        return;
    };
}

pub unsafe fn nk_font_find_glyph(mut font: *mut Font, mut unicode: Rune) -> *const FontGlyph {
    let mut i: Int = 0i32;
    let mut count: Int = 0;
    let mut total_glyphs: Int = 0i32;
    let mut glyph: *const FontGlyph = 0 as *const FontGlyph;
    let mut iter: *const FontConfig = 0 as *const FontConfig;
    if font.is_null() || (*font).glyphs.is_null() {
        return 0 as *const FontGlyph;
    } else {
        glyph = (*font).fallback;
        iter = (*font).config;
        loop {
            count = nk_range_count((*iter).range);
            i = 0i32;
            while i < count {
                let mut f: Rune = *(*iter).range.offset((i * 2i32 + 0i32) as isize);
                let mut t: Rune = *(*iter).range.offset((i * 2i32 + 1i32) as isize);
                let mut diff: Int = t.wrapping_sub(f).wrapping_add(1i32 as Uint) as Int;
                if unicode >= f && unicode <= t {
                    return &mut *(*font).glyphs.offset(
                        (total_glyphs as Rune).wrapping_add(unicode.wrapping_sub(f)) as isize,
                    ) as *mut FontGlyph;
                } else {
                    total_glyphs += diff;
                    i += 1
                }
            }
            iter = (*iter).n;
            if !(iter != (*font).config) {
                break;
            }
        }
        return glyph;
    };
}
unsafe fn nk_range_count(mut range: *const Rune) -> Int {
    let mut iter: *const Rune = range;
    if range.is_null() {
        return 0i32;
    } else {
        loop {
            let fresh55 = iter;
            iter = iter.offset(1);
            if !(*fresh55 != 0i32 as Uint) {
                break;
            }
        }
        return if iter == range {
            0i32
        } else {
            (range.ptr_offset_to(iter).expect("bad offset_to") as Long / 2i32 as Long) as Int
        };
    };
}
unsafe fn nk_font_text_width(
    mut handle: Handle,
    mut height: f32,
    mut text: *const Char,
    mut len: Int,
) -> f32 {
    let mut unicode: Rune = 0;
    let mut text_len: Int = 0i32;
    let mut text_width: f32 = 0i32 as f32;
    let mut glyph_len: Int = 0i32;
    let mut scale: f32 = 0i32 as f32;
    let mut font: *mut Font = handle.ptr as *mut Font;
    if font.is_null() || text.is_null() || 0 == len {
        return 0i32 as f32;
    } else {
        scale = height / (*font).info.height;
        text_len = nk_utf_decode(text, &mut unicode, len);
        glyph_len = text_len;
        if 0 == glyph_len {
            return 0i32 as f32;
        } else {
            while text_len <= len && 0 != glyph_len {
                let mut g: *const FontGlyph = 0 as *const FontGlyph;
                if unicode == 65533i32 as Uint {
                    break;
                }
                /* query currently drawn glyph information */
                g = nk_font_find_glyph(font, unicode);
                text_width += (*g).xadvance * scale;
                /* offset next glyph */
                glyph_len =
                    nk_utf_decode(text.offset(text_len as isize), &mut unicode, len - text_len);
                text_len += glyph_len
            }
            return text_width;
        }
    };
}
unsafe fn nk_font_bake_convert(
    mut out_memory: *mut Void,
    mut img_width: Int,
    mut img_height: Int,
    mut in_memory: *const Void,
) -> () {
    let mut n: Int = 0i32;
    let mut dst: *mut Rune = 0 as *mut Rune;
    let mut src: *const u8 = 0 as *const u8;
    if out_memory.is_null() || in_memory.is_null() || 0 == img_height || 0 == img_width {
        return;
    } else {
        dst = out_memory as *mut Rune;
        src = in_memory as *const u8;
        n = img_width * img_height;
        while n > 0i32 {
            let fresh57 = dst;
            dst = dst.offset(1);
            let fresh56 = src;
            src = src.offset(1);
            *fresh57 = (*fresh56 as Rune) << 24i32 | 16777215i32 as Uint;
            n -= 1
        }
        return;
    };
}

const nk_custom_cursor_data: [Char; 2431] = [
    46, 46, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 88, 88, 88, 88, 88, 88, 45, 32, 32, 32,
    32, 88, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 45, 88, 88, 88, 88, 88, 88, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 88, 88, 88, 88, 88, 88, 46, 46, 45, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 45, 88, 46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32,
    45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    45, 88, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 88, 45, 45, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    45, 88, 88, 88, 46, 88, 88, 88, 45, 32, 32, 88, 46, 46, 46, 88, 32, 32, 45, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 88, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 46, 46, 46, 46,
    88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    88, 46, 46, 46, 46, 88, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 88,
    32, 32, 45, 32, 88, 46, 46, 46, 46, 46, 88, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46,
    46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 88,
    88, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 88, 32, 32, 45, 88, 46, 46,
    46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 46, 46, 88, 32,
    32, 32, 32, 32, 32, 32, 45, 88, 46, 46, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 46, 46, 88, 88, 46, 88, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 88, 32, 32, 45, 88, 88, 88, 88, 46, 88, 88, 88, 88,
    45, 32, 32, 32, 32, 32, 32, 32, 88, 88, 88, 88, 46, 88, 88, 88, 88, 32, 32, 32, 32, 32, 32, 32,
    45, 88, 46, 88, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 88, 46, 88, 32, 88, 46, 88, 88, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32,
    45, 32, 32, 88, 46, 88, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 88, 32, 32, 32,
    88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46,
    88, 32, 32, 32, 88, 88, 88, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 88,
    32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 88,
    46, 88, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32,
    32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32,
    88, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 88, 32, 32, 45, 32, 32, 32,
    88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32,
    88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32,
    45, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46,
    88, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 88, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32,
    45, 32, 32, 88, 46, 46, 88, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 88, 46, 46, 88, 32, 32,
    45, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32,
    32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32,
    45, 32, 32, 88, 46, 88, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 88, 46, 46, 46,
    88, 88, 88, 88, 88, 88, 46, 88, 88, 88, 88, 88, 88, 46, 46, 46, 88, 32, 45, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 88, 88, 45, 88, 88, 32, 32, 32, 88, 46, 88, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 46, 46, 88, 32, 32, 32, 45, 32, 32, 88, 46, 88,
    32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 88, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
    46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88,
    46, 88, 32, 88, 46, 88, 45, 88, 46, 88, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    88, 46, 46, 46, 46, 46, 46, 46, 46, 88, 32, 32, 45, 32, 32, 88, 46, 88, 32, 32, 45, 32, 32, 32,
    88, 46, 88, 32, 32, 32, 45, 32, 88, 46, 46, 46, 88, 88, 88, 88, 88, 88, 46, 88, 88, 88, 88, 88,
    88, 46, 46, 46, 88, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 46, 46, 88,
    45, 88, 46, 46, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46,
    46, 46, 46, 46, 88, 32, 45, 88, 88, 88, 46, 88, 88, 88, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32,
    45, 32, 32, 88, 46, 46, 88, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 88, 46, 46, 88, 32, 32,
    45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 88, 45, 88, 46, 46, 46, 88,
    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 88,
    45, 88, 46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 88, 46,
    88, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 88, 45, 88, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 46, 46, 46, 88, 88, 88, 88, 88, 45, 88, 88, 88, 88, 88,
    88, 88, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 88,
    46, 88, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88,
    46, 46, 46, 46, 46, 88, 45, 88, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    88, 46, 46, 46, 88, 46, 46, 88, 32, 32, 32, 32, 45, 45, 45, 45, 45, 45, 45, 45, 45, 32, 32, 32,
    88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 88, 88, 88, 88, 88, 88,
    45, 88, 88, 88, 88, 88, 88, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 88, 32, 88,
    46, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 45, 88, 88, 88, 88, 46, 88, 88, 88, 88,
    45, 32, 32, 32, 32, 32, 32, 32, 88, 88, 88, 88, 46, 88, 88, 88, 88, 32, 32, 32, 32, 32, 32, 32,
    45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
    45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 88, 46, 88, 32, 32, 88, 46, 46, 88, 32, 32, 32,
    45, 32, 32, 32, 32, 32, 32, 32, 45, 88, 46, 46, 46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 32, 32,
    32, 32, 88, 46, 46, 46, 46, 46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 88,
    88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 88, 46, 46, 88, 32, 32, 45, 32, 32, 32, 32, 32,
    32, 32, 45, 32, 88, 46, 46, 46, 46, 46, 88, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46,
    46, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 88, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 88,
    46, 46, 46, 88, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 46, 46, 88, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    88, 46, 46, 88, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    32, 88, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 88, 46, 88, 32, 32, 32,
    45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    45, 32, 88, 46, 46, 46, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 46, 46, 46, 88, 32,
    45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
    32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 88, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 88, 46, 46, 46, 46,
    46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 88, 45, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    32, 32, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
    45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 32, 88, 46, 46, 46, 88, 88, 88, 88, 88, 88,
    88, 88, 88, 88, 88, 88, 88, 46, 46, 46, 88, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 45, 32, 32, 88, 46, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    88, 46, 46, 88, 32, 32, 45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    45, 32, 32, 32, 88, 46, 88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 46, 88, 32, 32, 32,
    45, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 45, 32, 32, 32, 32, 88,
    88, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 88, 88, 32, 32, 32, 32, 45, 32, 32, 32, 32, 32,
    32, 32, 32, 32, 32, 32, 0,
];

unsafe fn nk_font_bake_custom_data(
    mut img_memory: *mut Void,
    mut img_width: Int,
    mut img_height: Int,
    mut img_dst: RectI,
    mut texture_data_mask: *const Char,
    mut tex_width: Int,
    mut tex_height: Int,
    mut white: Char,
    mut black: Char,
) -> () {
    let mut pixels: *mut u8 = 0 as *mut u8;
    let mut y: Int = 0i32;
    let mut x: Int = 0i32;
    let mut n: Int = 0i32;
    if img_memory.is_null() || 0 == img_width || 0 == img_height || texture_data_mask.is_null() {
        return;
    } else {
        pixels = img_memory as *mut u8;
        y = 0i32;
        n = 0i32;
        while y < tex_height {
            x = 0i32;
            while x < tex_width {
                let off0: Int = img_dst.x as Int + x + (img_dst.y as Int + y) * img_width;
                let off1: Int = off0 + 1i32 + tex_width;
                *pixels.offset(off0 as isize) =
                    (if *texture_data_mask.offset(n as isize) as Int == white as Int {
                        255i32
                    } else {
                        0i32
                    }) as u8;
                *pixels.offset(off1 as isize) =
                    (if *texture_data_mask.offset(n as isize) as Int == black as Int {
                        255i32
                    } else {
                        0i32
                    }) as u8;
                x += 1;
                n += 1
            }
            y += 1
        }
        return;
    };
}

unsafe fn nk_font_bake(
    mut baker: *mut FontBaker,
    mut image_memory: *mut Void,
    mut width: Int,
    mut height: Int,
    mut glyphs: *mut FontGlyph,
    mut glyphs_count: Int,
    mut config_list: *const FontConfig,
    mut font_count: Int,
) -> () {
    let mut input_i: Int = 0i32;
    let mut glyph_n: Rune = 0i32 as Rune;
    let mut config_iter: *const FontConfig = 0 as *const FontConfig;
    let mut it: *const FontConfig = 0 as *const FontConfig;
    if image_memory.is_null()
        || 0 == width
        || 0 == height
        || config_list.is_null()
        || 0 == font_count
        || glyphs.is_null()
        || 0 == glyphs_count
    {
        return;
    } else {
        /* second font pass: render glyphs */
        nk_zero(image_memory, (width as Size).wrapping_mul(height as Size));
        (*baker).spc.pixels = image_memory as *mut Uchar;
        (*baker).spc.height = height;
        input_i = 0i32;
        config_iter = config_list;
        while input_i < font_count && !config_iter.is_null() {
            it = config_iter;
            loop {
                let mut cfg: *const FontConfig = it;
                let fresh58 = input_i;
                input_i = input_i + 1;
                let mut tmp: *mut FontBackData =
                    &mut *(*baker).build.offset(fresh58 as isize) as *mut FontBackData;
                nk_tt_PackSetOversampling(
                    &mut (*baker).spc,
                    (*cfg).oversample_h as Uint,
                    (*cfg).oversample_v as Uint,
                );
                nk_tt_PackFontRangesRenderIntoRects(
                    &mut (*baker).spc,
                    &mut (*tmp).info,
                    (*tmp).ranges,
                    (*tmp).range_count as Int,
                    (*tmp).rects,
                    &mut (*baker).alloc,
                );
                it = (*it).n;
                if !(it != config_iter) {
                    break;
                }
            }
            config_iter = (*config_iter).next
        }
        nk_tt_PackEnd(&mut (*baker).spc, &mut (*baker).alloc);
        /* third pass: setup font and glyphs */
        input_i = 0i32;
        config_iter = config_list;
        while input_i < font_count && !config_iter.is_null() {
            it = config_iter;
            loop {
                let mut i: Size = 0i32 as Size;
                let mut char_idx: Int = 0i32;
                let mut glyph_count: Rune = 0i32 as Rune;
                let mut cfg_0: *const FontConfig = it;
                let fresh59 = input_i;
                input_i = input_i + 1;
                let mut tmp_0: *mut FontBackData =
                    &mut *(*baker).build.offset(fresh59 as isize) as *mut FontBackData;
                let mut dst_font: *mut BakedFont = (*cfg_0).font;
                let mut FontScale: f32 =
                    nk_tt_ScaleForPixelHeight(&mut (*tmp_0).info, (*cfg_0).size);
                let mut unscaled_ascent: Int = 0;
                let mut unscaled_descent: Int = 0;
                let mut unscaled_line_gap: Int = 0;
                nk_tt_GetFontVMetrics(
                    &mut (*tmp_0).info,
                    &mut unscaled_ascent,
                    &mut unscaled_descent,
                    &mut unscaled_line_gap,
                );
                /* fill baked font */
                if 0 == (*cfg_0).merge_mode {
                    (*dst_font).ranges = (*cfg_0).range;
                    (*dst_font).height = (*cfg_0).size;
                    (*dst_font).ascent = unscaled_ascent as f32 * FontScale;
                    (*dst_font).descent = unscaled_descent as f32 * FontScale;
                    (*dst_font).glyph_offset = glyph_n
                }
                /* fill own baked font glyph array */
                i = 0i32 as Size;
                while i < (*tmp_0).range_count as Ulong {
                    let mut range: *mut TtPackRange =
                        &mut *(*tmp_0).ranges.offset(i as isize) as *mut TtPackRange;
                    char_idx = 0i32;
                    while char_idx < (*range).num_chars {
                        let mut codepoint: Rune = 0i32 as Rune;
                        let mut dummy_x: f32 = 0i32 as f32;
                        let mut dummy_y: f32 = 0i32 as f32;
                        let mut q: TtAlignedQuad = TtAlignedQuad {
                            x0: 0.,
                            y0: 0.,
                            s0: 0.,
                            t0: 0.,
                            x1: 0.,
                            y1: 0.,
                            s1: 0.,
                            t1: 0.,
                        };
                        let mut glyph: *mut FontGlyph = 0 as *mut FontGlyph;
                        /* query glyph bounds from stb_truetype */
                        let mut pc: *const TtPackedChar =
                            &mut *(*range).chardata_for_range.offset(char_idx as isize)
                                as *mut TtPackedChar;
                        if !(0 == (*pc).x0 && 0 == (*pc).x1 && 0 == (*pc).y0 && 0 == (*pc).y1) {
                            codepoint =
                                ((*range).first_unicode_codepoint_in_range + char_idx) as Rune;
                            nk_tt_GetPackedQuad(
                                (*range).chardata_for_range,
                                width,
                                height,
                                char_idx,
                                &mut dummy_x,
                                &mut dummy_y,
                                &mut q,
                                0i32,
                            );
                            /* fill own glyph type with data */
                            glyph = &mut *glyphs.offset(
                                (*dst_font)
                                    .glyph_offset
                                    .wrapping_add((*dst_font).glyph_count)
                                    .wrapping_add(glyph_count)
                                    as isize,
                            ) as *mut FontGlyph;
                            (*glyph).codepoint = codepoint;
                            (*glyph).x0 = q.x0;
                            (*glyph).y0 = q.y0;
                            (*glyph).x1 = q.x1;
                            (*glyph).y1 = q.y1;
                            (*glyph).y0 += (*dst_font).ascent + 0.5f32;
                            (*glyph).y1 += (*dst_font).ascent + 0.5f32;
                            (*glyph).w = (*glyph).x1 - (*glyph).x0 + 0.5f32;
                            (*glyph).h = (*glyph).y1 - (*glyph).y0;
                            if (*cfg_0).coord_type as Uint == NK_COORD_PIXEL as Int as Uint {
                                (*glyph).u0 = q.s0 * width as f32;
                                (*glyph).v0 = q.t0 * height as f32;
                                (*glyph).u1 = q.s1 * width as f32;
                                (*glyph).v1 = q.t1 * height as f32
                            } else {
                                (*glyph).u0 = q.s0;
                                (*glyph).v0 = q.t0;
                                (*glyph).u1 = q.s1;
                                (*glyph).v1 = q.t1
                            }
                            (*glyph).xadvance = (*pc).xadvance + (*cfg_0).spacing.x;
                            if 0 != (*cfg_0).pixel_snap {
                                (*glyph).xadvance = ((*glyph).xadvance + 0.5f32) as Int as f32
                            }
                            glyph_count = glyph_count.wrapping_add(1)
                        }
                        char_idx += 1
                    }
                    i = i.wrapping_add(1)
                }
                (*dst_font).glyph_count =
                    ((*dst_font).glyph_count as Uint).wrapping_add(glyph_count) as Rune as Rune;
                glyph_n = (glyph_n as Uint).wrapping_add(glyph_count) as Rune as Rune;
                it = (*it).n;
                if !(it != config_iter) {
                    break;
                }
            }
            config_iter = (*config_iter).next
        }
        return;
    };
}
unsafe fn nk_tt_GetPackedQuad(
    mut chardata: *mut TtPackedChar,
    mut pw: Int,
    mut ph: Int,
    mut char_index: Int,
    mut xpos: *mut f32,
    mut ypos: *mut f32,
    mut q: *mut TtAlignedQuad,
    mut align_to_integer: Int,
) -> () {
    let mut x: f32 = 0.;
    let mut tx: Int = 0;
    let mut ty: Int = 0;
    let mut y: f32 = 0.;
    let mut ipw: f32 = 1.0f32 / pw as f32;
    let mut iph: f32 = 1.0f32 / ph as f32;
    let mut b: *mut TtPackedChar = chardata.offset(char_index as isize);
    if 0 != align_to_integer {
        tx = nk_ifloorf(*xpos + (*b).xoff + 0.5f32);
        ty = nk_ifloorf(*ypos + (*b).yoff + 0.5f32);
        x = tx as f32;
        y = ty as f32;
        (*q).x0 = x;
        (*q).y0 = y;
        (*q).x1 = x + (*b).xoff2 - (*b).xoff;
        (*q).y1 = y + (*b).yoff2 - (*b).yoff
    } else {
        (*q).x0 = *xpos + (*b).xoff;
        (*q).y0 = *ypos + (*b).yoff;
        (*q).x1 = *xpos + (*b).xoff2;
        (*q).y1 = *ypos + (*b).yoff2
    }
    (*q).s0 = (*b).x0 as Int as f32 * ipw;
    (*q).t0 = (*b).y0 as Int as f32 * iph;
    (*q).s1 = (*b).x1 as Int as f32 * ipw;
    (*q).t1 = (*b).y1 as Int as f32 * iph;
    *xpos += (*b).xadvance;
}
unsafe fn nk_tt_ScaleForPixelHeight(mut info: *const TtFontInfo, mut height: f32) -> f32 {
    let mut fheight: Int = nk_ttSHORT((*info).data.offset((*info).hhea as isize).offset(4isize))
        as Int
        - nk_ttSHORT((*info).data.offset((*info).hhea as isize).offset(6isize)) as Int;
    return height / fheight as f32;
}
unsafe fn nk_ttSHORT(mut p: *const u8) -> i16 {
    return (*p.offset(0isize) as Int * 256i32 + *p.offset(1isize) as Int) as i16;
}
unsafe fn nk_tt_GetFontVMetrics(
    mut info: *const TtFontInfo,
    mut ascent: *mut Int,
    mut descent: *mut Int,
    mut lineGap: *mut Int,
) -> () {
    if !ascent.is_null() {
        *ascent = nk_ttSHORT((*info).data.offset((*info).hhea as isize).offset(4isize)) as Int
    }
    if !descent.is_null() {
        *descent = nk_ttSHORT((*info).data.offset((*info).hhea as isize).offset(6isize)) as Int
    }
    if !lineGap.is_null() {
        *lineGap = nk_ttSHORT((*info).data.offset((*info).hhea as isize).offset(8isize)) as Int
    };
}
unsafe fn nk_tt_PackEnd(mut spc: *mut TtPackContext, mut alloc: *mut Allocator) -> () {
    (*alloc).free.expect("non-null function pointer")((*alloc).userdata, (*spc).nodes);
    (*alloc).free.expect("non-null function pointer")((*alloc).userdata, (*spc).pack_info);
}
unsafe fn nk_tt_PackFontRangesRenderIntoRects(
    mut spc: *mut TtPackContext,
    mut info: *mut TtFontInfo,
    mut ranges: *mut TtPackRange,
    mut num_ranges: Int,
    mut rects: *mut RpRect,
    mut alloc: *mut Allocator,
) -> Int {
    let mut i: Int = 0;
    let mut j: Int = 0;
    let mut k: Int = 0;
    let mut return_value: Int = 1i32;
    /* save current values */
    let mut old_h_over: Int = (*spc).h_oversample as Int;
    let mut old_v_over: Int = (*spc).v_oversample as Int;
    /* rects array must be big enough to accommodate all characters in the given ranges */
    k = 0i32;
    i = 0i32;
    while i < num_ranges {
        let mut fh: f32 = (*ranges.offset(i as isize)).font_size;
        let mut recip_h: f32 = 0.;
        let mut recip_v: f32 = 0.;
        let mut sub_x: f32 = 0.;
        let mut sub_y: f32 = 0.;
        let mut scale: f32 = if fh > 0i32 as f32 {
            nk_tt_ScaleForPixelHeight(info, fh)
        } else {
            nk_tt_ScaleForMappingEmToPixels(info, -fh)
        };
        (*spc).h_oversample = (*ranges.offset(i as isize)).h_oversample as Uint;
        (*spc).v_oversample = (*ranges.offset(i as isize)).v_oversample as Uint;
        recip_h = 1.0f32 / (*spc).h_oversample as f32;
        recip_v = 1.0f32 / (*spc).v_oversample as f32;
        sub_x = nk_tt__oversample_shift((*spc).h_oversample as Int);
        sub_y = nk_tt__oversample_shift((*spc).v_oversample as Int);
        j = 0i32;
        while j < (*ranges.offset(i as isize)).num_chars {
            let mut r: *mut RpRect = &mut *rects.offset(k as isize) as *mut RpRect;
            if 0 != (*r).was_packed {
                let mut bc: *mut TtPackedChar = &mut *(*ranges.offset(i as isize))
                    .chardata_for_range
                    .offset(j as isize)
                    as *mut TtPackedChar;
                let mut advance: Int = 0;
                let mut lsb: Int = 0;
                let mut x0: Int = 0;
                let mut y0: Int = 0;
                let mut x1: Int = 0;
                let mut y1: Int = 0;
                let mut codepoint: Int =
                    if 0 != (*ranges.offset(i as isize)).first_unicode_codepoint_in_range {
                        (*ranges.offset(i as isize)).first_unicode_codepoint_in_range + j
                    } else {
                        *(*ranges.offset(i as isize))
                            .array_of_unicode_codepoints
                            .offset(j as isize)
                    };
                let mut glyph: Int = nk_tt_FindGlyphIndex(info, codepoint);
                let mut pad: RpCoord = (*spc).padding as RpCoord;
                /* pad on left and top */
                (*r).x = ((*r).x as Int + pad as Int) as RpCoord;
                (*r).y = ((*r).y as Int + pad as Int) as RpCoord;
                (*r).w = ((*r).w as Int - pad as Int) as RpCoord;
                (*r).h = ((*r).h as Int - pad as Int) as RpCoord;
                nk_tt_GetGlyphHMetrics(info, glyph, &mut advance, &mut lsb);
                nk_tt_GetGlyphBitmapBox(
                    info,
                    glyph,
                    scale * (*spc).h_oversample as f32,
                    scale * (*spc).v_oversample as f32,
                    &mut x0,
                    &mut y0,
                    &mut x1,
                    &mut y1,
                );
                nk_tt_MakeGlyphBitmapSubpixel(
                    info,
                    (*spc)
                        .pixels
                        .offset((*r).x as Int as isize)
                        .offset(((*r).y as Int * (*spc).stride_in_bytes) as isize),
                    ((*r).w as Uint)
                        .wrapping_sub((*spc).h_oversample)
                        .wrapping_add(1i32 as Uint) as Int,
                    ((*r).h as Uint)
                        .wrapping_sub((*spc).v_oversample)
                        .wrapping_add(1i32 as Uint) as Int,
                    (*spc).stride_in_bytes,
                    scale * (*spc).h_oversample as f32,
                    scale * (*spc).v_oversample as f32,
                    0i32 as f32,
                    0i32 as f32,
                    glyph,
                    alloc,
                );
                if (*spc).h_oversample > 1i32 as Uint {
                    nk_tt__h_prefilter(
                        (*spc)
                            .pixels
                            .offset((*r).x as Int as isize)
                            .offset(((*r).y as Int * (*spc).stride_in_bytes) as isize),
                        (*r).w as Int,
                        (*r).h as Int,
                        (*spc).stride_in_bytes,
                        (*spc).h_oversample as Int,
                    );
                }
                if (*spc).v_oversample > 1i32 as Uint {
                    nk_tt__v_prefilter(
                        (*spc)
                            .pixels
                            .offset((*r).x as Int as isize)
                            .offset(((*r).y as Int * (*spc).stride_in_bytes) as isize),
                        (*r).w as Int,
                        (*r).h as Int,
                        (*spc).stride_in_bytes,
                        (*spc).v_oversample as Int,
                    );
                }
                (*bc).x0 = (*r).x;
                (*bc).y0 = (*r).y;
                (*bc).x1 = ((*r).x as Int + (*r).w as Int) as u16;
                (*bc).y1 = ((*r).y as Int + (*r).h as Int) as u16;
                (*bc).xadvance = scale * advance as f32;
                (*bc).xoff = x0 as f32 * recip_h + sub_x;
                (*bc).yoff = y0 as f32 * recip_v + sub_y;
                (*bc).xoff2 = (x0 as f32 + (*r).w as Int as f32) * recip_h + sub_x;
                (*bc).yoff2 = (y0 as f32 + (*r).h as Int as f32) * recip_v + sub_y
            } else {
                return_value = 0i32
            }
            k += 1;
            j += 1
        }
        i += 1
    }
    /* restore original values */
    (*spc).h_oversample = old_h_over as Uint;
    (*spc).v_oversample = old_v_over as Uint;
    return return_value;
}

unsafe fn nk_tt_ScaleForMappingEmToPixels(mut info: *const TtFontInfo, mut pixels: f32) -> f32 {
    let mut unitsPerEm: Int =
        nk_ttUSHORT((*info).data.offset((*info).head as isize).offset(18isize)) as Int;
    return pixels / unitsPerEm as f32;
}

unsafe fn nk_ttUSHORT(mut p: *const u8) -> u16 {
    return (*p.offset(0isize) as Int * 256i32 + *p.offset(1isize) as Int) as u16;
}

unsafe fn nk_tt__v_prefilter(
    mut pixels: *mut Uchar,
    mut w: Int,
    mut h: Int,
    mut stride_in_bytes: Int,
    mut kernel_width: Int,
) -> () {
    let mut buffer: [Uchar; 8] = [0; 8];
    let mut safe_h: Int = h - kernel_width;
    let mut j: Int = 0;
    j = 0i32;
    while j < w {
        let mut i: Int = 0;
        let mut total: Uint = 0;
        nk_memset(buffer.as_mut_ptr() as *mut Void, 0i32, kernel_width as Size);
        total = 0i32 as Uint;
        /* make kernel_width a constant in common cases so compiler can optimize out the divide */
        match kernel_width {
            2 => {
                i = 0i32;
                while i <= safe_h {
                    total = total.wrapping_add(
                        (*pixels.offset((i * stride_in_bytes) as isize) as Int
                            - buffer[(i & 8i32 - 1i32) as usize] as Int)
                            as Uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] =
                        *pixels.offset((i * stride_in_bytes) as isize);
                    *pixels.offset((i * stride_in_bytes) as isize) =
                        total.wrapping_div(2i32 as Uint) as Uchar;
                    i += 1
                }
            }
            3 => {
                i = 0i32;
                while i <= safe_h {
                    total = total.wrapping_add(
                        (*pixels.offset((i * stride_in_bytes) as isize) as Int
                            - buffer[(i & 8i32 - 1i32) as usize] as Int)
                            as Uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] =
                        *pixels.offset((i * stride_in_bytes) as isize);
                    *pixels.offset((i * stride_in_bytes) as isize) =
                        total.wrapping_div(3i32 as Uint) as Uchar;
                    i += 1
                }
            }
            4 => {
                i = 0i32;
                while i <= safe_h {
                    total = total.wrapping_add(
                        (*pixels.offset((i * stride_in_bytes) as isize) as Int
                            - buffer[(i & 8i32 - 1i32) as usize] as Int)
                            as Uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] =
                        *pixels.offset((i * stride_in_bytes) as isize);
                    *pixels.offset((i * stride_in_bytes) as isize) =
                        total.wrapping_div(4i32 as Uint) as Uchar;
                    i += 1
                }
            }
            5 => {
                i = 0i32;
                while i <= safe_h {
                    total = total.wrapping_add(
                        (*pixels.offset((i * stride_in_bytes) as isize) as Int
                            - buffer[(i & 8i32 - 1i32) as usize] as Int)
                            as Uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] =
                        *pixels.offset((i * stride_in_bytes) as isize);
                    *pixels.offset((i * stride_in_bytes) as isize) =
                        total.wrapping_div(5i32 as Uint) as Uchar;
                    i += 1
                }
            }
            _ => {
                i = 0i32;
                while i <= safe_h {
                    total = total.wrapping_add(
                        (*pixels.offset((i * stride_in_bytes) as isize) as Int
                            - buffer[(i & 8i32 - 1i32) as usize] as Int)
                            as Uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] =
                        *pixels.offset((i * stride_in_bytes) as isize);
                    *pixels.offset((i * stride_in_bytes) as isize) =
                        total.wrapping_div(kernel_width as Uint) as Uchar;
                    i += 1
                }
            }
        }
        while i < h {
            total = total.wrapping_sub(buffer[(i & 8i32 - 1i32) as usize] as Uint);
            *pixels.offset((i * stride_in_bytes) as isize) =
                total.wrapping_div(kernel_width as Uint) as Uchar;
            i += 1
        }
        pixels = pixels.offset(1isize);
        j += 1
    }
}

unsafe fn nk_tt__h_prefilter(
    mut pixels: *mut Uchar,
    mut w: Int,
    mut h: Int,
    mut stride_in_bytes: Int,
    mut kernel_width: Int,
) -> () {
    let mut buffer: [Uchar; 8] = [0; 8];
    let mut safe_w: Int = w - kernel_width;
    let mut j: Int = 0;
    j = 0i32;
    while j < h {
        let mut i: Int = 0;
        let mut total: Uint = 0;
        nk_memset(buffer.as_mut_ptr() as *mut Void, 0i32, kernel_width as Size);
        total = 0i32 as Uint;
        /* make kernel_width a constant in common cases so compiler can optimize out the divide */
        match kernel_width {
            2 => {
                i = 0i32;
                while i <= safe_w {
                    total = total.wrapping_add(
                        (*pixels.offset(i as isize) as Int
                            - buffer[(i & 8i32 - 1i32) as usize] as Int)
                            as Uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] = *pixels.offset(i as isize);
                    *pixels.offset(i as isize) = total.wrapping_div(2i32 as Uint) as Uchar;
                    i += 1
                }
            }
            3 => {
                i = 0i32;
                while i <= safe_w {
                    total = total.wrapping_add(
                        (*pixels.offset(i as isize) as Int
                            - buffer[(i & 8i32 - 1i32) as usize] as Int)
                            as Uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] = *pixels.offset(i as isize);
                    *pixels.offset(i as isize) = total.wrapping_div(3i32 as Uint) as Uchar;
                    i += 1
                }
            }
            4 => {
                i = 0i32;
                while i <= safe_w {
                    total = total.wrapping_add(
                        (*pixels.offset(i as isize) as Uint)
                            .wrapping_sub(buffer[(i & 8i32 - 1i32) as usize] as Uint),
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] = *pixels.offset(i as isize);
                    *pixels.offset(i as isize) = total.wrapping_div(4i32 as Uint) as Uchar;
                    i += 1
                }
            }
            5 => {
                i = 0i32;
                while i <= safe_w {
                    total = total.wrapping_add(
                        (*pixels.offset(i as isize) as Int
                            - buffer[(i & 8i32 - 1i32) as usize] as Int)
                            as Uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] = *pixels.offset(i as isize);
                    *pixels.offset(i as isize) = total.wrapping_div(5i32 as Uint) as Uchar;
                    i += 1
                }
            }
            _ => {
                i = 0i32;
                while i <= safe_w {
                    total = total.wrapping_add(
                        (*pixels.offset(i as isize) as Int
                            - buffer[(i & 8i32 - 1i32) as usize] as Int)
                            as Uint,
                    );
                    buffer[(i + kernel_width & 8i32 - 1i32) as usize] = *pixels.offset(i as isize);
                    *pixels.offset(i as isize) = total.wrapping_div(kernel_width as Uint) as Uchar;
                    i += 1
                }
            }
        }
        while i < w {
            total = total.wrapping_sub(buffer[(i & 8i32 - 1i32) as usize] as Uint);
            *pixels.offset(i as isize) = total.wrapping_div(kernel_width as Uint) as Uchar;
            i += 1
        }
        pixels = pixels.offset(stride_in_bytes as isize);
        j += 1
    }
}

unsafe fn nk_tt_FindGlyphIndex(mut info: *const TtFontInfo, mut unicode_codepoint: Int) -> Int {
    let mut data: *const u8 = (*info).data;
    let mut index_map: u32 = (*info).index_map as u32;
    let mut format: u16 = nk_ttUSHORT(data.offset(index_map as isize).offset(0isize));
    if format as Int == 0i32 {
        /* apple byte encoding */
        let mut bytes: i32 = nk_ttUSHORT(data.offset(index_map as isize).offset(2isize)) as i32;
        if unicode_codepoint < bytes - 6i32 {
            return *data
                .offset(index_map as isize)
                .offset(6isize)
                .offset(unicode_codepoint as isize) as Int;
        } else {
            return 0i32;
        }
    } else if format as Int == 6i32 {
        let mut first: u32 = nk_ttUSHORT(data.offset(index_map as isize).offset(6isize)) as u32;
        let mut count: u32 = nk_ttUSHORT(data.offset(index_map as isize).offset(8isize)) as u32;
        if unicode_codepoint as u32 >= first
            && (unicode_codepoint as u32) < first.wrapping_add(count)
        {
            return nk_ttUSHORT(
                data.offset(index_map as isize)
                    .offset(10isize)
                    .offset(((unicode_codepoint - first as Int) * 2i32) as isize),
            ) as Int;
        } else {
            return 0i32;
        }
    } else if format as Int == 2i32 {
        /* @TODO: high-byte mapping for japanese/chinese/korean */
        return 0i32;
    } else if format as Int == 4i32 {
        /* standard mapping for windows fonts: binary search collection of ranges */
        let mut segcount: u16 =
            (nk_ttUSHORT(data.offset(index_map as isize).offset(6isize)) as Int >> 1i32) as u16;
        let mut searchRange: u16 =
            (nk_ttUSHORT(data.offset(index_map as isize).offset(8isize)) as Int >> 1i32) as u16;
        let mut entrySelector: u16 = nk_ttUSHORT(data.offset(index_map as isize).offset(10isize));
        let mut rangeShift: u16 =
            (nk_ttUSHORT(data.offset(index_map as isize).offset(12isize)) as Int >> 1i32) as u16;
        /* do a binary search of the segments */
        let mut endCount: u32 = index_map.wrapping_add(14i32 as Uint);
        let mut search: u32 = endCount;
        if unicode_codepoint > 65535i32 {
            return 0i32;
        } else {
            /* they lie from endCount .. endCount + segCount */
            /* but searchRange is the nearest power of two, so... */
            if unicode_codepoint
                >= nk_ttUSHORT(
                    data.offset(search as isize)
                        .offset((rangeShift as Int * 2i32) as isize),
                ) as Int
            {
                search =
                    (search as Uint).wrapping_add((rangeShift as Int * 2i32) as u32) as u32 as u32
            }
            /* now decrement to bias correctly to find smallest */
            search = (search as Uint).wrapping_sub(2i32 as Uint) as u32 as u32;
            while 0 != entrySelector {
                let mut end: u16 = 0;
                searchRange = (searchRange as Int >> 1i32) as u16;
                end = nk_ttUSHORT(
                    data.offset(search as isize)
                        .offset((searchRange as Int * 2i32) as isize),
                );
                if unicode_codepoint > end as Int {
                    search = (search as Uint).wrapping_add((searchRange as Int * 2i32) as u32)
                        as u32 as u32
                }
                entrySelector = entrySelector.wrapping_sub(1)
            }
            search = (search as Uint).wrapping_add(2i32 as Uint) as u32 as u32;
            let mut offset: u16 = 0;
            let mut start: u16 = 0;
            let mut item: u16 = (search.wrapping_sub(endCount) >> 1i32) as u16;
            start = nk_ttUSHORT(
                data.offset(index_map as isize)
                    .offset(14isize)
                    .offset((segcount as Int * 2i32) as isize)
                    .offset(2isize)
                    .offset((2i32 * item as Int) as isize),
            );
            if unicode_codepoint < start as Int {
                return 0i32;
            } else {
                offset = nk_ttUSHORT(
                    data.offset(index_map as isize)
                        .offset(14isize)
                        .offset((segcount as Int * 6i32) as isize)
                        .offset(2isize)
                        .offset((2i32 * item as Int) as isize),
                );
                if offset as Int == 0i32 {
                    return (unicode_codepoint
                        + nk_ttSHORT(
                            data.offset(index_map as isize)
                                .offset(14isize)
                                .offset((segcount as Int * 4i32) as isize)
                                .offset(2isize)
                                .offset((2i32 * item as Int) as isize),
                        ) as Int) as u16 as Int;
                } else {
                    return nk_ttUSHORT(
                        data.offset(offset as Int as isize)
                            .offset(((unicode_codepoint - start as Int) * 2i32) as isize)
                            .offset(index_map as isize)
                            .offset(14isize)
                            .offset((segcount as Int * 6i32) as isize)
                            .offset(2isize)
                            .offset((2i32 * item as Int) as isize),
                    ) as Int;
                }
            }
        }
    } else if format as Int == 12i32 || format as Int == 13i32 {
        let mut ngroups: u32 = nk_ttULONG(data.offset(index_map as isize).offset(12isize));
        let mut low: i32 = 0;
        let mut high: i32 = 0;
        low = 0i32;
        high = ngroups as i32;
        /* Binary search the right group. */
        while low < high {
            /* rounds down, so low <= mid < high */
            let mut mid: i32 = low + (high - low >> 1i32);
            let mut start_char: u32 = nk_ttULONG(
                data.offset(index_map as isize)
                    .offset(16isize)
                    .offset((mid * 12i32) as isize),
            );
            let mut end_char: u32 = nk_ttULONG(
                data.offset(index_map as isize)
                    .offset(16isize)
                    .offset((mid * 12i32) as isize)
                    .offset(4isize),
            );
            if (unicode_codepoint as u32) < start_char {
                high = mid
            } else if unicode_codepoint as u32 > end_char {
                low = mid + 1i32
            } else {
                let mut start_glyph: u32 = nk_ttULONG(
                    data.offset(index_map as isize)
                        .offset(16isize)
                        .offset((mid * 12i32) as isize)
                        .offset(8isize),
                );
                if format as Int == 12i32 {
                    return start_glyph as Int + unicode_codepoint - start_char as Int;
                } else {
                    return start_glyph as Int;
                }
            }
        }
        /* not found */
        return 0i32;
    } else {
        return 0i32;
    };
}

unsafe fn nk_ttULONG(mut p: *const u8) -> u32 {
    return (((*p.offset(0isize) as Int) << 24i32)
        + ((*p.offset(1isize) as Int) << 16i32)
        + ((*p.offset(2isize) as Int) << 8i32)
        + *p.offset(3isize) as Int) as u32;
}

unsafe fn nk_tt_MakeGlyphBitmapSubpixel(
    mut info: *const TtFontInfo,
    mut output: *mut Uchar,
    mut out_w: Int,
    mut out_h: Int,
    mut out_stride: Int,
    mut scale_x: f32,
    mut scale_y: f32,
    mut shift_x: f32,
    mut shift_y: f32,
    mut glyph: Int,
    mut alloc: *mut Allocator,
) -> () {
    let mut ix0: Int = 0;
    let mut iy0: Int = 0;
    let mut vertices: *mut TtVertex = 0 as *mut TtVertex;
    let mut num_verts: Int = nk_tt_GetGlyphShape(info, alloc, glyph, &mut vertices);
    let mut gbm: TtBitmap = TtBitmap {
        w: 0,
        h: 0,
        stride: 0,
        pixels: 0 as *mut Uchar,
    };
    nk_tt_GetGlyphBitmapBoxSubpixel(
        info,
        glyph,
        scale_x,
        scale_y,
        shift_x,
        shift_y,
        &mut ix0,
        &mut iy0,
        0 as *mut Int,
        0 as *mut Int,
    );
    gbm.pixels = output;
    gbm.w = out_w;
    gbm.h = out_h;
    gbm.stride = out_stride;
    if 0 != gbm.w && 0 != gbm.h {
        nk_tt_Rasterize(
            &mut gbm,
            0.3499999940395355f32,
            vertices,
            num_verts,
            scale_x,
            scale_y,
            shift_x,
            shift_y,
            ix0,
            iy0,
            1i32,
            alloc,
        );
    }
    (*alloc).free.expect("non-null function pointer")((*alloc).userdata, vertices as *mut Void);
}

unsafe fn nk_tt_GetGlyphShape(
    mut info: *const TtFontInfo,
    mut alloc: *mut Allocator,
    mut glyph_index: Int,
    mut pvertices: *mut *mut TtVertex,
) -> Int {
    let mut dx: i16 = 0;
    let mut dy: i16 = 0;
    let mut numberOfContours: i16 = 0;
    let mut endPtsOfContours: *const u8 = 0 as *const u8;
    let mut data: *const u8 = (*info).data;
    let mut vertices: *mut TtVertex = 0 as *mut TtVertex;
    let mut num_vertices: Int = 0i32;
    let mut g: Int = nk_tt__GetGlyfOffset(info, glyph_index);
    *pvertices = 0 as *mut TtVertex;
    if g < 0i32 {
        return 0i32;
    } else {
        numberOfContours = nk_ttSHORT(data.offset(g as isize));
        if numberOfContours as Int > 0i32 {
            let mut flags: u8 = 0i32 as u8;
            let mut flagcount: u8 = 0;
            let mut ins: i32 = 0;
            let mut i: i32 = 0;
            let mut j: i32 = 0i32;
            let mut m: i32 = 0;
            let mut n: i32 = 0;
            let mut next_move: i32 = 0;
            let mut was_off: i32 = 0i32;
            let mut off: i32 = 0;
            let mut start_off: i32 = 0i32;
            let mut x: i32 = 0;
            let mut y: i32 = 0;
            let mut cx: i32 = 0;
            let mut cy: i32 = 0;
            let mut sx: i32 = 0;
            let mut sy: i32 = 0;
            let mut scx: i32 = 0;
            let mut scy: i32 = 0;
            let mut points: *const u8 = 0 as *const u8;
            endPtsOfContours = data.offset(g as isize).offset(10isize);
            ins = nk_ttUSHORT(
                data.offset(g as isize)
                    .offset(10isize)
                    .offset((numberOfContours as Int * 2i32) as isize),
            ) as i32;
            points = data
                .offset(g as isize)
                .offset(10isize)
                .offset((numberOfContours as Int * 2i32) as isize)
                .offset(2isize)
                .offset(ins as isize);
            n = 1i32 + nk_ttUSHORT(
                endPtsOfContours
                    .offset((numberOfContours as Int * 2i32) as isize)
                    .offset(-2isize),
            ) as Int;
            /* a loose bound on how many vertices we might need */
            m = n + 2i32 * numberOfContours as Int;
            vertices = (*alloc).alloc.expect("non-null function pointer")(
                (*alloc).userdata,
                0 as *mut Void,
                (m as Size).wrapping_mul(mem::size_of::<TtVertex>() as Ulong),
            ) as *mut TtVertex;
            if vertices.is_null() {
                return 0i32;
            } else {
                next_move = 0i32;
                flagcount = 0i32 as u8;
                /* in first pass, we load uninterpreted data into the allocated array */
                /* above, shifted to the end of the array so we won't overwrite it when */
                /* we create our final data starting from the front */
                /* starting offset for uninterpreted data, regardless of how m ends up being calculated */
                off = m - n;
                /* first load flags */
                i = 0i32;
                while i < n {
                    if flagcount as Int == 0i32 {
                        let fresh60 = points;
                        points = points.offset(1);
                        flags = *fresh60;
                        if 0 != flags as Int & 8i32 {
                            let fresh61 = points;
                            points = points.offset(1);
                            flagcount = *fresh61
                        }
                    } else {
                        flagcount = flagcount.wrapping_sub(1)
                    }
                    (*vertices.offset((off + i) as isize)).type_0 = flags;
                    i += 1
                }
                /* now load x coordinates */
                x = 0i32;
                i = 0i32;
                while i < n {
                    flags = (*vertices.offset((off + i) as isize)).type_0;
                    if 0 != flags as Int & 2i32 {
                        let fresh62 = points;
                        points = points.offset(1);
                        dx = *fresh62 as i16;
                        /* ??? */
                        x += if 0 != flags as Int & 16i32 {
                            dx as Int
                        } else {
                            -(dx as Int)
                        }
                    } else if 0 == flags as Int & 16i32 {
                        x = x + (*points.offset(0isize) as Int * 256i32
                            + *points.offset(1isize) as Int) as i16
                            as Int;
                        points = points.offset(2isize)
                    }
                    (*vertices.offset((off + i) as isize)).x = x as i16;
                    i += 1
                }
                /* now load y coordinates */
                y = 0i32;
                i = 0i32;
                while i < n {
                    flags = (*vertices.offset((off + i) as isize)).type_0;
                    if 0 != flags as Int & 4i32 {
                        let fresh63 = points;
                        points = points.offset(1);
                        dy = *fresh63 as i16;
                        /* ??? */
                        y += if 0 != flags as Int & 32i32 {
                            dy as Int
                        } else {
                            -(dy as Int)
                        }
                    } else if 0 == flags as Int & 32i32 {
                        y = y + (*points.offset(0isize) as Int * 256i32
                            + *points.offset(1isize) as Int) as i16
                            as Int;
                        points = points.offset(2isize)
                    }
                    (*vertices.offset((off + i) as isize)).y = y as i16;
                    i += 1
                }
                /* now convert them to our format */
                num_vertices = 0i32;
                scy = 0i32;
                scx = scy;
                cy = scx;
                cx = cy;
                sy = cx;
                sx = sy;
                i = 0i32;
                while i < n {
                    flags = (*vertices.offset((off + i) as isize)).type_0;
                    x = (*vertices.offset((off + i) as isize)).x as i32;
                    y = (*vertices.offset((off + i) as isize)).y as i32;
                    if next_move == i {
                        if i != 0i32 {
                            num_vertices = nk_tt__close_shape(
                                vertices,
                                num_vertices,
                                was_off,
                                start_off,
                                sx,
                                sy,
                                scx,
                                scy,
                                cx,
                                cy,
                            )
                        }
                        /* now start the new one                */
                        start_off = (0 == flags as Int & 1i32) as Int;
                        if 0 != start_off {
                            /* if we start off with an off-curve point, then when we need to find a point on the curve */
                            /* where we can start, and we need to save some state for when we wraparound. */
                            scx = x;
                            scy = y;
                            if 0 == (*vertices.offset((off + i + 1i32) as isize)).type_0 as Int
                                & 1i32
                            {
                                /* next point is also a curve point, so interpolate an on-point curve */
                                sx = x + (*vertices.offset((off + i + 1i32) as isize)).x as i32
                                    >> 1i32;
                                sy = y + (*vertices.offset((off + i + 1i32) as isize)).y as i32
                                    >> 1i32
                            } else {
                                /* otherwise just use the next point as our start point */
                                sx = (*vertices.offset((off + i + 1i32) as isize)).x as i32;
                                sy = (*vertices.offset((off + i + 1i32) as isize)).y as i32;
                                /* we're using point i+1 as the starting point, so skip it */
                                i += 1
                            }
                        } else {
                            sx = x;
                            sy = y
                        }
                        let fresh64 = num_vertices;
                        num_vertices = num_vertices + 1;
                        nk_tt_setvertex(
                            &mut *vertices.offset(fresh64 as isize),
                            NK_TT_vmove as Int as u8,
                            sx,
                            sy,
                            0i32,
                            0i32,
                        );
                        was_off = 0i32;
                        next_move =
                            1i32 + nk_ttUSHORT(endPtsOfContours.offset((j * 2i32) as isize)) as Int;
                        j += 1
                    } else if 0 == flags as Int & 1i32 {
                        /* if it's a curve */
                        /* two off-curve control points in a row means interpolate an on-curve midpoint */
                        if 0 != was_off {
                            let fresh65 = num_vertices;
                            num_vertices = num_vertices + 1;
                            nk_tt_setvertex(
                                &mut *vertices.offset(fresh65 as isize),
                                NK_TT_vcurve as Int as u8,
                                cx + x >> 1i32,
                                cy + y >> 1i32,
                                cx,
                                cy,
                            );
                        }
                        cx = x;
                        cy = y;
                        was_off = 1i32
                    } else {
                        if 0 != was_off {
                            let fresh66 = num_vertices;
                            num_vertices = num_vertices + 1;
                            nk_tt_setvertex(
                                &mut *vertices.offset(fresh66 as isize),
                                NK_TT_vcurve as Int as u8,
                                x,
                                y,
                                cx,
                                cy,
                            );
                        } else {
                            let fresh67 = num_vertices;
                            num_vertices = num_vertices + 1;
                            nk_tt_setvertex(
                                &mut *vertices.offset(fresh67 as isize),
                                NK_TT_vline as Int as u8,
                                x,
                                y,
                                0i32,
                                0i32,
                            );
                        }
                        was_off = 0i32
                    }
                    i += 1
                }
                num_vertices = nk_tt__close_shape(
                    vertices,
                    num_vertices,
                    was_off,
                    start_off,
                    sx,
                    sy,
                    scx,
                    scy,
                    cx,
                    cy,
                )
            }
        } else if numberOfContours as Int == -1i32 {
            /* Compound shapes. */
            let mut more: Int = 1i32;
            let mut comp: *const u8 = data.offset(g as isize).offset(10isize);
            num_vertices = 0i32;
            vertices = 0 as *mut TtVertex;
            while 0 != more {
                let mut flags_0: u16 = 0;
                let mut gidx: u16 = 0;
                let mut comp_num_verts: Int = 0i32;
                let mut i_0: Int = 0;
                let mut comp_verts: *mut TtVertex = 0 as *mut TtVertex;
                let mut tmp: *mut TtVertex = 0 as *mut TtVertex;
                let mut mtx: [f32; 6] = [
                    1i32 as f32,
                    0i32 as f32,
                    0i32 as f32,
                    1i32 as f32,
                    0i32 as f32,
                    0i32 as f32,
                ];
                let mut m_0: f32 = 0.;
                let mut n_0: f32 = 0.;
                flags_0 = nk_ttSHORT(comp) as u16;
                comp = comp.offset(2isize);
                gidx = nk_ttSHORT(comp) as u16;
                comp = comp.offset(2isize);
                if 0 != flags_0 as Int & 2i32 {
                    /* XY values */
                    if 0 != flags_0 as Int & 1i32 {
                        /* shorts */
                        mtx[4usize] = nk_ttSHORT(comp) as f32;
                        comp = comp.offset(2isize);
                        mtx[5usize] = nk_ttSHORT(comp) as f32;
                        comp = comp.offset(2isize)
                    } else {
                        mtx[4usize] = *(comp as *const Char) as f32;
                        comp = comp.offset(1isize);
                        mtx[5usize] = *(comp as *const Char) as f32;
                        comp = comp.offset(1isize)
                    }
                }
                /* @TODO handle matching point */
                if 0 != flags_0 as Int & 1i32 << 3i32 {
                    /* WE_HAVE_A_SCALE */
                    mtx[3usize] = nk_ttSHORT(comp) as Int as f32 / 16384.0f32;
                    mtx[0usize] = mtx[3usize];
                    comp = comp.offset(2isize);
                    mtx[2usize] = 0i32 as f32;
                    mtx[1usize] = mtx[2usize]
                } else if 0 != flags_0 as Int & 1i32 << 6i32 {
                    /* WE_HAVE_AN_X_AND_YSCALE */
                    mtx[0usize] = nk_ttSHORT(comp) as Int as f32 / 16384.0f32;
                    comp = comp.offset(2isize);
                    mtx[2usize] = 0i32 as f32;
                    mtx[1usize] = mtx[2usize];
                    mtx[3usize] = nk_ttSHORT(comp) as Int as f32 / 16384.0f32;
                    comp = comp.offset(2isize)
                } else if 0 != flags_0 as Int & 1i32 << 7i32 {
                    /* WE_HAVE_A_TWO_BY_TWO */
                    mtx[0usize] = nk_ttSHORT(comp) as Int as f32 / 16384.0f32;
                    comp = comp.offset(2isize);
                    mtx[1usize] = nk_ttSHORT(comp) as Int as f32 / 16384.0f32;
                    comp = comp.offset(2isize);
                    mtx[2usize] = nk_ttSHORT(comp) as Int as f32 / 16384.0f32;
                    comp = comp.offset(2isize);
                    mtx[3usize] = nk_ttSHORT(comp) as Int as f32 / 16384.0f32;
                    comp = comp.offset(2isize)
                }
                /* Find transformation scales. */
                m_0 = nk_sqrt(mtx[0usize] * mtx[0usize] + mtx[1usize] * mtx[1usize]);
                n_0 = nk_sqrt(mtx[2usize] * mtx[2usize] + mtx[3usize] * mtx[3usize]);
                /* Get indexed glyph. */
                comp_num_verts = nk_tt_GetGlyphShape(info, alloc, gidx as Int, &mut comp_verts);
                if comp_num_verts > 0i32 {
                    /* Transform vertices. */
                    i_0 = 0i32;
                    while i_0 < comp_num_verts {
                        let mut v: *mut TtVertex =
                            &mut *comp_verts.offset(i_0 as isize) as *mut TtVertex;
                        let mut x_0: Short = 0;
                        let mut y_0: Short = 0;
                        x_0 = (*v).x;
                        y_0 = (*v).y;
                        (*v).x = (m_0 * (mtx[0usize] * x_0 as Int as f32
                            + mtx[2usize] * y_0 as Int as f32
                            + mtx[4usize])) as Short;
                        (*v).y = (n_0 * (mtx[1usize] * x_0 as Int as f32
                            + mtx[3usize] * y_0 as Int as f32
                            + mtx[5usize])) as Short;
                        x_0 = (*v).cx;
                        y_0 = (*v).cy;
                        (*v).cx = (m_0 * (mtx[0usize] * x_0 as Int as f32
                            + mtx[2usize] * y_0 as Int as f32
                            + mtx[4usize])) as Short;
                        (*v).cy = (n_0 * (mtx[1usize] * x_0 as Int as f32
                            + mtx[3usize] * y_0 as Int as f32
                            + mtx[5usize])) as Short;
                        i_0 += 1
                    }
                    /* Append vertices. */
                    tmp = (*alloc).alloc.expect("non-null function pointer")(
                        (*alloc).userdata,
                        0 as *mut Void,
                        ((num_vertices + comp_num_verts) as Size).wrapping_mul(mem::size_of::<
                            TtVertex,
                        >(
                        )
                            as Ulong),
                    ) as *mut TtVertex;
                    if tmp.is_null() {
                        if !vertices.is_null() {
                            (*alloc).free.expect("non-null function pointer")(
                                (*alloc).userdata,
                                vertices as *mut Void,
                            );
                        }
                        if !comp_verts.is_null() {
                            (*alloc).free.expect("non-null function pointer")(
                                (*alloc).userdata,
                                comp_verts as *mut Void,
                            );
                        }
                        return 0i32;
                    } else {
                        if num_vertices > 0i32 {
                            nk_memcopy(
                                tmp as *mut Void,
                                vertices as *const Void,
                                (num_vertices as Size)
                                    .wrapping_mul(mem::size_of::<TtVertex>() as Ulong),
                            );
                        }
                        nk_memcopy(
                            tmp.offset(num_vertices as isize) as *mut Void,
                            comp_verts as *const Void,
                            (comp_num_verts as Size)
                                .wrapping_mul(mem::size_of::<TtVertex>() as Ulong),
                        );
                        if !vertices.is_null() {
                            (*alloc).free.expect("non-null function pointer")(
                                (*alloc).userdata,
                                vertices as *mut Void,
                            );
                        }
                        vertices = tmp;
                        (*alloc).free.expect("non-null function pointer")(
                            (*alloc).userdata,
                            comp_verts as *mut Void,
                        );
                        num_vertices += comp_num_verts
                    }
                }
                /* More components ? */
                more = flags_0 as Int & 1i32 << 5i32
            }
        } else {
            assert!(numberOfContours < 0);
        }
        /* @TODO other compound variations? */
        /* numberOfCounters == 0, do nothing */
        *pvertices = vertices;
        return num_vertices;
    };
}

unsafe fn nk_sqrt(mut x: f32) -> f32 {
    return x * nk_inv_sqrt(x);
}

unsafe fn nk_tt__GetGlyfOffset(mut info: *const TtFontInfo, mut glyph_index: Int) -> Int {
    let mut g1: Int = 0;
    let mut g2: Int = 0;
    if glyph_index >= (*info).numGlyphs {
        /* glyph index out of range */
        return -1i32;
    } else if (*info).indexToLocFormat >= 2i32 {
        /* unknown index->glyph map format */
        return -1i32;
    } else {
        if (*info).indexToLocFormat == 0i32 {
            g1 = (*info).glyf
                + nk_ttUSHORT(
                    (*info)
                        .data
                        .offset((*info).loca as isize)
                        .offset((glyph_index * 2i32) as isize),
                ) as Int * 2i32;
            g2 = (*info).glyf
                + nk_ttUSHORT(
                    (*info)
                        .data
                        .offset((*info).loca as isize)
                        .offset((glyph_index * 2i32) as isize)
                        .offset(2isize),
                ) as Int * 2i32
        } else {
            g1 = (*info).glyf
                + nk_ttULONG(
                    (*info)
                        .data
                        .offset((*info).loca as isize)
                        .offset((glyph_index * 4i32) as isize),
                ) as Int;
            g2 = (*info).glyf
                + nk_ttULONG(
                    (*info)
                        .data
                        .offset((*info).loca as isize)
                        .offset((glyph_index * 4i32) as isize)
                        .offset(4isize),
                ) as Int
        }
        /* if length is 0, return -1 */
        return if g1 == g2 { -1i32 } else { g1 };
    };
}

unsafe fn nk_tt__close_shape(
    mut vertices: *mut TtVertex,
    mut num_vertices: Int,
    mut was_off: Int,
    mut start_off: Int,
    mut sx: i32,
    mut sy: i32,
    mut scx: i32,
    mut scy: i32,
    mut cx: i32,
    mut cy: i32,
) -> Int {
    if 0 != start_off {
        if 0 != was_off {
            let fresh68 = num_vertices;
            num_vertices = num_vertices + 1;
            nk_tt_setvertex(
                &mut *vertices.offset(fresh68 as isize),
                NK_TT_vcurve as Int as u8,
                cx + scx >> 1i32,
                cy + scy >> 1i32,
                cx,
                cy,
            );
        }
        let fresh69 = num_vertices;
        num_vertices = num_vertices + 1;
        nk_tt_setvertex(
            &mut *vertices.offset(fresh69 as isize),
            NK_TT_vcurve as Int as u8,
            sx,
            sy,
            scx,
            scy,
        );
    } else if 0 != was_off {
        let fresh70 = num_vertices;
        num_vertices = num_vertices + 1;
        nk_tt_setvertex(
            &mut *vertices.offset(fresh70 as isize),
            NK_TT_vcurve as Int as u8,
            sx,
            sy,
            cx,
            cy,
        );
    } else {
        let fresh71 = num_vertices;
        num_vertices = num_vertices + 1;
        nk_tt_setvertex(
            &mut *vertices.offset(fresh71 as isize),
            NK_TT_vline as Int as u8,
            sx,
            sy,
            0i32,
            0i32,
        );
    }
    return num_vertices;
}

unsafe fn nk_tt_setvertex(
    mut v: *mut TtVertex,
    mut type_0: u8,
    mut x: i32,
    mut y: i32,
    mut cx: i32,
    mut cy: i32,
) -> () {
    (*v).type_0 = type_0;
    (*v).x = x as i16;
    (*v).y = y as i16;
    (*v).cx = cx as i16;
    (*v).cy = cy as i16;
}

unsafe fn nk_tt_Rasterize(
    mut result: *mut TtBitmap,
    mut flatness_in_pixels: f32,
    mut vertices: *mut TtVertex,
    mut num_verts: Int,
    mut scale_x: f32,
    mut scale_y: f32,
    mut shift_x: f32,
    mut shift_y: f32,
    mut x_off: Int,
    mut y_off: Int,
    mut invert: Int,
    mut alloc: *mut Allocator,
) -> () {
    let mut scale: f32 = if scale_x > scale_y { scale_y } else { scale_x };
    let mut winding_count: Int = 0;
    let mut winding_lengths: *mut Int = 0 as *mut Int;
    let mut windings: *mut TtPoint = nk_tt_FlattenCurves(
        vertices,
        num_verts,
        flatness_in_pixels / scale,
        &mut winding_lengths,
        &mut winding_count,
        alloc,
    );
    if !windings.is_null() {
        nk_tt__rasterize(
            result,
            windings,
            winding_lengths,
            winding_count,
            scale_x,
            scale_y,
            shift_x,
            shift_y,
            x_off,
            y_off,
            invert,
            alloc,
        );
        (*alloc).free.expect("non-null function pointer")(
            (*alloc).userdata,
            winding_lengths as *mut Void,
        );
        (*alloc).free.expect("non-null function pointer")((*alloc).userdata, windings as *mut Void);
    };
}

unsafe fn nk_tt_FlattenCurves(
    mut vertices: *mut TtVertex,
    mut num_verts: Int,
    mut objspace_flatness: f32,
    mut contour_lengths: *mut *mut Int,
    mut num_contours: *mut Int,
    mut alloc: *mut Allocator,
) -> *mut TtPoint {
    let mut current_block: u64;
    /* returns number of contours */
    let mut points: *mut TtPoint = 0 as *mut TtPoint;
    let mut num_points: Int = 0i32;
    let mut objspace_flatness_squared: f32 = objspace_flatness * objspace_flatness;
    let mut i: Int = 0;
    let mut n: Int = 0i32;
    let mut start: Int = 0i32;
    let mut pass: Int = 0;
    /* count how many "moves" there are to get the contour count */
    i = 0i32;
    while i < num_verts {
        if (*vertices.offset(i as isize)).type_0 as Int == NK_TT_vmove as Int {
            n += 1
        }
        i += 1
    }
    *num_contours = n;
    if n == 0i32 {
        return 0 as *mut TtPoint;
    } else {
        *contour_lengths = (*alloc).alloc.expect("non-null function pointer")(
            (*alloc).userdata,
            0 as *mut Void,
            (mem::size_of::<Int>() as Ulong).wrapping_mul(n as Size),
        ) as *mut Int;
        if (*contour_lengths).is_null() {
            *num_contours = 0i32;
            return 0 as *mut TtPoint;
        } else {
            /* make two passes through the points so we don't need to realloc */
            pass = 0i32;
            loop {
                if !(pass < 2i32) {
                    current_block = 6483416627284290920;
                    break;
                }
                let mut x: f32 = 0i32 as f32;
                let mut y: f32 = 0i32 as f32;
                if pass == 1i32 {
                    points = (*alloc).alloc.expect("non-null function pointer")(
                        (*alloc).userdata,
                        0 as *mut Void,
                        (num_points as Size).wrapping_mul(mem::size_of::<TtPoint>() as Ulong),
                    ) as *mut TtPoint;
                    if points.is_null() {
                        current_block = 13292377088154198382;
                        break;
                    }
                }
                num_points = 0i32;
                n = -1i32;
                i = 0i32;
                while i < num_verts {
                    match (*vertices.offset(i as isize)).type_0 as Int {
                        1 => {
                            /* start the next contour */
                            if n >= 0i32 {
                                *(*contour_lengths).offset(n as isize) = num_points - start
                            }
                            n += 1;
                            start = num_points;
                            x = (*vertices.offset(i as isize)).x as f32;
                            y = (*vertices.offset(i as isize)).y as f32;
                            let fresh72 = num_points;
                            num_points = num_points + 1;
                            nk_tt__add_point(points, fresh72, x, y);
                        }
                        2 => {
                            x = (*vertices.offset(i as isize)).x as f32;
                            y = (*vertices.offset(i as isize)).y as f32;
                            let fresh73 = num_points;
                            num_points = num_points + 1;
                            nk_tt__add_point(points, fresh73, x, y);
                        }
                        3 => {
                            nk_tt__tesselate_curve(
                                points,
                                &mut num_points,
                                x,
                                y,
                                (*vertices.offset(i as isize)).cx as f32,
                                (*vertices.offset(i as isize)).cy as f32,
                                (*vertices.offset(i as isize)).x as f32,
                                (*vertices.offset(i as isize)).y as f32,
                                objspace_flatness_squared,
                                0i32,
                            );
                            x = (*vertices.offset(i as isize)).x as f32;
                            y = (*vertices.offset(i as isize)).y as f32
                        }
                        _ => {}
                    }
                    i += 1
                }
                *(*contour_lengths).offset(n as isize) = num_points - start;
                pass += 1
            }
            match current_block {
                13292377088154198382 => {
                    (*alloc).free.expect("non-null function pointer")(
                        (*alloc).userdata,
                        points as *mut Void,
                    );
                    (*alloc).free.expect("non-null function pointer")(
                        (*alloc).userdata,
                        *contour_lengths as *mut Void,
                    );
                    *contour_lengths = 0 as *mut Int;
                    *num_contours = 0i32;
                    return 0 as *mut TtPoint;
                }
                _ => return points,
            }
        }
    };
}

unsafe fn nk_tt__tesselate_curve(
    mut points: *mut TtPoint,
    mut num_points: *mut Int,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
    mut x2: f32,
    mut y2: f32,
    mut objspace_flatness_squared: f32,
    mut n: Int,
) -> Int {
    /* tesselate until threshold p is happy...
     * @TODO warped to compensate for non-linear stretching */
    /* midpoint */
    let mut mx: f32 = (x0 + 2i32 as f32 * x1 + x2) / 4i32 as f32;
    let mut my: f32 = (y0 + 2i32 as f32 * y1 + y2) / 4i32 as f32;
    /* versus directly drawn line */
    let mut dx: f32 = (x0 + x2) / 2i32 as f32 - mx;
    let mut dy: f32 = (y0 + y2) / 2i32 as f32 - my;
    /* 65536 segments on one curve better be enough! */
    if n > 16i32 {
        return 1i32;
    } else {
        /* half-pixel error allowed... need to be smaller if AA */
        if dx * dx + dy * dy > objspace_flatness_squared {
            nk_tt__tesselate_curve(
                points,
                num_points,
                x0,
                y0,
                (x0 + x1) / 2.0f32,
                (y0 + y1) / 2.0f32,
                mx,
                my,
                objspace_flatness_squared,
                n + 1i32,
            );
            nk_tt__tesselate_curve(
                points,
                num_points,
                mx,
                my,
                (x1 + x2) / 2.0f32,
                (y1 + y2) / 2.0f32,
                x2,
                y2,
                objspace_flatness_squared,
                n + 1i32,
            );
        } else {
            nk_tt__add_point(points, *num_points, x2, y2);
            *num_points = *num_points + 1i32
        }
        return 1i32;
    };
}

unsafe fn nk_tt__add_point(mut points: *mut TtPoint, mut n: Int, mut x: f32, mut y: f32) -> () {
    if points.is_null() {
        /* during first pass, it's unallocated */
        return;
    } else {
        (*points.offset(n as isize)).x = x;
        (*points.offset(n as isize)).y = y;
        return;
    };
}

unsafe fn nk_tt__rasterize(
    mut result: *mut TtBitmap,
    mut pts: *mut TtPoint,
    mut wcount: *mut Int,
    mut windings: Int,
    mut scale_x: f32,
    mut scale_y: f32,
    mut shift_x: f32,
    mut shift_y: f32,
    mut off_x: Int,
    mut off_y: Int,
    mut invert: Int,
    mut alloc: *mut Allocator,
) -> () {
    let mut y_scale_inv: f32 = if 0 != invert { -scale_y } else { scale_y };
    let mut e: *mut TtEdge = 0 as *mut TtEdge;
    let mut n: Int = 0;
    let mut i: Int = 0;
    let mut j: Int = 0;
    let mut k: Int = 0;
    let mut m: Int = 0;
    let mut vsubsample: Int = 1i32;
    /* vsubsample should divide 255 evenly; otherwise we won't reach full opacity */
    /* now we have to blow out the windings into explicit edge lists */
    n = 0i32;
    i = 0i32;
    while i < windings {
        n += *wcount.offset(i as isize);
        i += 1
    }
    e = (*alloc).alloc.expect("non-null function pointer")(
        (*alloc).userdata,
        0 as *mut Void,
        (mem::size_of::<TtEdge>() as Ulong).wrapping_mul((n + 1i32) as Size),
    ) as *mut TtEdge;
    if e.is_null() {
        return;
    } else {
        n = 0i32;
        m = 0i32;
        i = 0i32;
        while i < windings {
            let mut p: *mut TtPoint = pts.offset(m as isize);
            m += *wcount.offset(i as isize);
            j = *wcount.offset(i as isize) - 1i32;
            k = 0i32;
            while k < *wcount.offset(i as isize) {
                let mut a: Int = k;
                let mut b: Int = j;
                /* skip the edge if horizontal */
                if !((*p.offset(j as isize)).y == (*p.offset(k as isize)).y) {
                    /* add edge from j to k to the list */
                    (*e.offset(n as isize)).invert = 0i32;
                    if 0 != if 0 != invert {
                        ((*p.offset(j as isize)).y > (*p.offset(k as isize)).y) as Int
                    } else {
                        ((*p.offset(j as isize)).y < (*p.offset(k as isize)).y) as Int
                    } {
                        (*e.offset(n as isize)).invert = 1i32;
                        a = j;
                        b = k
                    }
                    (*e.offset(n as isize)).x0 = (*p.offset(a as isize)).x * scale_x + shift_x;
                    (*e.offset(n as isize)).y0 =
                        ((*p.offset(a as isize)).y * y_scale_inv + shift_y) * vsubsample as f32;
                    (*e.offset(n as isize)).x1 = (*p.offset(b as isize)).x * scale_x + shift_x;
                    (*e.offset(n as isize)).y1 =
                        ((*p.offset(b as isize)).y * y_scale_inv + shift_y) * vsubsample as f32;
                    n += 1
                }
                let fresh74 = k;
                k = k + 1;
                j = fresh74
            }
            i += 1
        }
        /* now sort the edges by their highest point (should snap to integer, and then by x) */
        /*STBTT_sort(e, n, sizeof(e[0]), nk_tt__edge_compare); */
        nk_tt__sort_edges(e, n);
        /* now, traverse the scanlines and find the intersections on each scanline, use xor winding rule */
        nk_tt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, alloc);
        (*alloc).free.expect("non-null function pointer")((*alloc).userdata, e as *mut Void);
        return;
    };
}
unsafe fn nk_tt__rasterize_sorted_edges(
    mut result: *mut TtBitmap,
    mut e: *mut TtEdge,
    mut n: Int,
    mut vsubsample: Int,
    mut off_x: Int,
    mut off_y: Int,
    mut alloc: *mut Allocator,
) -> () {
    let mut z_1: *mut TtActiveEdge = 0 as *mut TtActiveEdge;
    /* directly AA rasterize edges w/o supersampling */
    let mut hh: TtHheap = TtHheap {
        alloc: Allocator {
            userdata: Handle {
                ptr: 0 as *mut Void,
            },
            alloc: None,
            free: None,
        },
        head: 0 as *mut TtHheapChunk,
        first_free: 0 as *mut Void,
        num_remaining_in_head_chunk: 0,
    };
    let mut active: *mut TtActiveEdge = 0 as *mut TtActiveEdge;
    let mut y: Int = 0;
    let mut j: Int = 0i32;
    let mut i: Int = 0;
    let mut scanline_data: [f32; 129] = [0.; 129];
    let mut scanline: *mut f32 = 0 as *mut f32;
    let mut scanline2: *mut f32 = 0 as *mut f32;
    nk_zero(
        &mut hh as *mut TtHheap as *mut Void,
        mem::size_of::<TtHheap>() as Ulong,
    );
    hh.alloc = *alloc;
    if (*result).w > 64i32 {
        scanline = (*alloc).alloc.expect("non-null function pointer")(
            (*alloc).userdata,
            0 as *mut Void,
            (((*result).w * 2i32 + 1i32) as Size).wrapping_mul(mem::size_of::<f32>() as Ulong),
        ) as *mut f32
    } else {
        scanline = scanline_data.as_mut_ptr()
    }
    scanline2 = scanline.offset((*result).w as isize);
    y = off_y;
    (*e.offset(n as isize)).y0 = (off_y + (*result).h) as f32 + 1i32 as f32;
    while j < (*result).h {
        /* find center of pixel for this scanline */
        let mut scan_y_top: f32 = y as f32 + 0.0f32;
        let mut scan_y_bottom: f32 = y as f32 + 1.0f32;
        let mut step: *mut *mut TtActiveEdge = &mut active;
        nk_memset(
            scanline as *mut Void,
            0i32,
            ((*result).w as Size).wrapping_mul(mem::size_of::<f32>() as Ulong),
        );
        nk_memset(
            scanline2 as *mut Void,
            0i32,
            (((*result).w + 1i32) as Size).wrapping_mul(mem::size_of::<f32>() as Ulong),
        );
        /* update all active edges; */
        /* remove all active edges that terminate before the top of this scanline */
        while !(*step).is_null() {
            let mut z: *mut TtActiveEdge = *step;
            if (*z).ey <= scan_y_top {
                /* delete from list */
                *step = (*z).next;
                (*z).direction = 0i32 as f32;
                nk_tt__hheap_free(&mut hh, z as *mut Void);
            } else {
                step = &mut (**step).next as *mut *mut TtActiveEdge
            }
        }
        /* insert all edges that start before the bottom of this scanline */
        while (*e).y0 <= scan_y_bottom {
            if (*e).y0 != (*e).y1 {
                let mut z_0: *mut TtActiveEdge = nk_tt__new_active(&mut hh, e, off_x, scan_y_top);
                if !z_0.is_null() {
                    /* insert at front */
                    (*z_0).next = active;
                    active = z_0
                }
            }
            e = e.offset(1isize)
        }
        /* now process all active edges */
        if !active.is_null() {
            nk_tt__fill_active_edges_new(
                scanline,
                scanline2.offset(1isize),
                (*result).w,
                active,
                scan_y_top,
            );
        }
        let mut sum: f32 = 0i32 as f32;
        i = 0i32;
        while i < (*result).w {
            let mut k: f32 = 0.;
            let mut m: Int = 0;
            sum += *scanline2.offset(i as isize);
            k = *scanline.offset(i as isize) + sum;
            k = if k < 0i32 as f32 { -k } else { k } * 255.0f32 + 0.5f32;
            m = k as Int;
            if m > 255i32 {
                m = 255i32
            }
            *(*result).pixels.offset((j * (*result).stride + i) as isize) = m as Uchar;
            i += 1
        }
        /* advance all the edges */
        step = &mut active;
        while !(*step).is_null() {
            z_1 = *step;
            /* advance to position for current scanline */
            (*z_1).fx += (*z_1).fdx;
            /* advance through list */
            step = &mut (**step).next as *mut *mut TtActiveEdge
        }
        y += 1;
        j += 1
    }
    nk_tt__hheap_cleanup(&mut hh);
    if scanline != scanline_data.as_mut_ptr() {
        (*alloc).free.expect("non-null function pointer")((*alloc).userdata, scanline as *mut Void);
    };
}
unsafe fn nk_tt__hheap_cleanup(mut hh: *mut TtHheap) -> () {
    let mut c: *mut TtHheapChunk = (*hh).head;
    while !c.is_null() {
        let mut n: *mut TtHheapChunk = (*c).next;
        (*hh).alloc.free.expect("non-null function pointer")((*hh).alloc.userdata, c as *mut Void);
        c = n
    }
}
unsafe fn nk_tt__fill_active_edges_new(
    mut scanline: *mut f32,
    mut scanline_fill: *mut f32,
    mut len: Int,
    mut e: *mut TtActiveEdge,
    mut y_top: f32,
) -> () {
    let mut x: Int = 0;
    let mut height: f32 = 0.;
    let mut t: f32 = 0.;
    let mut y_bottom: f32 = y_top + 1i32 as f32;
    while !e.is_null() {
        /* brute force every pixel */
        /* compute intersection points with top & bottom */
        if (*e).fdx == 0i32 as f32 {
            let mut x0: f32 = (*e).fx;
            if x0 < len as f32 {
                if x0 >= 0i32 as f32 {
                    nk_tt__handle_clipped_edge(scanline, x0 as Int, e, x0, y_top, x0, y_bottom);
                    nk_tt__handle_clipped_edge(
                        scanline_fill.offset(-1isize),
                        x0 as Int + 1i32,
                        e,
                        x0,
                        y_top,
                        x0,
                        y_bottom,
                    );
                } else {
                    nk_tt__handle_clipped_edge(
                        scanline_fill.offset(-1isize),
                        0i32,
                        e,
                        x0,
                        y_top,
                        x0,
                        y_bottom,
                    );
                }
            }
        } else {
            let mut x0_0: f32 = (*e).fx;
            let mut dx: f32 = (*e).fdx;
            let mut xb: f32 = x0_0 + dx;
            let mut x_top: f32 = 0.;
            let mut x_bottom: f32 = 0.;
            let mut y0: f32 = 0.;
            let mut y1: f32 = 0.;
            let mut dy: f32 = (*e).fdy;
            /* compute endpoints of line segment clipped to this scanline (if the */
            /* line segment starts on this scanline. x0 is the intersection of the */
            /* line with y_top, but that may be off the line segment. */
            if (*e).sy > y_top {
                x_top = x0_0 + dx * ((*e).sy - y_top);
                y0 = (*e).sy
            } else {
                x_top = x0_0;
                y0 = y_top
            }
            if (*e).ey < y_bottom {
                x_bottom = x0_0 + dx * ((*e).ey - y_top);
                y1 = (*e).ey
            } else {
                x_bottom = xb;
                y1 = y_bottom
            }
            if x_top >= 0i32 as f32
                && x_bottom >= 0i32 as f32
                && x_top < len as f32
                && x_bottom < len as f32
            {
                /* from here on, we don't have to range check x values */
                if x_top as Int == x_bottom as Int {
                    height = 0.;
                    /* simple case, only spans one pixel */
                    x = x_top as Int;
                    height = y1 - y0;
                    *scanline.offset(x as isize) += (*e).direction
                        * (1.0f32 - (x_top - x as f32 + (x_bottom - x as f32)) / 2.0f32)
                        * height;
                    /* everything right of this pixel is filled */
                    *scanline_fill.offset(x as isize) += (*e).direction * height
                } else {
                    let mut x_0: Int = 0;
                    let mut x1: Int = 0;
                    let mut x2: Int = 0;
                    let mut y_crossing: f32 = 0.;
                    let mut step: f32 = 0.;
                    let mut sign: f32 = 0.;
                    let mut area: f32 = 0.;
                    /* covers 2+ pixels */
                    if x_top > x_bottom {
                        /* flip scanline vertically; signed area is the same */
                        t = 0.;
                        y0 = y_bottom - (y0 - y_top);
                        y1 = y_bottom - (y1 - y_top);
                        t = y0;
                        y0 = y1;
                        y1 = t;
                        t = x_bottom;
                        x_bottom = x_top;
                        x_top = t;
                        dx = -dx;
                        dy = -dy;
                        t = x0_0;
                        x0_0 = xb;
                        xb = t
                    }
                    x1 = x_top as Int;
                    x2 = x_bottom as Int;
                    /* compute intersection with y axis at x1+1 */
                    y_crossing = (x1 as f32 + 1i32 as f32 - x0_0) * dy + y_top;
                    sign = (*e).direction;
                    /* area of the rectangle covered from y0..y_crossing */
                    area = sign * (y_crossing - y0);
                    /* area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing) */
                    *scanline.offset(x1 as isize) +=
                        area * (1.0f32 - (x_top - x1 as f32 + (x1 + 1i32 - x1) as f32) / 2.0f32);
                    step = sign * dy;
                    x_0 = x1 + 1i32;
                    while x_0 < x2 {
                        *scanline.offset(x_0 as isize) += area + step / 2i32 as f32;
                        area += step;
                        x_0 += 1
                    }
                    y_crossing += dy * (x2 - (x1 + 1i32)) as f32;
                    *scanline.offset(x2 as isize) += area + sign
                        * (1.0f32 - ((x2 - x2) as f32 + (x_bottom - x2 as f32)) / 2.0f32)
                        * (y1 - y_crossing);
                    *scanline_fill.offset(x2 as isize) += sign * (y1 - y0)
                }
            } else {
                /* if edge goes outside of box we're drawing, we require */
                /* clipping logic. since this does not match the intended use */
                /* of this library, we use a different, very slow brute */
                /* force implementation */
                let mut x_1: Int = 0;
                x_1 = 0i32;
                while x_1 < len {
                    /* cases: */
                    /* */
                    /* there can be up to two intersections with the pixel. any intersection */
                    /* with left or right edges can be handled by splitting into two (or three) */
                    /* regions. intersections with top & bottom do not necessitate case-wise logic. */
                    /* */
                    /* the old way of doing this found the intersections with the left & right edges, */
                    /* then used some simple logic to produce up to three segments in sorted order */
                    /* from top-to-bottom. however, this had a problem: if an x edge was epsilon */
                    /* across the x border, then the corresponding y position might not be distinct */
                    /* from the other y segment, and it might ignored as an empty segment. to avoid */
                    /* that, we need to explicitly produce segments based on x positions. */
                    /* rename variables to clear pairs */
                    let mut ya: f32 = y_top;
                    let mut x1_0: f32 = x_1 as f32;
                    let mut x2_0: f32 = (x_1 + 1i32) as f32;
                    let mut x3: f32 = xb;
                    let mut y3: f32 = y_bottom;
                    let mut yb: f32 = 0.;
                    let mut y2: f32 = 0.;
                    yb = (x_1 as f32 - x0_0) / dx + y_top;
                    y2 = (x_1 as f32 + 1i32 as f32 - x0_0) / dx + y_top;
                    if x0_0 < x1_0 && x3 > x2_0 {
                        /* three segments descending down-right */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x1_0, yb);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x1_0, yb, x2_0, y2);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x2_0, y2, x3, y3);
                    } else if x3 < x1_0 && x0_0 > x2_0 {
                        /* three segments descending down-left */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x2_0, y2);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x2_0, y2, x1_0, yb);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x1_0, yb, x3, y3);
                    } else if x0_0 < x1_0 && x3 > x1_0 {
                        /* two segments across x, down-right */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x1_0, yb);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x1_0, yb, x3, y3);
                    } else if x3 < x1_0 && x0_0 > x1_0 {
                        /* two segments across x, down-left */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x1_0, yb);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x1_0, yb, x3, y3);
                    } else if x0_0 < x2_0 && x3 > x2_0 {
                        /* two segments across x+1, down-right */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x2_0, y2);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x2_0, y2, x3, y3);
                    } else if x3 < x2_0 && x0_0 > x2_0 {
                        /* two segments across x+1, down-left */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x2_0, y2);
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x2_0, y2, x3, y3);
                    } else {
                        /* one segment */
                        nk_tt__handle_clipped_edge(scanline, x_1, e, x0_0, ya, x3, y3);
                    }
                    x_1 += 1
                }
            }
        }
        e = (*e).next
    }
}
unsafe fn nk_tt__handle_clipped_edge(
    mut scanline: *mut f32,
    mut x: Int,
    mut e: *mut TtActiveEdge,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
) -> () {
    if y0 == y1 {
        return;
    } else if y0 > (*e).ey {
        return;
    } else if y1 < (*e).sy {
        return;
    } else {
        if y0 < (*e).sy {
            x0 += (x1 - x0) * ((*e).sy - y0) / (y1 - y0);
            y0 = (*e).sy
        }
        if y1 > (*e).ey {
            x1 += (x1 - x0) * ((*e).ey - y1) / (y1 - y0);
            y1 = (*e).ey
        }
        if !(x0 == x as f32) {
            if !(x0 == (x + 1i32) as f32) {
                if !(x0 <= x as f32) {
                    assert!(x0 >= (x + 1i32) as f32);
                }
            }
        }
        if x0 <= x as f32 && x1 <= x as f32 {
            *scanline.offset(x as isize) += (*e).direction * (y1 - y0)
        } else if !(x0 >= (x + 1i32) as f32 && x1 >= (x + 1i32) as f32) {
            /* coverage = 1 - average x position */
            *scanline.offset(x as isize) +=
                (*e).direction * (y1 - y0) * (1.0f32 - (x0 - x as f32 + (x1 - x as f32)) / 2.0f32)
        }
        return;
    };
}
unsafe fn nk_tt__new_active(
    mut hh: *mut TtHheap,
    mut e: *mut TtEdge,
    mut off_x: Int,
    mut start_point: f32,
) -> *mut TtActiveEdge {
    let mut z: *mut TtActiveEdge =
        nk_tt__hheap_alloc(hh, mem::size_of::<TtActiveEdge>() as Ulong) as *mut TtActiveEdge;
    let mut dxdy: f32 = ((*e).x1 - (*e).x0) / ((*e).y1 - (*e).y0);
    /*STBTT_assert(e->y0 <= start_point); */
    if z.is_null() {
        return z;
    } else {
        (*z).fdx = dxdy;
        (*z).fdy = if dxdy != 0i32 as f32 {
            1i32 as f32 / dxdy
        } else {
            0i32 as f32
        };
        (*z).fx = (*e).x0 + dxdy * (start_point - (*e).y0);
        (*z).fx -= off_x as f32;
        (*z).direction = if 0 != (*e).invert { 1.0f32 } else { -1.0f32 };
        (*z).sy = (*e).y0;
        (*z).ey = (*e).y1;
        (*z).next = 0 as *mut TtActiveEdge;
        return z;
    };
}
unsafe fn nk_tt__hheap_alloc(mut hh: *mut TtHheap, mut size: Size) -> *mut Void {
    if !(*hh).first_free.is_null() {
        let mut p: *mut Void = (*hh).first_free;
        (*hh).first_free = *(p as *mut *mut Void);
        return p;
    } else {
        if (*hh).num_remaining_in_head_chunk == 0i32 {
            let mut count: Int = if size < 32i32 as Ulong {
                2000i32
            } else if size < 128i32 as Ulong {
                800i32
            } else {
                100i32
            };
            let mut c: *mut TtHheapChunk = (*hh).alloc.alloc.expect("non-null function pointer")(
                (*hh).alloc.userdata,
                0 as *mut Void,
                (mem::size_of::<TtHheapChunk>() as Ulong)
                    .wrapping_add(size.wrapping_mul(count as Size)),
            ) as *mut TtHheapChunk;
            if c.is_null() {
                return 0 as *mut Void;
            } else {
                (*c).next = (*hh).head;
                (*hh).head = c;
                (*hh).num_remaining_in_head_chunk = count
            }
        }
        (*hh).num_remaining_in_head_chunk -= 1;
        return ((*hh).head as *mut Char)
            .offset(size.wrapping_mul((*hh).num_remaining_in_head_chunk as Size) as isize)
            as *mut Void;
    };
}
unsafe fn nk_tt__hheap_free(mut hh: *mut TtHheap, mut p: *mut Void) -> () {
    let ref mut fresh75 = *(p as *mut *mut Void);
    *fresh75 = (*hh).first_free;
    (*hh).first_free = p;
}
unsafe fn nk_tt__sort_edges(mut p: *mut TtEdge, mut n: Int) -> () {
    nk_tt__sort_edges_quicksort(p, n);
    nk_tt__sort_edges_ins_sort(p, n);
}
unsafe fn nk_tt__sort_edges_ins_sort(mut p: *mut TtEdge, mut n: Int) -> () {
    let mut i: Int = 0;
    let mut j: Int = 0;
    i = 1i32;
    while i < n {
        let mut t: TtEdge = *p.offset(i as isize);
        let mut a: *mut TtEdge = &mut t;
        j = i;
        while j > 0i32 {
            let mut b: *mut TtEdge = &mut *p.offset((j - 1i32) as isize) as *mut TtEdge;
            let mut c: Int = ((*a).y0 < (*b).y0) as Int;
            if 0 == c {
                break;
            }
            *p.offset(j as isize) = *p.offset((j - 1i32) as isize);
            j -= 1
        }
        if i != j {
            *p.offset(j as isize) = t
        }
        i += 1
    }
}
unsafe fn nk_tt__sort_edges_quicksort(mut p: *mut TtEdge, mut n: Int) -> () {
    let mut z: Int = 0;
    /* threshold for transitioning to insertion sort */
    while n > 12i32 {
        let mut t: TtEdge = TtEdge {
            x0: 0.,
            y0: 0.,
            x1: 0.,
            y1: 0.,
            invert: 0,
        };
        let mut c01: Int = 0;
        let mut c12: Int = 0;
        let mut c: Int = 0;
        let mut m: Int = 0;
        let mut i: Int = 0;
        let mut j: Int = 0;
        /* compute median of three */
        m = n >> 1i32;
        c01 = ((*p.offset(0isize)).y0 < (*p.offset(m as isize)).y0) as Int;
        c12 = ((*p.offset(m as isize)).y0 < (*p.offset((n - 1i32) as isize)).y0) as Int;
        /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
        if c01 != c12 {
            /* otherwise, we'll need to swap something else to middle */
            z = 0;
            c = ((*p.offset(0isize)).y0 < (*p.offset((n - 1i32) as isize)).y0) as Int;
            /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
            /* 0<mid && mid>n:  0>n => 0; 0<n => n */
            z = if c == c12 { 0i32 } else { n - 1i32 };
            t = *p.offset(z as isize);
            *p.offset(z as isize) = *p.offset(m as isize);
            *p.offset(m as isize) = t
        }
        /* now p[m] is the median-of-three */
        /* swap it to the beginning so it won't move around */
        t = *p.offset(0isize);
        *p.offset(0isize) = *p.offset(m as isize);
        *p.offset(m as isize) = t;
        /* partition loop */
        i = 1i32;
        j = n - 1i32;
        loop {
            /* handling of equality is crucial here */
            /* for sentinels & efficiency with duplicates */
            while (*p.offset(i as isize)).y0 < (*p.offset(0isize)).y0 {
                i += 1
            }
            while (*p.offset(0isize)).y0 < (*p.offset(j as isize)).y0 {
                j -= 1
            }
            /* make sure we haven't crossed */
            if i >= j {
                break;
            }
            t = *p.offset(i as isize);
            *p.offset(i as isize) = *p.offset(j as isize);
            *p.offset(j as isize) = t;
            i += 1;
            j -= 1
        }
        /* recurse on smaller side, iterate on larger */
        if j < n - i {
            nk_tt__sort_edges_quicksort(p, j);
            p = p.offset(i as isize);
            n = n - i
        } else {
            nk_tt__sort_edges_quicksort(p.offset(i as isize), n - i);
            n = j
        }
    }
}
unsafe fn nk_tt_GetGlyphBitmapBoxSubpixel(
    mut font: *const TtFontInfo,
    mut glyph: Int,
    mut scale_x: f32,
    mut scale_y: f32,
    mut shift_x: f32,
    mut shift_y: f32,
    mut ix0: *mut Int,
    mut iy0: *mut Int,
    mut ix1: *mut Int,
    mut iy1: *mut Int,
) -> () {
    let mut x0: Int = 0;
    let mut y0: Int = 0;
    let mut x1: Int = 0;
    let mut y1: Int = 0;
    if 0 == nk_tt_GetGlyphBox(font, glyph, &mut x0, &mut y0, &mut x1, &mut y1) {
        /* e.g. space character */
        if !ix0.is_null() {
            *ix0 = 0i32
        }
        if !iy0.is_null() {
            *iy0 = 0i32
        }
        if !ix1.is_null() {
            *ix1 = 0i32
        }
        if !iy1.is_null() {
            *iy1 = 0i32
        }
    } else {
        /* move to integral bboxes (treating pixels as little squares, what pixels get touched)? */
        if !ix0.is_null() {
            *ix0 = nk_ifloorf(x0 as f32 * scale_x + shift_x)
        }
        if !iy0.is_null() {
            *iy0 = nk_ifloorf(-y1 as f32 * scale_y + shift_y)
        }
        if !ix1.is_null() {
            *ix1 = nk_iceilf(x1 as f32 * scale_x + shift_x)
        }
        if !iy1.is_null() {
            *iy1 = nk_iceilf(-y0 as f32 * scale_y + shift_y)
        }
    };
}
unsafe fn nk_tt_GetGlyphBox(
    mut info: *const TtFontInfo,
    mut glyph_index: Int,
    mut x0: *mut Int,
    mut y0: *mut Int,
    mut x1: *mut Int,
    mut y1: *mut Int,
) -> Int {
    let mut g: Int = nk_tt__GetGlyfOffset(info, glyph_index);
    if g < 0i32 {
        return 0i32;
    } else {
        if !x0.is_null() {
            *x0 = nk_ttSHORT((*info).data.offset(g as isize).offset(2isize)) as Int
        }
        if !y0.is_null() {
            *y0 = nk_ttSHORT((*info).data.offset(g as isize).offset(4isize)) as Int
        }
        if !x1.is_null() {
            *x1 = nk_ttSHORT((*info).data.offset(g as isize).offset(6isize)) as Int
        }
        if !y1.is_null() {
            *y1 = nk_ttSHORT((*info).data.offset(g as isize).offset(8isize)) as Int
        }
        return 1i32;
    };
}
unsafe fn nk_tt_GetGlyphBitmapBox(
    mut font: *const TtFontInfo,
    mut glyph: Int,
    mut scale_x: f32,
    mut scale_y: f32,
    mut ix0: *mut Int,
    mut iy0: *mut Int,
    mut ix1: *mut Int,
    mut iy1: *mut Int,
) -> () {
    nk_tt_GetGlyphBitmapBoxSubpixel(
        font, glyph, scale_x, scale_y, 0.0f32, 0.0f32, ix0, iy0, ix1, iy1,
    );
}
unsafe fn nk_tt_GetGlyphHMetrics(
    mut info: *const TtFontInfo,
    mut glyph_index: Int,
    mut advanceWidth: *mut Int,
    mut leftSideBearing: *mut Int,
) -> () {
    let mut numOfLongHorMetrics: u16 =
        nk_ttUSHORT((*info).data.offset((*info).hhea as isize).offset(34isize));
    if glyph_index < numOfLongHorMetrics as Int {
        if !advanceWidth.is_null() {
            *advanceWidth = nk_ttSHORT(
                (*info)
                    .data
                    .offset((*info).hmtx as isize)
                    .offset((4i32 * glyph_index) as isize),
            ) as Int
        }
        if !leftSideBearing.is_null() {
            *leftSideBearing = nk_ttSHORT(
                (*info)
                    .data
                    .offset((*info).hmtx as isize)
                    .offset((4i32 * glyph_index) as isize)
                    .offset(2isize),
            ) as Int
        }
    } else {
        if !advanceWidth.is_null() {
            *advanceWidth = nk_ttSHORT(
                (*info)
                    .data
                    .offset((*info).hmtx as isize)
                    .offset((4i32 * (numOfLongHorMetrics as Int - 1i32)) as isize),
            ) as Int
        }
        if !leftSideBearing.is_null() {
            *leftSideBearing = nk_ttSHORT(
                (*info)
                    .data
                    .offset((*info).hmtx as isize)
                    .offset((4i32 * numOfLongHorMetrics as Int) as isize)
                    .offset((2i32 * (glyph_index - numOfLongHorMetrics as Int)) as isize),
            ) as Int
        }
    };
}
unsafe fn nk_tt__oversample_shift(mut oversample: Int) -> f32 {
    if 0 == oversample {
        return 0.0f32;
    } else {
        return -(oversample - 1i32) as f32 / (2.0f32 * oversample as f32);
    };
}
unsafe fn nk_tt_PackSetOversampling(
    mut spc: *mut TtPackContext,
    mut h_oversample: Uint,
    mut v_oversample: Uint,
) -> () {
    if h_oversample <= 8i32 as Uint {
        (*spc).h_oversample = h_oversample
    }
    if v_oversample <= 8i32 as Uint {
        (*spc).v_oversample = v_oversample
    };
}
unsafe fn nk_font_bake_pack(
    mut baker: *mut FontBaker,
    mut image_memory: *mut Size,
    mut width: *mut Int,
    mut height: *mut Int,
    mut custom: *mut RectI,
    mut config_list: *const FontConfig,
    mut count: Int,
    mut alloc: *mut Allocator,
) -> Int {
    let mut custom_space: RpRect = RpRect {
        id: 0,
        w: 0,
        h: 0,
        x: 0,
        y: 0,
        was_packed: 0,
    };
    static mut max_height: Size = unsafe { (1024i32 * 32i32) as Size };
    let mut config_iter: *const FontConfig = 0 as *const FontConfig;
    let mut it: *const FontConfig = 0 as *const FontConfig;
    let mut total_glyph_count: Int = 0i32;
    let mut total_range_count: Int = 0i32;
    let mut range_count: Int = 0i32;
    let mut i: Int = 0i32;
    if image_memory.is_null()
        || width.is_null()
        || height.is_null()
        || config_list.is_null()
        || 0 == count
    {
        return nk_false as Int;
    } else {
        config_iter = config_list;
        while !config_iter.is_null() {
            it = config_iter;
            loop {
                range_count = nk_range_count((*it).range);
                total_range_count += range_count;
                total_glyph_count += nk_range_glyph_count((*it).range, range_count);
                it = (*it).n;
                if !(it != config_iter) {
                    break;
                }
            }
            config_iter = (*config_iter).next
        }
        /* setup font baker from temporary memory */
        config_iter = config_list;
        while !config_iter.is_null() {
            it = config_iter;
            loop {
                let fresh76 = i;
                i = i + 1;
                if 0 == nk_tt_InitFont(
                    &mut (*(*baker).build.offset(fresh76 as isize)).info,
                    (*it).ttf_blob as *const Uchar,
                    0i32,
                ) {
                    return nk_false as Int;
                } else {
                    it = (*it).n;
                    if !(it != config_iter) {
                        break;
                    }
                }
            }
            config_iter = (*config_iter).next
        }
        *height = 0i32;
        *width = if total_glyph_count > 1000i32 {
            1024i32
        } else {
            512i32
        };
        nk_tt_PackBegin(
            &mut (*baker).spc,
            0 as *mut Uchar,
            *width,
            max_height as Int,
            0i32,
            1i32,
            alloc,
        );
        let mut input_i: Int = 0i32;
        let mut range_n: Int = 0i32;
        let mut rect_n: Int = 0i32;
        let mut char_n: Int = 0i32;
        if !custom.is_null() {
            /* pack custom user data first so it will be in the upper left corner*/
            custom_space = RpRect {
                id: 0,
                w: 0,
                h: 0,
                x: 0,
                y: 0,
                was_packed: 0,
            };
            nk_zero(
                &mut custom_space as *mut RpRect as *mut Void,
                mem::size_of::<RpRect>() as Ulong,
            );
            custom_space.w = (*custom).w as RpCoord;
            custom_space.h = (*custom).h as RpCoord;
            nk_tt_PackSetOversampling(&mut (*baker).spc, 1i32 as Uint, 1i32 as Uint);
            nk_rp_pack_rects(
                (*baker).spc.pack_info as *mut RpContext,
                &mut custom_space,
                1i32,
            );
            *height = if *height < custom_space.y as Int + custom_space.h as Int {
                custom_space.y as Int + custom_space.h as Int
            } else {
                *height
            };
            (*custom).x = custom_space.x as Short;
            (*custom).y = custom_space.y as Short;
            (*custom).w = custom_space.w as Short;
            (*custom).h = custom_space.h as Short
        }
        /* first font pass: pack all glyphs */
        input_i = 0i32;
        config_iter = config_list;
        while input_i < count && !config_iter.is_null() {
            it = config_iter;
            loop {
                let mut n: Int = 0i32;
                let mut glyph_count: Int = 0;
                let mut in_range: *const Rune = 0 as *const Rune;
                let mut cfg: *const FontConfig = it;
                let fresh77 = input_i;
                input_i = input_i + 1;
                let mut tmp: *mut FontBackData =
                    &mut *(*baker).build.offset(fresh77 as isize) as *mut FontBackData;
                /* count glyphs + ranges in current font */
                glyph_count = 0i32;
                range_count = 0i32;
                in_range = (*cfg).range;
                while 0 != *in_range.offset(0isize) && 0 != *in_range.offset(1isize) {
                    glyph_count += (*in_range.offset(1isize)).wrapping_sub(*in_range.offset(0isize))
                        as Int + 1i32;
                    range_count += 1;
                    in_range = in_range.offset(2isize)
                }
                /* setup ranges  */
                (*tmp).ranges = (*baker).ranges.offset(range_n as isize);
                (*tmp).range_count = range_count as Rune;
                range_n += range_count;
                i = 0i32;
                while i < range_count {
                    in_range = &*(*cfg).range.offset((i * 2i32) as isize) as *const Rune;
                    (*(*tmp).ranges.offset(i as isize)).font_size = (*cfg).size;
                    (*(*tmp).ranges.offset(i as isize)).first_unicode_codepoint_in_range =
                        *in_range.offset(0isize) as Int;
                    (*(*tmp).ranges.offset(i as isize)).num_chars =
                        (*in_range.offset(1isize)).wrapping_sub(*in_range.offset(0isize)) as Int
                            + 1i32;
                    let ref mut fresh78 = (*(*tmp).ranges.offset(i as isize)).chardata_for_range;
                    *fresh78 = (*baker).packed_chars.offset(char_n as isize);
                    char_n += (*(*tmp).ranges.offset(i as isize)).num_chars;
                    i += 1
                }
                /* pack */
                (*tmp).rects = (*baker).rects.offset(rect_n as isize);
                rect_n += glyph_count;
                nk_tt_PackSetOversampling(
                    &mut (*baker).spc,
                    (*cfg).oversample_h as Uint,
                    (*cfg).oversample_v as Uint,
                );
                n = nk_tt_PackFontRangesGatherRects(
                    &mut (*baker).spc,
                    &mut (*tmp).info,
                    (*tmp).ranges,
                    (*tmp).range_count as Int,
                    (*tmp).rects,
                );
                nk_rp_pack_rects((*baker).spc.pack_info as *mut RpContext, (*tmp).rects, n);
                /* texture height */
                i = 0i32;
                while i < n {
                    if 0 != (*(*tmp).rects.offset(i as isize)).was_packed {
                        *height = if *height
                            < (*(*tmp).rects.offset(i as isize)).y as Int
                                + (*(*tmp).rects.offset(i as isize)).h as Int
                        {
                            (*(*tmp).rects.offset(i as isize)).y as Int
                                + (*(*tmp).rects.offset(i as isize)).h as Int
                        } else {
                            *height
                        }
                    }
                    i += 1
                }
                it = (*it).n;
                if !(it != config_iter) {
                    break;
                }
            }
            config_iter = (*config_iter).next
        }
        *height = nk_round_up_pow2(*height as u32) as Int;
        *image_memory = (*width as Size).wrapping_mul(*height as Size);
        return nk_true as Int;
    };
}

unsafe fn nk_rp_pack_rects(
    mut context: *mut RpContext,
    mut rects: *mut RpRect,
    mut num_rects: Int,
) -> () {
    let mut i: Int = 0;
    /* we use the 'was_packed' field internally to allow sorting/unsorting */
    i = 0i32;
    while i < num_rects {
        (*rects.offset(i as isize)).was_packed = i;
        i += 1
    }
    /* sort according to heuristic */
    nk_rp_qsort(rects, num_rects as Uint, Some(nk_rect_height_compare));
    i = 0i32;
    while i < num_rects {
        let mut fr: RpFindResult = nk_rp__skyline_pack_rectangle(
            context,
            (*rects.offset(i as isize)).w as Int,
            (*rects.offset(i as isize)).h as Int,
        );
        if !fr.prev_link.is_null() {
            (*rects.offset(i as isize)).x = fr.x as RpCoord;
            (*rects.offset(i as isize)).y = fr.y as RpCoord
        } else {
            let ref mut fresh79 = (*rects.offset(i as isize)).y;
            *fresh79 = 65535i32 as RpCoord;
            (*rects.offset(i as isize)).x = *fresh79
        }
        i += 1
    }
    /* unsort */
    nk_rp_qsort(rects, num_rects as Uint, Some(nk_rect_original_order));
    /* set was_packed flags */
    i = 0i32;
    while i < num_rects {
        (*rects.offset(i as isize)).was_packed = !((*rects.offset(i as isize)).x as Int == 65535i32
            && (*rects.offset(i as isize)).y as Int == 65535i32)
            as Int;
        i += 1
    }
}

unsafe fn nk_rect_original_order(mut a: *const Void, mut b: *const Void) -> Int {
    let mut p: *const RpRect = a as *const RpRect;
    let mut q: *const RpRect = b as *const RpRect;
    return if (*p).was_packed < (*q).was_packed {
        -1i32
    } else {
        ((*p).was_packed > (*q).was_packed) as Int
    };
}

unsafe fn nk_rp_qsort(
    mut array: *mut RpRect,
    mut len: Uint,
    mut cmp: Option<unsafe fn(_: *const Void, _: *const Void) -> Int>,
) -> () {
    let mut right: Uint = 0;
    let mut left: Uint = 0i32 as Uint;
    let mut stack: [Uint; 64] = [0; 64];
    /* iterative quick sort */
    let mut pos: Uint = 0i32 as Uint;
    let mut seed: Uint = len
        .wrapping_div(2i32 as Uint)
        .wrapping_mul(69069i32 as Uint)
        .wrapping_add(1i32 as Uint);
    loop {
        if left.wrapping_add(1i32 as Uint) < len {
            let mut pivot: RpRect = RpRect {
                id: 0,
                w: 0,
                h: 0,
                x: 0,
                y: 0,
                was_packed: 0,
            };
            let mut tmp: RpRect = RpRect {
                id: 0,
                w: 0,
                h: 0,
                x: 0,
                y: 0,
                was_packed: 0,
            };
            if pos == 64i32 as Uint {
                pos = 0i32 as Uint;
                len = stack[pos as usize]
            }
            pivot = *array
                .offset(left.wrapping_add(seed.wrapping_rem(len.wrapping_sub(left))) as isize);
            seed = seed
                .wrapping_mul(69069i32 as Uint)
                .wrapping_add(1i32 as Uint);
            let fresh80 = pos;
            pos = pos.wrapping_add(1);
            stack[fresh80 as usize] = len;
            right = left.wrapping_sub(1i32 as Uint);
            loop {
                right = right.wrapping_add(1);
                if cmp.expect("non-null function pointer")(
                    &mut *array.offset(right as isize) as *mut RpRect as *const Void,
                    &mut pivot as *mut RpRect as *const Void,
                ) < 0i32
                {
                    continue;
                }
                loop {
                    len = len.wrapping_sub(1);
                    if !(cmp.expect("non-null function pointer")(
                        &mut pivot as *mut RpRect as *const Void,
                        &mut *array.offset(len as isize) as *mut RpRect as *const Void,
                    ) < 0i32)
                    {
                        break;
                    }
                }
                if right >= len {
                    break;
                }
                tmp = *array.offset(right as isize);
                *array.offset(right as isize) = *array.offset(len as isize);
                *array.offset(len as isize) = tmp
            }
            len = len.wrapping_add(1)
        } else {
            if pos == 0i32 as Uint {
                break;
            }
            left = len;
            pos = pos.wrapping_sub(1);
            len = stack[pos as usize]
        }
    }
}

unsafe fn nk_rp__skyline_pack_rectangle(
    mut context: *mut RpContext,
    mut width: Int,
    mut height: Int,
) -> RpFindResult {
    let mut next_0: *mut RpNode = 0 as *mut RpNode;
    let mut next: *mut RpNode = 0 as *mut RpNode;
    /* find best position according to heuristic */
    let mut res: RpFindResult = nk_rp__skyline_find_best_pos(context, width, height);
    let mut node: *mut RpNode = 0 as *mut RpNode;
    let mut cur: *mut RpNode = 0 as *mut RpNode;
    /* bail if: */
    /*    1. it failed */
    /*    2. the best node doesn't fit (we don't always check this) */
    /*    3. we're out of memory */
    if res.prev_link.is_null()
        || res.y + height > (*context).height
        || (*context).free_head.is_null()
    {
        res.prev_link = 0 as *mut *mut RpNode;
        return res;
    } else {
        /* on success, create new node */
        node = (*context).free_head;
        (*node).x = res.x as RpCoord;
        (*node).y = (res.y + height) as RpCoord;
        (*context).free_head = (*node).next;
        /* insert the new node into the right starting point, and */
        /* let 'cur' point to the remaining nodes needing to be */
        /* stitched back in */
        cur = *res.prev_link;
        if ((*cur).x as Int) < res.x {
            /* preserve the existing one, so start testing with the next one */
            next = (*cur).next;
            (*cur).next = node;
            cur = next
        } else {
            *res.prev_link = node
        }
        /* from here, traverse cur and free the nodes, until we get to one */
        /* that shouldn't be freed */
        while !(*cur).next.is_null() && (*(*cur).next).x as Int <= res.x + width {
            next_0 = (*cur).next;
            /* move the current node to the free list */
            (*cur).next = (*context).free_head;
            (*context).free_head = cur;
            cur = next_0
        }
        /* stitch the list back in */
        (*node).next = cur;
        if ((*cur).x as Int) < res.x + width {
            (*cur).x = (res.x + width) as RpCoord
        }
        return res;
    };
}

unsafe fn nk_rp__skyline_find_best_pos(
    mut c: *mut RpContext,
    mut width: Int,
    mut height: Int,
) -> RpFindResult {
    let mut best_waste: Int = 1i32 << 30i32;
    let mut best_x: Int = 0;
    let mut best_y: Int = 1i32 << 30i32;
    let mut fr: RpFindResult = RpFindResult {
        x: 0,
        y: 0,
        prev_link: 0 as *mut *mut RpNode,
    };
    let mut prev: *mut *mut RpNode = 0 as *mut *mut RpNode;
    let mut node: *mut RpNode = 0 as *mut RpNode;
    let mut tail: *mut RpNode = 0 as *mut RpNode;
    let mut best: *mut *mut RpNode = 0 as *mut *mut RpNode;
    /* align to multiple of c->align */
    width = width + (*c).align - 1i32;
    width -= width % (*c).align;
    node = (*c).active_head;
    prev = &mut (*c).active_head as *mut *mut RpNode;
    while (*node).x as Int + width <= (*c).width {
        let mut y: Int = 0;
        let mut waste: Int = 0;
        y = nk_rp__skyline_find_min_y(c, node, (*node).x as Int, width, &mut waste);
        /* actually just want to test BL */
        if (*c).heuristic == NK_RP_HEURISTIC_Skyline_BL_sortHeight as Int {
            /* bottom left */
            if y < best_y {
                best_y = y;
                best = prev
            }
        } else if y + height <= (*c).height {
            /* can only use it if it first vertically */
            if y < best_y || y == best_y && waste < best_waste {
                best_y = y;
                best_waste = waste;
                best = prev
            }
        }
        prev = &mut (*node).next as *mut *mut RpNode;
        node = (*node).next
    }
    best_x = if best.is_null() {
        0i32
    } else {
        (**best).x as Int
    };
    /* if doing best-fit (BF), we also have to try aligning right edge to each node position */
    /* */
    /* e.g, if fitting */
    /* */
    /*     ____________________ */
    /*    |____________________| */
    /* */
    /*            into */
    /* */
    /*   |                         | */
    /*   |             ____________| */
    /*   |____________| */
    /* */
    /* then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned */
    /* */
    /* This makes BF take about 2x the time */
    if (*c).heuristic == NK_RP_HEURISTIC_Skyline_BF_sortHeight as Int {
        tail = (*c).active_head;
        node = (*c).active_head;
        prev = &mut (*c).active_head as *mut *mut RpNode;
        /* find first node that's admissible */
        while ((*tail).x as Int) < width {
            tail = (*tail).next
        }
        while !tail.is_null() {
            let mut xpos: Int = (*tail).x as Int - width;
            let mut y_0: Int = 0;
            let mut waste_0: Int = 0;
            /* find the left position that matches this */
            while (*(*node).next).x as Int <= xpos {
                prev = &mut (*node).next as *mut *mut RpNode;
                node = (*node).next
            }
            y_0 = nk_rp__skyline_find_min_y(c, node, xpos, width, &mut waste_0);
            if y_0 + height < (*c).height {
                if y_0 <= best_y {
                    if y_0 < best_y
                        || waste_0 < best_waste
                        || waste_0 == best_waste && xpos < best_x
                    {
                        best_x = xpos;
                        best_y = y_0;
                        best_waste = waste_0;
                        best = prev
                    }
                }
            }
            tail = (*tail).next
        }
    }
    fr.prev_link = best;
    fr.x = best_x;
    fr.y = best_y;
    return fr;
}

unsafe fn nk_rp__skyline_find_min_y(
    mut c: *mut RpContext,
    mut first: *mut RpNode,
    mut x0: Int,
    mut width: Int,
    mut pwaste: *mut Int,
) -> Int {
    let mut node: *mut RpNode = first;
    let mut x1: Int = x0 + width;
    let mut min_y: Int = 0;
    let mut visited_width: Int = 0;
    let mut waste_area: Int = 0;
    /* we ended up handling this in the caller for efficiency */
    min_y = 0i32;
    waste_area = 0i32;
    visited_width = 0i32;
    while ((*node).x as Int) < x1 {
        if (*node).y as Int > min_y {
            /* raise min_y higher. */
            /* we've accounted for all waste up to min_y, */
            /* but we'll now add more waste for everything we've visited */
            waste_area += visited_width * ((*node).y as Int - min_y);
            min_y = (*node).y as Int;
            /* the first time through, visited_width might be reduced */
            if ((*node).x as Int) < x0 {
                visited_width += (*(*node).next).x as Int - x0
            } else {
                visited_width += (*(*node).next).x as Int - (*node).x as Int
            }
        } else {
            /* add waste area */
            let mut under_width: Int = (*(*node).next).x as Int - (*node).x as Int;
            if under_width + visited_width > width {
                under_width = width - visited_width
            }
            waste_area += under_width * (min_y - (*node).y as Int);
            visited_width += under_width
        }
        node = (*node).next
    }
    *pwaste = waste_area;
    return min_y;
}

unsafe fn nk_rect_height_compare(mut a: *const Void, mut b: *const Void) -> Int {
    let mut p: *const RpRect = a as *const RpRect;
    let mut q: *const RpRect = b as *const RpRect;
    if (*p).h as Int > (*q).h as Int {
        return -1i32;
    } else if ((*p).h as Int) < (*q).h as Int {
        return 1i32;
    } else {
        return if (*p).w as Int > (*q).w as Int {
            -1i32
        } else {
            (((*p).w as Int) < (*q).w as Int) as Int
        };
    };
}

unsafe fn nk_tt_PackFontRangesGatherRects(
    mut spc: *mut TtPackContext,
    mut info: *mut TtFontInfo,
    mut ranges: *mut TtPackRange,
    mut num_ranges: Int,
    mut rects: *mut RpRect,
) -> Int {
    let mut i: Int = 0;
    let mut j: Int = 0;
    /* rects array must be big enough to accommodate all characters in the given ranges */
    let mut k: Int = 0;
    k = 0i32;
    i = 0i32;
    while i < num_ranges {
        let mut fh: f32 = (*ranges.offset(i as isize)).font_size;
        let mut scale: f32 = if fh > 0i32 as f32 {
            nk_tt_ScaleForPixelHeight(info, fh)
        } else {
            nk_tt_ScaleForMappingEmToPixels(info, -fh)
        };
        (*ranges.offset(i as isize)).h_oversample = (*spc).h_oversample as Uchar;
        (*ranges.offset(i as isize)).v_oversample = (*spc).v_oversample as Uchar;
        j = 0i32;
        while j < (*ranges.offset(i as isize)).num_chars {
            let mut x0: Int = 0;
            let mut y0: Int = 0;
            let mut x1: Int = 0;
            let mut y1: Int = 0;
            let mut codepoint: Int =
                if 0 != (*ranges.offset(i as isize)).first_unicode_codepoint_in_range {
                    (*ranges.offset(i as isize)).first_unicode_codepoint_in_range + j
                } else {
                    *(*ranges.offset(i as isize))
                        .array_of_unicode_codepoints
                        .offset(j as isize)
                };
            let mut glyph: Int = nk_tt_FindGlyphIndex(info, codepoint);
            nk_tt_GetGlyphBitmapBoxSubpixel(
                info,
                glyph,
                scale * (*spc).h_oversample as f32,
                scale * (*spc).v_oversample as f32,
                0i32 as f32,
                0i32 as f32,
                &mut x0,
                &mut y0,
                &mut x1,
                &mut y1,
            );
            (*rects.offset(k as isize)).w =
                (x1 - x0 + (*spc).padding + (*spc).h_oversample as Int - 1i32) as RpCoord;
            (*rects.offset(k as isize)).h =
                (y1 - y0 + (*spc).padding + (*spc).v_oversample as Int - 1i32) as RpCoord;
            k += 1;
            j += 1
        }
        i += 1
    }
    return k;
}

unsafe fn nk_tt_PackBegin(
    mut spc: *mut TtPackContext,
    mut pixels: *mut Uchar,
    mut pw: Int,
    mut ph: Int,
    mut stride_in_bytes: Int,
    mut padding: Int,
    mut alloc: *mut Allocator,
) -> Int {
    let mut num_nodes: Int = pw - padding;
    let mut context: *mut RpContext = (*alloc).alloc.expect("non-null function pointer")(
        (*alloc).userdata,
        0 as *mut Void,
        mem::size_of::<RpContext>() as Ulong,
    ) as *mut RpContext;
    let mut nodes: *mut RpNode = (*alloc).alloc.expect("non-null function pointer")(
        (*alloc).userdata,
        0 as *mut Void,
        (mem::size_of::<RpNode>() as Ulong).wrapping_mul(num_nodes as Size),
    ) as *mut RpNode;
    if context.is_null() || nodes.is_null() {
        if !context.is_null() {
            (*alloc).free.expect("non-null function pointer")(
                (*alloc).userdata,
                context as *mut Void,
            );
        }
        if !nodes.is_null() {
            (*alloc).free.expect("non-null function pointer")(
                (*alloc).userdata,
                nodes as *mut Void,
            );
        }
        return 0i32;
    } else {
        (*spc).width = pw;
        (*spc).height = ph;
        (*spc).pixels = pixels;
        (*spc).pack_info = context as *mut Void;
        (*spc).nodes = nodes as *mut Void;
        (*spc).padding = padding;
        (*spc).stride_in_bytes = if stride_in_bytes != 0i32 {
            stride_in_bytes
        } else {
            pw
        };
        (*spc).h_oversample = 1i32 as Uint;
        (*spc).v_oversample = 1i32 as Uint;
        nk_rp_init_target(context, pw - padding, ph - padding, nodes, num_nodes);
        if !pixels.is_null() {
            nk_memset(pixels as *mut Void, 0i32, (pw * ph) as Size);
        }
        /* background of 0 around pixels */
        return 1i32;
    };
}

unsafe fn nk_rp_init_target(
    mut context: *mut RpContext,
    mut width: Int,
    mut height: Int,
    mut nodes: *mut RpNode,
    mut num_nodes: Int,
) -> () {
    let mut i: Int = 0;
    i = 0i32;
    while i < num_nodes - 1i32 {
        let ref mut fresh81 = (*nodes.offset(i as isize)).next;
        *fresh81 = &mut *nodes.offset((i + 1i32) as isize) as *mut RpNode;
        i += 1
    }
    let ref mut fresh82 = (*nodes.offset(i as isize)).next;
    *fresh82 = 0 as *mut RpNode;
    (*context).init_mode = NK_RP__INIT_skyline as Int;
    (*context).heuristic = NK_RP_HEURISTIC_Skyline_default as Int;
    (*context).free_head = &mut *nodes.offset(0isize) as *mut RpNode;
    (*context).active_head = &mut (*context).extra[0usize] as *mut RpNode;
    (*context).width = width;
    (*context).height = height;
    (*context).num_nodes = num_nodes;
    nk_rp_setup_allow_out_of_mem(context, 0i32);
    /* node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly) */
    (*context).extra[0usize].x = 0i32 as RpCoord;
    (*context).extra[0usize].y = 0i32 as RpCoord;
    (*context).extra[0usize].next = &mut (*context).extra[1usize] as *mut RpNode;
    (*context).extra[1usize].x = width as RpCoord;
    (*context).extra[1usize].y = 65535i32 as RpCoord;
    (*context).extra[1usize].next = 0 as *mut RpNode;
}
unsafe fn nk_rp_setup_allow_out_of_mem(
    mut context: *mut RpContext,
    mut allow_out_of_mem: Int,
) -> () {
    if 0 != allow_out_of_mem {
        /* if it's ok to run out of memory, then don't bother aligning them; */
        /* this gives better packing, but may fail due to OOM (even though */
        /* the rectangles easily fit). @TODO a smarter approach would be to only */
        /* quantize once we've hit OOM, then we could get rid of this parameter. */
        (*context).align = 1i32
    } else {
        (*context).align = ((*context).width + (*context).num_nodes - 1i32) / (*context).num_nodes
    };
}
unsafe fn nk_tt_InitFont(
    mut info: *mut TtFontInfo,
    mut data2: *const Uchar,
    mut fontstart: Int,
) -> Int {
    let mut cmap: u32 = 0;
    let mut t: u32 = 0;
    let mut i: i32 = 0;
    let mut numTables: i32 = 0;
    let mut data: *const u8 = data2;
    (*info).data = data;
    (*info).fontstart = fontstart;
    /* required */
    cmap = nk_tt__find_table(
        data,
        fontstart as u32,
        b"cmap\x00" as *const u8 as *const Char,
    );
    /* required */
    (*info).loca = nk_tt__find_table(
        data,
        fontstart as u32,
        b"loca\x00" as *const u8 as *const Char,
    ) as Int;
    /* required */
    (*info).head = nk_tt__find_table(
        data,
        fontstart as u32,
        b"head\x00" as *const u8 as *const Char,
    ) as Int;
    /* required */
    (*info).glyf = nk_tt__find_table(
        data,
        fontstart as u32,
        b"glyf\x00" as *const u8 as *const Char,
    ) as Int;
    /* required */
    (*info).hhea = nk_tt__find_table(
        data,
        fontstart as u32,
        b"hhea\x00" as *const u8 as *const Char,
    ) as Int;
    /* required */
    (*info).hmtx = nk_tt__find_table(
        data,
        fontstart as u32,
        b"hmtx\x00" as *const u8 as *const Char,
    ) as Int;
    /* not required */
    (*info).kern = nk_tt__find_table(
        data,
        fontstart as u32,
        b"kern\x00" as *const u8 as *const Char,
    ) as Int;
    if 0 == cmap
        || 0 == (*info).loca
        || 0 == (*info).head
        || 0 == (*info).glyf
        || 0 == (*info).hhea
        || 0 == (*info).hmtx
    {
        return 0i32;
    } else {
        t = nk_tt__find_table(
            data,
            fontstart as u32,
            b"maxp\x00" as *const u8 as *const Char,
        );
        if 0 != t {
            (*info).numGlyphs = nk_ttUSHORT(data.offset(t as isize).offset(4isize)) as Int
        } else {
            (*info).numGlyphs = 65535i32
        }
        /* find a cmap encoding table we understand *now* to avoid searching */
        /* later. (todo: could make this installable) */
        /* the same regardless of glyph. */
        numTables = nk_ttUSHORT(data.offset(cmap as isize).offset(2isize)) as i32;
        (*info).index_map = 0i32;
        i = 0i32;
        while i < numTables {
            let mut encoding_record: u32 = cmap
                .wrapping_add(4i32 as Uint)
                .wrapping_add((8i32 as Uint).wrapping_mul(i as u32));
            /* find an encoding we understand: */
            match nk_ttUSHORT(data.offset(encoding_record as isize)) as Int {
                3 => {
                    match nk_ttUSHORT(data.offset(encoding_record as isize).offset(2isize)) as Int {
                        1 | 10 => {
                            /* MS/Unicode */
                            (*info).index_map = cmap.wrapping_add(nk_ttULONG(
                                data.offset(encoding_record as isize).offset(4isize),
                            )) as Int
                        }
                        _ => {}
                    }
                }
                0 => {
                    /* Mac/iOS has these */
                    /* all the encodingIDs are unicode, so we don't bother to check it */
                    (*info).index_map = cmap.wrapping_add(nk_ttULONG(
                        data.offset(encoding_record as isize).offset(4isize),
                    )) as Int
                }
                _ => {}
            }
            i += 1
        }
        if (*info).index_map == 0i32 {
            return 0i32;
        } else {
            (*info).indexToLocFormat =
                nk_ttUSHORT(data.offset((*info).head as isize).offset(50isize)) as Int;
            return 1i32;
        }
    };
}
unsafe fn nk_tt__find_table(mut data: *const u8, mut fontstart: u32, mut tag: *const Char) -> u32 {
    /* @OPTIMIZE: binary search */
    let mut num_tables: i32 = nk_ttUSHORT(data.offset(fontstart as isize).offset(4isize)) as i32;
    let mut tabledir: u32 = fontstart.wrapping_add(12i32 as Uint);
    let mut i: i32 = 0;
    i = 0i32;
    while i < num_tables {
        let mut loc: u32 = tabledir.wrapping_add((16i32 * i) as u32);
        if *data.offset(loc as isize).offset(0isize).offset(0isize) as Int
            == *tag.offset(0isize) as Int
            && *data.offset(loc as isize).offset(0isize).offset(1isize) as Int
                == *tag.offset(1isize) as Int
            && *data.offset(loc as isize).offset(0isize).offset(2isize) as Int
                == *tag.offset(2isize) as Int
            && *data.offset(loc as isize).offset(0isize).offset(3isize) as Int
                == *tag.offset(3isize) as Int
        {
            return nk_ttULONG(data.offset(loc as isize).offset(8isize));
        } else {
            i += 1
        }
    }
    return 0i32 as u32;
}
unsafe fn nk_range_glyph_count(mut range: *const Rune, mut count: Int) -> Int {
    let mut i: Int = 0i32;
    let mut total_glyphs: Int = 0i32;
    i = 0i32;
    while i < count {
        let mut diff: Int = 0;
        let mut f: Rune = *range.offset((i * 2i32 + 0i32) as isize);
        let mut t: Rune = *range.offset((i * 2i32 + 1i32) as isize);
        diff = t.wrapping_sub(f).wrapping_add(1i32 as Uint) as Int;
        total_glyphs += diff;
        i += 1
    }
    return total_glyphs;
}
unsafe fn FontBaker(
    mut memory: *mut Void,
    mut glyph_count: Int,
    mut count: Int,
    mut alloc: *mut Allocator,
) -> *mut FontBaker {
    let mut baker: *mut FontBaker = 0 as *mut FontBaker;
    if memory.is_null() {
        return 0 as *mut FontBaker;
    } else {
        /* setup baker inside a memory block  */
        baker = ((memory as *mut u8).offset(nk_baker_align.wrapping_sub(1i32 as Ulong) as isize)
            as Long as Size & !nk_baker_align.wrapping_sub(1i32 as Ulong)) as Long
            as *mut Void as *mut FontBaker;
        (*baker).build = ((baker.offset(1isize) as *mut u8)
            .offset(nk_build_align.wrapping_sub(1i32 as Ulong) as isize)
            as Long as Size & !nk_build_align.wrapping_sub(1i32 as Ulong))
            as Long as *mut Void as *mut FontBackData;
        (*baker).packed_chars = (((*baker).build.offset(count as isize) as *mut u8)
            .offset(nk_char_align.wrapping_sub(1i32 as Ulong) as isize)
            as Long as Size
            & !nk_char_align.wrapping_sub(1i32 as Ulong)) as Long
            as *mut Void as *mut TtPackedChar;
        (*baker).rects = (((*baker).packed_chars.offset(glyph_count as isize) as *mut u8)
            .offset(nk_rect_align.wrapping_sub(1i32 as Ulong) as isize)
            as Long as Size & !nk_rect_align.wrapping_sub(1i32 as Ulong))
            as Long as *mut Void as *mut RpRect;
        (*baker).ranges = (((*baker).rects.offset(glyph_count as isize) as *mut u8)
            .offset(nk_range_align.wrapping_sub(1i32 as Ulong) as isize)
            as Long as Size
            & !nk_range_align.wrapping_sub(1i32 as Ulong)) as Long
            as *mut Void as *mut TtPackRange;
        (*baker).alloc = *alloc;
        return baker;
    };
}

const nk_range_align: Size = mem::align_of::<TtPackRange>() as Size;
const nk_rect_align: Size = mem::align_of::<RpRect>() as Size;
const nk_char_align: Size = mem::align_of::<TtPackedChar>() as Size;
const nk_build_align: Size = mem::align_of::<FontBackData>() as Size;
const nk_baker_align: Size = mem::align_of::<FontBaker>() as Size;

unsafe fn nk_font_baker_memory(
    mut temp: *mut Size,
    mut glyph_count: *mut Int,
    mut config_list: *mut FontConfig,
    mut count: Int,
) -> () {
    let mut range_count: Int = 0i32;
    let mut total_range_count: Int = 0i32;
    let mut iter: *mut FontConfig = 0 as *mut FontConfig;
    let mut i: *mut FontConfig = 0 as *mut FontConfig;
    if config_list.is_null() {
        *temp = 0i32 as Size;
        *glyph_count = 0i32;
        return;
    } else {
        *glyph_count = 0i32;
        iter = config_list;
        while !iter.is_null() {
            i = iter;
            loop {
                if (*i).range.is_null() {
                    (*iter).range = nk_font_default_glyph_ranges()
                }
                range_count = nk_range_count((*i).range);
                total_range_count += range_count;
                *glyph_count += nk_range_glyph_count((*i).range, range_count);
                i = (*i).n;
                if !(i != iter) {
                    break;
                }
            }
            iter = (*iter).next
        }
        *temp = (*glyph_count as Size).wrapping_mul(mem::size_of::<RpRect>() as Ulong);
        *temp = (*temp as Ulong).wrapping_add(
            (total_range_count as Size).wrapping_mul(mem::size_of::<TtPackRange>() as Ulong),
        ) as Size as Size;
        *temp = (*temp as Ulong).wrapping_add(
            (*glyph_count as Size).wrapping_mul(mem::size_of::<TtPackedChar>() as Ulong),
        ) as Size as Size;
        *temp = (*temp as Ulong)
            .wrapping_add((count as Size).wrapping_mul(mem::size_of::<FontBackData>() as Ulong))
            as Size as Size;
        *temp = (*temp as Ulong).wrapping_add(mem::size_of::<FontBaker>() as Ulong) as Size as Size;
        *temp = (*temp as Ulong).wrapping_add(
            nk_rect_align
                .wrapping_add(nk_range_align)
                .wrapping_add(nk_char_align),
        ) as Size as Size;
        *temp = (*temp as Ulong).wrapping_add(nk_build_align.wrapping_add(nk_baker_align)) as Size
            as Size;
        return;
    };
}

pub unsafe fn nk_font_atlas_end(
    mut atlas: *mut FontAtlas,
    mut texture: Handle,
    mut null: *mut DrawNullTexture,
) -> () {
    let mut i: Int = 0i32;
    let mut font_iter: *mut Font = 0 as *mut Font;
    if atlas.is_null() {
        if null.is_null() {
            return;
        } else {
            (*null).texture = texture;
            (*null).uv = Point::new(0.5f32, 0.5f32)
        }
    }
    if !null.is_null() {
        (*null).texture = texture;
        (*null).uv.x = ((*atlas).custom.x as Int as f32 + 0.5f32) / (*atlas).tex_width as f32;
        (*null).uv.y = ((*atlas).custom.y as Int as f32 + 0.5f32) / (*atlas).tex_height as f32
    }
    font_iter = (*atlas).fonts;
    while !font_iter.is_null() {
        (*font_iter).texture = texture;
        (*font_iter).handle.texture = texture;
        font_iter = (*font_iter).next
    }
    i = 0i32;
    while i < NK_CURSOR_COUNT as Int {
        (*atlas).cursors[i as usize].img.handle = texture;
        i += 1
    }
    (*atlas).temporary.free.expect("non-null function pointer")(
        (*atlas).temporary.userdata,
        (*atlas).pixel,
    );
    (*atlas).pixel = 0 as *mut Void;
    (*atlas).tex_width = 0i32;
    (*atlas).tex_height = 0i32;
    (*atlas).custom.x = 0i32 as Short;
    (*atlas).custom.y = 0i32 as Short;
    (*atlas).custom.w = 0i32 as Short;
    (*atlas).custom.h = 0i32 as Short;
}

pub unsafe fn nk_font_atlas_cleanup(mut atlas: *mut FontAtlas) -> () {
    if atlas.is_null() || (*atlas).permanent.alloc.is_none() || (*atlas).permanent.free.is_none() {
        return;
    } else {
        if !(*atlas).config.is_null() {
            let mut iter: *mut FontConfig = 0 as *mut FontConfig;
            iter = (*atlas).config;
            while !iter.is_null() {
                let mut i: *mut FontConfig = 0 as *mut FontConfig;
                i = (*iter).n;
                while i != iter {
                    (*atlas).permanent.free.expect("non-null function pointer")(
                        (*atlas).permanent.userdata,
                        (*i).ttf_blob,
                    );
                    (*i).ttf_blob = 0 as *mut Void;
                    i = (*i).n
                }
                (*atlas).permanent.free.expect("non-null function pointer")(
                    (*atlas).permanent.userdata,
                    (*iter).ttf_blob,
                );
                (*iter).ttf_blob = 0 as *mut Void;
                iter = (*iter).next
            }
        }
        return;
    };
}

pub unsafe fn nk_font_atlas_clear(mut atlas: *mut FontAtlas) -> () {
    if atlas.is_null() || (*atlas).permanent.alloc.is_none() || (*atlas).permanent.free.is_none() {
        return;
    } else {
        if !(*atlas).config.is_null() {
            let mut iter: *mut FontConfig = 0 as *mut FontConfig;
            let mut next: *mut FontConfig = 0 as *mut FontConfig;
            iter = (*atlas).config;
            while !iter.is_null() {
                let mut i: *mut FontConfig = 0 as *mut FontConfig;
                let mut n: *mut FontConfig = 0 as *mut FontConfig;
                i = (*iter).n;
                while i != iter {
                    n = (*i).n;
                    if !(*i).ttf_blob.is_null() {
                        (*atlas).permanent.free.expect("non-null function pointer")(
                            (*atlas).permanent.userdata,
                            (*i).ttf_blob,
                        );
                    }
                    (*atlas).permanent.free.expect("non-null function pointer")(
                        (*atlas).permanent.userdata,
                        i as *mut Void,
                    );
                    i = n
                }
                next = (*iter).next;
                if !(*i).ttf_blob.is_null() {
                    (*atlas).permanent.free.expect("non-null function pointer")(
                        (*atlas).permanent.userdata,
                        (*iter).ttf_blob,
                    );
                }
                (*atlas).permanent.free.expect("non-null function pointer")(
                    (*atlas).permanent.userdata,
                    iter as *mut Void,
                );
                iter = next
            }
            (*atlas).config = 0 as *mut FontConfig
        }
        if !(*atlas).fonts.is_null() {
            let mut iter_0: *mut Font = 0 as *mut Font;
            let mut next_0: *mut Font = 0 as *mut Font;
            iter_0 = (*atlas).fonts;
            while !iter_0.is_null() {
                next_0 = (*iter_0).next;
                (*atlas).permanent.free.expect("non-null function pointer")(
                    (*atlas).permanent.userdata,
                    iter_0 as *mut Void,
                );
                iter_0 = next_0
            }
            (*atlas).fonts = 0 as *mut Font
        }
        if !(*atlas).glyphs.is_null() {
            (*atlas).permanent.free.expect("non-null function pointer")(
                (*atlas).permanent.userdata,
                (*atlas).glyphs as *mut Void,
            );
        }
        nk_zero(atlas as *mut Void, mem::size_of::<FontAtlas>() as Ulong);
        return;
    };
}

pub unsafe fn nk_buffer_init_default(mut buffer: *mut Buffer) -> () {
    let mut alloc: Allocator = Allocator {
        userdata: Handle {
            ptr: 0 as *mut Void,
        },
        alloc: None,
        free: None,
    };
    alloc.userdata.ptr = 0 as *mut Void;
    alloc.alloc = Some(nk_malloc);
    alloc.free = Some(nk_mfree);
    nk_buffer_init(buffer, &mut alloc, (4i32 * 1024i32) as Size);
}

pub unsafe fn nk_buffer_info(mut s: *mut MemoryStatus, mut b: *mut Buffer) -> () {
    if s.is_null() || b.is_null() {
        return;
    } else {
        (*s).allocated = (*b).allocated;
        (*s).size = (*b).memory.size;
        (*s).needed = (*b).needed;
        (*s).memory = (*b).memory.ptr;
        (*s).calls = (*b).calls;
        return;
    };
}

pub unsafe fn nk_buffer_push(
    mut b: *mut Buffer,
    mut type_0: BufferAllocationType,
    mut memory: *const Void,
    mut size: Size,
    mut align: Size,
) -> () {
    let mut mem: *mut Void = nk_buffer_alloc(b, type_0, size, align);
    if mem.is_null() {
        return;
    } else {
        nk_memcopy(mem, memory, size);
        return;
    };
}

pub unsafe fn nk_buffer_memory_const(mut buffer: *const Buffer) -> *const Void {
    if buffer.is_null() {
        return 0 as *const Void;
    } else {
        return (*buffer).memory.ptr;
    };
}

pub unsafe fn nk_str_init_default(mut str: *mut Str) -> () {
    let mut alloc: Allocator = Allocator {
        userdata: Handle {
            ptr: 0 as *mut Void,
        },
        alloc: None,
        free: None,
    };
    alloc.userdata.ptr = 0 as *mut Void;
    alloc.alloc = Some(nk_malloc);
    alloc.free = Some(nk_mfree);
    nk_buffer_init(&mut (*str).buffer, &mut alloc, 32i32 as Size);
    (*str).len = 0i32;
}

pub unsafe fn nk_str_init(mut str: *mut Str, mut alloc: *const Allocator, mut size: Size) -> () {
    nk_buffer_init(&mut (*str).buffer, alloc, size);
    (*str).len = 0i32;
}

pub unsafe fn nk_str_clear(mut str: *mut Str) -> () {
    nk_buffer_clear(&mut (*str).buffer);
    (*str).len = 0i32;
}

pub unsafe fn nk_str_free(mut str: *mut Str) -> () {
    nk_buffer_free(&mut (*str).buffer);
    (*str).len = 0i32;
}

pub unsafe fn nk_str_append_str_char(mut s: *mut Str, mut str: *const Char) -> Int {
    return nk_str_append_text_char(s, str, nk_strlen(str));
}

pub unsafe fn nk_str_append_text_utf8(
    mut str: *mut Str,
    mut text: *const Char,
    mut len: Int,
) -> Int {
    let mut i: Int = 0i32;
    let mut byte_len: Int = 0i32;
    let mut unicode: Rune = 0;
    if str.is_null() || text.is_null() || 0 == len {
        return 0i32;
    } else {
        i = 0i32;
        while i < len {
            byte_len += nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
            i += 1
        }
        nk_str_append_text_char(str, text, byte_len);
        return len;
    };
}

pub unsafe fn nk_str_append_str_utf8(mut str: *mut Str, mut text: *const Char) -> Int {
    let mut runes: Int = 0i32;
    let mut byte_len: Int = 0i32;
    let mut num_runes: Int = 0i32;
    let mut glyph_len: Int = 0i32;
    let mut unicode: Rune = 0;
    if str.is_null() || text.is_null() {
        return 0i32;
    } else {
        byte_len = nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
        glyph_len = byte_len;
        while unicode != '\u{0}' as i32 as Uint && 0 != glyph_len {
            glyph_len = nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
            byte_len += glyph_len;
            num_runes += 1
        }
        nk_str_append_text_char(str, text, byte_len);
        return runes;
    };
}

pub unsafe fn nk_str_append_text_runes(
    mut str: *mut Str,
    mut text: *const Rune,
    mut len: Int,
) -> Int {
    let mut i: Int = 0i32;
    let mut byte_len: Int = 0i32;
    let mut glyph: Glyph = [0; 4];
    if str.is_null() || text.is_null() || 0 == len {
        return 0i32;
    } else {
        i = 0i32;
        while i < len {
            byte_len = nk_utf_encode(*text.offset(i as isize), glyph.as_mut_ptr(), 4i32);
            if 0 == byte_len {
                break;
            }
            nk_str_append_text_char(str, glyph.as_mut_ptr(), byte_len);
            i += 1
        }
        return len;
    };
}

pub unsafe fn nk_str_append_str_runes(mut str: *mut Str, mut runes: *const Rune) -> Int {
    let mut i: Int = 0i32;
    let mut glyph: Glyph = [0; 4];
    let mut byte_len: Int = 0;
    if str.is_null() || runes.is_null() {
        return 0i32;
    } else {
        while *runes.offset(i as isize) != '\u{0}' as i32 as Uint {
            byte_len = nk_utf_encode(*runes.offset(i as isize), glyph.as_mut_ptr(), 4i32);
            nk_str_append_text_char(str, glyph.as_mut_ptr(), byte_len);
            i += 1
        }
        return i;
    };
}

pub unsafe fn nk_str_insert_text_char(
    mut str: *mut Str,
    mut pos: Int,
    mut text: *const Char,
    mut len: Int,
) -> Int {
    return nk_str_insert_text_utf8(str, pos, text, len);
}

pub unsafe fn nk_str_insert_str_char(
    mut str: *mut Str,
    mut pos: Int,
    mut text: *const Char,
) -> Int {
    return nk_str_insert_text_utf8(str, pos, text, nk_strlen(text));
}

pub unsafe fn nk_str_insert_str_utf8(
    mut str: *mut Str,
    mut pos: Int,
    mut text: *const Char,
) -> Int {
    let mut runes: Int = 0i32;
    let mut byte_len: Int = 0i32;
    let mut num_runes: Int = 0i32;
    let mut glyph_len: Int = 0i32;
    let mut unicode: Rune = 0;
    if str.is_null() || text.is_null() {
        return 0i32;
    } else {
        byte_len = nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
        glyph_len = byte_len;
        while unicode != '\u{0}' as i32 as Uint && 0 != glyph_len {
            glyph_len = nk_utf_decode(text.offset(byte_len as isize), &mut unicode, 4i32);
            byte_len += glyph_len;
            num_runes += 1
        }
        nk_str_insert_at_rune(str, pos, text, byte_len);
        return runes;
    };
}

pub unsafe fn nk_str_insert_str_runes(
    mut str: *mut Str,
    mut pos: Int,
    mut runes: *const Rune,
) -> Int {
    let mut i: Int = 0i32;
    let mut glyph: Glyph = [0; 4];
    let mut byte_len: Int = 0;
    if str.is_null() || runes.is_null() {
        return 0i32;
    } else {
        while *runes.offset(i as isize) != '\u{0}' as i32 as Uint {
            byte_len = nk_utf_encode(*runes.offset(i as isize), glyph.as_mut_ptr(), 4i32);
            nk_str_insert_at_rune(str, pos + i, glyph.as_mut_ptr(), byte_len);
            i += 1
        }
        return i;
    };
}

pub unsafe fn nk_str_remove_runes(mut str: *mut Str, mut len: Int) -> () {
    let mut index: Int = 0;
    let mut begin: *const Char = 0 as *const Char;
    let mut end: *const Char = 0 as *const Char;
    let mut unicode: Rune = 0;
    if str.is_null() || len < 0i32 {
        return;
    } else if len >= (*str).len {
        (*str).len = 0i32;
        return;
    } else {
        index = (*str).len - len;
        begin = nk_str_at_rune(str, index, &mut unicode, &mut len);
        end = ((*str).buffer.memory.ptr as *const Char).offset((*str).buffer.allocated as isize);
        nk_str_remove_chars(
            str,
            begin.ptr_offset_to(end).expect("bad offset_to") as Long as Int + 1i32,
        );
        return;
    };
}

pub unsafe fn nk_str_at_char(mut s: *mut Str, mut pos: Int) -> *mut Char {
    if s.is_null() || pos > (*s).buffer.allocated as Int {
        return 0 as *mut Char;
    } else {
        return ((*s).buffer.memory.ptr as *mut u8).offset(pos as isize) as *mut Void as *mut Char;
    };
}

pub unsafe fn nk_str_at_char_const(mut s: *const Str, mut pos: Int) -> *const Char {
    if s.is_null() || pos > (*s).buffer.allocated as Int {
        return 0 as *const Char;
    } else {
        return ((*s).buffer.memory.ptr as *mut u8).offset(pos as isize) as *mut Void as *mut Char;
    };
}

pub unsafe fn nk_str_get(mut s: *mut Str) -> *mut Char {
    if s.is_null() || 0 == (*s).len || 0 == (*s).buffer.allocated {
        return 0 as *mut Char;
    } else {
        return (*s).buffer.memory.ptr as *mut Char;
    };
}

pub unsafe fn nk_filter_ascii(mut box_0: *const TextEdit, mut unicode: Rune) -> Int {
    if unicode > 128i32 as Uint {
        return nk_false as Int;
    } else {
        return nk_true as Int;
    };
}

pub unsafe fn nk_filter_hex(mut box_0: *const TextEdit, mut unicode: Rune) -> Int {
    if (unicode < '0' as i32 as Uint || unicode > '9' as i32 as Uint)
        && (unicode < 'a' as i32 as Uint || unicode > 'f' as i32 as Uint)
        && (unicode < 'A' as i32 as Uint || unicode > 'F' as i32 as Uint)
    {
        return nk_false as Int;
    } else {
        return nk_true as Int;
    };
}

pub unsafe fn nk_filter_oct(mut box_0: *const TextEdit, mut unicode: Rune) -> Int {
    if unicode < '0' as i32 as Uint || unicode > '7' as i32 as Uint {
        return nk_false as Int;
    } else {
        return nk_true as Int;
    };
}

pub unsafe fn nk_filter_binary(mut box_0: *const TextEdit, mut unicode: Rune) -> Int {
    if unicode != '0' as i32 as Uint && unicode != '1' as i32 as Uint {
        return nk_false as Int;
    } else {
        return nk_true as Int;
    };
}

pub unsafe fn nk_textedit_init_default(mut state: *mut TextEdit) -> () {
    if state.is_null() {
        return;
    } else {
        nk_memset(
            state as *mut Void,
            0i32,
            mem::size_of::<TextEdit>() as Ulong,
        );
        nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, None);
        nk_str_init_default(&mut (*state).string);
        return;
    };
}

pub unsafe fn nk_textedit_init(
    mut state: *mut TextEdit,
    mut alloc: *mut Allocator,
    mut size: Size,
) -> () {
    if state.is_null() || alloc.is_null() {
        return;
    } else {
        nk_memset(
            state as *mut Void,
            0i32,
            mem::size_of::<TextEdit>() as Ulong,
        );
        nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, None);
        nk_str_init(&mut (*state).string, alloc, size);
        return;
    };
}

pub unsafe fn nk_textedit_init_fixed(
    mut state: *mut TextEdit,
    mut memory: *mut Void,
    mut size: Size,
) -> () {
    if state.is_null() || memory.is_null() || 0 == size {
        return;
    } else {
        nk_memset(
            state as *mut Void,
            0i32,
            mem::size_of::<TextEdit>() as Ulong,
        );
        nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, None);
        nk_str_init_fixed(&mut (*state).string, memory, size);
        return;
    };
}

pub unsafe fn nk_textedit_free(mut state: *mut TextEdit) -> () {
    if state.is_null() {
        return;
    } else {
        nk_str_free(&mut (*state).string);
        return;
    };
}

pub unsafe fn nk_textedit_paste(
    mut state: *mut TextEdit,
    mut ctext: *const Char,
    mut len: Int,
) -> Int {
    /* API paste: replace existing selection with passed-in text */
    let mut glyphs: Int = 0;
    let mut text: *const Char = ctext;
    if (*state).mode as Int == NK_TEXT_EDIT_MODE_VIEW as Int {
        return 0i32;
    } else {
        /* if there's a selection, the paste should delete it */
        nk_textedit_clamp(state);
        nk_textedit_delete_selection(state);
        /* try to insert the characters */
        glyphs = nk_utf_len(ctext, len);
        if 0 != nk_str_insert_text_char(&mut (*state).string, (*state).cursor, text, len) {
            nk_textedit_makeundo_insert(state, (*state).cursor, glyphs);
            (*state).cursor += len;
            (*state).has_preferred_x = 0i32 as Uchar;
            return 1i32;
        } else {
            /* remove the undo since we didn't actually insert the characters */
            if 0 != (*state).undo.undo_point {
                (*state).undo.undo_point -= 1
            }
            return 0i32;
        }
    };
}

pub unsafe fn nk_stroke_curve(
    mut b: *mut CommandBuffer,
    mut ax: f32,
    mut ay: f32,
    mut ctrl0x: f32,
    mut ctrl0y: f32,
    mut ctrl1x: f32,
    mut ctrl1y: f32,
    mut bx: f32,
    mut by: f32,
    mut line_thickness: f32,
    mut col: Color,
) -> () {
    let mut cmd: *mut CommandCurve = 0 as *mut CommandCurve;
    if b.is_null() || col.a as Int == 0i32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        cmd = nk_command_buffer_push(b, NK_COMMAND_CURVE, mem::size_of::<CommandCurve>() as Ulong)
            as *mut CommandCurve;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).line_thickness = line_thickness as Ushort;
            (*cmd).begin.x = ax as Short;
            (*cmd).begin.y = ay as Short;
            (*cmd).ctrl[0usize].x = ctrl0x as Short;
            (*cmd).ctrl[0usize].y = ctrl0y as Short;
            (*cmd).ctrl[1usize].x = ctrl1x as Short;
            (*cmd).ctrl[1usize].y = ctrl1y as Short;
            (*cmd).end.x = bx as Short;
            (*cmd).end.y = by as Short;
            (*cmd).color = col;
            return;
        }
    };
}

pub unsafe fn nk_stroke_circle(
    mut b: *mut CommandBuffer,
    mut r: Rect,
    mut line_thickness: f32,
    mut c: Color,
) -> () {
    let mut cmd: *mut CommandCircle = 0 as *mut CommandCircle;
    if b.is_null() || r.w == 0i32 as f32 || r.h == 0i32 as f32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const Rect = &mut (*b).clip as *mut Rect;
            if (*clip).x > r.x + r.w
                || (*clip).x + (*clip).w < r.x
                || (*clip).y > r.y + r.h
                || (*clip).y + (*clip).h < r.y
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_CIRCLE,
            mem::size_of::<CommandCircle>() as Ulong,
        ) as *mut CommandCircle;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).line_thickness = line_thickness as Ushort;
            (*cmd).x = r.x as Short;
            (*cmd).y = r.y as Short;
            (*cmd).w = (if r.w < 0i32 as f32 {
                0i32 as f32
            } else {
                r.w
            }) as Ushort;
            (*cmd).h = (if r.h < 0i32 as f32 {
                0i32 as f32
            } else {
                r.h
            }) as Ushort;
            (*cmd).color = c;
            return;
        }
    };
}

pub unsafe fn nk_stroke_arc(
    mut b: *mut CommandBuffer,
    mut cx: f32,
    mut cy: f32,
    mut radius: f32,
    mut a_min: f32,
    mut a_max: f32,
    mut line_thickness: f32,
    mut c: Color,
) -> () {
    let mut cmd: *mut CommandArc = 0 as *mut CommandArc;
    if b.is_null() || c.a as Int == 0i32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        cmd = nk_command_buffer_push(b, NK_COMMAND_ARC, mem::size_of::<CommandArc>() as Ulong)
            as *mut CommandArc;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).line_thickness = line_thickness as Ushort;
            (*cmd).cx = cx as Short;
            (*cmd).cy = cy as Short;
            (*cmd).r = radius as Ushort;
            (*cmd).a[0usize] = a_min;
            (*cmd).a[1usize] = a_max;
            (*cmd).color = c;
            return;
        }
    };
}

pub unsafe fn nk_stroke_triangle(
    mut b: *mut CommandBuffer,
    mut x0: f32,
    mut y0: f32,
    mut x1: f32,
    mut y1: f32,
    mut x2: f32,
    mut y2: f32,
    mut line_thickness: f32,
    mut c: Color,
) -> () {
    let mut cmd: *mut CommandTriangle = 0 as *mut CommandTriangle;
    if b.is_null() || c.a as Int == 0i32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut clip: *const Rect = &mut (*b).clip as *mut Rect;
            if !((*clip).x <= x0
                && x0 < (*clip).x + (*clip).w
                && ((*clip).y <= y0 && y0 < (*clip).y + (*clip).h))
                && !((*clip).x <= x1
                    && x1 < (*clip).x + (*clip).w
                    && ((*clip).y <= y1 && y1 < (*clip).y + (*clip).h))
                && !((*clip).x <= x2
                    && x2 < (*clip).x + (*clip).w
                    && ((*clip).y <= y2 && y2 < (*clip).y + (*clip).h))
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_TRIANGLE,
            mem::size_of::<CommandTriangle>() as Ulong,
        ) as *mut CommandTriangle;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).line_thickness = line_thickness as Ushort;
            (*cmd).a.x = x0 as Short;
            (*cmd).a.y = y0 as Short;
            (*cmd).b.x = x1 as Short;
            (*cmd).b.y = y1 as Short;
            (*cmd).c.x = x2 as Short;
            (*cmd).c.y = y2 as Short;
            (*cmd).color = c;
            return;
        }
    };
}

pub unsafe fn nk_stroke_polyline(
    mut b: *mut CommandBuffer,
    mut points: *mut f32,
    mut point_count: Int,
    mut line_thickness: f32,
    mut col: Color,
) -> () {
    let mut i: Int = 0;
    let mut size: Size = 0i32 as Size;
    let mut cmd: *mut CommandPolyline = 0 as *mut CommandPolyline;
    if b.is_null() || col.a as Int == 0i32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        size = (mem::size_of::<CommandPolyline>() as Ulong).wrapping_add(
            (mem::size_of::<Short>() as Ulong)
                .wrapping_mul(2i32 as Ulong)
                .wrapping_mul(point_count as Size),
        );
        cmd = nk_command_buffer_push(b, NK_COMMAND_POLYLINE, size) as *mut CommandPolyline;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).color = col;
            (*cmd).point_count = point_count as Ushort;
            (*cmd).line_thickness = line_thickness as Ushort;
            i = 0i32;
            while i < point_count {
                (*cmd).points[i as usize].x = *points.offset((i * 2i32) as isize) as Short;
                (*cmd).points[i as usize].y = *points.offset((i * 2i32 + 1i32) as isize) as Short;
                i += 1
            }
            return;
        }
    };
}

pub unsafe fn nk_stroke_polygon(
    mut b: *mut CommandBuffer,
    mut points: *mut f32,
    mut point_count: Int,
    mut line_thickness: f32,
    mut col: Color,
) -> () {
    let mut i: Int = 0;
    let mut size: Size = 0i32 as Size;
    let mut cmd: *mut CommandPolygon = 0 as *mut CommandPolygon;
    if b.is_null() || col.a as Int == 0i32 || line_thickness <= 0i32 as f32 {
        return;
    } else {
        size = (mem::size_of::<CommandPolygon>() as Ulong).wrapping_add(
            (mem::size_of::<Short>() as Ulong)
                .wrapping_mul(2i32 as Ulong)
                .wrapping_mul(point_count as Size),
        );
        cmd = nk_command_buffer_push(b, NK_COMMAND_POLYGON, size) as *mut CommandPolygon;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).color = col;
            (*cmd).line_thickness = line_thickness as Ushort;
            (*cmd).point_count = point_count as Ushort;
            i = 0i32;
            while i < point_count {
                (*cmd).points[i as usize].x = *points.offset((i * 2i32) as isize) as Short;
                (*cmd).points[i as usize].y = *points.offset((i * 2i32 + 1i32) as isize) as Short;
                i += 1
            }
            return;
        }
    };
}

pub unsafe fn nk_fill_arc(
    mut b: *mut CommandBuffer,
    mut cx: f32,
    mut cy: f32,
    mut radius: f32,
    mut a_min: f32,
    mut a_max: f32,
    mut c: Color,
) -> () {
    let mut cmd: *mut CommandArcFilled = 0 as *mut CommandArcFilled;
    if b.is_null() || c.a as Int == 0i32 {
        return;
    } else {
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_ARC_FILLED,
            mem::size_of::<CommandArcFilled>() as Ulong,
        ) as *mut CommandArcFilled;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).cx = cx as Short;
            (*cmd).cy = cy as Short;
            (*cmd).r = radius as Ushort;
            (*cmd).a[0usize] = a_min;
            (*cmd).a[1usize] = a_max;
            (*cmd).color = c;
            return;
        }
    };
}

pub unsafe fn nk_fill_polygon(
    mut b: *mut CommandBuffer,
    mut points: *mut f32,
    mut point_count: Int,
    mut col: Color,
) -> () {
    let mut i: Int = 0;
    let mut size: Size = 0i32 as Size;
    let mut cmd: *mut CommandPolygonFilled = 0 as *mut CommandPolygonFilled;
    if b.is_null() || col.a as Int == 0i32 {
        return;
    } else {
        size = (mem::size_of::<CommandPolygonFilled>() as Ulong).wrapping_add(
            (mem::size_of::<Short>() as Ulong)
                .wrapping_mul(2i32 as Ulong)
                .wrapping_mul(point_count as Size),
        );
        cmd =
            nk_command_buffer_push(b, NK_COMMAND_POLYGON_FILLED, size) as *mut CommandPolygonFilled;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).color = col;
            (*cmd).point_count = point_count as Ushort;
            i = 0i32;
            while i < point_count {
                (*cmd).points[i as usize].x = *points.offset((i * 2i32 + 0i32) as isize) as Short;
                (*cmd).points[i as usize].y = *points.offset((i * 2i32 + 1i32) as isize) as Short;
                i += 1
            }
            return;
        }
    };
}

pub unsafe fn nk_push_custom(
    mut b: *mut CommandBuffer,
    mut r: Rect,
    mut cb: CommandCustomCallback,
    mut usr: Handle,
) -> () {
    let mut cmd: *mut CommandCustom = 0 as *mut CommandCustom;
    if b.is_null() {
        return;
    } else {
        if 0 != (*b).use_clipping {
            let mut c: *const Rect = &mut (*b).clip as *mut Rect;
            if (*c).w == 0i32 as f32 || (*c).h == 0i32 as f32
                || ((*c).x > r.x + r.w
                    || (*c).x + (*c).w < r.x
                    || (*c).y > r.y + r.h
                    || (*c).y + (*c).h < r.y)
            {
                return;
            }
        }
        cmd = nk_command_buffer_push(
            b,
            NK_COMMAND_CUSTOM,
            mem::size_of::<CommandCustom>() as Ulong,
        ) as *mut CommandCustom;
        if cmd.is_null() {
            return;
        } else {
            (*cmd).x = r.x as Short;
            (*cmd).y = r.y as Short;
            (*cmd).w = (if (0i32 as f32) < r.w {
                r.w
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).h = (if (0i32 as f32) < r.h {
                r.h
            } else {
                0i32 as f32
            }) as Ushort;
            (*cmd).callback_data = usr;
            (*cmd).callback = cb;
            return;
        }
    };
}

pub unsafe fn nk_style_item_image(mut img: Image) -> StyleItem {
    let mut i: StyleItem = StyleItem {
        type_0: NK_STYLE_ITEM_COLOR,
        data: nk_style_item_data {
            image: Image {
                handle: Handle {
                    ptr: 0 as *mut Void,
                },
                w: 0,
                h: 0,
                region: [0; 4],
            },
        },
    };
    i.type_0 = NK_STYLE_ITEM_IMAGE;
    i.data.image = img;
    return i;
}

const nk_red: Color = Color {
    r: 255,
    g: 0,
    b: 0,
    a: 255,
};

const nk_green: Color = Color {
    r: 0,
    g: 255,
    b: 0,
    a: 255,
};

const nk_blue: Color = Color {
    r: 0,
    g: 0,
    b: 255,
    a: 255,
};

static mut nk_black: Color = Color {
    r: 0,
    g: 0,
    b: 0,
    a: 255,
};

static mut nk_yellow: Color = Color {
    r: 255,
    g: 255,
    b: 0,
    a: 255,
};
